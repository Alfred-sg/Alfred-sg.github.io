{"meta":{"title":"修子范语","subtitle":"Alfredo's Notes","description":"人苦不知足，既得陇，复望蜀","author":"Alfred","url":"http://xzfyu.com","root":"/"},"pages":[{"title":"分类","date":"2018-02-03T14:37:00.000Z","updated":"2018-02-03T14:40:05.000Z","comments":false,"path":"categories/index.html","permalink":"http://xzfyu.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-02-03T14:35:11.000Z","updated":"2018-02-03T14:35:48.000Z","comments":false,"path":"tags/index.html","permalink":"http://xzfyu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端工程体系","slug":"frontend/architecture/前端工程体系","date":"2020-12-30T16:00:00.000Z","updated":"2020-03-27T11:41:17.916Z","comments":true,"path":"2020/12/31/frontend/architecture/前端工程体系/","link":"","permalink":"http://xzfyu.com/2020/12/31/frontend/architecture/前端工程体系/","excerpt":"","text":"我常常执着于部分（比如昏天暗地地解读一个源码），不能跳出来看看整体。这篇文章旨在于整理我所理解的前端工程体系，方便逐步演进顶层观念并指导后续发展。因为见识的有限和理解的不足，这篇文章本难免缺陷和差缪，还望有识予以理解。 我所理解的前端工程体系大致如上图。左半部分以 antd + umi、fusion + 飞冰为参照加以说明，组件库用于提供基础的通用组件。模板工程通常提供了应用层面的最佳实践，因此不止于使用在组件库之内的基础通用组件、在组件库之外的图表和编辑器组件等，还包含状态管理、路由管理、服务调用等内容。当某些组件还未包含在组件库中，但在应用中经常使用，那么这些组件也可以通过模板工程下沉到组件库中。由组件库往上，可以生长出业务组件、区块、前端工程模板，这些都可以被物料中心所吸纳，以便使用特定的域作为标识，在可视化搭建等其他应用、前端 IDE 工具或简单的本地开发环境中复用。这部分内容不限于 web 场景，还包含小程序等场景。事实上，fusion 的物料中心包含 rax 组件，支付宝小程序也提供了基础组件库和 IDE 开发环境。 右半部分在于使用 node 服务封装后端接口提供定制化的数据，包含但不限于元数据（如菜单栏）、查询数据库的动态数据等。node 服务不止可以提供数据接口，还包含构建发布平台（构建工具通过命令行工具与其打通）、mock 服务（在应用本地运行时动态获取）、国际化服务（在应用启动阶段动态拉取）等。 ## 组件库现行较为火热的组件库有 ant design、fusion、material ui、element ui 等。以下是 ant design 的大体结构： bisheng: 解析 markdown 文件并生成静态网站。主流程上，它借助 nunjucks、webpack、ssr 机制启动本地服务器、生成打包文件，以及通过 gh-pages 将静态页面上传到 github 服务器上。实现可参考 聊聊 antd 网站是怎么制作的。 antd-tools、scripts: 提供基本的命令行工具。antd-tools 基于 gulp 实现，它集成了 compile（基于不同组件的入口文件编译 less、ts、svg 等）、dist（使用 webpack 打包整个组件库）、deps-lint（检查模块是否被依赖）、pub（编译、打包并发布）、guard、sort-api-table、api-collection、clean 等操作。 ant design 的定制主题功能基于 less 的 modifyVars，即将可定制的样式定义为 less 变量，随后就可以通过 less-loader 引用外部 less 变量文件实现定制。ant design 中可配置的样式见 这里。无障碍功能基于节点的 aria-、role- 属性实现，可参考 aria初探。国际化功能基于 react 的 context 机制实现，同时会设置 moment 的语言。按需加载功能借助于 babel-plugin-import 插件；其原理为在 babel 编译期间转换 import 语句，并加载必要的样式（默认加载组件文件夹下的 css/index.js 文件）。 以下是 react-components 组件图谱，动效、对齐、伸缩作为基础的组件或工具函数，其上再延伸出表单、数据展示、导航、回馈组件等。 ant-design 的组件基本基于 ConfigProvider 构建。ConfigProvider 通过 react 的 context 机制提供国际化、弹层根节点获取函数、空态渲染函数等。 参考如果我是阿里的前端架构师，我会这么搭建前端架构体系蚂蚁前端研发最佳实践","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"前端技术汇总贴","slug":"frontend/architecture/前端技术汇总贴","date":"2020-06-08T16:00:00.000Z","updated":"2020-03-08T10:42:40.982Z","comments":true,"path":"2020/06/09/frontend/architecture/前端技术汇总贴/","link":"","permalink":"http://xzfyu.com/2020/06/09/frontend/architecture/前端技术汇总贴/","excerpt":"","text":"下载立即收藏！这应该是你见过的最全前端下载总结 校验身份证号根据〖中华人民共和国国家标准 GB 11643-1999〗中有关公民身份号码的规定，公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 地址码表示编码对象常住户口所在县(市、旗、区)的行政区划代码。 出生日期码表示编码对象出生的年、月、日，其中年份用四位数字表示，年、月、日之间不用分隔符。 顺序码表示同一地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号。顺序码的奇数分给男性，偶数分给女性。 校验码是根据前面十七位数字码，按照 ISO 7064:1983.MOD 11-2 校验码计算出来的检验码。 12345678910111213141516171819202122232425262728293031323334353637383940414243const City = &#123; 11:\"北京\", 12:\"天津\", 13:\"河北\", 14:\"山西\", 15:\"内蒙古\", 21:\"辽宁\", 22:\"吉林\", 23:\"黑龙江 \", 31:\"上海\", 32:\"江苏\", 33:\"浙江\", 34:\"安徽\", 35:\"福建\", 36:\"江西\", 37:\"山东\", 41:\"河南\", 42:\"湖北 \", 43:\"湖南\", 44:\"广东\", 45:\"广西\", 46:\"海南\", 50:\"重庆\", 51:\"四川\", 52:\"贵州\", 53:\"云南\", 54:\"西藏\", 61:\"陕西\", 62:\"甘肃\", 63:\"青海\", 64:\"宁夏\", 65:\"新疆\", 71:\"台湾\", 81:\"香港\", 82:\"澳门\", 91:\"国外\"&#125;;// 15位校验规则：6位地址编码+6位出生日期+3位顺序号// 18位校验规则：6位地址编码+8位出生日期+3位顺序号+1位校验位const IdentityCodeRegExp = /^\\d&#123;6&#125;(18|19|20)?\\d&#123;2&#125;(0[1-9]|1[012])(0[1-9]|[12]\\d|3[01])\\d&#123;3&#125;(\\d|X)$/i;// 校验位规则 公式:∑(ai×Wi)(mod 11)// i----表示号码字符从由至左包括校验码在内的位置序号； // ai----表示第i位置上的号码字符值； // Wi----示第i位置上的加权因子，其数值依据公式Wi=2^(n-1）(mod 11)计算得出。const factor = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ];// 加权因子const parity = [ 1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2 ];// 校验位const IdentityCodeValid = (code) =&gt; &#123; if( !code || !IdentityCodeRegExp.test(code) )&#123; return \"身份证号格式错误\"; &#125; if( !City[code.substr(0,2)] )&#123; return \"身份证号中地址编码错误\"; &#125; // 18位身份证需要验证最后一位校验位 if( code.length == 18 )&#123; let sum = 0; code.substr(0,17).split('').forEach((ai, i) =&gt; &#123; let wi = factor[i]; sum += ai * wi; &#125;); let last = parity[sum % 11]; if( last != code[17] )&#123; return \"校验位错误\"; &#125; &#125;&#125; 参考 完美身份证正则表达式。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"react fiber 代码梳理篇","slug":"frontend/react16/react fiber 代码梳理篇","date":"2020-04-28T16:00:00.000Z","updated":"2020-03-09T15:01:26.082Z","comments":true,"path":"2020/04/29/frontend/react16/react fiber 代码梳理篇/","link":"","permalink":"http://xzfyu.com/2020/04/29/frontend/react16/react fiber 代码梳理篇/","excerpt":"","text":"scheduleWork正如 react fiber 搜罗整理篇 已点明的，fiber reconciler 对首次渲染和再次渲染会采用不同的机制。 首次渲染 —— 比如用户侧在浏览器环境调用 ReactDOM.render(rootReactElement, rootDomElement) —— 时，fiber reconciler 首先会通过 createContainer 将根节点 rootDomElement 转化成 fiberRoot 根节点；然后通过 updateContainer 执行 scheduleWork(fiberRoot, expirationTime) 调度作业，完成渲染。 再次渲染 —— 比如类组件或函数组件状态更新 —— 时，react fiber 类组件状态更新篇、react fiber hooks钩子篇 已指出，两者都会执行 scheduleWork(fiber, expirationTime) 调度作业，实现重绘。 可见，两种场景均依赖于 scheduleWork。 executionContext &amp; expirationTimescheduleWork 内有两个核心要素：executionContext 执行上下文，用于更新方式以及所处阶段；expirationTime 过期时间。 executionContextreact 使用位运算更新或判断 executionContext 值，如使用 executionContext |= RenderContext 更新；使用 executionContext &amp; RenderContext !== NoContext 判断是否处于 render 阶段。fiber reconciler 在每次变更 executionContext 时都会保存先前值，等操作完成后再将 executionContext 置回先前值（本文中贴示代码均省略这一过程）。介于 executionContext 初始值为 NoContext，使用 executionContext === NoContext 可判断调用栈是否回到底部。以下是 executionContext 状态值的基础枚举： 0b000000 NoContext：空状态，作为初始值，可用于推断调用栈是否回到底部、或者推断 executionContext 处于那种状态 0b000001 BatchedContext：批量执行更新任务，如调用 batchedUpdates 更新时。 0b000010 EventContext：执行更新任务，如调用 batchedEventUpdates 更新时。 0b000100 DiscreteEventContext：以 UserBlockingPriority 优先级执行任务，如调用 discreteUpdates 更新时。 0b001000 LegacyUnbatchedContext：传统的非批量执行更新任务，如首次挂载时调用 unbatchedUpdates 更新时。 0b010000 RenderContext：当前更新处于 render 阶段 0b100000 CommitContext：当前更新处于 commit 阶段 expirationTimefiber 的 expirationTime 基于 computeExpirationForFiber 计算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function computeExpirationForFiber( currentTime: ExpirationTime, fiber: Fiber, suspenseConfig: null | SuspenseConfig,): ExpirationTime &#123; const mode = fiber.mode; if ((mode &amp; BlockingMode) === NoMode) &#123; return Sync; &#125; const priorityLevel = getCurrentPriorityLevel(); if ((mode &amp; ConcurrentMode) === NoMode) &#123; return priorityLevel === ImmediatePriority ? Sync : Batched; &#125; if ((executionContext &amp; RenderContext) !== NoContext) &#123; // Use whatever time we're already rendering // TODO: Should there be a way to opt out, like with `runWithPriority`? return renderExpirationTime; &#125; let expirationTime; if (suspenseConfig !== null) &#123; // Compute an expiration time based on the Suspense timeout. expirationTime = computeSuspenseExpiration( currentTime, suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION, ); &#125; else &#123; // Compute an expiration time based on the Scheduler priority. switch (priorityLevel) &#123; case ImmediatePriority: expirationTime = Sync; break; case UserBlockingPriority: // TODO: Rename this to computeUserBlockingExpiration expirationTime = computeInteractiveExpiration(currentTime); break; case NormalPriority: case LowPriority: // TODO: Handle LowPriority // TODO: Rename this to... something better. expirationTime = computeAsyncExpiration(currentTime); break; case IdlePriority: expirationTime = Idle; break; default: invariant(false, 'Expected a valid priority level'); &#125; &#125; // If we're in the middle of rendering a tree, do not update at the same // expiration time that is already rendering. // TODO: We shouldn't have to do this if the update is on a different root. // Refactor computeExpirationForFiber + scheduleUpdate so we have access to // the root when we check for this condition. if (workInProgressRoot !== null &amp;&amp; expirationTime === renderExpirationTime) &#123; // This is a trick to move this update into a separate batch expirationTime -= 1; &#125; return expirationTime;&#125; 0 NoWork： 1 Never： 2 Idle： 3 ContinuousHydration： 1073741822 Batched： 1073741823 Sync： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115const scheduleWork = scheduleUpdateOnFiber;function scheduleUpdateOnFiber( fiber: Fiber, expirationTime: ExpirationTime,) &#123; const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime); if (expirationTime === Sync) &#123; if ( (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; (executionContext &amp; (RenderContext | CommitContext)) === NoContext ) &#123; // This is a legacy edge case. The initial mount of a ReactDOM.render-ed // root inside of batchedUpdates should be synchronous, but layout updates // should be deferred until the end of the batch. performSyncWorkOnRoot(root); &#125; else &#123; ensureRootIsScheduled(root); if (executionContext === NoContext) &#123; // Flush the synchronous work now, unless we're already working or inside // a batch. This is intentionally inside scheduleUpdateOnFiber instead of // scheduleCallbackForFiber to preserve the ability to schedule a callback // without immediately flushing it. We only do this for user-initiated // updates, to preserve historical behavior of legacy mode. flushSyncCallbackQueue(); &#125; &#125; &#125; else &#123; ensureRootIsScheduled(root); &#125;&#125;function ensureRootIsScheduled(root: FiberRoot) &#123; const lastExpiredTime = root.lastExpiredTime; if (lastExpiredTime !== NoWork) &#123; // Special case: Expired work should flush synchronously. root.callbackExpirationTime = Sync; root.callbackPriority = ImmediatePriority; root.callbackNode = scheduleSyncCallback( performSyncWorkOnRoot.bind(null, root), ); return; &#125; const expirationTime = getNextRootExpirationTimeToWorkOn(root); const existingCallbackNode = root.callbackNode;// 上一个调度任务 if (expirationTime === NoWork) &#123; // There's nothing to work on. if (existingCallbackNode !== null) &#123; root.callbackNode = null; root.callbackExpirationTime = NoWork; root.callbackPriority = NoPriority; &#125; return; &#125; const currentTime = requestCurrentTimeForUpdate(); const priorityLevel = inferPriorityFromExpirationTime( currentTime, expirationTime, ); // 对于之前的渲染任务，校验其是否有足够的优先级及过期时间，否则取消 if (existingCallbackNode !== null) &#123; const existingCallbackPriority = root.callbackPriority; const existingCallbackExpirationTime = root.callbackExpirationTime; if ( // Callback must have the exact same expiration time. existingCallbackExpirationTime === expirationTime &amp;&amp; existingCallbackPriority &gt;= priorityLevel ) &#123; return; &#125; cancelCallback(existingCallbackNode); &#125; root.callbackExpirationTime = expirationTime; root.callbackPriority = priorityLevel; let callbackNode; // 同步作业，以 ImmediatePriority 优先级调度执行 if (expirationTime === Sync) &#123; callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root)); // 禁用定时调度时，以指定的 priorityLevel 优先级调度 &#125; else if (disableSchedulerTimeoutBasedOnReactExpirationTime) &#123; callbackNode = scheduleCallback( priorityLevel, performConcurrentWorkOnRoot.bind(null, root), ); // 指定 timeout 延时调度，优先级为 priorityLevel &#125; else &#123; callbackNode = scheduleCallback( priorityLevel, performConcurrentWorkOnRoot.bind(null, root), &#123;timeout: expirationTimeToMs(expirationTime) - now()&#125;, ); &#125; root.callbackNode = callbackNode;&#125;// 1. 同步任务添加到 syncQueue 队列中// 2. 调度 flushSyncCallbackQueue 以 ImmediatePriority 优先级执行// 3. 若报错，重试调度作业function scheduleSyncCallback(callback: SchedulerCallback) &#123; if (syncQueue === null) &#123; syncQueue = [callback]; // 使用 scheduler 模块透出接口执行调度作业 immediateQueueCallbackNode = Scheduler_scheduleCallback( Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl, ); &#125; else &#123; syncQueue.push(callback); &#125; return fakeCallbackNode;&#125; 同步模式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function performSyncWorkOnRoot(root) &#123; // Check if there's expired work on this root. Otherwise, render at Sync. const lastExpiredTime = root.lastExpiredTime; const expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync; // If we have a work-in-progress fiber, it means there's still work to do // in this root. if (workInProgress !== null) &#123; executionContext |= RenderContext; do &#123; try &#123; workLoopSync(); break; &#125; catch (thrownValue) &#123; // 错误边界捕获处理 handleError(root, thrownValue); &#125; &#125; while (true); // 同步作业，此时 workInProgress 必须为 null if (workInProgress !== null) &#123; invariant( false, 'Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.', ); // render 阶段完成，将 work-in-progress fiber 置为 finished-work fiber &#125; else &#123; root.finishedWork = (root.current.alternate: any); root.finishedExpirationTime = expirationTime; finishSyncRender(root); &#125; // 调度的渲染任务，避免排队中的任务长期阻塞 ensureRootIsScheduled(root); &#125;&#125;// render 阶段function workLoopSync() &#123; while (workInProgress !== null) &#123; workInProgress = performUnitOfWork(workInProgress); &#125;&#125;// commit 阶段function finishSyncRender(root) &#123; workInProgressRoot = null; commitRoot(root);&#125; 异步模式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function performConcurrentWorkOnRoot(root, didTimeout) &#123; // Since we know we're in a React event, we can clear the current // event time. The next update will compute a new event time. currentEventTime = NoWork; if (didTimeout) &#123; // The render task took too long to complete. Mark the current time as // expired to synchronously render all expired work in a single batch. const currentTime = requestCurrentTimeForUpdate(); markRootExpiredAtTime(root, currentTime); // This will schedule a synchronous callback. ensureRootIsScheduled(root); return null; &#125; // Determine the next expiration time to work on, using the fields stored // on the root. const expirationTime = getNextRootExpirationTimeToWorkOn(root); if (expirationTime !== NoWork) &#123; const originalCallbackNode = root.callbackNode; // If we have a work-in-progress fiber, it means there's still work to do // in this root. if (workInProgress !== null) &#123; executionContext |= RenderContext; do &#123; try &#123; workLoopConcurrent(); break; &#125; catch (thrownValue) &#123; handleError(root, thrownValue); &#125; &#125; while (true); if (workInProgress !== null) &#123; // There's still work left over. Exit without committing. stopInterruptedWorkLoopTimer(); &#125; else &#123; // We now have a consistent tree. The next step is either to commit it, // or, if something suspended, wait to commit it after a timeout. stopFinishedWorkLoopTimer(); const finishedWork: Fiber = ((root.finishedWork = root.current.alternate): any); root.finishedExpirationTime = expirationTime; finishConcurrentRender( root, finishedWork, workInProgressRootExitStatus, expirationTime, ); &#125; ensureRootIsScheduled(root); if (root.callbackNode === originalCallbackNode) &#123; // The task node scheduled for this root is the same one that's // currently executed. Need to return a continuation. return performConcurrentWorkOnRoot.bind(null, root); &#125; &#125; &#125; return null;&#125;function workLoopConcurrent() &#123; // Perform work until Scheduler asks us to yield while (workInProgress !== null &amp;&amp; !shouldYield()) &#123; workInProgress = performUnitOfWork(workInProgress); &#125;&#125; 附录fiber.tag 类型ReactWorkTags.js 展示了 fiber 的类型（基于不同的类型会作不同处理）： FunctionComponent：函数式组件。React$ElementType 为构造函数。 ClassComponent：类组件。React$ElementType 为函数。 HostComponent：Host 组件（如 DOM 节点）。React$ElementType 为 string。 Fragment：Fragment 组件。React$ElementType 为 REACT_FRAGMENT_TYPE。 Mode：React$ElementType 为 REACT_CONCURRENT_MODE_TYPE 或 REACT_STRICT_MODE_TYPE。 Profiler：React$ElementType 为 REACT_PROFILER_TYPE。 SuspenseComponent：React$ElementType 为 REACT_SUSPENSE_TYPE。 SuspenseListComponent：React$ElementType 为 REACT_SUSPENSE_LIST_TYPE。 IndeterminateComponent： HostRoot： HostPortal： HostText： ContextConsumer：Context.Consumer 组件。React$ElementType 为对象，React$ElementType$$typeof 为 REACT_CONTEXT_TYPE。 ContextProvider：Context.Provider 组件。React$ElementType 为对象，React$ElementType$$typeof 为 REACT_PROVIDER_TYPE。 ForwardRef：React$ElementType 为对象，React$ElementType$$typeof 为 REACT_FORWARD_REF_TYPE。 MemoComponent：React$ElementType 为对象，React$ElementType$$typeof 为 REACT_MEMO_TYPE。 LazyComponent：React$ElementType 为对象，React$ElementType$$typeof 为 REACT_LAZY_TYPE。 FundamentalComponent：React$ElementType 为对象，React$ElementType$$typeof 为 REACT_FUNDAMENTAL_TYPE。 ScopeComponent：React$ElementType 为对象，React$ElementType$$typeof 为 REACT_SCOPE_TYPE。 SimpleMemoComponent： IncompleteClassComponent： DehydratedFragment： Chunk： 参考React源码解析之ExpirationTime","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"http://xzfyu.com/categories/frontend/react/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react16","slug":"react16","permalink":"http://xzfyu.com/tags/react16/"},{"name":"fiber-renconciler","slug":"fiber-renconciler","permalink":"http://xzfyu.com/tags/fiber-renconciler/"}]},{"title":"架构入门","slug":"计算机科学/软件工程/体系结构设计","date":"2020-04-28T16:00:00.000Z","updated":"2020-04-16T23:59:49.263Z","comments":true,"path":"2020/04/29/计算机科学/软件工程/体系结构设计/","link":"","permalink":"http://xzfyu.com/2020/04/29/计算机科学/软件工程/体系结构设计/","excerpt":"","text":"分层架构分层架构将系统功能划分为几个独立的层次，每一层只依赖下一层提供的服务和设施，内部保持内聚性，层与层之间松耦合。 它的优点有： 每一层可以由独立的小团队负责，以清晰的接口促成各层之间协作。在系统草创、不具形态时，这一点也是干扰多方协作的缺点。 可以在不变更接口的基础上更换每一层的实现；也可以快速某一层之上快速实现新的一层，以便复用其下的处理逻辑。 在每一层可以提供身份校验等冗余服务，以提升系统的可靠性。 它的缺点有： 各层实现纯粹的分离是困难的，高层可能不得不与底层直接交互。 层次越多，系统对服务的处理需要层层传递，影响性能；响应业务变动也可能需要多层修改。 以下是它的典型实例。 桌面和 web 应用桌面和 web 应用的常见分层如下： 表现层/UI 层：负责绘制用户界面。 应用逻辑层/领域层：实现业务逻辑。 数据服务层/持久层：提供底层数据交互。 上图是网上找的一个 OA 系统的分层结构。即时通讯等通用服务即可游离在分层结构之外；也可以作为通用服务层，存在于应用逻辑层和数据服务层之间。 网络模型ISO 的开发系统互联（OSI，Open Systems Interconnection）参考模型分层如下： 物理层 physical layer：通过集线器、中继器、网线、双绞线等物理介质传递原始比特流。 数据链路层 data link layer：将比特组合成字节，字节组合成帧，以帧传输数据；使用链路层地址（以太网使用MAC地址）访问网桥、网卡、以太网交换机等物理介质；主要功能包含差错控制（错误重发、成功应答）和流量控制（对接快速发送发和慢速接收方）。参考 数据链路层通俗的讲是什么。 网络层 network layer：通过 IP 寻址建立两个节点间的连接以控制子网的运行，将数据包从源端路由到接收方。物理介质为路由器、三层交换机。 传输层 transport layer：将上层的数据切割成较小的单元，以完成点对点的通信。自传输层以上各层，均为点对点通信，源机器和目标机器通过报文头和控制信息通信；以下各层，一台机器仅与其直接另据通过协议通信，即源机器和目标机器被多个路由器隔离了。物理介质为四层路由器、四层交换机。 会话层 session layer：负责建立、管理和终止表示层实体之间的通信会话，功能包含对话控制（谁来传递数据）、令牌管理（禁止双方同时执行某一操作）、同步功能（在长传输过程中设置断点，以便系统崩溃后的恢复）。 表示层 presentation layer：表示层关注传递数据的语法和语义（包含数据转换、编码、加密、压缩等），其下各层关注怎样传递数据。 应用层 application layer：为用户直接提供各种网络服务，包含 http、https、www、ftp 等。 参考 OSI网络模型。 前端实例典型的前端应用也体现出分层结构。 services：接口层，对接后端服务。 stores：状态机层，桥接页面和接口。 pages：页面路由层，绘制页面。 面向服务架构富客户端、客户端-服务器模式、基于 ESB 企业服务总线的 SOA 服务导向架构、microservices architecture 微服务架构，微服务架构是循着这条演进路线发展而来的。客户端-服务器模式可用于解释现行的很多架设，如 hsf 服务即包含客户端和服务端，此外还有微服务架构中的配置中心；redis 消息服务；sql 服务器和应用服务器的关系也是客户端-服务器模式。基于 ESB 企业服务总线的服务架构通常会聚焦于服务的注册和调用，未深入服务的集成、拓展和复用。如钟华在《企业IT架构转型之道》中所提到的，面向服务架构的核心在于服务的复用，微服务是 SOA 的一个演化。在面向服务架构中，系统的功能以服务的形态呈现，每一个服务来自于独立的服务器，便于水平扩展。 它的优点即为缺点，因为在低耦合的各服务单独部署的情况下，一方面会便于开发和水平扩展，另一方面众多的服务会造成其调用链路过长，影响性能，难于管理和失败回滚。 分层架构可用于解释单个 java 应用；微服务架构可用于解释企业生产中的应用簇。 《Software Architecture Patterns》给出了下面这张微服务架构图。可是在实际工程中，通常结合业务所设计的微服务架构远不止这么简单： 插件架构插件架构由内核、插件集组成。因其主要功能逻辑由插件实现，内核相对较小，它也被称为微核架构。插件应尽可能的相互独立，以避免紧耦合带来的复杂性。插件之间通过内核进行交互。在插件架构中，内核决定了插件运行的生命周期。在笔者的理解中，插件架构的极致就是以组件表现插件，以容器表现内核，组件自行决定其生命周期，容器只是聚合了一些功能逻辑，比如统一的数据周转或存储流程。当插件架构表现为容器架构时，其适用于有大量数据需要保存的场景，如一个组件生产数据，其他组件消费数据。 它的优点有： 易于通过开发插件的形式扩展功能，这样也支持了高度定制的场景。 开发模式可以采用渐进式地推出或拓展插件。 它的缺点有： 内核的稳定性决定着整个系统的稳定性，不便于分布式部署。 插件通过内核通信会比较低效。 它的典型架构图如下： 就前端层面，不少工具会采用插件架构，如 umi、mocha、babel、webpack 等。前端应用中的 stores 层也具有容器特征，因为可在这一层对数据作记录、追踪等统一处理。同样的，多数可视化编辑器也采用容器架构。在 Ian Sommerville 所著的《软件工程》中，作者指明使用容器架构的例子有指挥和控制系统、管理信息系统、CAD 系统和软件的交互开发环境（即 IDE）等交互式系统，并给出了 IDE 系统的容器体系架构图： 管道和过滤器架构管道和过滤器架构指数据从一个处理单元流入另一个处理单元，每经过一个处理单元就做一次变换。管道和过滤器架构来自于 UNIX，在 UNIX 系统中，管道能从一个进程到另一个进程传递文本流。管道和过滤器架构可以实现为顺序的系统（批处理模型），也可以实现为并发的系统。 它的优缺点有： 架构易于理解并支持变换的复用，容易通过添加变换的方式进行扩展。相应的，管道处理的数据格式需要协商好，数据也能成为系统中管道控制语句的判断条件。 工作流和很多业务处理体系结构很匹配。 参考软件架构入门体系结构设计https://juejin.im/entry/5b723ffb6fb9a009a85cafca控制的体系结构模式","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"软件工程","slug":"计算机科学/软件工程","permalink":"http://xzfyu.com/categories/计算机科学/软件工程/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"}]},{"title":"前端模块化机制","slug":"frontend/architecture/模块化机制","date":"2020-04-11T16:00:00.000Z","updated":"2020-04-12T09:53:43.936Z","comments":true,"path":"2020/04/12/frontend/architecture/模块化机制/","link":"","permalink":"http://xzfyu.com/2020/04/12/frontend/architecture/模块化机制/","excerpt":"","text":"前端模块化规范有 AMD、CMD、CommonJS、ES2015 规范： AMD 模块化规范：requirejs 为其主要实现。 CMD 模块化规范：seajs 为其主要实现。 CommonJS 模块化规范：作为CommonJS 规范的一部分，nodejs是其较常见的实现。 ES 2015 模块化规范：作为es 官方规范的一部分。 对于 AMD、CMD，本文尝试解读 requirejs、seajs 的实现。对于 CommonJS、ES6，本文更多聚焦于尝试解读其规范。介于笔者认知的不足，本文对 ES6 规范中 Cyclic Module Record、Source Text Module Record 并未作过多的投入（因为对 babel 理解的有限，本文也未深入 babel-helper-module-transforms）。实际上，这两个模型的规划设计恰恰是前端模块系统的精髓所在。相形之下，本文通过解读 requirejs、seajs 源码反演其设计并未臻于妙境。 AMD示例12345678910111213141516171819202122// 直接导出对象define(module);// 定义没有依赖的模块define(function()&#123; return module;&#125;);// 定义有依赖的模块define(['module1', 'module2'], function(module1, module2)&#123; return module;&#125;);// callback 内部通过 require 加载模块define(function(require, exports, module) &#123; const module1 = require('module1'); return module;&#125;);require(['module1', 'module2'], function(m1, m2)&#123; // 使用 module1、module2&#125;) requirejs 支持浏览器、web worker、nodejs 环境。 插件机制，’plugin!resource’ 形式指定资源。 通过在模块导出中使用 require 实现循环依赖。 通过 config.shim 支持将全局变量转换成依赖模块。 基于不同的上下文对模块进行分区。 requirejs 中有两类模块：一类为使用 define 语法书写的模块；另一类为使用 require 语法加载的模块。requirejs 会在全局上下文中定义 define、require 函数；这两个函数都会基于不同的上下文实现分区定义和加载模块，默认在顶层上下文中定义和加载模块。 define(name?, deps?, callback): 定义模块名、依赖、函数体（返回导出）。callback 有两种形式，一种显式指定依赖，另一种显式以 require, exports, module 为参数。 require(config?, deps, callback, errback, optional): 加载模块，通过 config.context 定义所使用的上下文，deps 依赖，callback 用于导出模块的句柄。 context 上下文主要包含如下属性或方法： registry：已注册、尚未启动加载流程的模块，对象形式，属性值为 Module 实例。 enabledRegistry：通过将 enabled = true 启动加载流程的模块，对象形式。 defined：已创建导出的模块，对象形式。 defQueue：define 模块已加载，它并未转化成 requirejs 内部的 Module 形式，依赖也未曾加载， require：在当前上下文环境中加载模块。由 context.makeRequire 创建。 模块的内部表示为 Module 实例，主要包含以下属性或方法： map：moduleMap 对象，通过 makeModuleMap 获得。其下包含 prefix 属性为插件，即 ‘i18n!my/nls/colors’ 中 i18n 插件；isDefine 是否命名模块。 pluginMaps：插件，用于转换加载的模块。 depMaps：依赖，数组形式；depCount：未加载的依赖数；depMatched：标识依赖已加载；depExports：依赖的导出内容，作为 callback 的参数。 load 方法：通过创建 script 节点或调用 importScripts 形式加载模块。 callPlguin 方法：通过插件加载模块。 fetch 方法：加载模块总接口，内部会以 load 或 callPlguin 方法加载模块。 init 方法：初始化，按条件执行 enable 或 check 方法。特别的，当模块作为依赖时，它会未经 init 方法处理，即使用 enable 方法加载。enable 方法尾部调用的 check 会依据 !inited 状态 fetch 模块。 enable 方法：将当前模块及其依赖、所使用的插件置为 enabled = true。若依赖已加载，则更新 mod.depExports 当前模块的依赖；若依赖未加载，调用依赖的 enable 方法加载依赖。尾部调用 check 方法，尝试创建模块的导出、或作错误处理、或加载模块。 check 方法：若模块尚未 inited 且不在 context.defQueue 队列中，调用 fetch 方法加载它；若报错，错误处理；若模块的依赖已加载完成，创建模块的导出，并触发 defined 事件，以向上创建 parentMod 的导出。其多态性需要通过 checkLoaded 函数反复触发不同情境的处理机制，如加载模块、错误处理、创建模块导出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// 加载模块及其依赖const enable = function () &#123; this.enabled = true; each(this.depMaps, bind(this, function (depMap, i) &#123; var id, mod, handler; if (typeof depMap === 'string') &#123; depMap = makeModuleMap(depMap, (this.map.isDefine ? this.map : this.map.parentMap), false, !this.skipMap); this.depMaps[i] = depMap; // 依赖已加载 handler = getOwn(handlers, depMap.id); if (handler) &#123; this.depExports[i] = handler(this); return; &#125; this.depCount += 1; // 绑定事件，依赖加载完成后，调用 this.check 加载当前模块 // on 方法同时为依赖创建 Module 实例，注册到 registry 中，但未执行 init 方法 on(depMap, 'defined', bind(this, function (depExports) &#123; if (this.undefed) &#123; return; &#125; this.defineDep(i, depExports); this.check(); &#125;)); &#125; // 将依赖的 enabled 置为 true，尝试加载依赖 id = depMap.id; mod = registry[id]; if (!hasProp(handlers, id) &amp;&amp; mod &amp;&amp; !mod.enabled) &#123; // 因依赖未执行 init 方法，通过 enable 调用 check 时将加载该依赖 context.enable(depMap, this); &#125; &#125;)); // 将插件的 enabled 置为 true eachProp(this.pluginMaps, bind(this, function (pluginMap) &#123; var mod = getOwn(registry, pluginMap.id); if (mod &amp;&amp; !mod.enabled) &#123; context.enable(pluginMap, this); &#125; &#125;)); // 创建模块的导出 this.check();&#125;// 多态，加载模块、或错误处理、或创建导出// mod.check 的多态操作既能由 enable 唤起，也能由 script 节点加载完成后通过 checkLoaded 函数唤起// 以创建模块的导出或作错误处理const check = function () &#123; if (!this.enabled) return; var err, cjsModule, id = this.map.id, depExports = this.depExports, exports = this.exports, factory = this.factory; // 模块未经初始化，通常是依赖，加载该模块 if (!this.inited) &#123; if (!hasProp(context.defQueueMap, id)) &#123; this.fetch(); &#125; // 错误处理 &#125; else if (this.error) &#123; this.emit('error', this.error); // 依赖已加载完成，创建导出，并触发 defined 事件 &#125; else if (!this.defining) &#123; this.defining = true; // depCount &lt; 1 表示依赖已加载完成 if (this.depCount &lt; 1 &amp;&amp; !this.defined) &#123; if (isFunction(factory)) &#123; // 执行 factory 句柄，生成刀块的导出 exports = context.execCb(id, factory, depExports, exports); // factory 句柄如 CommonJS 一样使用 module、module.exports 进行赋值导出 if (this.map.isDefine &amp;&amp; exports === undefined) &#123; cjsModule = this.module; if (cjsModule) &#123; exports = cjsModule.exports; &#125; else if (this.usingExports) &#123; exports = this.exports; &#125; &#125; &#125; else &#123; exports = factory; &#125; this.exports = exports; // 清理 context.registry，设置 context.defined，表示模块已 defined if (this.map.isDefine &amp;&amp; !this.ignore) &#123; defined[id] = exports; &#125; cleanRegistry(id); this.defined = true; &#125; this.defining = false; if (this.defined &amp;&amp; !this.defineEmitted) &#123; this.defineEmitted = true; // 触发 defined 事件，促使加载已当前模块为依赖的模块 this.emit('defined', this.exports); &#125; &#125;&#125;, requirejs 主要是在浏览器环境实现 js 脚本的模块化加载，其基本逻辑流程为： 首先在 html 中通过 script 节点加载 requirejs 模块，该 script 节点的 data-main 属性指定了 entryMod 入口模块。 requirejs 模块执行期间，会通过 req({}) 创建顶层上下文并加载 entryMod 入口模块。 入口模块通常为 require 模块，因此会执行 require 函数，创建内部表示 Module 实例，并执行 entryMod.enable 方法。 当入口模块没有依赖，会直接调用 entryMod.check 执行入口模块的句柄。 当入口模块有依赖，调用依赖的 enable 方法，此时依赖没有经过 init 方法处理，它会在 check 方法执行期间使用 fetch 方法加载依赖。 当依赖为 require 模块时，重复 entryMod 的处理机制。 当依赖为 define 模块，加载该 define 模块，通过 script 节点加载事件加载其子依赖，内部依旧使用子依赖的 check 方法获取模块。 完成入口模块的句柄。 依赖模块加载机制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// define 定义模块，只更新 context.defQueue 或 globalDefQueue，并不会加载依赖、执行 callbackdefine = function (name, deps, callback) &#123; // ...参数处理，会将 require, [exports], [module] 注入 deps 依赖中 // 如 define() 函数指定了上下文（通过 script 节点属性指定），直接更新 context.defQueue // 如未指定，等待 takeGlobalQueue 函数更新 context.defQueue // https://github.com/requirejs/requirejs/blob/master/require.js#L558 if (context) &#123; context.defQueue.push([name, deps, callback]); context.defQueueMap[name] = true; &#125; else &#123; globalDefQueue.push([name, deps, callback]); &#125;&#125;;// require 加载模块，对外接口req = requirejs = function (deps, callback, errback, optional) &#123; // 参数处理，deps 可能以 config 形式传入 if (config &amp;&amp; config.context) &#123; contextName = config.context; &#125; context = getOwn(contexts, contextName); if (!context) &#123; context = contexts[contextName] = req.s.newContext(contextName); &#125; // 配置 context，并加载 data-main 入口模块 if (config) context.configure(config); return context.require(deps, callback, errback);&#125;;req(&#123;&#125;);// 加载入口模块// context.require 函数内部实现，通过 context.makeRequire(relMap, options) 制作function localRequire(deps, callback, errback) &#123; var map, requireMod; // require('module') 形式，直接导出模块 if (typeof deps === 'string') &#123; if (relMap &amp;&amp; hasProp(handlers, deps)) &#123; return handlers[deps](registry[relMap.id]); &#125; // nodejs 等环境使用 req.get 获取模块 if (req.get) &#123; return req.get(context, deps, relMap, localRequire); &#125; map = makeModuleMap(deps, relMap, false, true); return defined[map.id]; &#125; // define 模块已加载，将其转换成 Module 实例并执行该实例的 check 方法 intakeDefines(); context.nextTick(function () &#123; intakeDefines(); // 获得 moduleMap 并创建 context.Module 实例，存入 context.registry[moduleMap.id] 中 requireMod = getModule(makeModuleMap(null, relMap)); // 执行 requireMod 的 enable 方法，将当前模块及其依赖、插件的 enabled 属性置为 true // 若依赖已加载，更新 requireMod.depExports requireMod.init(deps, callback, errback, &#123; enabled: true &#125;); checkLoaded(); &#125;); return localRequire;&#125; CMD示例1234567891011121314151617// 直接导出对象define([moduleName], [deps], [moduleFactoryOrObject]);define(module);define(function(require, exports, module) &#123; // ...&#125;);define(['module1', 'module2'], function(require, exports, module)&#123; // module.dependencies 依赖 // ...&#125;);require('module');seajs.use('js/main');// 入口模块 seajs 支持插件。插件通过事件接口与 seajs 主流程进行交互，仅需导入插件脚本，即可加载如 css 模块等。 define 句柄中的 require 会通过正则表达式提前收集为依赖。 与 requirejs 相比较，seajs 的编码结构更为清晰。seajs 处理流程为： html 中导入 seajs 脚本。 通过 seajs.use 加载首层依赖及处理句柄。内部会创建 Module 实例，并调用 mod.load 加载依赖。 所有依赖加载完成后，会执行 mod.onload 创建 Module 实例的 mod.callback 创建模块的导出。 mod.callback 内，调用依赖的 exec 创建依赖的导出，然后执行当前模块的 callback 句柄创建导出。 在以上步骤中，被依赖模块会通过 pass 方法将自身及父模块灌入到依赖的 _entry 属性中，已使加载完成后的依赖能确切地预知到哪些被依赖模块需要创建导出。当然，被依赖模块可能有多个依赖模块，只有当这些依赖模块都加载完成后，被依赖模块才能执行其句柄，这通过被依赖模块的 remain 属性判断。有多少未加载的依赖，被依赖模块的 remain 属性即为多少；在每个依赖加载完成后，remain 属性也相应减 1；当所有依赖加载完成后，remain 属性即为 0。 以下是 Module 实例包含的属性： uri：模块的地址。 dependencies：模块的依赖，数组形式。 deps：模块依赖的导出，数组形式。 status：状态。FETCHING 加载中；SAVED 元数据已存入模块实例；LOADING 依赖加载中；LOADED 依赖加载完成，可以创建模块的导出；EXECUTING 模块的句柄执行中；EXECUTED 模块的句柄执行完成，即导出创建成功；ERROR 模块加载失败。 _entry：被依赖模块，作为当前模块加载的入口，数组形式。当前模块加载完成，将通过 module.onload 方法唤起所有被依赖模块的 callback 句柄，这一行为等价于 requirejs 中的 emit(‘defined’)。 remain：标识未加载的依赖数。值为 0 时，所有依赖均已加载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990Module.use = function (ids, callback, uri) &#123; var mod = Module.get(uri, isArray(ids) ? ids : [ids]) mod._entry.push(mod)// 用于构成依赖的 _entry 属性，当前模块的 _entry 将被清空 // 通过 mod.callback 创建入口模块的导出 mod.callback = function() &#123; var exports = [] var uris = mod.resolve()// 获取依赖路径 for (var i = 0, len = uris.length; i &lt; len; i++) &#123; // 执行依赖模块的句柄，创建依赖模块的导出 // exec 会为句柄注入 require, exports, module exports[i] = cachedMods[uris[i]].exec() &#125; if (callback) &#123; callback.apply(global, exports) &#125; &#125; // 加载入口模块及其依赖 mod.load()&#125;Module.define = function (id, deps, factory) &#123; // parseDependencies 通过正则表达式从 factory 句柄中解析显式调用 require 语句的依赖 if (!isArray(deps) &amp;&amp; isFunction(factory)) &#123; deps = typeof parseDependencies === \"undefined\" ? [] : parseDependencies(factory.toString()) &#125; var meta = &#123; id: id, uri: Module.resolve(id),// Module.resolve 解析出绝对路径 deps: deps, factory: factory &#125; // Module.save 通过 Module.get 创建 Module 实例，并将 meta 存入 Module 实例，状态置为 SAVED meta.uri ? Module.save(meta.uri, meta) : // Save information for \"saving\" work in the script onload event anonymousMeta = meta&#125;Module.prototype.load = function() &#123; var mod = this mod.status = STATUS.LOADING var uris = mod.resolve()// 解析依赖路径 for (var i = 0, len = uris.length; i &lt; len; i++) &#123; mod.deps[mod.dependencies[i]] = Module.get(uris[i])// 依赖转变成 Module 实例 &#125; // 将当前模块及其祖先传入依赖中，作为依赖的 _entry 属性 // 以便依赖创建导出后，能唤起当前模块及其祖先件的 onload 方法 mod.pass() // 当依赖已加载，mod._entry 将不被清空，这时只需执行 mod.onload // 通过 mod.onload 执行所有被依赖模块的 callback 方法 if (mod._entry.length) &#123; mod.onload() return &#125; var requestCache = &#123;&#125; var m for (i = 0; i &lt; len; i++) &#123; m = cachedMods[uris[i]]// cachedMods 缓存所有 Module 实例 if (m.status &lt; STATUS.FETCHING) &#123; // 构建依赖加载函数，存入 requestCache 中 // 该函数会通过创建 script 节点或调用 importScripts 加载依赖 // 依赖加载完成后，递归调用 m.load 创建依赖的导出 m.fetch(requestCache) &#125; else if (m.status === STATUS.SAVED) &#123; // 旨在调用 m.onload 创建依赖的导出 m.load() &#125; &#125; // 逐个调用依赖加载函数 for (var requestUri in requestCache) &#123; if (requestCache.hasOwnProperty(requestUri)) &#123; requestCache[requestUri]() &#125; &#125;&#125; CommonJSCommonJS 规范指出：es2015 等官方规范定义了适用于客户端的标准 api，在服务端等领域却留下了巨大的真空。CommonJS 规范旨在于填补这个真空，像 Python、Rudy、Java 那样提供标准库，以期开发者使用 CommonJS 标准接口就能编写跨 js 解释器、跨宿主环境的应用。这些应用可以是服务端应用、命令行工具、桌面 GUI 应用、Adobe AIR 等混合应用。 Modules/1.1.1 规范定义了实现模块系统的最小特性： 在模块上下文中提供 require、exports、module 变量。每个模块以 module.id 作为唯一标识；module.uri 作为除沙箱环境外可访问的资源位。模块标识以小驼峰式设定，可以指定为相对路径。 require 函数以模块唯一标识为入参，模块导出 api 为出参。对于循环依赖，依赖模块须导出被依赖模块执行时所需的 api。require.main 或者为模块上下文中的 module 变量，或者为 undefined。require.pathes 用于指定 loader 加载模块的目录列表，优先级从高到低（loader 会对其进行解析）；但是 loader 不只会在 require.pathes 范围内查找模块。 exports 初始时持有 module.exports 相同的指针。exports 可用于增量改写导出方法或属性；module.exports 可用于全量改写导出对象。 CommonJS 的典型实现有 nodejs、browserify。 示例1234567// 导入const mod = require('moduleName');const x = require('moduleName').x;// 导出exports.x = mod;// 增量导出module.exports = mod;// 全量导出 nodejsnodejs 实现 require 函数的源码见于 cjs/loader.js。nodejs v13.12.0 也实现了 ES2015 模块的加载方式，参见 esm/loader.js。 CommonJS 在 nodejs 环境应用时，可用于加载 js、C++ 模块。与 requirejs、seajs 主要在浏览器环境加载远程资源不同的是，nodejs 加载的都是本地资源。nodejs 文档详细描绘了模块寻址流程。以 require(x) 为例，即如下： x 为 fs 等核心模块，加载该核心模块。 x 为文件模块 x 以 ‘/‘, ‘./‘, ‘../‘ 起始，首先查找 x 模块；其次查找 x.js、x.json、x.node 模块；其次查找 x/package.json 文件，取 main 属性加载模块，若 main 属性不存在，则加载 x/index.js、x/index.json、x/index.node 模块。 x 在 package.json 的 exports 属性中，按 exports 属性检索文件。 向上查找各 node_modules 文件夹中的 x 模块。 加载模块的整体流程为： 基于寻址流程获取 filename。 尝试从 Module._cache 中获取缓存。 loadNativeModule 加载核心模块。 创建 Module 实例并调用 module.load 加载文件模块。在 module.load 执行过程中，会使用 Module._extensions[extension] 编译执行 js 文件、解析 json 文件或执行 C++ 模块。 js 文件：使用 module._compile 编译处理模块内容。正是在这一过程中，nodejs 会使用 模块封装器 包装模块体，为其注入 require、module、exports、filename、dirname。 另据死月在《Node.js 来一打 C++ 扩展》中提到，npm 2.x 嵌套式依赖管理方案适合 node 端开发，相同依赖可以有多个版本；npm 3.x 扁平化管理方案适合纯前端开发，打包体积会较小。 ES2015比 AMD、CMD、CommonJS 后推出的 ECMAScript6 Module 规范旨在于整合前述模块化规范的优势，使不同的用户都满意。它有以下特点： 语法结构适合静态分析，编译期即可识别语法错误。 支持循环依赖、异步加载。 ES2015 规定以 Abstract Module Record 抽象模块记录封装单个模块的导入和导出。该规范还定义了 Cyclic Module Record 抽象子类用于处理循环依赖、Source Text Module Record 具体子类用于解析文件模块。其他规范或实现可据此实现自己的模块记录子类。Module Record 模块记录包含以下属性和方法（所有实现类均需包含）： [[Realm]]：创建模块的域。 [[Environment]]：模块对应的顶层词法环境。 [[Namespace]]：模块的命名空间。 [[HostDefined]]：宿主环境提供的附加信息。 GetExportedNames([exportStarSet])：获取导出列表。 ResolveExport(exportName [, resolveSet])：获取导出名称的绑定，{[[module]]: Module Record, [[bindingName]]: String} 形式。 Link()：递归解析模块依赖，创建模块的 Environment Record。 Evaluate()：创建模块的导出。首先会创建依赖的导出，然后再创建当前模块的导出；其次作错误处理。 我们可以发现，ES2015 规范中的模块导出构建过程与 seajs 有些相似，如 Link 方法譬如 seajs 中的 pass 方法，Evaluate 方法譬如 onLoad 方法。 示例1234567891011121314151617// 导入模块import v from \"mod\";import * as ns from \"mod\";import &#123; x &#125; from \"mod\";import &#123; x as v &#125; from \"mod\";import \"mod\";// 导出模块export var v;export default function f()&#123;&#125;;export default function()&#123;&#125;;export default 42;export &#123; x &#125;;export &#123; v as x &#125;;export &#123; x &#125; from \"mod\";export &#123; v as x &#125; from \"mod\";export * from \"mod\"; 其他UMDUMD 模块用于适配 AMD、CommonJs 模块化规范，它会用下述代码包裹模块体： 1234567891011121314((root, factory) =&gt; &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; //AMD define(['jquery'], factory); &#125; else if (typeof exports === 'object') &#123; //CommonJS var $ = requie('jquery'); module.exports = factory($); &#125; else &#123; root.testModule = factory(root.jQuery); &#125;&#125;)(this, ($) =&gt; &#123; //todo&#125;); 打包打包一个模块，可使用 webpack 或 rollup。 如使用 webpack 打包，有以下两个配置会影响打包策略。 output.library：指定导出模块名。 output.libraryTarget：指定打包后的模块系统。可选项 commonjs、commonjs2、amd、umd、var、global、window 等。commonjs2 用于改写 module.exports；commonjs 用于改写 exports 的指定属性。 与 webpack 会为打包后的模块添加如 webpackUniversalModuleDefinition 等内容不同，rollup 打包产物格外纯净，因此编写 library 推荐使用 rollup 进行打包。在 rollup 配置文件中，output.format 可用于打包后的模块系统，可选项包含 amd, cjs, esm, iife, umd。esm 即 ES2015 模块化规范；cjs 即 CommonJS；iife 将模块包装成立即执行的匿名函数（见于参考文档）。 参考前端模块化详解深入了解前端模块化","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"node 命令行工具","slug":"frontend/工程化/命令行工具","date":"2020-04-04T16:00:00.000Z","updated":"2020-04-05T03:33:07.239Z","comments":true,"path":"2020/04/05/frontend/工程化/命令行工具/","link":"","permalink":"http://xzfyu.com/2020/04/05/frontend/工程化/命令行工具/","excerpt":"","text":"示例简单的命令行工具一般按照以下流程编写： package.json 文件中添加 bin 属性，指定命令的名称，如 “bin”: { “create-app”: “bin/create-app.js” }。 bin/create-app.js 文件中添加 #!/usr/bin/env node，指定这是一个使用 node 执行的命令行工具。 使用 commander.js 编写 bin/create-app.js 脚本内容。 通过 npm link 或 yarn link 将软件包链接到全局空间，即可以调用 create-app directory 命令了。 12345678910111213141516171819202122232425262728293031#!/usr/bin/env nodeconst program = require('commander');const inquirer = require('inquirer');program .command('create-app &lt;directory&gt;') .action((directory) =&gt; &#123; inquirer.prompt([&#123; type: 'list', name: 'type', message: 'which framework do you want to use?', choices: ['react', 'vue', 'angular'] &#125;, &#123; type: 'input', name: 'name', message: \"what is your app's name?\", default: directory &#125;, &#123; type: 'input', name: 'version', message: \"what is your app's version?\", default: 'daily/0.0.1' &#125;, &#123; type: 'input', name: 'description', message: \"what is your app's description?\" &#125;]).then(answers =&gt; &#123; // 创建前端项目 &#125;) &#125;) .parse(process.argv); 命令行工具适用于编写命令行工具的模块有： commander.js 编写 node 命令。 yargs 编写 node 命令。 common-bin 在 yargs 基础上，以类语法形式编写 node 命令。 Inquirer.js 编写终端交互式面板。 enquirer 编写终端交互式面板。 概要地讲，commander.js 首先注册命令行参数处理规则，随后通过甄别用户输入（node 环境中的 progress.argv），再从已注册的处理规则中选取其一并应用之。 命令行参数通常被抽象称为子命令、选项。选项部分功能包含设置短标识、默认值、描述，特殊选项为版本号信息。子命令是一类处理操作 action handler 的抽象，其功能包含设置必选参数、可选参数、选项、描述等。选项、子命令构成 help 内容提示。选项和命令是对常规如 git push –force 命令的抽象。更为灵活的是通过 commander.js、yargs 解析用户输入，由开发者决定如何使用这些参数。当然，直接对 progress.argv 作处理也是可选的方案。这是 commander.js 模块所提供的核心功能。 commander.js 本质是非交互式的，在用户输入完成后调用 commander.js 模块进行处理，无需监听键盘事件。Inquirer.js、enquirer 是交互式的，需要监听用户侧的键盘输入，以实现单选、多选、密码等交互动作。它们借助 readline 模块处理标准输入 process.stdin、标准输出 process.stdout。 以下仅介绍 commander.js、Inquirer.js 的实现，因为 yargs、common-bin 与 commander.js 功能相同，enquirer 与 Inquirer.js 功能相同。 commander.jscommander.js 抽象了 Commander 命令模型、Option 选项模型两个类。为使 –help 操作能打印父命令包含的子命令信息，command 实例持有 parent 属性指向父命令，commands 属性存储下属命令，以及 _noHelp 等属性限定打印的帮助信息内容。一个 command 实例可以分为三阶段：注册阶段、执行阶段、打印帮助信息阶段。这里仅说明注册阶段、执行阶段的核心方法。 注册阶段主要方法 command、addCommand：注册命令。command 方法的参数为命令行输入模板，如 ‘clone [destination]’，返回值为新注册的子命令；addCommand 方法的参数为 Commander 实例，返回值为父命令。 action：注册命令的处理操作 action handler。命令是可执行的，除了注册处理操作以外，还可以通过 command 方法指定执行文件 _executableFile（默认为工程目录中的 program-command 文件）。 _parseExpectedArgs：用于为命令解析必选、可选参数，存入 Commander 实例的 _args 属性中。 option、requiredOption：用于为命令添加选项，Option 实例，存入 Commander 实例的 options 属性中。选项同样可以用 &lt;&gt;、[] 指定其为必选还是可选选项。选项可设置短标识、描述、默认值、选项值的匹配函数或正则。选项的值通过事件处理函数设置。特殊的，–no- 起始的选项会设置默认值为 true。 执行阶段主要方法 parse、parseAsync: 解析用户输入，随后选用命令并执行。命令行输入分为三种情况，库本身通过 npm link 注册可调用命令、或使用 node 调用可执行性模块、或在 electron 环境下执行。其处理流程包含：通过 parseOptions 方法解析选项；找到匹配的命令并执行，或打印命令的帮助信息。执行命令有两种，一种为通过 action 方法注册了可执行函数，另一种通过 _executableFile 指定了可执行文件，可参阅源码中的 _parseCommand、_executeSubCommand 部分。 commander.arguments 方法游离在主流程之外，其目的在于解析命令行输入，由开发者自行决定如何处理。 12345678910111213141516171819202122232425262728const program = require('commander');// 1. action handlerprogram .command('rm &lt;dir&gt;') .option('-r, --recursive', 'Remove recursively') .action(function (dir, cmdObj) &#123; console.log('remove ' + dir + (cmdObj.recursive ? ' recursively' : '')) &#125;) .parse(process.argv);// 2. executable fileprogram .command('install [name]', 'install one or more packages') .command('search [query]', 'search with optional query') .command('update', 'update installed packages', &#123;executableFile: 'myUpdateSubCommand'&#125;) .command('list', 'list packages installed', &#123;isDefault: true&#125;) .parse(process.argv);// 3. argumentsprogram .version('0.1.0') .arguments('&lt;cmd&gt; [env]') .action(function (cmd, env) &#123; cmdValue = cmd; envValue = env; &#125;) .parse(process.argv); Inquirer.js作为一个使用 leran 打造的工程，Inquirer.js 由如下模块构成： 在传统模式中，Inquirer.js 通过 StateManager 制作 input 等模块。有趣的是，Inquirer.js 像 react 一样实现了 hooks 机制，input 等模块也改由 hooks 实现了。 StateManagerStateManager 类命令行界面交互及渲染逻辑。借助 readline 监听命令行输入，即键盘事件（回车、返回作为单次交互的终止符）。在逻辑上，它首先会根据初始化输入渲染命令行输出；然后通过监听键盘事件，它会把命令行输入存入内部状态中；同时在变更内部状态期间，它会重新渲染输出；直到用户点击回车或返回，交互行为才会宣告结束，它会驱动执行最终回调。在以上过程中，用户侧的键盘输入并不会直接转化成命令行输出，这借助 mute-stream 模块使输出面板变得静默（不会即时响应用户输入），而需要经由状态值变更来驱动输出面板的重绘。 关于交互事件的监听，readline 模块提供了 readline.createInterface 方法用于创建 readline.Interface 实例（以 rl 指代）。通过 rl.on(‘line’, handler) 可以监听 line 事件；通过 rl.input.on(‘keypress’) 可以监听键盘事件（当按键为回车或返回键时，这个事件同时会触发 line 事件绑定函数）。关于输出面板的渲染，Inquirer.js 借助 readline.output.write 渲染输出面板；readline.setPrompt 设置提示。在 screen-manager 模块中，Inquirer.js 首先会基于待渲染内容调用 readline.setPrompt 设置提示，然后基于 cli-width 模块为渲染内容分行，再行调用 readline.output.write 绘制输出面板，随后基于 ansi-escapes 模块调整光标的位置。 对于 input、select 等模块的交互和渲染差异，Inquirer.js 基于不同的 StateManager 实例呈现多态。在创建 StateManager 实例过程中，它允许 input 模块注册 onKeypress、onLine 等钩子，以对命令行输入作出不同的响应；同时设置 render 状态渲染函数，以便在命令行输出中绘制不同的内容。input 等模块提供的状态渲染函数仅需要将状态值转变为待渲染的内容，由 screen-manager 模块进行绘制。 以 input 模块为例，单个 StateManager 实例的总执行流程为： [内部]input 模块通过 createPrompt 注册 config.onKeypress 等配置，render 状态渲染函数。 [调用者]通过 input 接口设定 initialState 初始状态、最终回调 cb，[内部]基于初始状态渲染命令行输出面板。 [内部]StateManager 实例内监听键盘行为，基于状态变更重绘输出面板。 [调用者]点击 enter 按键，[内部]StateManager 实例驱动执行最终回调 cb，[调用者]消费最终状态。 以下是 StateManager 摘要性源码（剔除了状态值校验、异步逻辑等）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110class StateManager &#123; constructor(configFactory, initialState, render) &#123; this.config = _.isFunction(configFactory) ? configFactory(this.rl) :configFactory; this.initialState = initialState; this.render = render; this.currentState = &#123; loadingIncrement: 0, value: '', status: 'idle' &#125;; const input = process.stdin; const output = new MuteStream(); output.pipe(process.stdout); // http://nodejs.cn/api/readline.html#readline_readline_createinterface_options this.rl = readline.createInterface(&#123; terminal: true, input, output &#125;); this.screen = new ScreenManager(this.rl); &#125; async execute(cb) &#123; let &#123; message &#125; = this.getState(); this.cb = cb; this.setState(&#123; message, status: 'idle' &#125;); this.rl.input.on('keypress', this.onKeypress); this.rl.on('line', this.handleLineEvent); &#125; // 将键盘输入记录到 state 中，并触发 onKeypress // enter、return 按键由 line 事件处理 onKeypress(value, key) &#123; const &#123; onKeypress = _.noop &#125; = this.config; if (key.name === 'enter' || key.name === 'return') return; this.setState(&#123; value: this.rl.line, error: null &#125;); onKeypress(this.rl.line, key, this.getState(), this.setState); &#125; // enter、return 按键，触发 onLine 完成 submit 等操作 handleLineEvent() &#123; const &#123; onLine = defaultOnLine &#125; = this.config; onLine(this.getState(), &#123; submit: this.onSubmit, setState: this.setState &#125;); &#125; // 剔除对 value 的校验、filter 处理后代码 async onSubmit() &#123; const state = this.getState(); const &#123; mapStateToValue = defaultMapStateToValue &#125; = this.config; let value = mapStateToValue(state); this.rl.pause(); // 状态值清空，解绑事件，执行 this.cb 回调 this.onDone(value); this.rl.resume(); &#125; setState(partialState) &#123; this.currentState = Object.assign(&#123;&#125;, this.currentState, partialState); this.onChange(this.getState()); &#125; // 状态变更时，重绘输出 onChange(state) &#123; const &#123; status, message, value, transformer &#125; = this.getState(); let error; if (state.error) &#123; error = `$&#123;chalk.red('&gt;&gt;')&#125; $&#123;state.error&#125;`; &#125; const renderState = Object.assign( &#123; prefix: this.getPrefix() &#125;, state, &#123; // Only pass message down if it's a string. Otherwise we're still in init state message: _.isFunction(message) ? 'Loading...' : message, value: transformer(value, &#123; isFinal: status === 'done' &#125;), validate: undefined, filter: undefined, transformer: undefined &#125; ); this.screen.render(this.render(renderState, this.config), error); &#125;&#125;const createPrompt = (config, render) =&gt; &#123; const run = initialState =&gt; new Promise(resolve =&gt; &#123; const prompt = new StateManager(config, initialState, render); prompt.execute(resolve); &#125;); run.render = render; run.config = config; return run;&#125;; hooks有趣的是，hooks 包括 useState、useEffect、useRef、useKeypress 等。其实现机制是创建一个 readline.Interface 实例对交互行为进行监听，以变更 state，并触发重绘流程，执行 effect 等。input 等基于 hooks 制作的模块主要在于变更 state，基于 state 获取输出面板上的待渲染内容。以下是 hooks 部分源码及 confirm 模块对 hooks 的应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137let sessionRl;let hooks = [];// 存储 hookslet hooksCleanup = [];// 存储 hooks 清理函数let index = 0;let handleChange = () =&gt; &#123;&#125;;// 清理 hooksconst cleanupHook = index =&gt; &#123; /* ... */ &#125;;exports.useState = defaultValue =&gt; &#123; const _idx = index; const value = _idx in hooks ? hooks[_idx] : defaultValue; index++; return [ value, newValue =&gt; &#123; hooks[_idx] = newValue; handleChange();// 驱动重绘 &#125; ];&#125;;exports.useKeypress = userHandler =&gt; &#123; const _idx = index; const prevHandler = hooks[_idx]; const handler = (input, event) =&gt; &#123; userHandler(event, sessionRl); &#125;; if (prevHandler !== handler) &#123; cleanupHook(_idx); sessionRl.input.on('keypress', handler); hooks[_idx] = handler; hooksCleanup[_idx] = () =&gt; &#123; sessionRl.input.removeListener('keypress', handler); &#125;; &#125; index++;&#125;;exports.useEffect = (cb, depArray) =&gt; &#123; const _idx = index; const oldDeps = hooks[_idx]; let hasChanged = true; if (oldDeps) &#123; hasChanged = depArray.some((dep, i) =&gt; !Object.is(dep, oldDeps[i])); &#125; if (hasChanged) &#123; cleanupHook(_idx); hooksCleanup[_idx] = cb(); &#125; hooks[_idx] = depArray; index++;&#125;;exports.useRef = val =&gt; &#123; return exports.useState(&#123; current: val &#125;)[0];&#125;;exports.createPrompt = view =&gt; &#123; return options =&gt; &#123; const input = process.stdin; const output = new MuteStream(); output.pipe(process.stdout); const rl = readline.createInterface(&#123; terminal: true, input, output &#125;); const screen = new ScreenManager(rl); return new Promise((resolve, reject) =&gt; &#123; sessionRl = rl; const done = value =&gt; &#123; let len = cleanupHook.length; while (len--) &#123; cleanupHook(len); &#125; screen.done(); hooks = []; index = 0; sessionRl = undefined; resolve(value); &#125;; hooks = []; const workLoop = config =&gt; &#123; index = 0; handleChange = () =&gt; workLoop(config);// 将最新的状态值交给 handleChange screen.render(...[view(config, done)].flat().filter(Boolean)); &#125;; // getPromptConfig 用于将 options 用户配置项转换为 config getPromptConfig(options).then(workLoop, reject); &#125;); &#125;;&#125;;// confirm 模块module.exports = createPrompt((config, done) =&gt; &#123; const [status, setStatus] = useState('pending'); const [value, setValue] = useState(''); const prefix = usePrefix(); // 监听键盘事件 useKeypress((key, rl) =&gt; &#123; if (isEnterKey(key)) &#123; const answer = value ? /^y(es)?/i.test(value) : config.default !== false; setValue(answer ? 'yes' : 'no'); setStatus('done'); done(answer); &#125; else &#123; setValue(rl.line); &#125; &#125;); // 重新计算熏染内容 let formattedValue = value; let defaultValue = ''; if (status === 'done') &#123; formattedValue = chalk.cyan(value ? 'yes' : 'no'); &#125; else &#123; defaultValue = chalk.dim(config.default === false ? ' (y/N)' : ' (Y/n)'); &#125; const message = chalk.bold(config.message); return `$&#123;prefix&#125; $&#123;message&#125;$&#123;defaultValue&#125; $&#123;formattedValue&#125;`;&#125;); 常用工具shelljs 用于执行 shell 脚本，常用如执行 git 操作。rimraf 移除文件夹或文件。chalk 在终端上带色彩打印内容。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"电商后台建模","slug":"计算机科学/软件工程/电商后台建模","date":"2020-03-28T16:00:00.000Z","updated":"2020-03-08T11:08:01.232Z","comments":true,"path":"2020/03/29/计算机科学/软件工程/电商后台建模/","link":"","permalink":"http://xzfyu.com/2020/03/29/计算机科学/软件工程/电商后台建模/","excerpt":"","text":"系统建模系统建模是对软件系统的抽象，滤除了对细节的关照，通常需要包含如下内容： 上下文模型：说明系统在上下文环境中有怎样的构成，边界如何。上下文模型并未说明各系统的交互关系。 业务过程模型：说明系统中某个业务人工或自动化的处理过程，并交代各系统在该业务过程中的交互行为。可使用 UML 活动图绘制。 交互模型：说明系统与外部参与者（用户或其他系统）之间的交互关系，其中传递的数据可通过文本或结构化表格描述。可使用 UML 用例图、时序图绘制。 结构模型：说明系统内各组件的构成和关系以及数据结构，包含静态模型和运行时的动态模型。可使用 UML 类图绘制。 行为模型：说明系统运行时的动态行为，动态行为发生缘由可以是数据或事件。可使用 UML 活动图、时序图、状态图绘制。 电商后台","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"软件工程","slug":"计算机科学/软件工程","permalink":"http://xzfyu.com/categories/计算机科学/软件工程/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"}]},{"title":"webpack 踩坑录","slug":"踩坑/webpack 踩坑录","date":"2020-03-17T16:00:00.000Z","updated":"2020-03-18T14:22:31.165Z","comments":true,"path":"2020/03/18/踩坑/webpack 踩坑录/","link":"","permalink":"http://xzfyu.com/2020/03/18/踩坑/webpack 踩坑录/","excerpt":"","text":"懒加载Q: 使用 webpack4, @babel/plugin-syntax-dynamic-import 插件后，react-router3 中基于 require.ensure 将不再生效，需要使用如 react-loadable 等加载方式。可参考 react-router的3种按需加载介绍。A: 猜想：webpack 中使用 require.ensure, import() 采用同一套机制，dynamic-import 插件也会影响 require.ensure，将导出模块转换成 promise。babel 文档 @babel/plugin-syntax-dynamic-import、webpack 文档 Dynamic Imports 指明，import() 需要加载 es6-promise 或者 promise-polyfill 垫片。require.ensure 是 webpack 所使用的传统方法。 Q: chunkFileName","categories":[{"name":"踩坑","slug":"踩坑","permalink":"http://xzfyu.com/categories/踩坑/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"图片校验码","slug":"frontend/guide/图片校验码","date":"2020-03-10T16:00:00.000Z","updated":"2020-03-11T02:27:09.399Z","comments":true,"path":"2020/03/11/frontend/guide/图片校验码/","link":"","permalink":"http://xzfyu.com/2020/03/11/frontend/guide/图片校验码/","excerpt":"","text":"纯前端实现纯前端实现图片校验码指的是通过 canvas 绘制随机串的方式。这种方式有极大的弊端：如果随机串在前端生成，那么通过拦截伪造请求仍然能正常调用后台接口；如果随机串由后台发送给前端，那么中间可以被拦截并伪造（当然，可尝试用加密技术进行保护）。因此，这种方式大体适用于学习研究的目的。以下代码段基于 react 验证码组件 整理，其实现也可以参考 在React中随机生成图形验证码。您可以在 codesandbox 查看效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import React, &#123; useState, useRef, useEffect &#125; from 'react';import styles from './index.less';const getRandom = (max: number, min: number, num?: number) =&gt; &#123; const asciiNum = ~~(Math.random() * (max - min + 1) + min) if (!num) return asciiNum; const arr = [] for (let i = 0; i &lt; num; i++) &#123; arr.push(getRandom(max, min)) &#125; return arr&#125;const VerifyCode = (&#123; code, onRefresh,&#125;: &#123; code: string, onRefresh?: () =&gt; void, &#125;) =&gt; &#123; const [rotate, setRotate] = useState(getRandom(15, -15, 4)); const [color, setColor] = useState([ getRandom(0, 255, 3), getRandom(0, 255, 3), getRandom(0, 255, 3), getRandom(0, 255, 3) ]); const canvasRef = useRef&lt;any&gt;(null); const refreshCanvas = () =&gt; &#123; const canvas = canvasRef.current; if (canvas &amp;&amp; canvas.getContext) &#123; let ctx = canvas.getContext(\"2d\"); ctx.clearRect(0, 0, canvas.width, canvas.height); for (let i = 0; i &lt; 4; i++) &#123; ctx.font = '80px Calibri'; //随机生成字体大小 ctx.fillStyle = `rgb($&#123;color[i].toString()&#125;)`; //随机生成字体颜色 let x = canvas.width / (5) * (i + 1); let y = canvas.height / 2; let deg = rotate[i]; /**设置旋转角度和坐标原点**/ ctx.translate(x, y); ctx.rotate(deg * Math.PI / 180); ctx.fillText(code[i], 0, 0); /**恢复旋转角度和坐标原点**/ ctx.rotate(-deg * Math.PI / 180); ctx.translate(-x, -y); &#125; /**绘制干扰线**/ for (let i = 0; i &lt; 4; i++) &#123; ctx.strokeStyle = getRandom(100, 255, 3); ctx.beginPath(); ctx.moveTo(getRandom(0, canvas.width), getRandom(0, canvas.height)); ctx.lineTo(getRandom(0, canvas.width), getRandom(0, canvas.height)); ctx.stroke(); &#125; /**绘制干扰点**/ for (let i = 0; i &lt; canvas.width / 4; i++) &#123; ctx.fillStyle = getRandom(0, 255); ctx.beginPath(); ctx.arc(getRandom(0, canvas.width), getRandom(0, canvas.height), 1, 0, 2 * Math.PI); ctx.fill(); &#125; &#125; &#125; useEffect(() =&gt; &#123; refreshCanvas(); &#125;, [code]); const handleRefresh = () =&gt; &#123; setRotate(getRandom(15, -15, 4)); setColor([ getRandom(0, 255, 3), getRandom(0, 255, 3), getRandom(0, 255, 3), getRandom(0, 255, 3) ]); onRefresh &amp;&amp; onRefresh(); &#125; return ( &lt;div className=&#123;styles.verify_code_wrap&#125;&gt; &lt;canvas className=&#123;styles.canvas&#125; ref=&#123;canvasRef&#125;&gt;&lt;/canvas&gt; &lt;div className=&#123;styles.refresh&#125; onClick=&#123;() =&gt; &#123; handleRefresh(); &#125;&#125; &gt; 看不清？换一个 &lt;/div&gt; &lt;/div&gt; )&#125;export default VerifyCode; 123456789101112131415161718192021222324.verify_code_wrap &#123; position: relative; overflow: hidden; width: 100%; height: 11.73333vw;&#125;.canvas &#123; width: 64%; height: 100%;&#125;.refresh &#123; display: inline-block; text-align: center; width: 30%; height: 100%; line-height: 11.73333vw; vertical-align: top; margin-left: 6%; cursor: pointer; color: #da2824;&#125; 后端传图片后端传图片指的是后端制作图片校验码，或者将以 base64 的方式传递给前端，或者以纯图片的方式传递。若为 base64 数据，前端部分仅需指定 img 的 src 值。若为纯图片，须使用原生接口刷新图片，如下： 12345678910111213141516171819202122export default () =&gt; &#123; const imgWrap = useRef&lt;HTMLDivElement&gt;(null); const handleRefresh = () =&gt; &#123; const image = new Image(); image.src = src; imgWrap.current.replaceChild(image, imgWrap.current.firstChild); &#125; return ( &lt;div ref=&#123;imgWrap&#125;&gt; &#123;validCodeData &amp;&amp; &lt;img src=&#123;src&#125; /&gt;&#125; &lt;div className=&#123;styles.refresh&#125; onClick=&#123;() =&gt; &#123; handleRefresh(); &#125;&#125; &gt; 看不清？换一个 &lt;/div&gt; &lt;/div&gt; )&#125; 后端部分可参考 Java实现图片验证码，结合 session 才能做完整校验。react中图片校验码实现以及new Buffer()使用方法 描述了使用 reponseType = arraybuffer 接取数据再转成 base64 的方式，未及尝试。arraybuffer 可参考 深入理解xhr的responseType中blob和arrayBuffer。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"guide","slug":"frontend/guide","permalink":"http://xzfyu.com/categories/frontend/guide/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"}]},{"title":"react fiber hooks钩子篇","slug":"frontend/react16/react fiber hooks钩子篇","date":"2020-03-07T16:00:00.000Z","updated":"2020-03-22T15:42:53.974Z","comments":true,"path":"2020/03/08/frontend/react16/react fiber hooks钩子篇/","link":"","permalink":"http://xzfyu.com/2020/03/08/frontend/react16/react fiber hooks钩子篇/","excerpt":"","text":"前言本文浅述了 react hooks 的执行机制，但在 expirationTime 优先级处理、suspenseConfig 配置、side-effects 执行机制、useContext、useTransition、useResponder 等方面显得力有不逮，并且未采用图文描述的形式。个中错谬，仍需勘正。 react hooks 的使用可参考 React Hooks的体系设计之一 - 分层、react-hooks中的一些懵逼点 等文章。 React Hooks 原理 以探索性的方式推想了 hooks 机制的实现原理；[译] 深入 React Hook 系统的原理 也能为理解 hooks 机制带来帮助。 主流程react hooks 在函数式组件的渲染函数内运行生效，其实现基于使用 renderWithHooks 封装渲染函数。在 renderWithHooks 运行过程中，通过感知组件的渲染阶段 —— mount 挂载、update 更新等，继而通过 ReactCurrentDispatcher 切换 useState 等函数的实现，以此在 mount 阶段构建 hook（包含初始状态、状态更新函数），或者在 update 阶段获取最新状态。 hook 以链表的形式存储在 workInProgressFiber.memoizedState 中。在首次渲染完成后，随着 workInProgressFiber 转化成新的 currentFiber，memoizedState 同样也被存入 currentFiber 中。再次渲染时，workInProgressFiber.memoizedState 会被重置为 null，因此基于 currentFiber.memoizedState 的值就可以区分 mount 挂载、update 更新阶段，以此切换 ReactCurrentDispatcher 实现，如 HooksDispatcherOnMount、HooksDispatcherOnUpdate。 以 useState 说明 hook 处理流程如下： 首次渲染时调用 useState，基于 HooksDispatcherOnMount 走 mountState 处理流程，构建 hook 并获取初始状态，随后消费 state 进行渲染，结束 mount 流程 基于 hook 更新状态，在状态更新逻辑的尾部会调用 scheduleWork 启动 fiber 重绘流程 再次渲染时调用 useState，基于 HooksDispatcherOnUpdate 走 updateState 流程，获取并消费最新 state 进行渲染，结束 update 流程 除了 mount 挂载、update 更新外，ReactCurrentDispatcher 另有两种实现态：为了避免 hook 在渲染函数外部执行，fiber reconciler 提供了 ContextOnlyDispatcher 实现；为了实现渲染函数内部当即更新 state，fiber reconciler 提供了 HooksDispatcherOnRerender 实现。逻辑上，渲染函数内部更新 state 使用 do-while 循环更新状态，这时 useState 调用将走 rerenderState 流程，且不会调用 scheduleWork（因为本身就在一个渲染流程中）；fiber reconciler 也限制了这种 state 更新方式的最大次数。 这里贴出 renderWithHooks 的删减版源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function renderWithHooks( current: Fiber | null,// current fiber workInProgress: Fiber,// work-in-progress fiber Component: any,// 函数组件的渲染函数 props: any,// 渲染函数的参数 props secondArg: any,// 渲染函数的次参 nextRenderExpirationTime: ExpirationTime,): any &#123; renderExpirationTime = nextRenderExpirationTime; // 缓存当前处理中的 fiber。renderWithHooks 结束置为 null currentlyRenderingFiber = workInProgress; // 函数体每次执行时重置 workInProgress.memoizedState，借以与 currentFiber.memoizedState 有差别 workInProgress.memoizedState = null; workInProgress.updateQueue = null; workInProgress.expirationTime = NoWork; // 使用 currentFiber.memoizedState 区分 mount、update 阶段，使用不同的 ReactCurrentDispatcher 实现 // mount 阶段，HooksDispatcherOnMount 将促使 useState 调用走 mountState 流程 // update 阶段，HooksDispatcherOnUpdate 将促使 useState 调用走 updateState 流程 ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate; // 调用渲染函数，获取 hook 或最新状态，渲染内容 let children = Component(props, secondArg); // 在渲染函数体内更新 state，限制函数体内最大更新次数 if (workInProgress.expirationTime === renderExpirationTime) &#123; let numberOfReRenders: number = 0; // do-while 循环获取最新 state do &#123; workInProgress.expirationTime = NoWork; invariant( numberOfReRenders &lt; RE_RENDER_LIMIT, 'Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.', ); numberOfReRenders += 1; // Start over from the beginning of the list currentHook = null; workInProgressHook = null; workInProgress.updateQueue = null; // HooksDispatcherOnRerender 将促使 useState 调用走 rerenderState 流程 ReactCurrentDispatcher.current = __DEV__ ? HooksDispatcherOnRerenderInDEV : HooksDispatcherOnRerender; // 调用渲染函数，获取最新状态，渲染内容 children = Component(props, secondArg); &#125; while (workInProgress.expirationTime === renderExpirationTime); &#125; // 将 ReactCurrentDispatcher 置为 ContextOnlyDispatcher，避免 hook 在函数体外调用 ReactCurrentDispatcher.current = ContextOnlyDispatcher; // didRenderTooFewHooks 为真，意为有些 hook 未执行完全，过早返回 state const didRenderTooFewHooks = currentHook !== null &amp;&amp; currentHook.next !== null; renderExpirationTime = NoWork; currentlyRenderingFiber = (null: any); currentHook = null; workInProgressHook = null; didScheduleRenderPhaseUpdate = false; invariant( !didRenderTooFewHooks, 'Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.', ); return children;&#125; 我们可以看到，renderWithHooks 执行过程中处理的缓存变量： ReactCurrentDispatcher：hook 处理策略，其实现有 HooksDispatcherOnMount、HooksDispatcherOnUpdate、HooksDispatcherOnRerender、ContextOnlyDispatcher，上文已有描述。 currentlyRenderingFiber：缓存当前处理中的 fiber。renderWithHooks 执行中置为 workInProgressFiber，执行完置为 null。这样切分后的功能函数不必以传参的方式获取当前处理中的 fiber。 workInProgressHook：当前处理中的 hook。mount 阶段，通过 mountWorkInProgressHook 构造 workInProgressHook，并存入 workInProgressFiber.memoizedState；update 阶段，通过 updateWorkInProgressHook 从 workInProgressFiber.memoizedState 中获取或拷贝 currentHook 得来。 currentHook：其意义在于 update 阶段起始，workInProgressFiber.memoizedState 会被重置，currentFiber.memoizedState 保存了 hook 的完整链表，因此需要通过 currentHook 从 currentFiber.memoizedState 取出 hook 钩子，拷贝给 workInProgressHook，才有真正要处理的 hook。 renderExpirationTime：组件渲染的 deadline 时间，决定了更新是否需要被应用、还是被挂起。 didScheduleRenderPhaseUpdate：是否在 render 阶段更新 state。renderWithHooks 执行完置为 false，状态更新时判断触发更新的 fiber 是否与 currentlyRenderingFiber 等值，如等值，置为 true。当报错时，fiber reconciler 将基于 didScheduleRenderPhaseUpdate 丢弃各 hook 的 queue.pending，参考文档。 state 类钩子本节将 useState、useReducer 置为同类，因为 useState 期间所使用的各方法筑基在 useReducer 各方法之上。 hooks 中的状态变更与 redux 相仿，即采用 reducer = (prevState, action) =&gt; newState 计算 nextState。通常而言，新的状态计算产生后，fiber reconciler 会调用 scheduleWork 重新调度当前 fiber 的渲染任务。这是 state 变更的主流程。依循上文，这两种钩子的整体处理流程为： mount 阶段，通过 mountReducer、mountState 创建 hook 基于 hook.dispatch 更新状态 update 阶段，通过 updateReducer、updateState 获取最新的 state，其内部会调用 scheduleWork 重绘 fiber 特别的，若渲染函数内更新状态，通过 rerenderReducer、rerenderState 获取最新的 state，其内部不会触发 fiber 重绘 hook 为链表。其中，hook.baseState 属性用于存储更新前的 state；memoizedState 属性用于存储更新后的 state；queue 属性即一个 UpdateQueue 实例，包含状态变更逻辑、排队中的状态变更规则；baseQueue 就绪中的状态变更规则。baseQueue 按照优先级处理，比如有两组优先级更新，优先级高的会将 memoizedState 置为最新状态，优先级低的仍旧使用 baseState 作为初始状态。 hook.queue 作为一个 UpdateQueue 实例，其包含：lastRenderedState 属性存储上一个 state；lastRenderedReducer 属性存储 reducer 内部状态变更逻辑；dispatch 属性存储用户侧调用的状态变更接口；pending 属性存储排队中的状态变更规则。queue.dispatch 构建时会与 currentlyRenderingFiber 绑定，惟其如此，才能判断状态更新是否在当前 fiber 的 render 阶段，还是异步触发，以此将 didScheduleRenderPhaseUpdate 置为 true。 hook.baseQueue、hook.queue.pending 均为 Update 链表形式。update 包含：eagerReducer 缓存上一个 reducer；eagerState 缓存上一个状态，以便复用；action 状态变更的规则；expirationTime 过期时间，即 deadline 时间，未到该时间点，更新将不予执行；suspenseConfig 意为 suspense 配置。当使用 useReducer 时，reducer 在历次渲染函数中是可变的，如果 reducer 没有发生变更，fiber reconciler 将复用 update.eagerState。 useState、useReducer 中的 hook.dispatch 均基于 dispatchAction 构建，且在 fiber reconciler 内部就会装填参数 fiber、queue，用户侧只需传入 action。hook.dispatch 对外透出时作为 useState、useReducer 返回值中的第二个数组项，调回该方法即可更新状态。其处理流程为： 基于 action 构建 update 实例，并将其添加到 hook.queue.pending 队列中 若在 render 阶段调用 hook.dispatch，更新 expirationTime，等待调度作业阶段获取 state；若否且 fiber 更新为同步任务，调用 reducer 计算最新状态 调用 scheduleWork 调度作业，执行重绘流程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function dispatchAction&lt;S, A&gt;( fiber: Fiber,// 状态变更所作用的 fiber，用于推断是否在 render 阶段应用更新 queue: UpdateQueue&lt;S, A&gt;,// hook.queue，用于获取状态变更逻辑 action: A,// 用户侧传入的状态变更规则 action) &#123; const currentTime = requestCurrentTimeForUpdate(); const suspenseConfig = requestCurrentSuspenseConfig(); const expirationTime = computeExpirationForFiber( currentTime, fiber, suspenseConfig, ); // 构建 update 实例 const update: Update&lt;S, A&gt; = &#123; expirationTime, suspenseConfig, action, eagerReducer: null, eagerState: null, next: (null: any), &#125;; // 将 update 添加到 hook.queue.pending 中 const pending = queue.pending; if (pending === null) &#123; update.next = update; &#125; else &#123; update.next = pending.next; pending.next = update; &#125; queue.pending = update; const alternate = fiber.alternate; // 推断是否在 render 阶段应用更新（调用 hook.dispatch） if ( fiber === currentlyRenderingFiber || (alternate !== null &amp;&amp; alternate === currentlyRenderingFiber) ) &#123; // This is a render phase update. Stash it in a lazily-created map of // queue -&gt; linked list of updates. After this render pass, we'll restart // and apply the stashed updates on top of the work-in-progress hook. didScheduleRenderPhaseUpdate = true; update.expirationTime = renderExpirationTime; currentlyRenderingFiber.expirationTime = renderExpirationTime; &#125; else &#123; // fiber.expirationTime 为 NoWork 时，采用同步更新处理 if ( fiber.expirationTime === NoWork &amp;&amp; (alternate === null || alternate.expirationTime === NoWork) ) &#123; // 应用 queue.lastRenderedReducer 变更状态，并将变更结果存入 update // 若状态未变更，直接退出 const lastRenderedReducer = queue.lastRenderedReducer; if (lastRenderedReducer !== null) &#123; let prevDispatcher; try &#123; const currentState: S = (queue.lastRenderedState: any); const eagerState = lastRenderedReducer(currentState, action); // reducer 调用后才会赋值 update.eagerReducer、update.eagerState update.eagerReducer = lastRenderedReducer; update.eagerState = eagerState; if (is(eagerState, currentState)) &#123; return; &#125; &#125; catch (error) &#123; // Suppress the error. It will throw again in the render phase. &#125; &#125; &#125; // 调度 fiber 的渲染任务 scheduleWork(fiber, expirationTime); &#125;&#125; 因为 hook.dispatch 会调度一些异步更新，对于这些异步更新，state 变更在 updateReducer 函数中处理。updateReducer 的处理流程为： 将 hook.queue.pend 排队更新任务队列添加到 hook.baseQueue 就绪更新任务队列中 执行 hook.baseQueue 中优先级足够的更新或复用 hook.dispatch 获得的更新状态 优先级不够的 update 任务等待下次调度作业处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function updateReducer&lt;S, I, A&gt;( reducer: (S, A) =&gt; S, initialArg: I, init?: I =&gt; S,): [S, Dispatch&lt;A&gt;] &#123; const hook = updateWorkInProgressHook(); const queue = hook.queue; invariant( queue !== null, 'Should have a queue. This is likely a bug in React. Please file an issue.', ); queue.lastRenderedReducer = reducer; const current: Hook = (currentHook: any); // fiber 渲染后，尚未执行完成 update 更新，存于 currentFiber let baseQueue = current.baseQueue; // 排队中的 update 更新，存于 workInProgressFiber let pendingQueue = queue.pending; // 将排队中的 update 更新添加到 baseQueue if (pendingQueue !== null) &#123; if (baseQueue !== null) &#123; let baseFirst = baseQueue.next; let pendingFirst = pendingQueue.next; baseQueue.next = pendingFirst; pendingQueue.next = baseFirst;// pending 队列尾节点添加 baseFirst &#125; current.baseQueue = baseQueue = pendingQueue; queue.pending = null; &#125; if (baseQueue !== null) &#123; let first = baseQueue.next; let newState = current.baseState; let newBaseState = null; let newBaseQueueFirst = null; let newBaseQueueLast = null; let update = first; do &#123; const updateExpirationTime = update.expirationTime; // update 优先级不足，将其存入 newBaseQueueList 等待更新 if (updateExpirationTime &lt; renderExpirationTime) &#123; const clone: Update&lt;S, A&gt; = &#123; expirationTime: update.expirationTime, suspenseConfig: update.suspenseConfig, action: update.action, eagerReducer: update.eagerReducer, eagerState: update.eagerState, next: (null: any), &#125;; if (newBaseQueueLast === null) &#123; newBaseQueueFirst = newBaseQueueLast = clone; newBaseState = newState; &#125; else &#123; newBaseQueueLast = newBaseQueueLast.next = clone; &#125; // Update the remaining priority in the queue. if (updateExpirationTime &gt; currentlyRenderingFiber.expirationTime) &#123; currentlyRenderingFiber.expirationTime = updateExpirationTime; markUnprocessedUpdateTime(updateExpirationTime); &#125; &#125; else &#123; // This update does have sufficient priority. // 同 UpdateQueue，当优先级高的 update 任务在优先级低的 update 任务后 // 添加到 newBaseQueueList 中，更新处理会执行多次 if (newBaseQueueLast !== null) &#123; const clone: Update&lt;S, A&gt; = &#123; expirationTime: Sync, // This update is going to be committed so we never want uncommit it. suspenseConfig: update.suspenseConfig, action: update.action, eagerReducer: update.eagerReducer, eagerState: update.eagerState, next: (null: any), &#125;; newBaseQueueLast = newBaseQueueLast.next = clone; &#125; // Mark the event time of this update as relevant to this render pass. // TODO: This should ideally use the true event time of this update rather than // its priority which is a derived and not reverseable value. // TODO: We should skip this update if it was already committed but currently // we have no way of detecting the difference between a committed and suspended // update here. markRenderEventTimeAndConfig( updateExpirationTime, update.suspenseConfig, ); // hook.dispatch 变更状态后再执行组件的渲染函数 // 若 reducer 未变更，复用之前的状态 update.eagerState // 若 reducer 变更，使用 reducer 计算最新的状态 if (update.eagerReducer === reducer) &#123; newState = ((update.eagerState: any): S); &#125; else &#123; const action = update.action; newState = reducer(newState, action); &#125; &#125; update = update.next; &#125; while (update !== null &amp;&amp; update !== first); if (newBaseQueueLast === null) &#123; newBaseState = newState; &#125; else &#123; newBaseQueueLast.next = (newBaseQueueFirst: any); &#125; if (!is(newState, hook.memoizedState)) &#123; markWorkInProgressReceivedUpdate(); &#125; hook.memoizedState = newState; hook.baseState = newBaseState; hook.baseQueue = newBaseQueueLast; queue.lastRenderedState = newState; &#125; const dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any); return [hook.memoizedState, dispatch];&#125; effect 类钩子本节将 useEffect、useLayoutEffect、useImperativeHandle、useDeferredValue 置为同类。它们都基于 Effect 数据结构。其包含：tag 指 side-effects 处理类型；create 指 side-effects 处理函数，在 commit 阶段执行，其返回值构成 effect.destroy（组件销毁时执行）；deps 指 side-effects 处理依赖。无论在 mount 还是 update 阶段，effect 类钩子的表现都是将 lastEffect 存入 workInProgressFiber.updateQueue，等待在 commit 阶段被执行。 12345678910111213141516171819202122232425262728293031323334353637383940function mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void &#123; const hook = mountWorkInProgressHook();// 构建 hook const nextDeps = deps === undefined ? null : deps; currentlyRenderingFiber.effectTag |= fiberEffectTag; // pushEffect 构建 effect，并将其以 &#123; lastEffect &#125; 形式存入 workInProgressFiber.updateQueue 中 hook.memoizedState = pushEffect( HookHasEffect | hookEffectTag, create, undefined, nextDeps, );&#125;function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void &#123; const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; let destroy = undefined; // 复用之前的 destory if (currentHook !== null) &#123; const prevEffect = currentHook.memoizedState; destroy = prevEffect.destroy; if (nextDeps !== null) &#123; const prevDeps = prevEffect.deps; if (areHookInputsEqual(nextDeps, prevDeps)) &#123; pushEffect(hookEffectTag, create, destroy, nextDeps); return; &#125; &#125; &#125; currentlyRenderingFiber.effectTag |= fiberEffectTag; hook.memoizedState = pushEffect( HookHasEffect | hookEffectTag, create, destroy, nextDeps, );&#125; useEffect、useLayoutEffect 的差别在于执行时机。useEffect 将 hookEffectTag 置为 HookPassive，意为等组件渲染完成后触发调用；useLayoutEffect 将 hookEffectTag 置为 HookLayout，它在计算节点样式后、页面刷新前执行。 useImperativeHandle 须结合 forwardRef 一起使用，用于设置父组件的 ref 引用。 其他useRef 用于缓存数据，特殊之处在于缓存 ref 引用。useMemo 通过函数计算缓存数据，每次 deps 变更时会重新计算。useCallback 用于缓存函数，每次 deps 变更时会重新计算。useContext 读取祖先组件构建的上下文。useTransition 用于延迟处理，参看 React useTransition。内部处理结合 runWithPriority、ReactCurrentBatchConfig.suspense 机制。useDeferredValue 用于延迟获取数据（引用形式更新）。内部处理使用 ReactCurrentBatchConfig.suspense 机制useResponder 响应式处理。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"http://xzfyu.com/categories/frontend/react/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"react fiber 类组件状态更新篇","slug":"frontend/react16/react fiber 类组件状态更新篇","date":"2020-03-03T16:00:00.000Z","updated":"2020-03-08T10:46:29.900Z","comments":true,"path":"2020/03/04/frontend/react16/react fiber 类组件状态更新篇/","link":"","permalink":"http://xzfyu.com/2020/03/04/frontend/react16/react fiber 类组件状态更新篇/","excerpt":"","text":"前言本文仅在局部层面上解释类组件的状态更新机制，并没有对函数组件的 hooks、fiber 优先级等作说明。 Update 及 UpdateQueueUpdatefiber reconciler 将 fiber 的状态更新抽象为 Update 单向链表： tag：更新类型，UpdateState、ReplaceState、ForceUpdate、CaptureUpdate payload：状态变更函数或新状态本身 callback：回调，作用于 fiber.effectTag，并将 callback 作为 side-effects 回调 expirationTime：deadline 时间，未到该时间点，不予更新 suspenseConfig：suspense 配置 next：指向下一个 Update priority：仅限于 dev 环境 createUpdate 函数用于创建 Update。getStateFromUpdate 函数用于通过 Update 获取新的 fiber 状态，其处理方式基于 tag 类型。如 tag 为 UpdateState 时，getStateFromUpdate 将取用更新前的 state 值，并混入 payload 返回值或 payload 本身，作为新的 state 值返回。“payload 返回值”指的是 payload 本身是一个函数，它会以组件实例作为上下文，并以 prevState、nextProps 作为参数。getStateFromUpdate 依循 tag 值的处理机制如下： UpdateState：基于 prevState 以及 payload 增量更新 ReplaceState：基于 payload 全量更新 ForceUpdate：state 值依旧取 prevState，同时 hasForceUpdate 会被置为 true。 CaptureUpdate：将 fiber.effectTag 置为 我们可以看到，虽然 Update 表现为链表形式，可以处理多个 state 更新作业，但是 getStateFromUpdate 与 fiber 任务的优先级、side-effects 机制均无关联。 UpdateQueue如react fiber 搜罗整理篇提到的，render 阶段的 state 更新作业可以被丢弃。在实现上，fiber reconciler 使用 UpdateQueue 存储 Update 更新队列。更新队列有两条，baseQueue 执行中的更新队列，pendingQueue（即 shared.pending）待执行的更新队列。因为 Update 表现为环状单向链表，baseQueue、pendingQueue 均存储单向链表的尾节点。丢弃更新作业的实现在于，将 pendingQueue 复制给 baseQueue，丢弃之前的 baseQueue（current fiber 和 work-in-progress fiber 均会重置 baseQueue）。UpdateQueue 的数据结构如下： baseState：先前的状态，作为 payload 函数的 prevState 参数 baseQueue：存储执行中的更新任务 Update 队列，尾节点存储形式 shared：以 pending 属性存储待执行的更新任务 Update 队列，尾节点存储形式 effects：side-effects 队列，commit 阶段执行 fiber reconciler 会在挂载组件时调用 initializeUpdateQueue 函数初始化 fiber 节点的 updateQueue 队列。只有挂载的组件才会有有效的状态更新，卸载的组件没必要使用 updateQueue 属性。enqueueUpdate 函数将 update 添加到 pendingQueue 队列中，典型如类组件在 setState 方法调用期间将 update 添加到 pendingQueue 中。 processUpdateQueue 函数用于应用 Update 队列完成状态更新。其流程如： 丢失原先的 baseQueue，将 pendingQueue 复制给 baseQueue，作为执行中的 Update 队列。 启用 while 循环处理 Update 队列。如优先级足够，获取最新的状态值；如不够，添加到 newBaseQueue 队列，等待下次处理。至于为什么要使用 while 循环？是因为函数式组件可能会同步使用多个 useState 更新状态。特殊的，对于优先级不足的任务，其所处理的 prevState 是前一个任务更新后的状态值，如官方注释所示；当 baseQueue 已清空，while 循环会继续遍历 pendingQueue 并应用更新。 while 循环结束后，如 newBaseQueue 队列非空，将其作为新的 baseQueue 以备更新；如为空，更新 baseState。 最后更新 work-in-progress fiber 的 memoizedState 等属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142function processUpdateQueue&lt;State&gt;( workInProgress: Fiber, props: any, instance: any, renderExpirationTime: ExpirationTime,): void &#123; const queue: UpdateQueue&lt;State&gt; = (workInProgress.updateQueue: any); hasForceUpdate = false; // 丢弃原先的更新任务 baseQueue，将 pendingQueue 复制给 baseQueue let baseQueue = queue.baseQueue; let pendingQueue = queue.shared.pending; if (pendingQueue !== null) &#123; if (baseQueue !== null) &#123; let baseFirst = baseQueue.next; let pendingFirst = pendingQueue.next; baseQueue.next = pendingFirst; pendingQueue.next = baseFirst; &#125; baseQueue = pendingQueue; queue.shared.pending = null; const current = workInProgress.alternate; if (current !== null) &#123; const currentQueue = current.updateQueue; if (currentQueue !== null) &#123; currentQueue.baseQueue = pendingQueue; &#125; &#125; &#125; // These values may change as we process the queue. if (baseQueue !== null) &#123; let first = baseQueue.next; let newState = queue.baseState; let newExpirationTime = NoWork; let newBaseState = null; let newBaseQueueFirst = null; let newBaseQueueLast = null; if (first !== null) &#123; let update = first; do &#123; // 优先级不足，将 update 添加到 newBaseQueue 队列中 // newBaseState 更新为前一个 update 任务的结果 const updateExpirationTime = update.expirationTime; if (updateExpirationTime &lt; renderExpirationTime) &#123; const clone: Update&lt;State&gt; = &#123; expirationTime: update.expirationTime, suspenseConfig: update.suspenseConfig, tag: update.tag, payload: update.payload, callback: update.callback, next: (null: any), &#125;; if (newBaseQueueLast === null) &#123; newBaseQueueFirst = newBaseQueueLast = clone; newBaseState = newState; &#125; else &#123; newBaseQueueLast = newBaseQueueLast.next = clone; &#125; if (updateExpirationTime &gt; newExpirationTime) &#123; newExpirationTime = updateExpirationTime; &#125; &#125; else &#123; // 如果 update 在优先级不足的 update 之后，将其拷贝到 newBaseQueue 队列中 if (newBaseQueueLast !== null) &#123; const clone: Update&lt;State&gt; = &#123; expirationTime: Sync, // This update is going to be committed so we never want uncommit it. suspenseConfig: update.suspenseConfig, tag: update.tag, payload: update.payload, callback: update.callback, next: (null: any), &#125;; newBaseQueueLast = newBaseQueueLast.next = clone; &#125; // Mark the event time of this update as relevant to this render pass. // TODO: This should ideally use the true event time of this update rather than // its priority which is a derived and not reverseable value. // TODO: We should skip this update if it was already committed but currently // we have no way of detecting the difference between a committed and suspended // update here. markRenderEventTimeAndConfig( updateExpirationTime, update.suspenseConfig, ); newState = getStateFromUpdate( workInProgress, queue, update, newState, props, instance, ); // 包含 callback 回调，更新 fiber.effectTag、baseQueue.effects const callback = update.callback; if (callback !== null) &#123; workInProgress.effectTag |= Callback; let effects = queue.effects; if (effects === null) &#123; queue.effects = [update]; &#125; else &#123; effects.push(update); &#125; &#125; &#125; update = update.next; if (update === null || update === first) &#123; pendingQueue = queue.shared.pending; if (pendingQueue === null) &#123; break; &#125; else &#123; // An update was scheduled from inside a reducer. Add the new // pending updates to the end of the list and keep processing. update = baseQueue.next = pendingQueue.next; pendingQueue.next = first; queue.baseQueue = baseQueue = pendingQueue; queue.shared.pending = null; &#125; &#125; &#125; while (true); &#125; // 如果没有优先级不足的 Update，更新 baseState if (newBaseQueueLast === null) &#123; newBaseState = newState; // 如果有优先级不足的 Update，使这些 Update 首尾相连 &#125; else &#123; newBaseQueueLast.next = (newBaseQueueFirst: any); &#125; queue.baseState = ((newBaseState: any): State);// 最新状态 queue.baseQueue = newBaseQueueLast;// 优先级不足的 update 队列 // Set the remaining expiration time to be whatever is remaining in the queue. // This should be fine because the only two other things that contribute to // expiration time are props and context. We're already in the middle of the // begin phase by the time we start processing the queue, so we've already // dealt with the props. Context in components that specify // shouldComponentUpdate is tricky; but we'll have to account for // that regardless. markUnprocessedUpdateTime(newExpirationTime); workInProgress.expirationTime = newExpirationTime; workInProgress.memoizedState = newState; &#125;&#125; 类组件状态更新流程类组件状态更新按如下 4 种场景处理： 当组件挂载时，通过 initializeUpdateQueue 函数初始化 updateQueue 队列。 当 state 变更或强制渲染时，通过 enqueueUpdate 函数将 update 添加到 pendingQueue 队列。 在 render 阶段，cloneUpdateQueue 函数能把 current fiber 中的 updateQueue 复制给 work-in-progress fiber。这样就如官方注释所说，current fiber 和 work-in-progress 会持有相同的 updateQueue。cloneUpdateQueue 函数执行后，就会调用 processUpdateQueue 获取最新状态。 在 commit 阶段，通过 commitUpdateQueue 函数执行 side-effects 回调。 其中，render 阶段和 commit 阶段均通过 scheduleWork（即 scheduleUpdateOnFiber） 启动。这里仅简要说明 scheduleWork 的内部表现： 使用 react scheduler 再解析篇提到的 unstable_scheduleCallback 调度任务，以整个渲染流程作为单个任务（表现为 performSyncWorkOnRoot 或 performConcurrentWorkOnRoot，内容包含react fiber 搜罗整理篇提到的 work-loop 大循环、 commitRootImpl 提交流程。届时 state 更新在 performSyncWorkOnRoot 等函数中表现为 batch 批量任务）； commitRootImpl 通过 Scheduler_runWithPriority 执行，因此在 scheduler 调度机制之外，不可打断。 setState当类组件通过 constructClassInstance 函数实例化期间，组件实例的 updater 属性即会赋值为 classComponentUpdater。组件实例的 setState 方法最终会触发 classComponentUpdater.enqueueSetState 方法的调用。其原理如下： 123456789101112131415161718192021222324252627// react 包下 ReactBaseClasses.js 文件Component.prototype.setState = function(partialState, callback) &#123; this.updater.enqueueSetState(this, partialState, callback, 'setState');&#125;;// react-reconciler 包下 ReactFiberClassComponent.js 文件const classComponentUpdater = &#123; isMounted, enqueueSetState(inst, payload, callback) &#123; const fiber = getInstance(inst); const currentTime = requestCurrentTimeForUpdate(); const suspenseConfig = requestCurrentSuspenseConfig(); const expirationTime = computeExpirationForFiber( currentTime, fiber, suspenseConfig, ); const update = createUpdate(expirationTime, suspenseConfig); update.payload = payload; if (callback !== undefined &amp;&amp; callback !== null) &#123; update.callback = callback; &#125; enqueueUpdate(fiber, update);// 添加到 pendingQueue scheduleWork(fiber, expirationTime);// 调度工作 &#125;, enqueueReplaceState(inst, payload, callback) &#123;/** **/&#125;, enqueueForceUpdate(inst, callback) &#123;/** **/&#125;,&#125;; processUpdateQueue对于类组件，processUpdateQueue 会在以下场景中执行： mountClassInstance 函数挂载组件时，以及该函数执行到 componentWillMount 生命周期时 resumeMountClassInstance 函数复用组件时 updateClassInstance 函数更新组件时 错误捕获及 Suspense在执行 work-loop 期间，fiber reconciler 会对捕获的错误进行处理，如这里，或这里。React Suspense 源码解读指出，react 先抛出错误，然后在 completeWork 执行完成之前捕获错误，并添加到 updateQueue 队列中。这里仅贴示 throwException 函数所用到的 createClassErrorUpdate 代码，用于将错误处理制作成 update。据此可以发现，getDerivedStateFromError、componentDidCatch 生命周期均基于构建 update 的方式得到调用。 123456789101112131415161718192021222324252627282930313233343536373839404142function createClassErrorUpdate( fiber: Fiber, errorInfo: CapturedValue&lt;mixed&gt;, expirationTime: ExpirationTime,): Update&lt;mixed&gt; &#123; // 通过 update 执行 getDerivedStateFromError const update = createUpdate(expirationTime, null); update.tag = CaptureUpdate; const getDerivedStateFromError = fiber.type.getDerivedStateFromError; if (typeof getDerivedStateFromError === 'function') &#123; const error = errorInfo.value; update.payload = () =&gt; &#123; logError(fiber, errorInfo); return getDerivedStateFromError(error); &#125;; &#125; const inst = fiber.stateNode; if (inst !== null &amp;&amp; typeof inst.componentDidCatch === 'function') &#123; update.callback = function callback() &#123; if (typeof getDerivedStateFromError !== 'function') &#123; // To preserve the preexisting retry behavior of error boundaries, // we keep track of which ones already failed during this batch. // This gets reset before we yield back to the browser. // TODO: Warn in strict mode if getDerivedStateFromError is // not defined. markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined logError(fiber, errorInfo); &#125; // 通过 side-effects 执行 componentDidCatch 生命周期 const error = errorInfo.value; const stack = errorInfo.stack; this.componentDidCatch(error, &#123; componentStack: stack !== null ? stack : '', &#125;); &#125;; &#125; return update;&#125; 特殊的，对于使用 React.Suspense 包裹的懒加载组件，fiber reconciler 会将 thenable 形式的懒加载函数抛出，以此进入错误处理；随后在 throwException 函数处理过程，thenable 会被添加到 updateQueue 队列中。 1234567function readLazyComponentType&lt;T&gt;(lazyComponent: LazyComponent&lt;T&gt;): T &#123; initializeLazyComponentType(lazyComponent); if (lazyComponent._status !== Resolved) &#123; throw lazyComponent._result;// 即懒加载函数 &#125; return lazyComponent._result;// 懒加载成功或失败结果&#125; 如上，错误捕获及 Suspense 处理都是在 work-loop 循环抛出异常后，再行更新 updateQueue 队列。既然已经退出了 work-loop 循环，这时 updateQueue 队列就需要在下次重绘时执行。throwException 函数注释部分指出，fiber reconciler 会通过 attachPingListener 函数重新 restart 渲染流程。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"http://xzfyu.com/categories/frontend/react/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"js 事件循环","slug":"frontend/architecture/js 事件循环","date":"2020-02-29T16:00:00.000Z","updated":"2020-03-08T10:42:40.982Z","comments":true,"path":"2020/03/01/frontend/architecture/js 事件循环/","link":"","permalink":"http://xzfyu.com/2020/03/01/frontend/architecture/js 事件循环/","excerpt":"","text":"事件循环基本js 是一门单线程非阻塞脚本语言。即便浏览器推出的 web worker 也只允许子线程承担计算任务，而不能操纵 dom 节点（因为主、子线程同时操纵 dom 会造成不一致）。 执行栈可用于解释 js 引擎对同步脚本的处理。即当函数首次被调用时，js 引擎就会为该过程创建执行上下文，并将该执行上下文压入执行栈中。执行上下文也称为执行环境，包含函数的私有作用域、父级作用域、参数、作用域中的变量以及 this 指向。当函数执行完毕后，js 引擎会在执行栈中销毁该执行上下文，并将执行栈定位到前一个执行上下文。执行上下文典型如下： 1234567891011121314151617executionContextObj = &#123; scopeChain: &#123;// 作用域链，对象形式，包含所有变量对象、所有父级执行上下文中的变量对象 /* variableObject + all parent execution context's variableObject */ &#125;, variableObject: &#123;// 变量对象，对象形式，包含函数形参、函数内部的变量以及函数声明(但不包含表达式) /* function arguments / parameters, inner variable and function declarations */ arguments: &#123; 0: 22,// 实参 length: 1 &#125;, realArg: 22,// 调用期间获得的实参 afunction: pointer to function afunction(),// 内部声明的函数，以指针形式引用 aVariable: undefined,// 内部变量 aVariable，创建阶段声明上移，为 undefined functionExp: undefined,// 内部以变量 functionExp 声明的函数变量，创建阶段声明上移，为 undefined &#125;, this: &#123;&#125;// this 关键字&#125; js 引擎对异步任务的处理则借助 callback queue 事件队列实现。即当主线程中的同步任务执行完毕时，js 引擎会去检查事件队列，并取出执行。异步任务有其优先级，在浏览器环境中，有 micro task 微任务、macro task 宏任务两类。微任务包含 Promise、MutaionObserver；宏任务包含 setTimeout、setInterval、setImmediate、requestAnimationFrame。浏览器先执行微任务，再执行宏任务。交互行为作为特殊的异步任务，通过收发消息的方式实现，详情可参考 深入理解javascript中的事件循环event-loop。 node 中的事件循环在 node 环境中，node 使用 v8 引擎解释 js 脚本，然后使用 libuv 引擎处理事件循环以及其他异步行为。在启动阶段，node 就会初始化 event loop 事件循环。下图描绘了 node 处理事件循环的各阶段，每个阶段都有一个先进先出的回调队列待执行： 123456789101112131415161718 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ pending callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ poll：I/O 事件完毕后，会进入 poll 阶段（同步模式会阻塞在 poll 阶段）。它首先会计算阻塞时间，然后执行 poll 队列，直到队列耗尽或超过阈值。然后检查脚本中是否有 setImmediate，如果有，进入 check 阶段。最后检查是否达到了定时器的指定时间，如果是，进入 timers 阶段。 check：执行 setImmediate 回调。其特殊意义在于，如果 poll 阶段队列为空，可以使用 setImmediate 使程序进入 check 阶段，而不至于阻塞在 poll 阶段。 close callbacks：调用如 socket.on(‘close’, …) 等回调。 timers：调用 setTimeout、setInterval 等回调。定时器通常会滞后于用户设定时间，因为它需要等待 timers 阶段之前的任务执行完成。技术上，定时器的执行时机由 poll 阶段控制。 pending callbacks：调用如某些系统操作（如TCP错误类型）的回调。 idle, prepare：node 内部使用。 需注意，在非 I/O 循环中调用 setImmediate、setTimeout，两者的执行时机是不确定的；在 I/O 循环中，setImmediate 总是先于 setTimeout。 process.nextTick 在事件循环算法之外，它将在事件循环的任意阶段继续执行前得到调用。无限递归的 process.nextTick 有可能会饿死 I/O，无法使事件循环达到 loop 阶段。node 为什么将 process.nextTick 设计为当前操作之后、事件循环之前呢？其目的是这样设计能使同步执行的回调通过 process.nextTick 转化成异步执行。 1234567891011121314151617181920212223// 同步脚本let bar;function someAsyncApiCall(callback) &#123; callback(); &#125;someAsyncApiCall(() =&gt; &#123; console.log('bar', bar); // undefined&#125;);bar = 1;// 借助 process.nextTick 实现异步let bar;function someAsyncApiCall(callback) &#123; process.nextTick(callback);&#125;someAsyncApiCall(() =&gt; &#123; console.log('bar', bar); // 1&#125;);bar = 1; 参考JavaScript中执行环境和栈详解JavaScript中的Event Loop（事件循环）机制The Node.js Event Loop, Timers, and process.nextTick()","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"react scheduler 再解析篇","slug":"frontend/react16/react scheduler 再解析篇","date":"2020-02-29T16:00:00.000Z","updated":"2020-03-08T10:46:31.790Z","comments":true,"path":"2020/03/01/frontend/react16/react scheduler 再解析篇/","link":"","permalink":"http://xzfyu.com/2020/03/01/frontend/react16/react scheduler 再解析篇/","excerpt":"","text":"顾名思义，scheduler 用于完成调度工作。 主流程任务队列scheduler 使用 Heap 堆存放任务队列。每个任务在进入 Heap 堆前，会根据 sortIndex、id 属性进行优先级排序。它首先比较 sortIndex 值，值越小，优先级越高；其次以相同的规则比较 id（即比较任务的创建顺序）。依循优先级的高低，scheduler 采用位运算取中位节点的方式交换任务在 Heap 堆中的位置。push 函数用于将任务添加到 Heap 堆的尾端，并重新按优先级调整 Heap 堆。peek、pop 用于取出 Heap 堆中的首个任务。其中，pop 会从 Heap 堆中移除首个任务，并重新按优先级调整 Heap 堆；peek 不会移除。在使用上，peek 主要拣选 Heap 堆中的首个任务；若任务已执行或已取消，则使用 pop 移除。详情可参考 SchedulerMinHeap.js。 scheduler 使用 Heap 堆机制构造了两个队列：taskQueue、timerQueue。taskQueue 存放将被处理的任务；timerQueue 存放延期处理的任务。可以推想的处理流程是：首先使用 peek 函数取出 taskQueue 中的任务并执行，完成后使用 pop 函数移除；在执行期间，检查当前时间是否满足 timerQueue 中任务的延期标准，若满足，将该任务移入 taskQueue，并从 timerQueue 中移除。任务由 timerQueue 流向 taskQueue 的过程由 advanceTimers 函数 完成。 任务节点每个任务节点抽象为以下属性的集合： id：任务节点的序号，创建任务时自增 1 callback：任务函数执行内容 priorityLevel：任务的优先级。优先级按 ImmediatePriority、UserBlockingPriority、NormalPriority、LowPriority、IdlePriority 顺序依次越低 startTime：时间戳，任务预期执行时间，默认为当前时间，即同步任务。可通过 options.delay 设为异步延时任务 expirationTime：过期时间，scheduler 基于该值进行异步任务的调度。通过 options.timeout 设定或 priorityLevel 计算 timeout 值后，timeout 与 startTime 相加称为 expirationTime sortIndex：默认值为 -1。对于异步延时任务，该值将赋为 expirationTime 在这里，有必要先比较以下 startTime、expirationTime：startTime 是用户侧设定的预期执行时间；scheduler 会对交互行为、计算行为分派不同的优先级，这就没法基于 startTime 进行调度，而是要基于优先级进行调度。UserBlockingPriority 交互行为优先级高，expirationTime 以及任务的 sortIndex 属性相应也低。在同一个队列中，对于 startTime 相同的任务，scheduler 会率先处理 expirationTime 较低的任务（即优先级较高的任务）。expirationTime 的另一个作用是，作为任务的最后执行期限，即如果当前时间未到达任务的最后执行期限，那么任务就可以不被执行。 任务运行流程创建任务的唯一接口为 unstable_scheduleCallback(priorityLevel, callback, options) 函数。任务分为两种，同步任务或异步延时任务。同步任务在 unstable_scheduleCallback 调用期间就会添加到 taskQueue 队列，且通过封装宿主环境 api 的 requestHostCallback 函数立即执行；异步延时任务会添加到 timerQueue 队列，且通过封装宿主环境 api 的 requestHostTimeout 函数延后执行。我们先按下 requestHostCallback、requestHostTimeout 宿主环境的封装接口不表，先以图示剖析一下 unstable_scheduleCallback 的执行流程： 在上图中，以 workLoop 方式循环调度 taskQueue 队列或以 handleTimeout 递归调度 timerQueue 队列这两种方式，只有一个在激活状态，也即 requestHostCallback、requestHostTimeout 只有一个在调用周期中。因为，taskQueue 队列调度完毕，会调用 requestHostTimeout 处理 timerQueue 队列；timerQueue 队列有一个任务进入 taskQueue，又会调用 requestHostCallback 处理 taskQueue 队列。 另外，workLoop 循环也使任务具有可并发执行的特性。任务若 返回函数，这个函数将作为 currentTask.callback 执行内容，即在 workLoop 循环中保证任务的回调被立即执行。 任务的暂停、中止等我们再来看看封装宿主环境 api 的 requestHostCallback、requestHostTimeout。在浏览器环境中，react 通过 MessageChannel 发送消息的方式触发任务的真正执行，详情可参看 requestHostCallback 函数 的实现，效果是在渲染后执行任务。至于 requestHostTimeout，react 则使用 setTimeout 方法实现。 任务的暂停与恢复需要指出的是，在单次 workLoop 循环中，如果 taskQueue 队列未被清空（比如任务被暂停了），react 会基于 MessageChannel 再次 发送消息，以处理 taskQueue 队列。为此，scheduler 对外提供 unstable_pauseExecution、unstable_continueExecution 接口用于暂停、恢复任务，这就是 react fiber 搜罗整理篇 提到的任务暂停与恢复。 任务的中止至于任务的中止，scheduler 提供 unstable_getFirstCallbackNode 函数 用于获取 taskQueue 的首个任务，然后就可以使用 unstable_cancelCallback 接口 销毁任务了。 避免任务长期工作为了避免工作任务长期占用主线程，react 使用帧率计算任务的 yieldInterval 最大工作时长。scheduler 允许使用 forceFrameRate 设置任务的最大工作时长。在任务执行开始时，scheduler 会基于任务的开始工作时间加 yieldInterval 计算任务的 deadline 暂停时间，一旦 workLoop 执行到 deadline 时间后，scheduler 会让出主线程以执行其他任务。判断任务运行是否达到 deadline，基于 shouldYieldToHost 函数 实现。 1234567891011121314151617function workLoop(hasTimeRemaining, initialTime) &#123; let currentTime = initialTime; while ( currentTask !== null &amp;&amp; !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused) ) &#123; if ( currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost())// 达到任务的最大运行时长，让出主线程 ) &#123; // This currentTask hasn't expired, and we've reached the deadline. break; &#125; &#125; // ...&#125; scheduler 对外提供了 unstable_shouldYield 接口 用于判断是否用暂停当前任务的执行，其一在于新添加任务的优先级高于当前任务，其二在于当前任务已达到 deadline。届时就可以调用 unstable_pauseExecution 暂停 workloop 循环，执行高优先级任务或仅让出主线程。 更改优先级unstable_next、unstable_runWithPriority 接口会改写 currentPriorityLevel，而 fiber 任务的优先级又是通过 currentPriorityLevel 实现的，这样就会使 unstable_scheduleCallback 执行期间的任务被置为特定的优先级。效果可参考 [译] React 中的调度。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"http://xzfyu.com/categories/frontend/react/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"进程与线程踩点","slug":"计算机科学/操作系统/进程与线程","date":"2020-02-28T16:00:00.000Z","updated":"2020-03-08T11:06:02.127Z","comments":true,"path":"2020/02/29/计算机科学/操作系统/进程与线程/","link":"","permalink":"http://xzfyu.com/2020/02/29/计算机科学/操作系统/进程与线程/","excerpt":"","text":"前言本篇基于《现代操作系统》整理。虽然笔者也不甚理解，但是这篇总结可以为后续深入探究 node 进程、java 并发、react 调度算法打个桩，从中也确实增进了对进程、中断等的理解。 进程进程概要单核 CPU 一瞬只能运行一个进程，因此需要通过多道程序设计实现多进程的伪并行，营造在 1 秒钟内有多个进程同时运行的错觉。一个进程就是一个正在执行程序的实例，包含程序计数器、寄存器和变量的当前值。程序计数器用于存放指令，CPU 层面有物理程序计数器，以进程抽象的程序层面有逻辑程序计数器。程序运行时，它的逻辑程序计数器会被装入物理程序计数器中；当程序结束或暂停时，物理程序计数器会被保存在内存中该程序的逻辑程序计数器中。进程有程序、输入、输出及状态；多个进程可共享 CPU，通过调度算法实现进程间的切换。 创建进程 UNIX 系统，已存在的进程执行 fork 系统调用创建一个与调用进程相同的副本进程。这两个进程拥有相同的内存映像、环境字符串和打开文件。当子进程执行 execve 等系统调用时，子进程的内存映像会被修改，随后运行一个新程序。在 fork 之后、execve 之前，子进程可以处理它的文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。有关文件描述符，可参考 理解文件描述符。 Windows 系统，一个 Win32 函数调用 CreateProcess 创建进程，同时把程序装入进程。该调用的参数包含要执行的程序、输入给程序的命令行参数、各种安全属性、打开文件是否继承的控制位、优先级信息、窗口规格等。 UNIX 中的父子进程会共享不可写内存，某些 UNIX 实现会允许子进程在写时 copy 父进程的内存。 Windows 中的父子进程一开始就会拥有不同的地址空间。 终止进程 正常退出。UNIX 通过执行 exit 系统调用退出；Windows 通过执行 ExitProcess 退出。 出错退出，因为进程发现严重的错误而自愿退出。 严重错误，因为程序本身的错误而非自愿退出。 被其他进程杀死。UNIX 通过执行 kill 系统调用杀死其他进程；Windows 通过执行 TerminateProcess 系统调用杀死其他进程。两者都需要相当的权限。 进程的状态 运行态（实际占用 CPU 运行中） 就绪态（可运行，等待 CPU 空闲） 阻塞态（除非外部事件触发，否则进程不能运行） 进程间的切换、进程状态的变更由运行调度算法的进程调度程序完成。 进程的实现操作系统维护着一张进程表，它为每个进程分配一个进程表项。该表项包含程序计数器、堆栈指针、内存分配状态、打开文件的状态、账号、调度信息、以及进程切换操作所需的信息。 进程调度中与 I/O 相关的是中断服务。当磁盘中断发生时，中断硬件会将程序计数器、程序状态字、[寄存器]压入堆栈（保存到进程表中），计算机随即跳到中断向量所指示的地址，运行处理中断服务。当中断服务处理完成后，被中断的进程都会返回到中断前的状态。完整流程如下（保存寄存器值、设置堆栈指针等需要汇编语言实现）： 硬件压入堆栈程序计数器等。 硬件从中断向量装入新的程序计数器。 汇编语言过程保存寄存器值。 汇编语言过程设置新的堆栈。 C中断服务历程运行（典型地读和缓冲输入）。 调度程序决定下一个将运行的进程。 C过程返回至汇编代码。 汇编语言过程开始运行新的当前进程。 线程线程概要同一个应用程序的某些活动会随着时间推移进入阻塞态，这时将应用程序拆解成准并行运行的多个顺序线程，会使程序设计模型变得简单。线程可以共享同一个地址控件和所有可用数据，不必考虑单道程序设计时所需面对的中断、定时器和上下文切换；线程也远比进程更为轻量级，创建和销毁都比较容易；多线程面对大量 I/O 处理时有性能优势。 《现代操作系统》举例说明了多线程的优点：在字处理软件中，交互线程负责处理与用户的交互；格式化线程在后台默默进行格式化操作；磁盘备份线程实现自动保存功能。这样就避免了用户须等待格式化完成再进行其他处理的问题。这三个线程也能共享处理中的文件，而不像进程那样不能共享。在 web 服务器中，分派线程用于从网络中读取请求，并分发给工作线程。当请求到达时，分派线程会挑选一个阻塞的工作线程，提交该请求，通常是对该工作线程所配有的某个专门字写入消息指针。接着分派线程会唤醒工作线程，将它从阻塞态转为就绪态，以处理请求；等请求处理完成后，工作线程会重新进入阻塞态。在大量数据处理中，输入线程用于把数据读入缓冲区；处理线程用于处理数据，并将输出写入缓冲区；输出线程将结果写到磁盘上。 三种处理模式 单线程：阻塞系统调用，便于程序设计，舍弃了性能。 多线程：阻塞系统调用，便于程序设计，通过并行改善了性能。 有限状态机：将这一程序转向 I/O 处理后，通过有限状态机机制保存状态，转而处理那一程序。当 I/O 处理完成后，通过信号或中断的形式唤醒这一程序，并装入状态。典型如 nodejs，借助中断实现非阻塞式调用。 进程与线程对比进程的内容有地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号处理程序、账号信息等属性。线程的内容有程序计数器、存放工作变量的寄存器、记录执行历史的堆栈（每一帧保存了已调用但未返回的过程）、状态等属性。进程的意义在于将资源分组后进行集中处理；线程的意义在于对某一分组资源采用多道程序处理。 线程基本特征线程有四种状态：运行、阻塞、就绪或终止。 线程的堆栈用于存放调用中但为返回的过程，同时包含相应过程的局部变量以及过程执行完成的返回地址。 在多线程模式下，执行线程有能力通过调用库函数创建或终止线程。如使用 thread_create 创建线程（通过参数指定要运行的过程名，通常会返回一个线程标识符）；thread_exit 退出线程；thread_join 等待某线程退出后再运行，参数为待运行线程的标识符；thread_yield 释放 CPU 来运行另一线程（线程没法像进程那样利用时间中断强制让出 CPU）；thread_attr_init 初始化某线程的属性结构；thread_attr_destory 删除某线程的属性结构。 线程的实现线程包可以在用户空间或内核中实现，即在进程的运行时系统中存放线程表或在内核中存放线程表。线程表与进程表类似，用于存放线程重新启动所需的信息。 在用户空间切换线程比在内核中更为高效，同时允许每个进程定制自己的调度算法。用户空间线程包需要处理阻塞问题，等待 I/O 的线程会长期占用 CPU，导致其他线程无法展开工作。解决方式有二：通过修改操作系统的方式将调用改成非阻塞式（不乐观）；二则通过包装器 jacker 提前检测系统调用是否会被阻塞，等线程安全了再进行调用。 内核线程包开销较大，且需要面对 fork 的子进程是否拥有与父进程相同线程、以及线程怎样订阅进程间通信信号等问题。但是，内核线程包中能够阻塞线程的调用都以系统调用的形式实现，内核有能力切换到其他就绪线程上，避免 CPU 空转。其能力体现为：采用调度程序激活机制，内核会为每个进程安排一定数量的虚拟处理器，随后由运行时系统将线程分配到处理器上。当内核感知到线程被阻塞后，内核会通知运行时系统，并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述。内核在上述堆栈地址启动运行时系统，从而发出通知，这是对 UNIX 中信号的一种粗略模拟。 混合实现综合了用户级线程和内核级线程的优点，单条内核线程下挂多条用户级线程，同样可以创建、销毁和调度这些用户级线程。 弹出式线程消息如 web 服务请求到达时，传统的做法是使用阻塞进程或线程等待消息达到，然后进行处理。另一种方式是在消息到达系统后创建一个弹出式线程（全新的，没有历史，创建会非常快）。在内核创建弹出式线程比在用户空间中更快捷，且容易访问所有的表格和 I/O 设备，以便于作中断处理。但是，出错的内核线程比用户线程危害更大。 多线程程序设计问题多线程会面临如下问题： 全局变量问题：某线程使用的全局变量会被另一线程篡改掉。有种解决方案是，为每个线程创建私有的全局变量，比如引入新的库过程（create_global、set_global、read_global 等）以创建、设置和读取这些线程范围内的全局变量。 库调用、内存分配问题：库调用在前一个执行期间，仍可进行二次调用；内存指针在线程切换期间可能会处于不稳定状态。有种解决方案是，为每个过程提供包装器，包装器会设置某个库在使用中的标识，这样该库的其他线程都会被阻塞。使用信号处理上述问题时会遇到额外的问题，在内核中发送非线程专用的信号，无法感知要把信号发送到哪个线程；如果信号采用广播模式，也会遇上诸如“某个线程想捕获信号，另一个想中断进程”的问题。 堆栈管理问题：进程的堆栈溢出时，内核会为该进程分配更多的堆栈；内核没法了解多线程的所有堆栈，无法为它们分配更多的堆栈。 进程通信进程间通信（Inter Process Communication, IPC）需要解决以下三个问题： A 进程怎样把信息传递给 B 进程（因为线程共享地址控件，线程间通信就没有这问题）。 怎样保证多个进程读写某一共享资源时会有一致性问题（线程间通信也会有这问题）。 B 进程处理前需要等待 A 进程处理完成之类的顺序问题（线程间通信也会有这问题）。 多进程读写同一共享资源时的一致性问题也称为竞争条件，因其处理结果取决于多进程运行的精确时序。处理竞争条件的策略有互斥，即避免多个进程同时读写共享数据。当把读写共享数据的程序片段称为临界区后，多个进程在某一时刻只能有一个进入临界区。其实现有（线程竞争也可以使用同样的解决思路： 屏蔽中断：在每个进程进入临界区时屏蔽中断，这样依赖于中断的进程切换就没法展开，某一时间就只能有一个进程在临界区中。在用户进程中屏蔽中断会导致其他 CPU 无法继续运行。 锁变量：通过共享锁变量标记某一进程在临界区中，阻断其他进程进入临界区。锁变量同样会有竞争条件问题。 严格轮换法：通过自旋锁阻断其他进程运行（自旋锁在 A 进程执行过程为 0，执行后为 1；B 进程执行过程为 1，执行后为 0），阻断可以用 while 锁变量实现（自旋锁为 0 时，B 进程无法运行；为 1 时， A 进程无法运行），使进程处于忙等待状态。 Pererson 算法：有两个进程，设置两个标识，一则以变量记录申请进入临界区的进程，二则以集合形式记录已申请进入临界区（处于运行态或阻塞态）的进程，直到运行结束才会释放。在 A 进程进入临界区期间，因为 A 进程在集合记录中，B 进程没法进入临界区；只有等到集合记录释放时，B 进程才能进入临界区。后续进程会进入忙等待状态。 TSL、XCHG 指令：通过汇编语言向寄存器中写入非零值，作循环处理，其他指令均无法修改，直到本指令的调用者执行结束。这样做就是锁住了内存总线（只能允许当前指令访问内存）。锁住内存总线的机制与屏蔽中断不同；屏蔽中断时，其他进程仍能访问内存。后续进程会进入忙等待状态。 sleep、wakeup 进程间通信原语（属于系统调用）：sleep 将引起调用进程阻塞，直到被另外一个进程唤起；wakeup 唤醒进程。有例子：生产者向缓存区刷入文件，消费者取出文件并打印，缓冲区计数标识有多少文件待打印。若计数标识为 0，消费者将睡眠；若计数标识已满，生产者将睡眠。 信号量：抽象为 down、up 系统调用。down 操作检查信号量，将信号量减 1；若该值为 0，进程将睡眠，但是 down 操作并未结束。up 操作将信号量增 1，唤醒由 down 操作休眠的进程，使其继续运行未完成的 down 操作。检查、更新信号量时，系统会调用 TSL、XCHG 指令锁住内存总线，屏蔽其他进程的竞争。信号量可用于实现中断，如启动 I/O 设备时执行 down 操作阻塞进程，中断到来时执行 up 操作使进程重新就绪；信号量可用于实现同步，如设置缓冲区空状态和满状态两个信号量，生产者 down 空状态信号量、up 满状态信号量，这样就能空状态下不能运行消费者进程。 互斥量 mutex：互斥量只有两种值，解锁或加锁，可基于 TSL、XCHG 指令实现只能单进程运行。使用互斥量也可以借助 futex 库或 pthread 库。 管程：管程由过程、变量和数据结构组成，任意时刻只能有一个活跃进程，它在编译器层面处理。wait 操作对条件变量执行，将阻塞进程；single 操作用于唤醒进程。Java 中的 synchronized 关键字即是管程的一种实现。 消息传递：通过 send、receive 收发消息。消息可以按进程地址编址，也可以按信箱这种新数据结构取用。生产者先接受消费者发送的空缓冲区，生产数据后，然后将数据项以消息的方式发送给消费者；消费者先接受生产者填充的数据项，消费数据后，然后将空缓冲区以消息的方式发送给生产者。 上述方式都通过共享内存实现进程间的通信，即生产者向共享内存填入数据，消费者从共享内存取出数据。上述方式或者适用于保证双进程模式下只有一个进程读写内存，或者保证了双进程模式下进程处理的时序性。 不同于以上，屏障机制适用于处理进程组：只有当所有的进程完成工作后才会着手下一个阶段，否则运行完成的进程都会被阻塞。屏障通过对运行完成的进程调用 barrier 源于实现。 此外，某些数据结构和算法组合在多进程处理中不必上锁，也能保证读写的一致性。如树在写竭诚中使用新节点数据填充后在插入或树结构变更后再删除节点，在读进程中仍能访问新增前或删除前的节点，在特定操作下也能保证读写一致性。 scheduler 调度进程按处理内容分为计算密集型和 I/O 密集型两类。因为 CPU 处理速度在提升，更多的进程越来越偏向于 I/O 密集型。对于 I/O 密集型进程，应使它们尽快得到处理，以便磁盘始终忙碌；对于计算密集型，则需要多运行一些这类进程，以使 CPU 充分利用。 调度时机 当父进程创建子进程时，调度程序可任意选择运行父进程或子进程。 进程退出时，调度程序会选择运行一个就绪态进程或空闲进程（当没有就绪态进程时）。 当进程由于 I/O、信号量等原因被阻塞时，调度程序会选择运行一个就绪态进程或空闲进程。 当 I/O 处理完结、中断发生时，调度程序将原进程置为就绪态。 调度程序对时钟中断的表现分为两类：非抢占式调度算法允许进程运行到直至阻塞或主动让出 CPU 为止；抢占式调度算法会为进程设置最大时段，当该时段结束时，调度程序就会挂起运行中的进程。对于硬件提供的 50HZ、60HZ 或其他频率的周期性中断，调度程序会在每个时钟中断或没 k 个时钟中断时做出调度决策，以实现抢占式调度。 调度环境及其调度算法调度环境分为三种： 批处理系统，一般使用非抢占式算法或长时间周期的抢占式算法，须保证吞吐量（每小时批处理作业数）足够大、周转时间（批处理作业平均完成时间）足够小、CPU 利用率足够高。 交互式环境，使用抢占式算法，须使响应时间足够快、满足用户期望。 实时系统，有时候没必要使用抢占，须满足截止时间要求、可预测性高（即错误少）。实时系统如病人监控装置、飞机自动驾驶系统以及自动化工厂中的机器人控制等。实时系统分为硬实时、软实时两种，硬实时要求在规定时间内必须执行完成，软实时可以容忍超过规定时间。实时系统会通过将程序拆分为一组进程以提升性能，其中每个进程的行为都是可预测和提前掌握的。实时系统按响应方式可分为周期性事件或非周期性事件。实时系统额调度算法可以在开始运行前作决定（静态的）或在运行过程中作决定（动态的）。 三种环境都需使每个进程公平分摊 CPU 份额，保证规定的策略被执行，保证系统的所有部分都忙碌。 适用于批处理系统的调度算法有： 先来先服务：非抢占式，使用队列维护就绪进程，算法简单，可能会引起不必要的性能消耗。 最短作业优先：非抢占式，先决条件是运行时间可预期，能使作业的平均处理时间缩短，在作业非同时运行的情况下未必是最优解。 最短剩余时间优先：抢占式，先决条件是运行时间可预期，补充了最短作业优先算法的不足。 适用于交互式系统的调度算法有： 轮转调度：抢占式，为每个进程设置最大可运行时长 —— 时间片。超过时间片的运行进程将被挂起，不满时间片的运行进程会在结束时立即被切换。时间片设置过小，将会使进程切换时的性能损耗比重加大；过大，将会使后续的叫请求长时间得不到处理。时间片一般设为 20-50 ms。 优先级调度：抢占式，为进程设置优先级，高优先级的会先行得到运行。为避免高优先级的进程霸占 CPU，调度程序会基于时钟中断降低该进程的优先级。当优先级分为多类后，对归属一类的进程可以再使用轮转调度算法。优先级也可以动态设置，即看进程在上一次时间片中所消耗的时长，时长越短，优先级越高。 多级队列：抢占式，先为进程设置高优先级，给予一个时间片，以使 I/O 密集型进程能得到尽快处理。若为计算密集型且在一个时间片内处理不完，则为进程设置次高优先级，给予两个时间片的运行时间；处理不完再将优先级逐级递减，时间片逐级增大。为了防止计算密集型进程长期抢占 CPU，当用户按下 Enter 键时，所有进程将会被移到最高优先级。 最短进程优先：类似最短作业优先，使用进程历史运行时间的加权平均预估进程的当前运行时间。 保证调度：抢占式，使进程均摊 CPU 运行时间，即调度程序会为运行时间比重最低的进程分配更多的时间，直到它超过运行时间比重次低的进程。 彩票调度：抢占式。以每秒运行时长抽象彩票，运行时长 20 ms，即 50 张彩票。持有彩票数越多的进程会占用相同分量的 CPU 执行时间。进程也可以将彩票让渡给协作式进程，以使协作式进程尽快完成工作。 公平分享调度：上述调度以进程度量调度策略，公平分享调度以用户度量调度策略，即满足用户 1 持有 4 个进程，用户 2 持有 2 个进程，两个用户均摊 CPU 的场景。 调度策略和调度机制对于父进程启动多个子进程的场景，在系统中调度没法或者子进程的重要性，而父进程却知道。因此，在系统层面实现 scheduling mechanism 调度机制并参数化，由用户进程决定 scheduling policy 调度策略。调度机制与调度策略分离，见及数据库管理系统、浏览器的实现。 线程调度如上文，线程分为两种：用户级线程和内核级线程。切换内核级线程比切换用户级线程要消耗更多性能。对于用户级线程，也可以在用户进程中实现线程调度算法，如 web 服务器中的分派线程。如没有进程内的调度算法，计算密集型的用户线程很可能长期占用 CPU。","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"操作系统","slug":"计算机科学/操作系统","permalink":"http://xzfyu.com/categories/计算机科学/操作系统/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"}]},{"title":"聊聊 Ant Design 组件库的构成","slug":"frontend/antd/聊聊组件库的构成","date":"2020-02-27T16:00:00.000Z","updated":"2020-03-08T10:25:17.101Z","comments":true,"path":"2020/02/28/frontend/antd/聊聊组件库的构成/","link":"","permalink":"http://xzfyu.com/2020/02/28/frontend/antd/聊聊组件库的构成/","excerpt":"","text":"底层功能组件rc-utilKeyCode: 记录了各按键的编码，并提供按键判断工具。 hooksuseMergedState(defaultStateValue, option) 主要用于表单项的 value 值状态处理，也可以用于其他状态处理。逻辑上，首先以 option.value、option.defaultValue、defaultStateValue 的顺序设置内部 value 状态值，该 value 值经 option.postState 转变后透出使用；同时透出的有 triggerChange 方法既能改变内部 value 状态值，又能触发 onChange 回调。 1234567891011121314151617181920212223242526272829303132333435363738function useControlledState&lt;T, R = T&gt;( defaultStateValue: T | (() =&gt; T), option?: &#123; defaultValue?: T | (() =&gt; T); value?: T; onChange?: (value: T, prevValue: T) =&gt; void; postState?: (value: T) =&gt; T; &#125;,): [R, (value: T) =&gt; void] &#123; const &#123; defaultValue, value, onChange, postState &#125; = option || &#123;&#125;; const [innerValue, setInnerValue] = React.useState&lt;T&gt;(() =&gt; &#123; if (value !== undefined) &#123; return value; &#125; if (defaultValue !== undefined) &#123; return typeof defaultValue === 'function' ? (defaultValue as any)() : defaultValue; &#125; return typeof defaultStateValue === 'function' ? (defaultStateValue as any)() : defaultStateValue; &#125;); let mergedValue = value !== undefined ? value : innerValue; if (postState) &#123; mergedValue = postState(mergedValue); &#125; function triggerChange(newValue: T) &#123; setInnerValue(newValue); if (mergedValue !== newValue &amp;&amp; onChange) &#123; onChange(newValue, mergedValue); &#125; &#125; return [(mergedValue as unknown) as R, triggerChange];&#125; rc-alignrc-triggerrc-trigger 作为触发器，它抽象了弹层触发的逻辑。功能点包含： 触发节点：children 触发节点。 弹层内容：popup 弹层内容；getPopupContainer 获得弹层容器。 渲染、销毁时机：forceRender 弹层未显示时予以绘制；destroyPopupOnHide 弹层隐藏时销毁。 弹层显示、隐藏时机：action 何种用户行为展示；mouseEnterDelay 鼠标移入后延迟展示；mouseLeaveDelay 鼠标移出时延迟隐藏；popupVisible 受控显示弹层；defaultPopupVisible 弹层默认状况。 弹层位置：alignPoint 跟随鼠标位置动态变动；popupAlign 弹层位置；builtinPlacements 触发元素和弹层的对齐关系隐射 { topLeft: { points: [‘tl’, ‘tl’] }} 两元素左上角对齐；popupPlacement 设置对齐位置。 弹层样式：popupClassName 样式名；getPopupClassNameFromAlign；popupStyle 样式；prefixCls 样式名前缀。zIndex 弹层 zIndex；stretch 弹层大小随触发元素动态变更。 弹层动效：popupTransitionName 弹层动效；maskTransitionName 蒙层动效。 蒙层：mask 是否显示蒙层；maskClosable 点击蒙层关闭弹层；getDocument 文档节点，绑定点击隐藏冒牌事件。 弹层交互：onPopupVisibleChange 弹层显示时回调；onPopupAlign 弹层位置调整时回调。 ref 引用：getRootDomNode 获取触发节点的 dom 元素；getPopupDomNode 获取弹层的 dom 元素。 通用组件按钮 Button 功能特性： 绘制按钮。 绘制按钮组。 样式特性： type 按钮类型：primary 主按钮、默认按钮、dashed 虚线按钮、danger 危险按钮和 link 链接按钮。其中，link 按钮以 a 节点渲染，其他按钮以 button 按钮渲染。 disabled、loading 按钮状态：默认正常状态、disabled 不可用状态、loading 加载中状态。加载中状态按钮将额外绘制加载图标。 shape 按钮形状：默认小圆角按钮、circle 圆形按钮、round 全圆角按钮。 size 按钮尺寸：large 大尺寸按钮、默认中尺寸按钮、small 小尺寸按钮。 block 按钮：100% 宽度构成块状按钮。 ghost 按钮：背景透明的按钮。 icon 图标：按钮内置图标。 按钮内容为双汉字，在双汉字之间插入空格。通过 ConfigProvider 的 autoInsertSpaceInButton 属性可以避免这一行为。 图标 Icon图标基于 ant-design-icons 制作。 功能特性： 绘制内置 svg 图标。 component 设置自定义 svg 图标渲染组件，自定义 svg 图标通过 @svgr/webpack 加载，参看 自定义 SVG 图标。 tabIndex 限制 tab 按键点选顺序。 viewbox 截取 svg 图片，参看 秒懂 svg 图片的 viewbox。 onClick 点击交互等。 Icon.createFromIconfontCN 绘制 iconfont 图标，参看 自定义 font 图标。 Icon.setTwoToneColor 设置双色图标的主色。 样式特性： theme 图标主题风格：outlined 默认描线、filled 实心、twoTone 双色。 type 图标类型：图标类型和 theme 主题风格构成按钮的编码类型，用于查询确切的 svg 图标。 spin 旋转图标。 rotate 旋转角度：基于 transform 样式制作。 twoToneColor 双色图标的主色。 className、style 设置 svg 图标颜色等。 排版 Typography 功能特性： 绘制 Title 标题、Text 文本、Paragraph 段落。 editable 编辑功能。编辑按钮使用 TransButton 组件包裹，便于使用 tab、enter 按键交互以及支持失焦、聚焦事件。编辑按钮点击时将绘制 Textarea。交互行为支持 editable.onStart、editable.onChange。 copyable 复制功能。copy 功能借助 copy-to-clipboard 库实现。复制按钮同样使用 TransButton 组件包裹。交互行为支持 copyable.onCopy；copyable.text 可设置复制内容。 ellipsis 文本省略，ellipsis.expandable 设置折叠展开功能。对于溢出的文本，ant-design 会借助 raf 在下一帧省略文本内容。文本省略采用两种方案实现：首先尝试使用 css 样式（-webkit-line-clamp、text-overflow 属性）；其次使用两分法查询待显示的文本内容，同时会合并文本节点。ant-design 同时会借助 rc-resize-observer 在屏幕大小改变调整显示文本。交互行为支持 ellipsis.onExpand。 样式特性： Title 标题按 level 设置不同级别，分别用 h1、h2、h3、h4 节点渲染。 Text 文本使用 span 节点绘制；Paragraph 段落使用 div 节点绘制。 type 文字类型：默认主要文字、secondary 次要文字浅灰色、warning 警告文字橘黄色、danger 错误文字红色。disabled 失效文字。mark 使用 mark 节点渲染。code 使用 code 节点渲染。underline 使用 u 节点渲染。delete 使用 del 节点渲染。strong 使用 strong 节点渲染。 布局组件栅格 Grid 功能特性： 提供栅格布局功能。栅格布局基于 less 函数制作，并运用了 MediaQuery 样式特性。 样式特性： flex 布局：Row 组件默认使用 block 绘制，可以基于 type 属性使用 flex 布局。flex 布局下，Row#justify 属性设置元素的水平对齐方式；Row#align 属性设置元素的垂直对齐方式；Col#order 属性设置元素的展示顺序。 Row#gutter 栅格间距（Row 组件设置左右减半负边距，Col 组件设置左右边距），间距可以根据屏幕大小动态调整。屏幕大小通过 enquire.js 库嗅探，以回调形式重绘组件。间距通过 Context 机制传入 Col 组件中。 布局 Layout 功能特性： 页面布局，包含 Header 头部、Content 内容、Sider 侧边栏、Footer 尾部。侧边栏可以展开折叠，由 Layout 组件通过收集折叠的侧边栏标识传入子组件中。 样式特性： 渲染时，Layout 组件使用 section 节点；Header 使用 header 节点；Content 使用 main 节点；Footer 使用 footer 节点。Layout 采用 flex 布局，主轴为垂直方向。 Sider#collapsible 激活侧边栏的展开折叠功能。其一可以通过触发按钮展开折叠侧边栏，其二基于 window.matchMedia 方式响应式展开折叠（触发按钮有两种，Sider 组件的展开折叠按钮、Sider 外围通过 Layout 获取状态的展开折叠按钮）。侧边栏内容由子组件渲染，侧边栏的展开折叠状态通过 Context 机制传递。 Sider#theme 设置侧边栏的样式主题。 导航组件固钉 Affix 功能特性： 绘制固钉。固钉会随着 target 节点的事件或者屏幕大小的调整改变位置。固钉的位置调整首先取决于 target 节点和固钉的渲染内容，因此 ant-design 首先会等待渲染完成，借助 raf （封装成方法的装饰器 throttleByAnimationFrameDecorator）调用 setState 重绘，重绘阶段经由 componentDidUpdate 生命周期计算固钉的偏移量等样式，再次使用 setState 进行重绘。依据屏幕大小的动态调整借助于 rc-resize-observer 库；依据 target 节点事件的动态调整借助于 rc-util 库绑定事件。 面包屑 BreadcrumbBreadcrumb 组件测试脚本通过 MemoryRouter 组件实现。 功能特性： 绘制面包屑。面包屑内容既可以使用 Breadcrumb.Item 组件渲染，又可以基于 routes 路由属性渲染（基于路由渲染时，额外可以使用 itemRender 渲染函数获取面包屑元素）。 样式特性： separator 分隔符，既可以通过 Breadcrumb#separator 属性设置，又可以通过 Breadcrumb.Separator 组件渲染。 Breadcrumb.Item#href 链接，设置后将使用 a 节点渲染，不然使用 span 节点渲染。 Breadcrumb.Item#overlay 下拉菜单的内容，下拉菜单通过 DropDown 组件渲染，展示位置在正下方。 下拉菜单 DropDown 功能特性 提供下拉菜单的渲染容器。下拉菜单的触发节点 DropDown#children 和下拉菜单 DropDown#overlay 的内容都由开发者提供，一般菜单内容为 Menu 组件渲染内容。DropDown 会为下拉菜单内容传入 selectable=false, focusable=true 以及 expandIcon 图标属性。渲染容器基于 rc-dropdown 库实现，rc-dropdown 内部使用 rc-trigger 库。 DropDown.Button 不止于提供下拉菜单的渲染容器，同时也将触发节点设置为按钮。它的实现借助于 Button、DropDown 组件。 样式特性： DropDown#getPopupContainer：基于 rc-trigger 库设置下拉菜单的渲染父节点，作为定位节点。 DropDown#align：基于 rc-trigger 库设置下拉菜单位置调整依据。 DropDown#placement：基于 rc-trigger 库设置下拉菜单的弹出位置。 DropDown#transitionName：基于 rc-trigger 库设置下拉菜单展示隐藏时的动效。 DropDown#trigger：基于 rc-trigger 库设置触发下拉菜单的行为 click、hover、contextMenu。当由 contextMenu 鼠标右键触发时，基于 rc-trigger 特性菜单位置也会跟随鼠标移动。 DropDown#forceRender、DropDown#mouseEnterDelay、DropDown#mouseLeaveDelay 等：均基于 rc-trigger 库实现。 导航菜单 Menu详情参考 菜单组件源码分析。 功能特性： 渲染菜单。菜单的基本要素包含 Menu 菜单容器、SubMenu 子菜单、MenuItem 菜单项。菜单以 context 机制对外承接 Sider 侧边栏组件，对内透传折叠、主题状态到 SubMenu、MenuItem 组件。菜单渲染基于 rc-menu、Tooltip 组件。 Menu 菜单容器，组织菜单顶层的展示模式、展开折叠内容及动效。 SubMenu 子菜单。 MenuItem 菜单项，以 Tooltip 组件绘制。 样式特性： Menu#mode 展示模式：vertical 垂直、horizontal 水平、inline 子菜单内嵌三种。在内嵌子菜单模式下，展开的子菜单通过 state.openKeys, state.inlineOpenKeys 交换实现。 Menu#theme 主题：light 浅色、dark 深色两种。 Menu#openKeys、Menu#defaultOpenKeys 展开的子菜单；Menu#onOpenChange 展开的子菜单变更时调用；Menu#subMenuCloseDelay、Menu#subMenuOpenDelay 子菜单展开、折叠时延； Menu#selectedKeys、Menu#defaultSelectedKeys 选中的菜单项；Menu#onSelect、Menu#onDeSelect 菜单项选中、取消选中时调用；Menu#selectable 是否可选；Menu#multiple 是否多选。 Menu#forceSubMenuRender 在子菜单展示之前就渲染进 DOM。 Menu#inlineCollapsed 内嵌模式下菜单是否收起；Menu#inlineIndent 内嵌模式下菜单缩进宽度。 Menu#onClick 菜单项点击时触发。 Menu#overflowedIndicator 菜单折叠时图标。 Pagination 分页器分页器基于 rc-pagination 渲染。分页器分为非简洁模式和简洁模式两种。非简洁模式有三部分构成：总页数、翻页列表、每页显示条数。简洁模式只有翻页功能，没有总页数、每页显示条数。内置状态包含 current 当前页码、pageSize 每页显示条目数。外置状态 total 总页数用于更新当前页码。翻页功能包含跳转上/下一页；跳转前/后三（或五）页（当前页码在总页码中间态时）。操作方法基于简单改变 current、pageSize 延伸出跳转上/下一页、通过按键改变页码等方法。改变每页显示的 Select 组件由 rc-pagination 通过 props 属性传值。 PageHeader 页头页头组合了 Breadcrumb 面包屑、Avatar 头像、Tag 标签等组件，用于绘制页头。 Steps 步骤条步骤条基于 rc-steps 渲染。Steps 组件主要包含一些样式特性，状态管理逻辑基本没有。当浏览器支持 flex 布局时，Step 采用 flex 布局渲染；不支持时，Step 采用百分比渲染：默认类型的 Steps 会用 margin 值为最后一个元素预留宽度（通过定时器计算最后一个元素的宽度，更新 state 以重绘），导航类型的 Steps 通过百分比均分宽度。 数据录入AutoComplete 自动完成自动完成组件基于 Select、Input 组件制作，主要逻辑也由 Select 组件承担。 Checkbox 复选框、Radio 单选框Checkbox 复选框、Radio 单选框可以参考 Radio, Checkbox。 Cascader 级联选择rc-cascader级联选择基于 rc-cascader 制作。rc-cascader 的实现又基于 rc-trigger 抽象弹层逻辑、array-tree-filter 扁平化、过滤树形数据。 实际的触发节点 props.children 通过 React.cloneElement 绑定 onKeyDown 键盘事件。如果 props.children 定义了 onKeyDown 方法，则取用该方法进行处理；如果没有，则使用 rc-cascader 内置的处理逻辑，包含 up/down 上下选、left/backspace 回选、right 向前选、esc/tab 隐藏等功能。 在 rc-cascader 中，array-tree-filter 负责根据级联选择的动态 value 值计算待展示的弹层菜单列表（即弹层菜单中，第二列起的次级列表，其与树结构首层混合，构成当前下拉菜单中展示的完整内容）。菜单中每个选项根据 label 值渲染内容，同时可以包含展开、加载中按钮；选项支持的交互行为包含双击隐藏弹层、点击选中、鼠标移入移出选中。选中的选项存入本地缓存中，在弹层显示状态更新时，用于使选项列表滚动至选中元素上（通过节点的 scrollTop 属性设置）。选项选中逻辑为：如果选中选项为否值或 disabled 状态，直接返回；如果级联选择开启了远程加载 loadData 功能，且选中选项不是叶子节点，首先基于 changeOnSelect 向外透出选中列表，然后更新级联选择的 state.activeValue 状态值并加载远程数据；如果只使用本地数据，且选中选项是叶子节点，向外透出选中列表并更新 state.value 状态值；如果只使用本地数据，根据 expandTrigger 触发行为向外透传选中列表、条件隐藏弹层，并更新 state。value 状态值。 CascaderCascader 组件在 rc-cascader 的基础上，默认使用输入框作为触发节点，也可以使用 props.children 替换。输入框有只读态、showSearch 搜索态两种：只读态基于 rc-cascader 点击展开弹层；搜索态阻止点击事件冒泡、支持失焦行为、键盘事件阻止 space/backspace 按键隐藏弹层、change 事件改编 inputValue 值（渲染时更新弹层选项列表）。选中的值在输入框中的表现通过固定定位的 span 节点渲染。输入框内可设置 allowClear 清空图标、suffixIcon 后缀图标。 输入框触发器能基于 SizeContext 获得外层传入的 size 尺寸。Cascader 对外提供的 ref 引用，可以使用 focus、blur 方法获得或失去焦点；input 属性即输入框节点。 全量的选项列表会通过扁平化处理。在渲染时，Cascader 会基于输入框的值进行筛选；筛选内容有最大展示条目限制；筛选内容有最大展示条目限制；选项内容可排序（以上，均可通过 props.showSearch 设置）。当没有（匹配的）选项时，展示空态。 弹层位置可基于 props.popupPlacement 或通过 ConfigContext 传入的 direction 设置（右下或左下对齐）。弹层大小可基于 props.showSearch.matchInputWidth 设置为与输入框等宽。弹层容器可基于 props.getPopupContainer 或通过 ConfigContext 传入的 getPopupContainer 设置。 Cascader 组件的值、弹层显示状态均是受控的；对外回调接口包含 onChange、onPopupVisibleChange。 DatePicker 日期选择框DatePicker 组件基于 rc-picker 制作，它指定 moment 作为时间处理工具，并从上下文中获取 locale、size 属性等，以提供时间选择的功能。 Form 表单可参考 Form。 InputNumber 数字输入框Input 输入框","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"react fiber 搜罗整理篇","slug":"frontend/react16/react fiber 搜罗整理篇","date":"2020-02-21T16:00:00.000Z","updated":"2020-03-08T11:28:01.421Z","comments":true,"path":"2020/02/22/frontend/react16/react fiber 搜罗整理篇/","link":"","permalink":"http://xzfyu.com/2020/02/22/frontend/react16/react fiber 搜罗整理篇/","excerpt":"","text":"fiber 出台的原委和特性The crux of the change is transitioning from processing updates in a synchronous, recursive way to relying on asynchronous scheduling and prioritization of interface changes. A look inside React Fiber 指明，react 演进出 fiber 架构的关键点在于渲染策略的变更，从原先的 Stack Reconciler 同步递归模式转变为 Fiber Reconciler 基于优先级的异步调度模式。这样就能避免其他文章所说的，Stack Reconciler 模式中的 JS 运算、页面布局和页面绘制将长期占用主线程，页面出现掉帧的现象。依照官方文档 Codebase Overview，Fiber Reconciler 包含如下特性： 将工作拆分为任务单元，实现增量渲染 按类型为任务单元设置优先级 任务单元可暂停、复用或中止 任务单元可并发执行 完全理解 React Fiber 提到增量渲染所采用的 cooperative scheduling 合作式调度是操作系统 3 种任务调度策略中的一种。其内容为：将渲染工作拆解，每次只做一小段，做完看是否还有时间继续下一个任务，没有就把时间控制权交还给主线程，有就继续处理下一个任务。 React Fiber Architecture 也指出，这一处理机跟 call stack 将执行函数作为栈帧添加到堆栈中相似。在处理 ui 时，浏览器提供了可用的 api：requestIdleCallback 会调度在空闲期间调用的低优先级函数；requestAnimationFrame 会调度在下一个动画帧上调用的高优先级函数。在 React 中，单个 fiber 就如同栈帧。React 的调度策略基于 pull 模式智能应用更新（基于 push 模式需要由开发者自主决定哪些更新是要应用的），且为不同的 fiber 设置不同的优先级，可以避免不必要的 UI 更新。 React 分层模型和数据结构推演 Inside Fiber: in-depth overview of the new reconciliation algorithm in React 提及的，React 各分层的数据处理走向比如： 用户侧创建 Class 或 Function 组件、Host 组件（如 DOM 节点）、Protals 等； 通过 React.createElement 创建 React 元素树，用于描述页面的呈现（Inside Fiber: in-depth overview of the new reconciliation algorithm in React 坚持认为 Virtual DOM 实际上指的是不可改变的 React 元素树）； 基于 React 元素树创建 fiber 节点树（也称为 internal instances 内部实例树）； 最后由 fiber 节点树获得具体平台相关的 public instance（也称为 Host instance，如真实的 DOM 树）。 上述数据结构的后半部分对应着 React 中的两个分层： Reconciler 层：执行 reconciliation 流程，通过 diff 算法等将组件状态变化反应为视图内容，并触发 side-effects（调用生命周期方法、更新 ref）等。 Renderer 层：根据不同的平台，渲染出真实的内容，比较常见的是 ReactDOM、ReactNative。 fiber，作为 unit of workfiber 基本结构fiber 节点可基于 React 元素创建，通过调用 createFiberFromTypeAndProps.js 实现。实际上，创建 fiber 节点不止于基于 React 元素一种。fiber 节点会以单向链表的形式构成节点树。 123456789101112131415161718192021222324252627export type Fiber = &#123;| /** 1. 承接 React 元素的相关属性 **/ tag: WorkTag,// fiber 节点的工作类型 elementType: any,// react 元素类型 key: null | string,// 用于 diff 算法的 key 键 type: any,// 类组件构造函数或函数组件自身 ref:// 引用 | null | (((handle: mixed) =&gt; void) &amp; &#123;_stringRef: ?string, ...&#125;) | RefObject, /** 2. props &amp; state **/ // React 元素类型的引用，可以认为这个属性保存了与 fiber 相关的本地状态 stateNode: any, pendingProps: any,// 待更新的 props memoizedProps: any,// 更新后的 props，作为输出透出到页面侧 memoizedState: any,// 更新后的 state，作为输出透出到页面侧 /** 存放 fiber 依赖的 contexts, events **/ dependencies: Dependencies | null, /** 3. fiber 树结构 **/ return: Fiber | null, // 类同堆栈的返回栈帧，通常是父节点 child: Fiber | null,// 子节点 sibling: Fiber | null,// 邻近的兄弟节点 index: number,|&#125;; fiber 工作单元fiber 节点树不像剥离掉 diff 算法后的 Virtual DOM 那样仅是一种表现，它内部集成了可调度工作任务以操作树的算法。Inside Fiber: in-depth overview of the new reconciliation algorithm in React 称单个 fiber 节点就是一个工作单元，这也是源码中的表现： You can think of a fiber as a data structure that represents some work to do or, in other words, a unit of work. Fiber’s architecture also provides a convenient way to track, schedule, pause and abort the work. current tree &amp; work-in-progress tree current tree：首次渲染或更新后设置，描述页面的当前展现； work-in-progress tree：更新时用于页面呈现所需的操作，更新后会替代 current tree。 使用 work-in-progress tree 直接替代 current tree 称为 double buffering 双缓冲技术，这样便于复用 fiber 对象、节省内存分配和 GC 的时间开销。current tree、work-in-progress tree 处理的简要流程如下： 首次渲染时，渲染完成的 fiber 节点树称为 current tree；更新渲染时，fiber 节点将被重用，current tree 会维持不变，更新内容反应为另一个 fiber 节点树 work-in-progress tree。当所有渲染流程走完时，work-in-progress tree 会被刷新到页面上，并成为新的 current tree（即 current tree 表示已渲染内容；work-in-progress tree 表示处理中的渲染内容）。current tree、work-in-progress tree 中的 fiber 节点以 alternate 属性相互持有对方，这样结对的处理方式便于延后批量应用更新内容，支持工作任务的可打断。下文将表明，Fiber Reconciler 的更新机制分为两阶段，render 阶段处理并获得以 work-in-progress tree 呈现的更新，commit 阶段应用 work-in-progress tree 的更新。 update queue可变的 state 更新会以 fiber.updateQueue 形式应用。ReactUpdateQueue.js 中阐明，UpdateQueue 跟 fiber 一样，也有 current queue、work-in-progress queue 两个队列。这两个队列共享同一个持久化的单链接链表。区别在于，这两个队列中指向活动中的 update 指针不同，work-in-progress 的指针索引在 render 阶段必然会大于或等于 current queue 的指针索引。提交阶段时，work-in-progress queue 会成为新的 current queue。任务的可中断正是在于，执行中的 work-in-progress queue 可被丢弃，并从 current queue 重新复制一份。 UpdateQueue 队列中的每个 update 任务有优先级标识。Reconciler 会根据优先级执行 update 任务。ReactUpdateQueue.js 指出需要特别注意的是，位于跳过的较低优先级之后高优先级任务仍旧会驻留在 UpdateQueue 队列中，就会造成这些高优先级任务被执行多次。正是因为这个原因，所以 render 阶段的生命周期函数才会打上 UNSAFE_ 标识，它们同样也会被执行多次，可能形成不必要的副作用（如在 UNSAFE_componentWillMount 中获取远程数据，请求就会发送多次）。 expiration timefiber 任务的优先级与 fiber.expirationTime 息息相关。留待下回分解。 side effects除了 state 更新以外，react 官方将更新 ref 引用、调用生命周期、订阅 state 变更 dom 等都视为 side effects。Inside Fiber: in-depth overview of the new reconciliation algorithm in React 引用了官方的原话： You’ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations “side effects” (or “effects” for short) because they can affect other components and can’t be done during rendering. 1234567891011121314151617181920212223242526export type Fiber = &#123;| // current tree、work-in-progress tree 中的 fiber 节点以 alternate 属性相互持有对方 alternate: Fiber | null, // state 更新处理队列，以链表形式呈现 updateQueue: UpdateQueue&lt;any&gt; | null, /** 优先级 **/ expirationTime: ExpirationTime,// fiber 任务预期执行时间，不包含子树中的更新 childExpirationTime: ExpirationTime,// 用于判断子树中的任务是否执行完成 // 以下四字段在 enableProfilerTimer 为 true 时设置 actualDuration?: number,// 当前 fiber 及子孙的渲染时间，rerender 时重置为 0 actualStartTime?: number,// render 阶段，fiber 任务开始时间 selfBaseDuration?: number,// 当前 fiber 的历史渲染时间 treeBaseDuration?: number,// 当前 fiber 子孙节点的历史渲染时间 // 用于描述 fiber 及其子树的特性，ConcurrentMode 表示默认情况下子树是否应异步 // 创建 fiber 时，默认继承父节点的 mode，创建时可修改，fiber 生命周期中将维持不变 mode: TypeOfMode, /** side-effects **/ effectTag: SideEffectTag, nextEffect: Fiber | null,// 链表结构，指向下一个带有 side-effects 的 fiber firstEffect: Fiber | null,// 链表中的首节点，便于快速更新链表 lastEffect: Fiber | null,// 链表中的尾节点，便于快速更新链表|&#125;; render、commit 两阶段渲染如上文已指出，React 将渲染过程分为 render/reconciliation、commit 两阶段。完全理解 React Fiber 将这两阶段类比为 Virtual DOM 技术中的 diff、patch 过程。 render 阶段计算并获取以 work-in-progress tree 呈现的更新，可中断； commit 阶段应用 work-in-progress tree 的更新。 React Fiber Architecture 中的以下描述也说明了两阶段的主要内容： reconciliation：The algorithm React uses to diff one tree with another to determine which parts need to be changed.update：A change in the data used to render a React app. Usually the result of setState. Eventually results in a re-render. render 阶段首次渲染时，reconciler 基于 React 元素创建 fiber，最终形成 fiber 节点树 current tree。当更新时，reconciler 会遍历 current tree，复用 fiber.alternate 备用节点，生成 work-in-progress tree。因为单个 fiber 也是 unit of work，work-in-progress tree 也可以称为任务单元树。 reconciler 会通过 performSyncWorkOnRoot、performConcurrentWorkOnRoot 函数启动 work-loop 循环 。该循环会使用深度优先算法处理 work-in-progress tree，只有经过更新的 fiber 节点才会被处理。work-loop 循环有以下四种处理函数： performUnitOfWork：从 work-in-progress tree 中取出 fiber ， beginWork：context 入栈后，更新当前 fiber 节点的 props、state 相关属性，视条件更新 side effects 链表，返回 fiber.child。 completeUnitOfWork：视条件更新 side effects 链表，返回 fiber.sibling 或 fiber.return。 completeWork：context 出栈等操作。 performUnitOfWork、completeUnitOfWork 主要用于迭代 fiber 节点，主要更新活动由 beginWork、completeWork 完成。以下是这四种函数迭代节点的流程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function workLoopSync() &#123; while (workInProgress !== null) &#123; workInProgress = performUnitOfWork(workInProgress); &#125;&#125;function performUnitOfWork(workInProgress) &#123; let next = beginWork(workInProgress); if (next === null) &#123; next = completeUnitOfWork(workInProgress); &#125; return next;&#125;function beginWork(workInProgress) &#123; console.log('work performed for ' + workInProgress.name); return workInProgress.child;&#125;function completeUnitOfWork(unitOfWork) &#123; workInProgress = unitOfWork; do &#123; const current = workInProgress.alternate; const returnFiber = workInProgress.return; if ((workInProgress.effectTag &amp; Incomplete) === NoEffect) &#123; let next = completeWork(current, workInProgress, renderExpirationTime); if (next !== null) &#123; return next; &#125; &#125; else if (returnFiber !== null) &#123; const next = unwindWork(workInProgress, renderExpirationTime); if (next !== null) &#123; return next; &#125; &#125; if (siblingFiber !== null) &#123; // If there is more work to do in this returnFiber, do that next. return siblingFiber; &#125; // Otherwise, return to the parent workInProgress = returnFiber; &#125; while (workInProgress !== null);&#125;function completeWork(workInProgress) &#123; console.log('work completed for ' + workInProgress.name); return null;&#125; 综上，更新时会生成部分节点带有 side effects 标识的 work-in-progress tree。effects list 链表会向上归并到父节点上，它会指示需要插入、更新或删除哪些节点，以及哪些组件需要调用其生命周期方法。current tree、work-in-progress tree、effects list 就是 render 阶段的所有产物（work-in-progress tree 在此时也被称为 finished-work tree）。 commit 阶段commit 阶段的主要工作在于将 effects list 链表应用到 fiber 节点树上。这部分工作由 finishSyncRender、finishConcurrentRender 函数启动。主要功能则由 commitRootImpl.js 完成。Inside Fiber: in-depth overview of the new reconciliation algorithm in React 指出它包含如下操作： 对标记了 Snapshot effect 的节点调用 getSnapshotBeforeUpdate 生命周期方法 对标记了 Deletion effect 的节点调用 componentWillUnmount 生命周期方法 执行所有 DOM 插入、更新和删除操作 将 finished-work tree 分配给 FiberRoot，并置为 current tree 对标记了 Placement effect 的节点调用 componentDidMount 生命周期方法 对标记了 Update effect 的节点调用 componentDidUpdate 生命周期方法 后记react fiber 是笔者长期没法啃下来的内容。这篇文章由以下文章汇总整理得来，却未对 scheduler、fiber 的优先级及类型等加诸说明。个中惭愧与骄傲处，留诗为念。 满身金紫一毛猴，偏腾赤手摘蟠桃。不慎数声尽入水，引得御马都发笑。 Inside Fiber: in-depth overview of the new reconciliation algorithm in React[译]深入React fiber架构及源码React Fiber Architecture完全理解 React FiberA look inside React FiberReact Fiber 源码分析","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"http://xzfyu.com/categories/frontend/react/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"umi-plugin-qiankun","slug":"frontend/工程化/umi-plugin-qiankun","date":"2020-02-16T16:00:00.000Z","updated":"2020-03-08T10:57:51.608Z","comments":true,"path":"2020/02/17/frontend/工程化/umi-plugin-qiankun/","link":"","permalink":"http://xzfyu.com/2020/02/17/frontend/工程化/umi-plugin-qiankun/","excerpt":"","text":"umi-plugin-qiankun 基于 qiankun，允许在 umi 环境中创建微服务。 按官方示例，搭建 umi 微服务可基于以下流程实现： 主应用 .umirc.js 添加 @umijs/plugin-qiankun 插件配置 master 内容：注册子应用（应用名、html 地址、路由前缀、路由方式、挂载节点、自定义属性等）、启动沙箱、启动预加载、启动异步渲染等。（备注：子应用也可以在运行时通过 src/app.js 这个特殊的运行时插件导出 qiankun 的方式动态注册） 子应用 .umirc.js 添加 @umijs/plugin-qiankun 插件配置 slave 内容：keepOriginalRoutes。 子应用入口文件中导出 qiankun = { bootstrap, mount, unmount }，非必要。 综上，注册子应用的方式有两种： 编译期通过 .umirc.js 注册。 运行时通过 src/app.js 注册。 基于 qiankun、umi 的运作机制，使用 umi-plugin-qiankun 搭建微服务就是在运行时获取编译期或运行时配置，然后调用 qiankun 的接口注册子应用并启动微服务。因为需要在运行时注册子应用，所以就需要借助运行时插件的能力。在实现上，umi-plugin-qiankun 会通过 qiankun-master、qiankun-slave 这两个额外插件分别会调用 api.addRuntimePlugin 接口注册各自的 runtimePlugin 运行时插件。关于 umi 的运行时插件，可参考 umi 运行时插件。 编译期配置（即 .umirc.js 中的 master、slave 内容）的获取，umi 提供的可实现方式是： 首先通过 api.onOptionChange 监听编译期配置变更。 然后通过 api.changePluginOption 将配置内容传递给 qiankun-master、qiankun-slave 这两个额外插件。 在 qiankun-master、qiankun-slave 中，调用 api.writeTmpFile 将配置内容写入 subAppsConfig.json 临时文件。 runtimePlugin 运行时插件读取临时文件，并相应注册子应用。 运行时配置（即 src/app.js 导出的 qiankun）的获取，umi 提供的可实现方式是：在 runtimePlugin 运行时插件通过调用 plugins.mergeConfigAsync(‘qiankun’) 读取导出内容。 微服务注册启动流程如上文，umi-plugin-qiankun 中的微服务注册启动流程就是读取编译器配置或运行时配置，再调用 qiankun 接口注册和启动微服务。这部分内容主要在 qiankun-master 这个额外插件实现。此外，umi-plugin-qiankun 支持使用 defer 配置异步渲染（子应用挂载在主应用渲染产生的节点上），这部分功能通过 api.writeTmpFile、api.addUmiExports 接口创建 qiankunDefer.js 临时文件实现。在启动微服务的流程中，umi-plugin-qiankun 首先会调用 render 脚本，然后（根据 defer 配置）等待 qiankunDefer 执行到 resolve 状态，最后调用 qiankun 接口启动微服务。想要使 qiankunDefer 变更到 resolve 状态，需要开发者手动调用 qiankunStart（也即 qiankunDefer.resolve）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*** qiankun-master *** runtimePlugin.js ***/// 获取编译器配置（.umirc.js 中的 master、slave 内容）import subAppConfig from '@tmp/subAppsConfig.json';// 获取运行时配置（src/app.js 导出的 qiankun），运行时配置优先级高于编译器配置async function getMasterRuntime() &#123; const plugins = require('umi/_runtimePlugin'); const config: GlobalOptions = (await plugins.mergeConfigAsync('qiankun')) || &#123;&#125;; const &#123; master &#125; = config; return master || config;&#125;export async function render(oldRender: typeof noop) &#123; // 执行 umi 应用的渲染脚本 // 渲染脚本先于 defer 流程，defer 才有效 oldRender(); // 子应用是否处于激活状态 function isAppActive(location: Location, history: IConfig['history'], base: App['base']) &#123; const baseConfig = toArray(base); switch (history) &#123; case 'hash': return baseConfig.some(pathPrefix =&gt; testPathWithPrefix(`#$&#123;pathPrefix&#125;`, location.hash)); case 'browser': return baseConfig.some(pathPrefix =&gt; testPathWithPrefix(pathPrefix, location.pathname)); default: return false; &#125; &#125; // 获取运行时配置、编译器配置 const runtimeConfig = await getMasterRuntime(); const &#123; apps, jsSandbox = false, prefetch = true, defer = false, lifeCycles, masterHistory, ...otherConfigs &#125; = &#123; ...(subAppConfig as Options), ...(runtimeConfig as Options), &#125;; assert(apps &amp;&amp; apps.length, 'sub apps must be config when using umi-plugin-qiankun'); // 注册子应用 registerMicroApps( apps.map((&#123; name, entry, base, history = masterHistory, mountElementId = defaultMountContainerId, props &#125;) =&gt; (&#123; name, entry, activeRule: location =&gt; isAppActive(location, history, base), render: (&#123; appContent, loading &#125;) =&gt; &#123; if (process.env.NODE_ENV === 'development') &#123; console.info(`app $&#123;name&#125; loading $&#123;loading&#125;`); &#125; if (mountElementId) &#123; const container = document.getElementById(mountElementId); if (container) &#123; const subApp = React.createElement('div', &#123; dangerouslySetInnerHTML: &#123; __html: appContent, &#125;, &#125;); ReactDOM.render(subApp, container); &#125; &#125; &#125;, // 将 base、history 都传入子应用 props: &#123; base, history, ...props, &#125;, &#125;)), lifeCycles, ); // 异步启动，需要在主应用中手动调用 qiankunStart 函数，以使 deferred 执行到 resolve 状态 if (defer) &#123; await deferred.promise; &#125; // 启动微服务 start(&#123; jsSandbox, prefetch, ...otherConfigs &#125;);&#125; 12345678910111213141516171819api.writeTmpFile( 'qiankunDefer.js', ` class Deferred &#123; constructor() &#123; this.promise = new Promise(resolve =&gt; this.resolve = resolve); &#125; &#125; export const deferred = new Deferred(); export const qiankunStart = deferred.resolve; `.trim(),);api.addUmiExports([ &#123; specifiers: ['qiankunStart'], source: '@tmp/qiankunDefer', &#125;,]); 子应用侧，结合 qiankun 加载子应用脚本生命周期函数的机制，qiankun-slave 这个额外插件会借助 api.modifyDefaultConfig 为子应用设置跟路由、挂载节点、开启 runtimePublicPath 等；借助 api.modifyPublicPathStr 将 publicPath 设置为 window.INJECTED_PUBLIC_PATH_BY_QIANKUN 或 api.config.publicPath、’/‘ 等；借助 api.modifyWebpackConfig 将打包模式改为 umd 模式，并将开发环境的 publicPath 与开发服务器 ip 地址挂钩。与此同时，qiankun-slave 会借助 api.modifyHTMLWithAST 为子应用的入口文件加载节点打上 entry 标识；借助 api.chainWebpackConfig 为开发环境的 source-map 增添跨域能力。以下仅展示部分脚本： 12345678910111213141516171819202122232425262728/*** qiankun-slave *** index.ts ***/api.modifyHTMLWithAST($ =&gt; &#123; $('script').each((_, el) =&gt; &#123; const scriptEl = $(el); const umiEntryJs = /\\/?umi(\\.\\w+)?\\.js$/g; if (umiEntryJs.test(scriptEl.attr('src') ?? '')) &#123; scriptEl.attr('entry', ''); &#125; &#125;); return $;&#125;);if (process.env.NODE_ENV === 'development' &amp;&amp; port) &#123; // 变更 webpack-dev-server websocket 默认监听地址 process.env.SOCKET_SERVER = `$&#123;protocol&#125;://$&#123;localIpAddress&#125;:$&#123;port&#125;/`; api.chainWebpackConfig(memo =&gt; &#123; // 禁用 devtool，启用 SourceMapDevToolPlugin memo.devtool(false); memo.plugin('source-map').use(webpack.SourceMapDevToolPlugin, [ &#123; namespace: pkgName, append: `\\n//# sourceMappingURL=$&#123;protocol&#125;://$&#123;localIpAddress&#125;:$&#123;port&#125;/[url]`, filename: '[file].map', &#125;, ]); &#125;);&#125; 子应用的生命周期函数umi-plugin-qiankun 允许在子应用的 src/app.js 配置生命周期函数。获取该部分的运行时配置同样通过添加运行时脚本实现，但这次并没有调用 api.addRuntimePlugin，而是调用 api.addRendererWrapperWithModule 将 qiankun-slave 插件中的 lifecycles.ts 模块注入到 umi.js 入口文件中，再通过调用 api.addEntryCode 使 umi.js 导出 bootstrap、mount、unmount 生命周期函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/*** qiankun-slave *** index.ts ***/const lifecyclePath = require.resolve('./lifecycles');api.addEntryImport(&#123; source: lifecyclePath, specifier: '&#123; genMount as qiankun_genMount, genBootstrap as qiankun_genBootstrap, genUnmount as qiankun_genUnmount &#125;',&#125;);// lifecycles.ts 以 moduleBeforeRendererPromises 形式添加到入口文件中// moduleBeforeRendererPromises 为什么返回 Promise，就像这个插件中的情形一样，可以改写 render// 改写完成后，再通过 resolve 进行渲染操作api.addRendererWrapperWithModule(lifecyclePath);// 往入口文件中插入脚本，对应 entry.js.tpl 中的 code，render 脚本渲染后再调用api.addEntryCode( ` export const bootstrap = qiankun_genBootstrap(Promise.all(moduleBeforeRendererPromises), render); export const mount = qiankun_genMount(); export const unmount = qiankun_genUnmount('$&#123;mountElementId&#125;'); if (!window.__POWERED_BY_QIANKUN__) &#123; bootstrap().then(mount); &#125; `,);/*** qiankun-slave *** lifecycles.ts ***/import ReactDOM from 'react-dom';import &#123; noop &#125; from '../common';type Defer = &#123; promise: Promise&lt;any&gt;; resolve(value?: any): void;&#125;;const defer: Defer = &#123;&#125;;defer.promise = new Promise(resolve =&gt; &#123; defer.resolve = resolve;&#125;);let render = noop;let hasMountedAtLeastOnce = false;// moduleBeforeRendererPromises 处理机制，需要返回 Promiseexport default () =&gt; defer.promise;// src/app.js 中配置的生命周期函数function getSlaveRuntime() &#123; const plugins = require('umi/_runtimePlugin'); const config = plugins.mergeConfig('qiankun') || &#123;&#125;; const &#123; slave &#125; = config; return slave || config;&#125;// 引导函数，先执行 src/app.js 中配置的 bootstrap 生命周期// 然后改写 render 脚本，渲染失败予以提示export function genBootstrap(promises: Promise&lt;any&gt;, oldRender: typeof noop) &#123; return async (...args: any[]) =&gt; &#123; const slaveRuntime = getSlaveRuntime(); if (slaveRuntime.bootstrap) await slaveRuntime.bootstrap(...args); render = () =&gt; promises.then(oldRender).catch(e =&gt; &#123; if (process.env.NODE_ENV === 'development') &#123; console.error('Render failed', e); &#125; &#125;); &#125;;&#125;// 挂载函数，先调用 defer.resolve 引起 render 渲染脚本执行// 其次执行 src/app.js 中配置的 mount 生命周期// 其次若非首次 mount，手动调用 render 渲染脚本export function genMount() &#123; return async (...args: any[]) =&gt; &#123; defer.resolve(); const slaveRuntime = getSlaveRuntime(); if (slaveRuntime.mount) await slaveRuntime.mount(...args); // 第一次 mount umi 会自动触发 render，非第一次 mount 则需手动触发 if (hasMountedAtLeastOnce) &#123; render(); &#125; hasMountedAtLeastOnce = true; &#125;;&#125;// 卸载函数export function genUnmount(mountElementId: string) &#123; return async (...args: any[]) =&gt; &#123; const container = document.getElementById(mountElementId); if (container) &#123; ReactDOM.unmountComponentAtNode(container); &#125; const slaveRuntime = getSlaveRuntime(); if (slaveRuntime.unmount) await slaveRuntime.unmount(...args); &#125;;&#125; 应用间的数据共享如 umi-plugin-qiankun 文档中所述，应用间的数据共享可通过 props 实现（子应用注册方式采用运行时配置），其次可基于公共的 hooks 实现共享。基于 hooks 实现数据共享的流程为： 开发者手动在主应用的工程目录下添加 src/rootExports.js 并导出 hooks； 由 qiankun-master 读取这些 hooks，并通过临时文件 qiankunRootExports.js 将其赋值到 window.g_rootExports 属性中； 由 qiankun-slave 创建 qiankunContext.js 临时文件，调用 React.createContext 生成上下文； 由 qiankun-slave 添加 rootContainer 类运行时脚本，以 qiankunContext 包裹原先的根节点，上下文中传入 window.g_rootExports 属性。 12345678910111213141516171819202122232425262728293031323334353637/*** qiankun-master *** index.ts ***/const rootExportsFile = join(api.paths.absSrcPath, 'rootExports.js');api.addPageWatcher(rootExportsFile);api.onGenerateFiles(() =&gt; &#123; const rootExports = `window.g_rootExports = $&#123;existsSync(rootExportsFile) ? `require('@/rootExports')` : `&#123;&#125;`&#125;; `.trim(); api.writeTmpFile('qiankunRootExports.js', rootExports);&#125;);/*** qiankun-slave *** index.ts ***/api.writeTmpFile( 'qiankunContext.js', `import &#123; createContext, useContext &#125; from 'react';export const Context = createContext(null);export function useRootExports() &#123; return useContext(Context);&#125;;`.trim(),);api.addUmiExports([ &#123; specifiers: ['useRootExports'], source: '@tmp/qiankunContext', &#125;,]);/*** qiankun-slave *** runtimePlguin.ts ***/function rootContainer(container: HTMLElement) &#123; const value = (window as any).g_rootExports; // eslint-disable-next-line global-require const &#123; Context &#125; = require('@tmp/qiankunContext'); return React.createElement(Context.Provider, &#123; value &#125;, container);&#125; 后记稍稍厘清这个插件已觉费力，再看到 umi 团队规划中的任务项”子应用嵌套、公共依赖加载策略“，略感望尘莫及。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"umi 运行时插件","slug":"frontend/工程化/umi运行时插件","date":"2020-02-16T16:00:00.000Z","updated":"2020-03-08T10:57:46.460Z","comments":true,"path":"2020/02/17/frontend/工程化/umi运行时插件/","link":"","permalink":"http://xzfyu.com/2020/02/17/frontend/工程化/umi运行时插件/","excerpt":"","text":"运行原理runtimePlugin 运行时插件也遵循先注册、后使用的流程。运行时插件表现为数组形式，数组项为运行时插件的导出对象。导出对象中的属性可以是函数、或对象、返回对象的 Promise（前者可称为执行类导出，后两者可称为配置类导出，因其用于获取配置项）。umi 包中的 runtimePlugin.js 提供了如下方法： plugins：运行时插件集合。 validKeys：校验 key 键集合。 init({ validKeys })：清空 plugins，赋值 plugins。 use(plugin)：注册插件，并校验插件的 key 键。 getItem(key)：获取 key 键为指定值的插件。 compose(item, { initialValue })：选用执行类导出以 reduce 机制依次执行其中的函数，函数执行时参数为上游的返回值。 apply(item, { initialValue, args })：选用执行类导出以 reduce 机制依次执行其中的函数，函数执行时参数为上游的返回值 memo，以及 apply 调用时传参 args。 applyForEach(item, { initialValue })：选用执行类导出以 array.forEach 机制依次执行其中的函数，函数执行时参数为 initialValue。 mergeConfig(item)：选用纯对象配置类导出，混合其配置输出。 mergeConfigAsync(item)：选用 Promise 形式的配置类导出，混合其配置输出。 上述方法的有效性都依赖于 plugins 运行时插件集合、validKeys 校验 key 键集合非空。那么，plugins、validKeys 都是在什么装填进内容的呢？采用倒溯法，我们可以在 umi-build-dev 包下的 entry.js.tpl 入口文件模板中找到如下代码： 12345678910const plugins = require('umi/_runtimePlugin');// 实际就是 umi 包中的 runtimePlugin.js&#123;&#123;#globalVariables&#125;&#125;window.g_plugins = plugins;&#123;&#123;/globalVariables&#125;&#125;plugins.init(&#123; validKeys: [&#123;&#123;#validKeys&#125;&#125;'&#123;&#123;&#123; . &#125;&#125;&#125;',&#123;&#123;/validKeys&#125;&#125;],&#125;);&#123;&#123;#plugins&#125;&#125;plugins.use(require('&#123;&#123;&#123; . &#125;&#125;&#125;'));&#123;&#123;/plugins&#125;&#125; 上述入口文件模板代码也即意味着 umi 在启动时会将运行时插件及其校验 key 键集合通过 mustache 模板引擎装填到入口文件中，以便其他调用文件所使用。实际入口文件内容由以下代码填充： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*** umi-build-dev *** FilesGenerator.js ***/// 调用 addRuntimePlugin 插件钩子，获得 umi 内部以及各 umi-plugin-* 注册的运行时插件const plugins = this.service .applyPlugins('addRuntimePlugin', &#123; initialValue: [], &#125;) .map(plugin =&gt; &#123; return winPath(relative(paths.absTmpDirPath, plugin)); &#125;);// 调用 addRuntimePluginKey 插件钩子，获得 umi 内部以及各 umi-plugin-* 注册的运行时插件校验 key 键const validKeys = this.service.applyPlugins('addRuntimePluginKey', &#123; initialValue: [ 'patchRoutes', 'render', 'rootContainer', 'modifyRouteProps', 'onRouteChange', 'modifyInitialProps', 'initialProps', ],&#125;);// ...// 使用 mustache 模板引擎生成入口文件内容，为其装填运行时插件及其校验 key 键const entryContent = Mustache.render(entryTpl, &#123; globalVariables: !this.service.config.disableGlobalVariables, code: this.service .applyPlugins('addEntryCode', &#123; initialValue: [], &#125;) .join('\\n\\n'), codeAhead: this.service .applyPlugins('addEntryCodeAhead', &#123; initialValue: [], &#125;) .join('\\n\\n'), imports: importsToStr( this.service.applyPlugins('addEntryImport', &#123; initialValue: moduleBeforeRenderer, &#125;), ).join('\\n'), importsAhead: importsToStr( this.service.applyPlugins('addEntryImportAhead', &#123; initialValue: [], &#125;), ).join('\\n'), polyfillImports: importsToStr( this.service.applyPlugins('addEntryPolyfillImports', &#123; initialValue: [], &#125;), ).join('\\n'), moduleBeforeRenderer, render: initialRender, plugins, validKeys, htmlTemplateMap: htmlTemplateMap.join('\\n'), findRoutePath: winPath(require.resolve('./findRoute')),&#125;); 提供给 umi-plugin-* 插件所使用的 api.addRuntimePlugin、api.addRuntimePluginKey 作为 ADD 类型的插件钩子，其意义在于给 opts.memo 添加元素，然后在 applyPlugins 阶段输出 plugins、validKeys。关于 umi 的插件钩子，可参看 umi 插件钩子机制。 内置实例从上方源码也可以看出，umi 内置有 patchRoutes、render、rootContainer、modifyRouteProps、onRouteChange、modifyInitialProps、initialProps 等运行时插件。 入口文件生成机制要说明这些插件的意义，先要解释一下 umi 中入口文件 umi.js 的生成策略。这部分功能由 FilesGenerator.js 模块中的 generateEntry 方法完成。它遵照一下流程： 读取 entry.js.tpl 模板。 根据 SSR、CSR 渲染策略生成 render 渲染脚本（生成 rootContainer 应用根元素并完成挂载）。 执行 modifyEntryRender 插件钩子，改写 render 渲染脚本。 执行 addRendererWrapperWithModule 插件钩子，获取 render 渲染前执行脚本。 执行 addRuntimePlugin、addRuntimePluginKey 插件钩子，获取运行时插件及其校验 key 键。较为特殊的运行时插件为工程目录下的 app.js 文件。 如果是 SSR 渲染，生成服务端渲染 html 模板（注：不甚理解）。 通过 mustache 模板引擎生成 umi.js 入口文件脚本内容。 将入口文件脚本内容写入打包文件夹中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/*** umi-build-dev *** FilesGenerator.js ***/generateEntry() &#123; const &#123; paths, config &#125; = this.service; // 步骤 1 const entryTpl = readFileSync(paths.defaultEntryTplPath, 'utf-8'); // 步骤 2、3 const initialRender = this.service.applyPlugins('modifyEntryRender', &#123; initialValue: `window.g_isBrowser = true;let props = &#123;&#125;;// Both support SSR and CSRif (window.g_useSSR) &#123; // 如果开启服务端渲染则客户端组件初始化 props 使用服务端注入的数据 props = window.g_initialData;&#125; else &#123; const pathname = location.pathname; const activeRoute = findRoute(require('@@/router').routes, pathname); // 在客户端渲染前，执行 getInitialProps 方法 // 拿到初始数据 if (activeRoute &amp;&amp; activeRoute.component &amp;&amp; activeRoute.component.getInitialProps) &#123; const initialProps = plugins.apply('modifyInitialProps', &#123; initialValue: &#123;&#125;, &#125;); props = activeRoute.component.getInitialProps ? await activeRoute.component.getInitialProps(&#123; route: activeRoute, isServer: false, location, ...initialProps, &#125;) : &#123;&#125;; &#125;&#125;const rootContainer = plugins.apply('rootContainer', &#123; initialValue: React.createElement(require('./router').default, props),&#125;);ReactDOM[window.g_useSSR ? 'hydrate' : 'render']( rootContainer, document.getElementById('$&#123;config.mountElementId&#125;'),); `.trim(), &#125;); // 步骤 4 const moduleBeforeRenderer = this.service .applyPlugins('addRendererWrapperWithModule', &#123; initialValue: [], &#125;) .map((source, index) =&gt; &#123; return &#123; source, specifier: `moduleBeforeRenderer$&#123;index&#125;`, &#125;; &#125;); // 步骤 5 const plugins = this.service .applyPlugins('addRuntimePlugin', &#123; initialValue: [], &#125;) .map(plugin =&gt; &#123; return winPath(relative(paths.absTmpDirPath, plugin)); &#125;); if (findJS(paths.absSrcPath, 'app')) &#123; plugins.push('@/app'); &#125; const validKeys = this.service.applyPlugins('addRuntimePluginKey', &#123; initialValue: [ 'patchRoutes', 'render', 'rootContainer', 'modifyRouteProps', 'onRouteChange', 'modifyInitialProps', 'initialProps', ], &#125;); assert( uniq(validKeys).length === validKeys.length, `Conflict keys found in [$&#123;validKeys.join(', ')&#125;]`, ); // 步骤 6 let htmlTemplateMap = []; if (config.ssr) &#123; const isProd = process.env.NODE_ENV === 'production'; const routePaths = getRoutePaths(this.RoutesManager.routes); htmlTemplateMap = routePaths.map(routePath =&gt; &#123; let ssrHtml = '&lt;&gt;&lt;/&gt;'; const hg = getHtmlGenerator(this.service, &#123; chunksMap: &#123; // TODO, for dynamic chunks // placeholder waiting manifest umi: [ isProd ? '__UMI_SERVER__.js' : 'umi.js', isProd ? '__UMI_SERVER__.css' : 'umi.css', ], &#125;, headScripts: [ &#123; content: 'window.g_useSSR=true;'.trim(), &#125;, ], scripts: [ &#123; content: `window.g_initialData = \\$&#123;stringify(props)&#125;;`.trim(), &#125;, ], &#125;); const content = hg.getMatchedContent(normalizePath(routePath, config.base)); ssrHtml = htmlToJSX(content).replace( `&lt;div id=\"$&#123;config.mountElementId || 'root'&#125;\"&gt;&lt;/div&gt;`, `&lt;div id=\"$&#123;config.mountElementId || 'root'&#125;\"&gt;&#123;rootContainer&#125;&lt;/div&gt;`, ); return `'$&#123;routePath&#125;': ($&#123;ssrHtml&#125;),`; &#125;); &#125; // 步骤 7 const entryContent = Mustache.render(entryTpl, &#123; globalVariables: !this.service.config.disableGlobalVariables,// 是否配置 window.g_history 等全局变量 code: this.service// 入口文件处添加的执行脚本，渲染后 .applyPlugins('addEntryCode', &#123; initialValue: [], &#125;) .join('\\n\\n'), codeAhead: this.service// 入口文件处添加的执行脚本，渲染前 .applyPlugins('addEntryCodeAhead', &#123; initialValue: [], &#125;) .join('\\n\\n'), imports: importsToStr(// 入口文件 import 的模块 this.service.applyPlugins('addEntryImport', &#123; initialValue: moduleBeforeRenderer, &#125;), ).join('\\n'), importsAhead: importsToStr(// 入口文件 import 的模块 this.service.applyPlugins('addEntryImportAhead', &#123; initialValue: [], &#125;), ).join('\\n'), polyfillImports: importsToStr(// 入口文件最顶层 import 的 ployfill 模块 this.service.applyPlugins('addEntryPolyfillImports', &#123; initialValue: [], &#125;), ).join('\\n'), moduleBeforeRenderer,// render 脚本执行前的操作函数 render: initialRender,// 渲染 rootContainer 的 render 脚本 plugins,// 运行时插件集合 validKeys,// 运行时插件校验 key 键集合 htmlTemplateMap: htmlTemplateMap.join('\\n'),// 服务端渲染 html 模板 findRoutePath: winPath(require.resolve('./findRoute')),// 提供 findRoute、getUrlQuery 函数的 findRoute 模块位置 &#125;); // 步骤 8 writeContent(paths.absLibraryJSPath, prettierFile(`$&#123;entryContent.trim()&#125;\\n`));&#125; renderrender 运行时插件的功能在于对渲染脚本进行封装。 12/*** umi-build-dev *** entry.js.tpl ***/const render = plugins.compose('render', &#123; initialValue: clientRender &#125;); rootContainerrootContainer 运行时插件的功能在于对渲染脚本进行封装。 1234/*** umi-build-dev *** entry.js.tpl ***/const rootContainer = plugins.apply('rootContainer', &#123; initialValue: App,&#125;); patchRoutespatchRoutes 运行时插件的功能在于追加或修改路由。其流程为：编译阶段获得配置路由或扫描文件路由，然后在运行时对这些路由进行再处理。 123/*** umi-build-dev *** router.js.tpl ***/const plugins = require('umi/_runtimePlugin');plugins.applyForEach('patchRoutes', &#123; initialValue: routes &#125;);// routes 为编译阶段输出路由 onRouteChangeonRouteChange 运行时插件的功能在于监听路由变更信息。 12345678910/*** umi *** router.js.tpl ***/function routeChangeHandler(location, action) &#123; plugins.applyForEach('onRouteChange', &#123; initialValue: &#123; routes, location, action, &#125;, &#125;);&#125; modifyRouteProps、modifyInitialProps、initialPropsmodifyRouteProps、modifyInitialProps 的功能在于修改注入路由组件的 props。modifyInitialProps、initialProps 在服务端渲染时使用。 123456789101112131415161718192021/*** umi *** renderRoutes.js ***/const newProps = plugins.apply('modifyRouteProps', &#123; initialValue: &#123; ...props, ...extraProps, ...compatProps, &#125;, args: &#123; route &#125;,&#125;);let &#123; component: Component &#125; = route;if (__IS_BROWSER &amp;&amp; Component.getInitialProps) &#123; const initialProps = plugins.apply('modifyInitialProps', &#123; initialValue: &#123;&#125;, &#125;); Component = wrapWithInitialProps(Component, initialProps);&#125;return ( &lt;Component &#123;...newProps&#125; route=&#123;route&#125;&gt; &#123;childRoutes&#125; &lt;/Component&gt;);","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"qiankun 微服务","slug":"frontend/architecture/qiankun 微服务","date":"2020-02-15T16:00:00.000Z","updated":"2020-03-08T10:42:40.982Z","comments":true,"path":"2020/02/16/frontend/architecture/qiankun 微服务/","link":"","permalink":"http://xzfyu.com/2020/02/16/frontend/architecture/qiankun 微服务/","excerpt":"","text":"qiankun 基于 single-spa、import-html-entry 实现。 启动流程跟 single-spa 一样，qiankun 启动微服务的流程仅有两步： registerMicroApps(apps, lifeCycles?, opts?) 注册应用。 start(opts?) 启动。 qiankun 提供了以下新特性： qiankun 微服务的渲染内容通过 html 脚本形式提供，render 渲染函数处理的就是 html 内容（引用）。html 中加载的 js 脚本同样需要透出 bootstrap、mount、unmount 等生命周期函数。多个应用不会在同一张 html 页面寻找 dom 节点，从而相互隔离。备注：import-html-entry 加载 html 时会将 js 处理成 execScripts 脚本加载器。 除了应用的 js 脚本提供 bootstrap、mount、unmount 等生命周期函数以外，qiankun 允许在 registerMicroApps 执行期间添加 beforeLoad(appName)、beforeMount、afterMount、beforeUnmount、afterUnmount 等钩子。 为应用的 js 脚本提供沙箱环境，隔离应用之间的全局变量。沙箱生命周期中调用的劫持器能自动解绑事件、影响应用的发布配置 publicPath 等。 静默加载其他应用，或者在首个应用 mount 完成后启动加载流程，或者在应用无变更的前提下启动加载流程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177function registerMicroApps&lt;T extends object = &#123;&#125;&gt;( apps: Array&lt;RegistrableApp&lt;T&gt;&gt;, lifeCycles?: LifeCycles&lt;T&gt;, opts?: RegisterMicroAppsOpts,) &#123; window.__POWERED_BY_QIANKUN__ = true; const &#123; beforeUnmount = [], afterUnmount = [], afterMount = [], beforeMount = [], beforeLoad = [] &#125; = lifeCycles || &#123;&#125;; microApps = [...microApps, ...apps]; let prevAppUnmountedDeferred: Deferred&lt;void&gt;; apps.forEach(app =&gt; &#123; const &#123; name, entry, render, activeRule, props = &#123;&#125; &#125; = app; registerApplication( name, async (&#123; name: appName &#125;) =&gt; &#123; // 加载应用须等待 start 执行结束 await frameworkStartedDefer.promise; // 通过 import-html-entry 获取应用的入口 html 及 js 脚本加载器 const &#123; template: appContent, execScripts, assetPublicPath &#125; = await importEntry(entry, opts); // 如果微服务页面只挂载一个应用（单例模式），等待前一个应用 unmount 后，才予 load 当前应用 // single-spa 会在前一个应用 unmount 的同时，处理当前应用的 load、bootstrap 流程 https://github.com/CanopyTax/single-spa/blob/master/src/navigation/reroute.js#L74 // 单例模式在 start 执行期间制定，默认为单例模式 if (await validateSingularMode(singularMode, app)) &#123; await (prevAppUnmountedDeferred &amp;&amp; prevAppUnmountedDeferred.promise); &#125; // 预先渲染微应用的 html 结构，等待 js 脚本 mount 内容 render(&#123; appContent, loading: true &#125;); let jsSandbox: Window = window; let mountSandbox = () =&gt; Promise.resolve(); let unmountSandbox = () =&gt; Promise.resolve(); if (useJsSandbox) &#123; const sandbox = genSandbox(appName, assetPublicPath); jsSandbox = sandbox.sandbox; mountSandbox = sandbox.mount; unmountSandbox = sandbox.unmount; &#125; await execHooksChain(toArray(beforeLoad), app); let &#123; bootstrap: bootstrapApp, mount, unmount &#125; = await execScripts(jsSandbox); // 如果应用脚本没有导出 bootstrap、mount、unmount，使用 window[appName] 中的值替代 if (!isFunction(bootstrapApp) || !isFunction(mount) || !isFunction(unmount)) &#123; const globalVariableExports = (window as any)[appName] || &#123;&#125;; bootstrapApp = globalVariableExports.bootstrap; mount = globalVariableExports.mount; unmount = globalVariableExports.unmount; if (!isFunction(bootstrapApp) || !isFunction(mount) || !isFunction(unmount)) &#123; throw new Error(`You need to export the functional lifecycles in $&#123;appName&#125; entry`); &#125; if (process.env.NODE_ENV === 'development') &#123; console.warn( `LifeCycles are not found from $&#123;appName&#125; entry exports, fallback to get them from window['$&#123;appName&#125;'] `, ); &#125; &#125; return &#123; // 微应用的引导流程，使用 single-spa 添加多个生命周期函数 bootstrap: [bootstrapApp], // 微应用的挂载流程 // 1. 单例模式下，等待前一个应用卸载完成 // 2. 预先渲染微应用的 html 结构，等待 js 脚本 mount 内容 // 3. 执行 beforeMount 钩子 // 4. 执行 sandbox.mount 钩子 // 5. 执行微应用的 mount 钩子 // 6. 将微应用的 html 结构置为非加载状态 // 7. 执行 afterMount 钩子 // 8. 设置 prevAppUnmountedDeferred，以满足微服务的单例模式机制 mount: [ async () =&gt; &#123; if ((await validateSingularMode(singularMode, app)) &amp;&amp; prevAppUnmountedDeferred) &#123; return prevAppUnmountedDeferred.promise; &#125; return undefined; &#125;, async () =&gt; render(&#123; appContent, loading: true &#125;), async () =&gt; execHooksChain(toArray(beforeMount), app), mountSandbox, mount, async () =&gt; render(&#123; appContent, loading: false &#125;), async () =&gt; execHooksChain(toArray(afterMount), app), async () =&gt; &#123; if (await validateSingularMode(singularMode, app)) &#123; prevAppUnmountedDeferred = new Deferred&lt;void&gt;(); &#125; &#125;, ], // 微应用的挂载流程 // 1. 执行 beforeUnmount 钩子 // 2. 执行微应用的 unmount 钩子 // 3. 执行 sandbox.unmount 钩子 // 4. 执行 afterUnmount 钩子 // 5. 将微应用的 html 结构置空 // 7. 执行 prevAppUnmountedDeferred.resolve，以便 load 其他应用 unmount: [ async () =&gt; execHooksChain(toArray(beforeUnmount), app), unmount, unmountSandbox, async () =&gt; execHooksChain(toArray(afterUnmount), app), async () =&gt; render(&#123; appContent: '', loading: false &#125;), async () =&gt; &#123; if ((await validateSingularMode(singularMode, app)) &amp;&amp; prevAppUnmountedDeferred) &#123; prevAppUnmountedDeferred.resolve(); &#125; &#125;, ], &#125;; &#125;, // 路由匹配策略 activeRule, // 自定义属性 props, ); &#125;);&#125;function start(opts: StartOpts = &#123;&#125;) &#123; const &#123; prefetch = true, jsSandbox = true, singular = true, fetch &#125; = opts; switch (prefetch) &#123; // 监听 single-spa:first-mount 事件，在非手机环境或网络较快时加载时，通过 window.requestIdleCallback 或 setTimeout 加载其他应用 case true: prefetchAfterFirstMounted(microApps, fetch); break; // 监听 single-spa:no-app-change 事件，静默加载其他应用 case 'all': prefetchAll(microApps, fetch); break; default: break; &#125; // 默认应用沙箱 if (jsSandbox) &#123; useJsSandbox = jsSandbox; &#125; // 默认单例模式 if (singular) &#123; singularMode = singular; &#125; startSpa(); frameworkStartedDefer.resolve();&#125;class Deferred&lt;T&gt; &#123; promise: Promise&lt;T&gt;; resolve!: (value?: T | PromiseLike&lt;T&gt;) =&gt; void; reject!: (reason?: any) =&gt; void; constructor() &#123; this.promise = new Promise((resolve, reject) =&gt; &#123; this.resolve = resolve; this.reject = reject; &#125;); &#125;&#125; 沙箱在 single-spa 微服务项目中，多个应用会共用 window 的对象，一个应用设置的全局变量会影响到另一个应用。为了隔离，qiankun 设计了沙箱机制。首先，qiankun 使用 Proxy 生成 window 对象的代理，该代理会作为应用脚本的执行上下文。当应用脚本对该代理设置属性时，qiankun 会使用 addedPropsMapInSandbox 记录新增的全局变量、modifiedPropsOriginalValueMapInSandbox 记录变更前的全局变量、currentUpdatedPropsValueMap 记录当前应用设置的全局变量（作为快照），然后对原始的 window 对象赋值，取值时通过代理从原始的 window 获得应用中设置的值（特别的，获取方法时会绑定上原始的 window）。当沙箱 unmount（即应用 unmount 时），qiankun 会基于 addedPropsMapInSandbox、modifiedPropsOriginalValueMapInSandbox 恢复 window 对象的属性。当沙箱再次 mount（即应用再次 mount 时），qiankun 会基于 modifiedPropsOriginalValueMapInSandbox 将原始 window 对象置为快照值。 sandbox 沙箱代码的执行时机遵从应用的生命周期： 当应用被 load 时，创建沙箱，即生成 window 对象的代理，同时调用 hijackAtBootstrapping 劫持 window 方法。这时 sandboxRunning 状态为 true。备注：因为没调用 single-spa 的 unloadApplication 方法，应用只会被 load 一次。 当应用被 bootstrap 时，沙箱被应用脚本实际使用，用于导出 bootstrap、mount、unmount 等生命周期函数。备注：因为没调用 single-spa 的 unloadApplication 方法，应用只会被 bootstrap 一次。 当应用首次被 mount 时，沙箱的 sandbox.mount 会先于应用脚本的 mount 生命周期执行，调用 hijackAtMounting 劫持 window 方法。 当应用被 unmount 时，沙箱的 sandbox.unmount 会后于应用脚本的 mount 生命周期执行，恢复 window 对象的属性和被劫持方法。sandboxRunning 置为 false. 当应用再次被 mount 时，load 阶段创建的沙箱会被复用，然后按照以下流程处理：首先恢复 hijackAtBootstrapping 阶段劫持方法的执行结果；其次因为 sandboxRunning 为 false，基于 modifiedPropsOriginalValueMapInSandbox 快照恢复 window 对象的历史数据；其次执行 hijackAtMounting 劫持 window 方法；其次恢复 hijackAtMounting 阶段劫持方法的执行结果；最后将 sandboxRunning 置为 true。 官方将应用 load 阶段的沙箱称为 app 环境沙箱；应用 mount 阶段的沙箱称为 render 沙箱。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127export function genSandbox(appName: string, assetPublicPath: string) &#123; const addedPropsMapInSandbox = new Map&lt;PropertyKey, any&gt;();// 记录新增变量 const modifiedPropsOriginalValueMapInSandbox = new Map&lt;PropertyKey, any&gt;();// 记录更新变量 const currentUpdatedPropsValueMap = new Map&lt;PropertyKey, any&gt;();// 记录新增或更新变量 // mountingFreers 用于释放 hijackAtMounting 劫持的方法 let mountingFreers: Freer[] = []; // sideEffectsRebuilders 用于恢复劫持方法的执行结果 let sideEffectsRebuilders: Rebuilder[] = []; let sandboxRunning = true; const boundValueSymbol = Symbol('bound value'); const rawWindow = window; const fakeWindow = Object.create(null) as Window; const sandbox: WindowProxy = new Proxy(fakeWindow, &#123; set(_: Window, p: PropertyKey, value: any): boolean &#123; if (sandboxRunning) &#123; if (!rawWindow.hasOwnProperty(p)) &#123; addedPropsMapInSandbox.set(p, value); &#125; else if (!modifiedPropsOriginalValueMapInSandbox.has(p)) &#123; const originalValue = (rawWindow as any)[p]; modifiedPropsOriginalValueMapInSandbox.set(p, originalValue); &#125; currentUpdatedPropsValueMap.set(p, value); (rawWindow as any)[p] = value; return true; &#125; if (process.env.NODE_ENV === 'development') &#123; console.warn(`Try to set window.$&#123;p.toString()&#125; while js sandbox destroyed or not active in $&#123;appName&#125;!`); &#125; // 在 strict-mode 下，Proxy 的 handler.set 返回 false 会抛出 TypeError，在沙箱卸载的情况下应该忽略错误 return true; &#125;, get(_: Window, p: PropertyKey): any &#123; // 避免用户使用 window.top、window.window、window.self 绕过沙箱机制 // https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L13 if (p === 'top' || p === 'window' || p === 'self') &#123; return sandbox; &#125; const value = (rawWindow as any)[p]; // 为纯函数（不是构造函数）绑定 rawWindow // qiankun 通过 prototype 中是否还有可枚举的拓展方法的方式来判断是否构造函数。检测方法不要随意替换，因为可能触发一些 edge case（比如在 lodash.isFunction 在 iframe 上下文中可能由于调用了 top window 对象触发的安全异常） if (typeof value === 'function' &amp;&amp; !isConstructable(value)) &#123; if (value[boundValueSymbol]) &#123;// 已绑定 rawWindow return value[boundValueSymbol]; &#125; const boundValue = value.bind(rawWindow); Object.keys(value).forEach(key =&gt; (boundValue[key] = value[key])); Object.defineProperty(value, boundValueSymbol, &#123; enumerable: false, value: boundValue &#125;); return boundValue; &#125; return value; &#125;, has(_: Window, p: string | number | symbol): boolean &#123; return p in rawWindow; &#125;, &#125;); // bootstrappingFreers 用于释放 hijackAtBootstrapping 劫持的方法 const bootstrappingFreers = hijackAtBootstrapping(appName, assetPublicPath, sandbox); return &#123; sandbox, async mount() &#123; const sideEffectsRebuildersAtBootstrapping = sideEffectsRebuilders.slice(0, bootstrappingFreers.length); const sideEffectsRebuildersAtMounting = sideEffectsRebuilders.slice(bootstrappingFreers.length); // 恢复 hijackAtBootstrapping 阶段劫持方法的执行结果 if (sideEffectsRebuildersAtBootstrapping.length) &#123; sideEffectsRebuildersAtBootstrapping.forEach(rebuild =&gt; rebuild()); &#125; /* ------ 因为有上下文依赖（window），以下代码执行顺序不能变 ------- */ // 沙箱未启动说明为唤醒流程，此时需从之前的修改记录中恢复上下文 if (!sandboxRunning) &#123; currentUpdatedPropsValueMap.forEach((v, p) =&gt; setWindowProp(p, v)); &#125; // render 沙箱启动时开始劫持各类全局监听，尽量不要在应用初始化阶段有 事件监听/定时器 等副作用 mountingFreers = hijackAtMounting(appName, sandbox); // 恢复 hijackAtMounting 阶段劫持方法的执行结果 if (sideEffectsRebuildersAtMounting.length) &#123; sideEffectsRebuildersAtMounting.forEach(rebuild =&gt; rebuild()); &#125; sideEffectsRebuilders = []; sandboxRunning = true; &#125;, async unmount() &#123; if (process.env.NODE_ENV === 'development') &#123; console.info(`$&#123;appName&#125; modified global properties will be restore`, [ ...addedPropsMapInSandbox.keys(), ...modifiedPropsOriginalValueMapInSandbox.keys(), ]); &#125; // 释放劫持处理 sideEffectsRebuilders = [...bootstrappingFreers, ...mountingFreers].map(free =&gt; free()); // 恢复 window 对象的属性 modifiedPropsOriginalValueMapInSandbox.forEach((v, p) =&gt; setWindowProp(p, v)); addedPropsMapInSandbox.forEach((_, p) =&gt; setWindowProp(p, undefined, true)); sandboxRunning = false; &#125;, &#125;;&#125; hijackerhijackPublicPath 在 hijackAtBootstrapping 阶段执行，意义是将 window.INJECTED_PUBLIC_PATH_BY_QIANKUN 设置为 assetPublicPath（用作 webpack 中的 publicPath），应用卸载时清空，挂载时恢复。 hijackTimer 在 hijackAtMounting 阶段执行，劫持 setInterval、setTimeout，意义是应用卸载时清空定时器。 hijackWindowListener 在 hijackAtMounting 阶段执行，劫持 window.addEventListener、 window.removeEventListener，意义是应用卸载时自动解绑绑定函数。 hijackHistoryListener 在 hijackAtMounting 阶段执行，使用 umi 时有效，意义是应用卸载自动解绑 window.g_history.listen 绑定的函数。 hijackDynamicHeadAppend 在 hijackAtBootstrapping、hijackAtMounting 阶段均会执行，劫持 HTMLHeadElement.prototype.appendChild 方法。当使用 HTMLHeadElement.prototype.appendChild 向 head 头部添加 link、style、script 节点行为（开发环境的实际表现就是应用脚本），script 节点内容需要在沙箱环境中运行。以下是 hijackDynamicHeadAppend 源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102function hijack(appName: string, proxy: Window): Freer &#123; const dynamicStyleSheetElements: Array&lt;HTMLLinkElement | HTMLStyleElement&gt; = []; HTMLHeadElement.prototype.appendChild = function appendChild&lt;T extends Node&gt;(this: any, newChild: T) &#123; const element = newChild as any; if (element.tagName) &#123; switch (element.tagName) &#123; case LINK_TAG_NAME: case STYLE_TAG_NAME: &#123; const stylesheetElement: HTMLLinkElement | HTMLStyleElement = newChild as any; // check if the currently specified application is active // While we switch page from qiankun app to a normal react routing page, the normal one may load stylesheet dynamically while page rendering, // but the url change listener must to wait until the current call stack is flushed. // This scenario may cause we record the stylesheet from react routing page dynamic injection, // and remove them after the url change triggered and qiankun app is unmouting // see https://github.com/ReactTraining/history/blob/master/modules/createHashHistory.js#L222-L230 const activated = checkActivityFunctions(window.location).some(name =&gt; name === appName); // only hijack dynamic style injection when app activated if (activated) &#123; dynamicStyleSheetElements.push(stylesheetElement); &#125; break; &#125; // 使用 import-html-entry 的 execScripts 执行 script 节点内容，使其运行在沙箱环境 case SCRIPT_TAG_NAME: &#123; const &#123; src, text &#125; = element as HTMLScriptElement; if (src) &#123; execScripts(null, [src], proxy).then( () =&gt; &#123; const loadEvent = new CustomEvent('load'); if (isFunction(element.onload)) &#123; element.onload(loadEvent); &#125; else &#123; element.dispatchEvent(loadEvent); &#125; &#125;, () =&gt; &#123; const errorEvent = new CustomEvent('error'); if (isFunction(element.onerror)) &#123; element.onerror(errorEvent); &#125; else &#123; element.dispatchEvent(errorEvent); &#125; &#125;, ); const dynamicScriptCommentElement = document.createComment(`dynamic script $&#123;src&#125; replaced by qiankun`); return rawHtmlAppendChild.call(this, dynamicScriptCommentElement) as T; &#125; execScripts(null, [`&lt;script&gt;$&#123;text&#125;&lt;/script&gt;`], proxy).then(element.onload, element.onerror); const dynamicInlineScriptCommentElement = document.createComment('dynamic inline script replaced by qiankun'); return rawHtmlAppendChild.call(this, dynamicInlineScriptCommentElement) as T; &#125; default: break; &#125; &#125; return rawHtmlAppendChild.call(this, element) as T; &#125;; return function free() &#123; HTMLHeadElement.prototype.appendChild = rawHtmlAppendChild; dynamicStyleSheetElements.forEach(stylesheetElement =&gt; &#123; if (document.head.contains(stylesheetElement)) &#123; if (stylesheetElement instanceof HTMLStyleElement &amp;&amp; isStyledComponentsLike(stylesheetElement)) &#123; if (stylesheetElement.sheet) &#123; // 缓存样式内容 setCachedRules(stylesheetElement, (stylesheetElement.sheet as CSSStyleSheet).cssRules); &#125; &#125; // 移除 style、link 节点 document.head.removeChild(stylesheetElement); &#125; &#125;); return function rebuild() &#123; dynamicStyleSheetElements.forEach(stylesheetElement =&gt; &#123; // 重新添加 style、link 节点 document.head.appendChild(stylesheetElement); // 恢复 style 节点的样式内容 if (stylesheetElement instanceof HTMLStyleElement &amp;&amp; isStyledComponentsLike(stylesheetElement)) &#123; const cssRules = getCachedRules(stylesheetElement); if (cssRules) &#123; for (let i = 0; i &lt; cssRules.length; i++) &#123; const cssRule = cssRules[i]; (stylesheetElement.sheet as CSSStyleSheet).insertRule(cssRule.cssText); &#125; &#125; &#125; &#125;); &#125;; &#125;;&#125; 示例以下改写自 qiankun 官方示例： 编写主应用，设定 html 页面、待渲染内容的布局（通常是菜单）。 编写子应用，子应用需使用 umd 方式打包，这样才能加载到导出的生命周期函数（如上文所述，子应用的 publicPath 可使用 assetPublicPath 配置）。 子应用独立部署，然后由主应用远程获取子应用的 html 页面；或者子应用与主应用以 monorepo 方式组织，如 qiankun 官方示例一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 主应用框架 html 内容// &lt;!DOCTYPE html&gt;// &lt;html lang=\"en\"&gt;// &lt;head&gt;// &lt;meta charset=\"UTF-8\"&gt;// &lt;title&gt;main framework&lt;/title&gt;// &lt;/head&gt;// &lt;body&gt;// &lt;main id=\"container\"&gt;&lt;/main&gt;// &lt;script src=\"./index.js\"&gt;&lt;/script&gt;// &lt;/body&gt;// &lt;/html&gt;// 主应用 index.js 脚本import React from 'react';import ReactDOM from 'react-dom';import &#123; registerMicroApps, setDefaultMountApp, start &#125; from '../../es';import Framework from './Framework';function render(&#123; appContent, loading &#125;) &#123; const container = document.getElementById('container'); ReactDOM.render(&lt;&gt; &lt;header className=&#123;style.header&#125;&gt; &lt;nav&gt; &lt;ol&gt; &lt;li&gt;&lt;a onClick=&#123;() =&gt; goto('home', '/')&#125;&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a onClick=&#123;() =&gt; goto('react15 app', '/15react15')&#125;&gt;react15 + antd2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a onClick=&#123;() =&gt; goto('vue app', '/vue')&#125;&gt;vue2 + element2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a onClick=&#123;() =&gt; goto('react app', '/react')&#125;&gt;react16 + antd3&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/nav&gt; &lt;/header&gt; &#123;loading ? &lt;div&gt;loading...&lt;/div&gt; : null&#125; &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: appContent &#125;&#125; className=&#123;style.appContainer&#125;/&gt; &lt;/&gt;, container);&#125;function genActiveRule(routerPrefix) &#123; return location =&gt; location.pathname.startsWith(routerPrefix);&#125;function initApp() &#123; render(&#123; appContent: '', loading: true &#125;);&#125;initApp();registerMicroApps( [ &#123; name: 'react16-main', entry: '//localhost:7100', render, activeRule: genActiveRule('/react') &#125;, &#123; name: 'react15 app', entry: '//localhost:7102', render, activeRule: genActiveRule('/15react15') &#125;, &#123; name: 'vue app', entry: '//localhost:7101', render, activeRule: genActiveRule('/vue') &#125;, ], &#123; beforeLoad: [ app =&gt; &#123; console.log('before load', app); &#125;, ], beforeMount: [ app =&gt; &#123; console.log('before mount', app); &#125;, ], afterUnmount: [ app =&gt; &#123; console.log('after unload', app); &#125;, ], &#125;,);setDefaultMountApp('/react');start(&#123; prefetch: true &#125;);// react16-main 应用脚本import React from 'react';import ReactDOM from 'react-dom';import App from './App';function render() &#123; ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));&#125;// 设置 publicPathif (window.__POWERED_BY_QIANKUN__) &#123; __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;&#125;if (!window.__POWERED_BY_QIANKUN__) &#123; render();&#125;export async function bootstrap() &#123; console.log('react app bootstraped');&#125;export async function mount(props) &#123; console.log(props); render();&#125;export async function unmount() &#123; ReactDOM.unmountComponentAtNode(document.getElementById('root'));&#125; 备注import-html-entryimport-html-entry 中的 importHTML 函数按以下流程处理： 默认使用 window.fetch 远程获取 html 页面内容； 再通过 processTpl(html, domain) 将 html 内容解析成 { template, scripts, styles, entry } 对象（通过正则表达式解析，entry 为入口文件 —— 默认取 entry 文件夹下脚本或最后一个 script 节点内容；scripts 脚本；styles 样式文件 —— 通过 link 节点加载的样式；template 移除脚本和样式后的 html 内容）； 再通过 getEmbedHTML 从远程拉取 link 节点内容，填充到 html 中； 最后返回 template（即 html）、assetPublicPath、getExternalScripts、getExternalStyleSheets、execScripts。execScripts(proxy) 会使用 window 代理执行 script 脚本；getExternalScripts、getExternalStyleSheets 均获取脚本内容。 importEntry 在 importHTML 的基础上，提供了多态实现，既可以指定 html 的 url，又可以指定 html 的内容。 以下是 execScripts 函数的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function execScripts(entry, scripts, proxy = window, opts = &#123;&#125;) &#123; const &#123; fetch = defaultFetch &#125; = opts; return getExternalScripts(scripts, fetch) .then(scriptsText =&gt; &#123; window.proxy = proxy;// 沙箱 const geval = eval; function exec(scriptSrc, inlineScript, resolve) &#123; const markName = `Evaluating script $&#123;scriptSrc&#125;`; const measureName = `Evaluating Time Consuming: $&#123;scriptSrc&#125;`; if (process.env.NODE_ENV === 'development') &#123; performance.mark(markName); &#125; // 入口文件导出，入口文件默认由最后一个 script 节点加载 if (scriptSrc === entry) &#123; noteGlobalProps();// 记录 global 之前导出属性 try &#123; // bind window.proxy to change `this` reference in script geval(`;(function(window)&#123;;$&#123;inlineScript&#125;\\n&#125;).bind(window.proxy)(window.proxy);`); &#125; catch (e) &#123; console.error(`error occurs while executing the entry $&#123;scriptSrc&#125;`); throw e; &#125; const exports = proxy[getGlobalProp()] || &#123;&#125;;// 拣选出执行入口文件后，global 的导出属性 resolve(exports); // 非入口文件执行 &#125; else &#123; try &#123; // bind window.proxy to change `this` reference in script geval(`;(function(window)&#123;;$&#123;inlineScript&#125;\\n&#125;).bind(window.proxy)(window.proxy);`); &#125; catch (e) &#123; console.error(`error occurs while executing $&#123;scriptSrc&#125;`); throw e; &#125; &#125; if (process.env.NODE_ENV === 'development') &#123; performance.measure(measureName, markName); performance.clearMarks(markName); performance.clearMeasures(measureName); &#125; &#125; function schedule(i, resolvePromise) &#123; if (i &lt; scripts.length) &#123; const scriptSrc = scripts[i]; const inlineScript = scriptsText[i]; exec(scriptSrc, inlineScript, resolvePromise); // resolve the promise while the last script executed and entry not provided if (!entry &amp;&amp; i === scripts.length - 1) &#123; resolvePromise(); &#125; else &#123; schedule(i + 1, resolvePromise); &#125; &#125; &#125; return new Promise(resolve =&gt; schedule(0, resolve)); &#125;);&#125; react-app-rewireqiankun 使用 react-app-rewire 制作微应用。仅需配置 config-overrides.js 以及 .env 约定端口号，然后使用 react-app-rewired start 启动。 123456789101112131415161718192021222324const &#123; name &#125; = require('./package');module.exports = &#123; webpack: function override(config, env) &#123; const copyConfig = &#123; ...config &#125;; console.log('env', env); copyConfig.output.library = `$&#123;name&#125;-[name]`; copyConfig.output.libraryTarget = 'umd'; copyConfig.output.jsonpFunction = `webpackJsonp_$&#123;name&#125;`; return config; &#125;, devServer: function(configFunction) &#123; return function(proxy, allowedHost) &#123; const config = configFunction(proxy, allowedHost); config.open = false; config.hot = false; config.headers = &#123; 'Access-Control-Allow-Origin': '*', &#125;; // Return your customised Webpack Development Server config. return config; &#125;; &#125;,&#125;; vuepressqiankun 使用 vuepress 制作文档。关于 vuepress，笔者将在后续的文章中加以介绍。 后记望洋兴叹。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"umi 插件钩子机制（修正版）","slug":"frontend/工程化/umi 插件钩子机制","date":"2020-02-15T16:00:00.000Z","updated":"2020-03-08T10:57:54.361Z","comments":true,"path":"2020/02/16/frontend/工程化/umi 插件钩子机制/","link":"","permalink":"http://xzfyu.com/2020/02/16/frontend/工程化/umi 插件钩子机制/","excerpt":"","text":"plugin hook 插件钩子在 umi 内部的表现一为 method 方法，一为 hook 钩子。简单而论，插件钩子运作机制分为两步：register 注册插件钩子、apply 执行插件钩子。插件钩子按 name 命名存入 pluginHooks[name] 中，执行期间以 reduce 机制依次执行并控制入参。以下为 umi 源码注册插件钩子、执行插件钩子的底层方法： register(hook, fn) 注册插件钩子，hook 插件钩子名，fn 插件钩子执行脚本。 applyPlugins(key, opts) 依次执行插件钩子，key 插件钩子名，opts.initialValue 插件钩子链执行首参，opts.args 插件钩子链内处理参数。 _applyPluginsAsync(key, opts) 异步方式依次执行插件钩子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*** umi-build-dev *** PluginAPI.js ***//** * 将插件钩子执行脚本添加到 pluginHooks[hook] 中 * @param &#123;string&#125; hook hook 名，对应 registerMethod 中的 name * @param &#123;function&#125; fn hook 处理函数，对应 registerMethod 中的插件钩子执行脚本 */register(hook, fn) &#123; assert( typeof hook === 'string', `The first argument of api.register() must be string, but got $&#123;hook&#125;`, ); assert( typeof fn === 'function', `The second argument of api.register() must be function, but got $&#123;fn&#125;`, ); const &#123; pluginHooks &#125; = this.service; pluginHooks[hook] = pluginHooks[hook] || []; pluginHooks[hook].push(&#123; fn, &#125;);&#125;/*** umi-build-dev *** Service.js ***//** * 取出 pluginHooks[key] 中的 hook 脚本（对应 registerMethod 中的插件钩子执行脚本）并依次执行 * @param &#123;string&#125; key hook 名，对应 registerMethod 中的 name * @param &#123;function&#125; opts 设置初始值 opts.initialValue 和传递参数 opts.args */ applyPlugins(key, opts = &#123;&#125;) &#123; debug(`apply plugins $&#123;key&#125;`); return (this.pluginHooks[key] || []).reduce((memo, &#123; fn &#125;) =&gt; &#123; try &#123; return fn(&#123; memo, args: opts.args, &#125;); &#125; catch (e) &#123; console.error(chalk.red(`Plugin apply failed: $&#123;e.message&#125;`)); throw e; &#125; &#125;, opts.initialValue);&#125;/** * 异步方式依次执行插件钩子 */ async _applyPluginsAsync(key, opts = &#123;&#125;) &#123; debug(`apply plugins async $&#123;key&#125;`); const hooks = this.pluginHooks[key] || []; let memo = opts.initialValue; for (const hook of hooks) &#123; const &#123; fn &#125; = hook; // eslint-disable-next-line no-await-in-loop memo = await fn(&#123; memo, args: opts.args, &#125;); &#125; return memo;&#125; 为什么 umi 选用 reduce 机制执行插件钩子呢？那就要说一下 umi 插件钩子承担的职责了。其一，插件钩子可用于修改配置项（包含添加和修改）；第二，插件钩子可用于监听事件；第三，插件钩子可用于设置普通的处理流程。仅以 webpack 配置为例，多个下游（下一个插件钩子执行脚本）如果想修改 webpack 配置，那就需要一种缓存机制将修改后的 webpack 配置传入下游，reduce 天然具有这种能力。那为何 umi 不使用上游的返回值 memo 作为下游的入参呢？我们再以 webpack 配置为例，线上环境、日常环境的配置内容往往是不同的，因此在插件钩子执行期间需要一个环境标识加以区分，umi 往下游传递的 opts.args 正好可以放这个环境标识。这样就解释了 applyPlugins 采用上述实现的原委了。 至于 umi 插件钩子为什么要承担那么多职能？笔者也摸不清头脑。 umi 内部将插件钩子定义为如下四类： apply 类：注册时提供 apply 自定义钩子处理函数，实现定制的处理流程。没有具体的应用场景。 ADD 类：注册时 type 值设为 ADD，用于添加配置项，典型如往 html 页面上添加 script 节点。 MODIFY 类：注册时 type 值设为 MODIFY，用于修改配置项，典型如修改 webpack 配置。 EVENT 类：注册时 type 值设为 EVENT，用于作事件处理，典型如监听 webpack 编译成功事件。 上述四种插件钩子的实际效用又是怎样的呢？ apply 类：没有具体的应用场景。 ADD、MODIFY 类：applyPlugins 执行返回结果供使用，因此需要在 applyPlugins 执行结束后才能确切明白其功能。 EVENT 类：插件钩子执行脚本即为功能实现。 registerMethod 用于创建多态注册插件钩子的方法，该方法存为 pluginMethods[name]（实际作为 umi-plugin-* 插件中所使用的接口，如 api.addRuntimePlugin 即是 pluginMethods.addRuntimePlugin）。如上所述，插件钩子函数在 apply 类型下都是 umi 内部约定的，即 pluginMethods.addRuntimePlugin(…args) 的调用结果在 applyPlugins 阶段的表现只有两种可能，一种意义，都是变更 opts.memo 的值： 当 args[0] 非函数，将 args[0] 塞入 opts.memo 中。 当 args[0] 为函数，使用该函数处理 opts.memo、opts.args，其返回值作为新的 opts.memo。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** umi-build-dev *** PluginAPI.js ***//** * 生成插件钩子的注册函数 pluginMethods[name] * 同一个 name 名下可以挂多个插件钩子脚本，以 pluginHooks[name] 形式存储 * 最终通过 applyPlugins 调用，以 reduce 方式依次执行，参数 opts = &#123; memo, args &#125; 以闭包形式向后传递 * @param &#123;string&#125; name 插件钩子名 * @param &#123;object&#125; opts = &#123; type, apply &#125; * type 插件钩子类型，umi 将根据 type 类型生成插件钩子脚本 * ADD 类型，往 opts.memo 里塞值 * MODIFY 类型，修改 opts.memo * EVENT 类型，首参绑定函数会消费 opts.args * apply 自定义插件钩子执行脚本，由该脚本消费 opts = &#123; memo, args &#125; */registerMethod(name, opts) &#123; assert(!this[name], `api.$&#123;name&#125; exists.`); assert(opts, `opts must supplied`); const &#123; type, apply &#125; = opts; assert(!(type &amp;&amp; apply), `Only be one for type and apply.`); assert(type || apply, `One of type and apply must supplied.`); this.service.pluginMethods[name] = (...args) =&gt; &#123; if (apply) &#123; this.register(name, opts =&gt; &#123; return apply(opts, ...args); &#125;); &#125; else if (type === this.API_TYPE.ADD) &#123; this.register(name, opts =&gt; &#123; return (opts.memo || []).concat( typeof args[0] === 'function' ? args[0](opts.memo, opts.args) : args[0], ); &#125;); &#125; else if (type === this.API_TYPE.MODIFY) &#123; this.register(name, opts =&gt; &#123; return typeof args[0] === 'function' ? args[0](opts.memo, opts.args) : args[0]; &#125;); &#125; else if (type === this.API_TYPE.EVENT) &#123; this.register(name, opts =&gt; &#123; return args[0](opts.args); &#125;); &#125; else &#123; throw new Error(`unexpected api type $&#123;type&#125;`); &#125; &#125;;&#125; 综上，register 用于底层注册插件钩子；applyPlugins、_applyPluginsAsync 用于底层调用插件钩子；registerMethod 用于生成插件钩子的注册方法。这四个方法均不对外暴露，对外暴露的是通过 registerMethod 生成的 pluginMethods[name]。那么，umi 内部为 umi-plugin-* 插件提供了多少种插件钩子的注册方法呢？我们可以看一下如下方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/*** umi-build-dev *** PluginAPI.js ***//** * 基于 registerMethod 生成插件钩子的注册方法 pluginMethods[name] */_addMethods() &#123; [ [ 'chainWebpackConfig', &#123; type: this.API_TYPE.EVENT, &#125;, ], [ '_registerConfig', &#123; type: this.API_TYPE.ADD, &#125;, ], 'onStart', 'onExit', 'onStartAsync', 'onRouteChange', 'onDevCompileDone', 'onBuildSuccess', 'onBuildSuccessAsync', 'onBuildFail', 'onPrintUmiError', 'addPageWatcher', 'addEntryCode', 'addEntryCodeAhead', 'addEntryImport', 'addEntryImportAhead', 'addEntryPolyfillImports', 'addRendererWrapperWithComponent', 'addRendererWrapperWithModule', 'addRouterImport', 'addRouterImportAhead', 'addVersionInfo', 'addUIPlugin', 'onUISocket', 'modifyAFWebpackOpts', 'modifyEntryRender', 'modifyEntryHistory', 'modifyRouteComponent', 'modifyRouterRootComponent', 'modifyWebpackConfig', '_beforeServerWithApp', 'beforeDevServer', '_beforeDevServerAsync', 'afterDevServer', 'addMiddlewareAhead', 'addMiddleware', 'addMiddlewareBeforeMock', 'addMiddlewareAfterMock', 'modifyRoutes', 'onPatchRoute', 'modifyHTMLContext', 'modifyPublicPathStr', 'addHTMLMeta', 'addHTMLLink', 'addHTMLScript', 'addHTMLStyle', 'addHTMLHeadScript', 'addUmiExports', 'modifyHTMLChunks', 'onGenerateFiles', 'onHTMLRebuild', 'modifyDefaultConfig', '_modifyConfig', 'modifyHTMLWithAST', '_modifyHelpInfo', 'addRuntimePlugin', 'addRuntimePluginKey', 'beforeBlockWriting', 'addBlockUIResource', 'modifyBlockUIResources', '_modifyBlockPackageJSONPath', '_modifyBlockDependencies', '_modifyBlockFile', '_modifyBlockTarget', '_modifyCommand', '_modifyBlockNewRouteConfig', 'beforeBuildCompileAsync', ].forEach(method =&gt; &#123; if (Array.isArray(method)) &#123; this.registerMethod(...method); &#125; else &#123; let type; const isPrivate = method.charAt(0) === '_'; const slicedMethod = isPrivate ? method.slice(1) : method; if (slicedMethod.indexOf('modify') === 0) &#123; type = this.API_TYPE.MODIFY; &#125; else if (slicedMethod.indexOf('add') === 0) &#123; type = this.API_TYPE.ADD; &#125; else if ( slicedMethod.indexOf('on') === 0 || slicedMethod.indexOf('before') === 0 || slicedMethod.indexOf('after') === 0 ) &#123; type = this.API_TYPE.EVENT; &#125; else &#123; throw new Error(`unexpected method name $&#123;method&#125;`); &#125; this.registerMethod(method, &#123; type &#125;); &#125; &#125;);&#125; 上述代码即意味着 umi 为 umi-plugin-* 插件提供了 api.chainWebpackConfig 等 pluginMethods[name]。 在内部实现上，pluginMethods[name] 表现为注册插件钩子；在外部调用表现上，pluginMethods[name] 如其 name 名所示，或者添加配置项（如 addRuntimePlugin），或者修改配置项（如 modifyWebpackConfig），或者执行事件处理函数（如 onDevCompileDone），主要分为以下几类： apply 类：以 umi 内置的自定义钩子函数处理 opts = { memo, args } 以及调用时获得的其他参数。 ADD 类：当首参为函数，该函数以 opts.memo、opts.args 为参数，用于获取新的 opts.memo；当首参非函数，将首参填入 opts.memo 以制作新的 opts.memo（如 addRuntimePlugin）。 MODIFY 类：当首参为函数，该函数以 opts.memo、opts.args 为参数，用于获取新的 opts.memo；当首参非函数，以首参作为新的 opts.memo（如 modifyWebpackConfig）。 EVENT 类：首参只能为函数，作为事件的绑定函数，以该函数处理 opts.args 消息（如 onDevCompileDone）。 在后续文章中，笔者将揭开这些方法的具体意义。 后记每每回头看，以往行文的精准性老是让人心生惭愧。此前一度觉得 umi 的 plugin hooks 机制很绕，现在看来，依然觉得很绕，只是 api.addRuntimePlugin 等对外接口显得清晰了。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"single-spa 实现前端微服务","slug":"frontend/architecture/single-spa 实现前端微服务","date":"2020-02-14T16:00:00.000Z","updated":"2020-03-08T10:42:40.982Z","comments":true,"path":"2020/02/15/frontend/architecture/single-spa 实现前端微服务/","link":"","permalink":"http://xzfyu.com/2020/02/15/frontend/architecture/single-spa 实现前端微服务/","excerpt":"","text":"文档及示例single-spa 具有以下功能特性：在无须刷新页面的前提下，同一个页面可使用不同的框架；基于不同框架实现的前端应用可以独立部署；制作新内容时可以使用不同的框架；支持应用内脚本的懒加载。 single-spa 借鉴了组件生命周期的思想，它为应用设置了针对路由的生命周期。当应用匹配路由/处于激活状态时，应用会把自身的内容挂载到页面上；反之则卸载。典型的 single-spa 由 html 页面、应用注册脚本、应用脚本自身构成。应用注册内容包含：name 应用名；loadingFunction 应用脚本加载函数；activityFunction 应用激活态判断函数。single-spa 又约定应用脚本包含以下生命周期：load 当应用匹配路由时就会加载脚本（非函数，只是一种状态）、bootstrap 引导函数（对接 html，应用内容首次挂载到页面前调用）、mount 挂载函数、unmount 卸载函数（须移除事件绑定等内容）、unload 非必要（unload 之后会重新启动 bootstrap 流程；借助 unload 可实现热更新）。生命周期函数获得参数包含 name 应用名、singleSpa 实例、mountParcel 手动挂载函数、customProps 自定义信息；它必须返回 Promise 或其本身为 async 函数；bootstrap、mount、unmount 生命周期函数不可缺省；生命周期函数可以指定多个，它们会构成异步调用链，逐个调用。官网中的实例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1. html 页面&lt;html&gt;&lt;body&gt; &lt;script src=\"single-spa-config.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// 2. 应用注册脚本import * as singleSpa from 'single-spa';const appName = 'app1';const loadingFunction = () =&gt; import('./app1/app1.js');// loadingFunction，须返回 promiseconst activityFunction = location =&gt; location.pathname.startsWith('/app1');// activityFunction，纯函数const customProps = &#123;&#125;;singleSpa.registerApplication(appName, loadingFunction, activityFunction, customProps);// customProps 可以不填singleSpa.start();// 3. 应用脚本 app1.js，可以在另一个仓库中let domEl;export function bootstrap(props) &#123; const &#123; name, // The name of the application singleSpa, // The singleSpa instance mountParcel, // Function for manually mounting customProps // Additional custom information &#125; = props; // Props are given to every lifecycle return Promise .resolve() .then(() =&gt; &#123; domEl = document.createElement('div'); domEl.id = 'app1'; document.body.appendChild(domEl); &#125;);&#125;export function mount(props) &#123; return Promise .resolve() .then(() =&gt; &#123; domEl.textContent = 'App 1 is mounted!' &#125;);&#125;export function unmount(props) &#123; return Promise .resolve() .then(() =&gt; &#123; domEl.textContent = ''; &#125;)&#125; 快速对接框架在官方提供的示例项目 single-spa-examples 中，single-spa 提供了便捷的引导、挂载、卸载工具（如 single-spa-angular、single-spa-angularjs、single-spa-ember、single-spa-inferno、single-spa-preact、single-spa-react、single-spa-svelte、single-spa-vue），便于对接各种框架。具体可参考官方的示例项目或官方文档 Starting From Scratch。以下为 single-spa-react 的使用示例： 12345678910111213141516171819202122import React from 'react';import ReactDOM from 'react-dom';import singleSpaReact from 'single-spa-react';import App from './containers/App.js';const reactLifecycles = singleSpaReact(&#123; React, ReactDOM, rootComponent: App,// 应用顶层组件 domElementGetter,// 挂载应用的页面 dom 元素&#125;);export const bootstrap = [ reactLifecycles.bootstrap,];export const mount = [ reactLifecycles.mount,];export const unmount = [ reactLifecycles.unmount,];function domElementGetter() &#123; return document.getElementById(\"root\");&#125; 拆分部署single-app 推荐的应用拆分部署策略有如下三种： 将所有应用置于同一个包下。构建时间将会变慢，构建和部署都绑定在一起，这就需要固定的发布计划，而不是临时发布。 创建根应用程序，以 npm 方式安装子应用。子应用程序有单独的存储仓库，每次更新时需要发版。根应用在单个 spa 应用更改时都需要重新安装、重建和重新部署。根应用和各个子应用也可以使用 monorepo 方法（借助 lerna 等）组织。 创建根应用程序，以动态模块加载的方式加载子应用。独立发布的子应用提供一个活动 url 资源地址，随后在根应用中借助模块加载器（如 SystemJS）动态加载。 超时single-app 允许在应用脚本中设置超时时间，一旦超时，应用即予挂死。 123456789101112131415161718192021export function bootstrap(props) &#123;...&#125;export function mount(props) &#123;...&#125;export function unmount(props) &#123;...&#125;export const timeouts = &#123; bootstrap: &#123; millis: 5000, dieOnTimeout: true, &#125;, mount: &#123; millis: 5000, dieOnTimeout: false, &#125;, unmount: &#123; millis: 5000, dieOnTimeout: true, &#125;, unload: &#123; millis: 5000, dieOnTimeout: true, &#125;,&#125;; 动效应用挂载、卸载时的动效既可以在应用内部处理，又可以使用 singlespa-transitions 处理。 包与应用不同，包没有 activityFunction 激活函数，而是通过手动调用加载。包可以像应用程序一样大，也可以像组件一样小。官方建议在应用程序上下文中装入包，那时包将与应用程序一起卸载。包有四种生命周期：bootstrap、mount、unmount、update。使用包允许我们在跨应用中共享组件。以下是官方示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 示例 1：普通应用中装入包const parcelConfig = &#123; bootstrap() &#123; return Promise.resolve() &#125;, mount() &#123; return Promise.resolve() &#125;, unmount() &#123; return Promise.resolve() &#125;&#125;const domElement = document.getElementById('place-in-dom-to-mount-parcel')// 挂载点const parcelProps = &#123;domElement, customProp1: 'foo'&#125;const parcel = singleSpa.mountRootParcel(parcelConfig, parcelProps)parcel.mountPromise.then(() =&gt; &#123;// 包挂载后触发 parcelProps.customProp1 = 'bar' return parcel.update(parcelProps)&#125;).then(() =&gt; &#123; return parcel.unmount()&#125;)// 示例 2：react 应用中装入包import React from 'react'import ReactDom from 'react-dom'import singleSpaReact from 'single-spa-react'import MyParcelComponent from './my-parcel-component.component.js'export const MyParcel = singleSpaReact(&#123; React, ReactDom, rootComponent: MyParcelComponent&#125;)import Parcel from 'single-spa-react/parcel'import MyParcel from './myparcel.js'export class myComponent extends React.Component &#123; render () &#123; // 以 Parcel 组件形式加载包 return ( &lt;Parcel config=&#123;MyParcel&#125; &#123; /* optional props */ &#125; &#123; /* and any extra props you want here */ &#125; /&gt; ) &#125;&#125;// 示例 3：跨应用复用包// app1export const AddContactParcel = &#123; bootstrap: bootstrapFn, mount: mountFn, unmount: unmountFn,&#125;// app2componentDidMount() &#123; SystemJS.import('App1').then(App1 =&gt; &#123; const domElement = document.body App2MountProps.mountParcel(App1.AddContactParcel, &#123;domElement&#125;) &#125;)&#125; 源码在实现上，single-spa 约定了应用、包的生命周期，并调度着应用、包生命周期周转（路由匹配机制）的流程。至于应用、包的加载函数、路由匹配策略及其生命周期函数则由开发者手动实现。 应用部分single-app 将应用抽象为如下形式： 12345678910111213141516&#123; name: string;// 应用名 parcels: &#123;&#125;,// 包 status: NOT_LOADED | LOADING_SOURCE_CODE | NOT_BOOTSTRAPPED | BOOTSTRAPPING | NOT_MOUNTED | MOUNTING | UPDATING | LOAD_ERROR | MOUNTED | UNMOUNTING | SKIP_BECAUSE_BROKEN;// 应用状态 customProps: &#123; [key: string]: any &#125;;// 自定义属性 loadImpl: string | (url: string) =&gt; Promise;// 应用模块位置或应用脚本加载函数 activeWhen: (location: string) =&gt; boolean;// 应用激活状态判断函数 bootstrap: (props: &#123; customProps, name, mountParcel, singleSpa &#125;) =&gt; Promise;// 引导函数 mount: (props: &#123; customProps, name, mountParcel, singleSpa &#125;) =&gt; Promise;// 挂载函数 unmount: (props: &#123; customProps, name, mountParcel, singleSpa &#125;) =&gt; Promise;// 卸载函数 unload: (props: &#123; customProps, name, mountParcel, singleSpa &#125;) =&gt; Promise;// 卸载脚本函数 timeouts: &#123; bootstrap, mount, unmount, unload &#125;;// 超时设置 loadErrorTime: null,// devtools: &#123; overlays &#125;,// 设置 window.__SINGLE_SPA_DEVTOOLS__ 的调试环境中使用&#125; 应用的生命周期（这些生命周期都会改变应用的状态）（如果设置了超时时间且 dieOnTimeout 为 true 时，bootstrap、mount、unmount 执行超时时会通过 Promise.reject 机制阻断后续流程）： load: 调用 app.loadImpl 加载脚本，并将 bootstrap、mount、unmount、unload 转化成异步调用链，设置超时时间。 bootstrap: 调用 app.bootstrap 作引导处理。 mount: 调用 app.mount 挂载内容，失败时 unmount。 unmount: 首先对应用中的包执行 unmountThisParcel 方法，其次调用 app.unmount 卸载内容。 unload: 调用 app.unload 卸载脚本，卸载后移除 app.bootstrap、app.mount、app.unmount、app.unload 等属性。unload 周期在开发者手动调用 unloadApplication 函数时触发，应用会重新退回到 NOT_LOADED 状态，需要再次执行 bootstrap 流程。 从全局层面看，single-app 按以下流程处理应用： 全局劫持 hashchange、popstate 事件，绑定 reroute 函数；并捕获单页应用中的绑定函数，以备后续处理。 registerApplication(appName, applicationOrLoadingFn, activityFn, customProps) 注册应用。该过程将调用 reroute 函数加载应用脚本；其他使用 registerApplication 注册的应用将在等待状态，直到 reroute 递归调用时才予加载。备注：registerApplication 期间，single-app 会通过调用 ensureJQuerySupport 改写 $.on 绑定 hashchange、popstate 事件的功能，以便支持使用 window.$。 start() 启动应用，该过程也将调用 reroute 函数。start 若未执行，reroute 将只加载应用脚本，但不会调用应用脚本内的 bootstrap、mount、unmount 等生命周期函数。 监听到 hashchange、popstate 事件，触发 reroute 函数卸载、挂载应用。对于挂载的应用，捕获到的绑定函数会在 reroute 尾端手动调用。 single-app 最核心的模块是 reroute，其负责调控应用脚本加载、卸载，应用内容挂载、卸载的流程。reroute 函数额外会使用 window.dispatchEvent 发送事件，以便于实现事件监听。 若应用未启动，通过 loadApps 加载匹配路由的应用脚本。加载完成后，若有其他应用脚本在排队注册中，递归调用 reroute 加载之。 若应用已启动，首先对不在用的应用脚本执行 unload、unmount 操作；然后对在用的但是未加载的应用脚本执行 load、bootstrap 操作，等到不在用的脚本 unmount 完成，再执行 mount 操作；其次对在用的同时已加载的应用脚本执行 bootstrap、mount 操作（mount 操作也要等到不在用的脚本 unmount 完成）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/** * reroute 或者由 registerApplication 触发调用，或者由 hashchange、popstate 事件触发调用。多个 registerApplication 会引起 reroute 递归调用；或者路由多次变更，reroute 未执行完成，也会导致 reroute 递归调动 * reroute 作为编程接口，也可以后接 then 方法拿取已挂载的应用 * @param &#123;array&#125; pendingPromises reroute 在执行期间，调用 registerApplication 或变更路由，pendingPromises 非空数组 * @param &#123;event&#125; eventArguments 事件对象，hashchange、popstate 事件时携带 * @state appChangeUnderway 指明 reroute 在一次执行周期中，其他 reroute 将被挂起，直到本次 reroute 递归调用才予以执行 * @state wasNoOp 应用是否发生变更，如加载了一个应用，卸载了一个应用 */export function reroute(pendingPromises = [], eventArguments) &#123; if (appChangeUnderway) &#123; return new Promise((resolve, reject) =&gt; &#123; peopleWaitingOnAppChange.push(&#123; resolve, reject, eventArguments, &#125;); &#125;); &#125; appChangeUnderway = true; let wasNoOp = true; // single-app 是否已 start。start 意味应用变更由路由变更引起 if (isStarted()) &#123; return performAppChanges(); &#125; else &#123; return loadApps(); &#125; // 筛选出待加载的脚本并加载之。所有加载完成后，调用 finishUpAndReturn function loadApps() &#123; return Promise.resolve().then(() =&gt; &#123; const loadPromises = getAppsToLoad().map(toLoadPromise); if (loadPromises.length &gt; 0) &#123; wasNoOp = false; &#125; return Promise .all(loadPromises) .then(finishUpAndReturn) .catch(err =&gt; &#123; callAllEventListeners();// 执行所有捕获的路由变更时间 throw err; &#125;) &#125;) &#125; // 处理路由变更引起的应用变更 function performAppChanges() &#123; return Promise.resolve().then(() =&gt; &#123; window.dispatchEvent(new CustomEvent(\"single-spa:before-routing-event\", getCustomEventDetail())); const unloadPromises = getAppsToUnload().map(toUnloadPromise); const unmountUnloadPromises = getAppsToUnmount() .map(toUnmountPromise) .map(unmountPromise =&gt; unmountPromise.then(toUnloadPromise)); const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises); if (allUnmountPromises.length &gt; 0) &#123; wasNoOp = false; &#125; const unmountAllPromise = Promise.all(allUnmountPromises); // 先 load，再 bootstrap，然后等待其他应用 unmount、unload 完成，再 mount const appsToLoad = getAppsToLoad(); const loadThenMountPromises = appsToLoad.map(app =&gt; &#123; return toLoadPromise(app) .then(toBootstrapPromise) .then(app =&gt; &#123; return unmountAllPromise .then(() =&gt; toMountPromise(app)) &#125;) &#125;) if (loadThenMountPromises.length &gt; 0) &#123; wasNoOp = false; &#125; // 已 bootstrap 过，再次 bootstrap，然后等待其他应用 unmount、unload 完成，再 mount const mountPromises = getAppsToMount() .filter(appToMount =&gt; appsToLoad.indexOf(appToMount) &lt; 0) .map(appToMount =&gt; &#123; return toBootstrapPromise(appToMount) .then(() =&gt; unmountAllPromise) .then(() =&gt; toMountPromise(appToMount)) &#125;) if (mountPromises.length &gt; 0) &#123; wasNoOp = false; &#125; return unmountAllPromise .catch(err =&gt; &#123; callAllEventListeners(); throw err; &#125;) .then(() =&gt; &#123; // 非必须的应用已卸载，可以安心调用挂载应用的 hashchange、popstate 绑定函数 callAllEventListeners(); return Promise .all(loadThenMountPromises.concat(mountPromises)) .catch(err =&gt; &#123; pendingPromises.forEach(promise =&gt; promise.reject(err)); throw err; &#125;) .then(() =&gt; finishUpAndReturn(false)) &#125;) &#125;) &#125; function finishUpAndReturn(callEventListeners=true) &#123; const returnValue = getMountedApps(); if (callEventListeners) &#123; callAllEventListeners(); &#125; pendingPromises.forEach(promise =&gt; promise.resolve(returnValue)); try &#123; const appChangeEventName = wasNoOp ? \"single-spa:no-app-change\": \"single-spa:app-change\"; window.dispatchEvent(new CustomEvent(appChangeEventName, getCustomEventDetail())); window.dispatchEvent(new CustomEvent(\"single-spa:routing-event\", getCustomEventDetail())); &#125; catch (err) &#123; // single-spa:no-app-change 事件监听器报错，single-spa 不予处理 setTimeout(() =&gt; &#123; throw err; &#125;); &#125; // reroute 单次执行结束，无挂起的 reroute 时，调用 reroute 将直接执行 appChangeUnderway = false; // 被挂起的 reroute，需要手动触发之 if (peopleWaitingOnAppChange.length &gt; 0) &#123; const nextPendingPromises = peopleWaitingOnAppChange; peopleWaitingOnAppChange = []; reroute(nextPendingPromises); &#125; return returnValue; &#125; // 手动调用挂载应用中被阻断的 haschange、popstate 绑定函数 function callAllEventListeners() &#123; pendingPromises.forEach(pendingPromise =&gt; &#123; callCapturedEventListeners(pendingPromise.eventArguments); &#125;); callCapturedEventListeners(eventArguments); &#125; function getCustomEventDetail() &#123; const result = &#123;detail: &#123;&#125;&#125; if (eventArguments &amp;&amp; eventArguments[0]) &#123; result.detail.originalEvent = eventArguments[0] &#125; return result &#125;&#125; 包部分single-app 将包抽象为如下内部表现形式： 12345678910111213141516&#123; id: number;// id name: string;// 包名 parentName: string;// 父包名或应用名 parcels: &#123;&#125;,// 包，以 &#123; id: parcel &#125; 形式存储 status: NOT_LOADED | LOADING_SOURCE_CODE | NOT_BOOTSTRAPPED | BOOTSTRAPPING | NOT_MOUNTED | MOUNTING | UPDATING | LOAD_ERROR | MOUNTED | UNMOUNTING | SKIP_BECAUSE_BROKEN;// 状态 customProps: &#123; [key: string]: any &#125;;// 自定义属性，包含 domElement 挂载节点 bootstrap: (props: &#123; customProps, name, mountParcel, singleSpa &#125;) =&gt; Promise;// 引导函数 mount: (props: &#123; customProps, name, mountParcel, singleSpa &#125;) =&gt; Promise;// 挂载函数 update: (props: &#123; customProps, name, mountParcel, singleSpa &#125;) =&gt; Promise;// 更新函数 unmountThisParcel: () =&gt; Promise;// 卸载接口，内部会调用 parcel.unmount 方法 unmount: (props: &#123; customProps, name, mountParcel, singleSpa &#125;) =&gt; Promise;// 卸载函数 unload: (props: &#123; customProps, name, mountParcel, singleSpa &#125;) =&gt; Promise;// 卸载脚本函数 timeouts: &#123; bootstrap, mount, unmount, unload &#125;;// 超时设置&#125; singleSpa.mountRootParcel(config, customProps)、singleSpa.mountParcel(config, customProps) 方法能将外部配置项 [config.name]、config.bootstrap、config.mount、[config.update]、config.unmount、customProps.domElement 转化成内部表现形式（config 可以包模块的加载函数）。在 singleSpa.mountRootParcel、singleSpa.mountParcel 调用期间，single-spa 会加载包模块，并为内部表现形式添加 name、bootstrap、mount、update、unmount、timeouts 等属性，并返回 { mount, unmount, getStatus, loadPromise, bootstrapPromise, mountPromise, unmountPromise } 对象，用于手动挂载或卸载包。 特别注意，singleSpa.mountRootParcel 将包挂在顶部；singleSpa.mountParcel 一般以应用的 props.mountParcel 形式使用，也即作为应用下的包，其将会随着应用的销毁而销毁。 从总体层面看，包加载、卸载的机制与应用相同，只是多了一个 update 生命周期，以及包的存活空间限制、包需要手动渲染。 single-spa-reactsingle-spa-react 便于 react 应用快速对接 single-app。 singleSpaReact(opts) 函数能指定顶层组件及其渲染位置、渲染方式，其返回内容可作为应用或包脚本的 bootstrap、mount、unmount、update 导出。 123456789101112131415singleSpaReact(opts: &#123; React: React; ReactDOM: ReactDOM; rootComponent: React.Component;// 顶层组件，通过 React.createElement 加载元素 loadRootComponent: () =&gt; React.Component;// 顶层组件加载函数，与 rootComponent 选填一项即可 suppressComponentDidCatchWarning: boolean;// react16 以上版本，若 rootComponent 未实现 componentDidCatch 方法，予以警告 domElementGetter?: () =&gt; DOMElement;// 获取挂载节点，不填会创建 id 为 `single-spa-application:$&#123;appName&#125;` 的节点进行挂载 parcelCanUpdate: boolean;// 包是否可渲染 renderType?: 'createRoot' | 'createBlockingRoot' | 'hydrate';// 渲染方式，分别使用 ReactDOM.createRoot、ReactDOM.createBlockingRoot、ReactDOM.hydrate、ReactDOM.render 方法渲染&#125;): &#123; bootstrap: (props) =&gt; Promise;// 加载顶层组件脚本 mount: (props) =&gt; Promise;// 将顶层组件渲染到页面上 unmount: (props) =&gt; Promise;// 使用 ReactDOM.unmountComponentAtNode 移除顶层组件 update: (props) =&gt; Promise;// 指定 parcelCanUpdate 前提下，刷新 rootComponent&#125;; 特别的，当以 React.createContext 机制赋值 SingleSpaContext 导出时，single-spa-react 会为所有应用、包添加上下文容器 SingleSpaContext.Providev，其 value 值为 mount 生命周期的 props（包含 mountParcel 方法，指定在当前应用或包中渲染其他包）。 single-spa-react 额外提供了 Parcel 组件，其接受 props.config 为包的生命周期导出模块（即 singleSpaReact 函数返回值），默认会将包渲染到组件树中；当指定 props.appendTo 属性，则会将包渲染到 props.appendTo 元素上。渲染的前提是它能获得 SingleSpaContext 传递的 mountParcel 函数（即包挂载在应用或其他包的 rootComponent 下），否则需要开发者显式指定 props.mountParcel 方法。 后记造物必有迹可循，只是曲折的历史会把它打扮得较难领会。创造者不只创造为外部所用的产物，还有对内部加倍透明的历史。如果只是使用，不是创造，何必知晓历史之古。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"DatePicker","slug":"frontend/antd/DatePicker","date":"2020-02-12T16:00:00.000Z","updated":"2020-03-08T10:35:18.564Z","comments":true,"path":"2020/02/13/frontend/antd/DatePicker/","link":"","permalink":"http://xzfyu.com/2020/02/13/frontend/antd/DatePicker/","excerpt":"","text":"新版的 DatePicker 基于 react-hooks 制作，让我们一步步揭开它的面纱。 DatePicker 分为 Picker 单值选择器、RangePicker 范围选择器两类。 公共模块除了时间处理模块可切换使用 day.js 或 moment 以外。Picker、RangePicker 复用了以下三个组件： PickerTrigger: 抽象了弹层展示逻辑的组件，基于 rc-trigger 制作，可设置 PickerPanel 的样式和对齐位置等。 PanelContext: 传递给 PickerPanel 的 context 内容包含 operationRef 面板操作的 ref 值、hideHeader 是否隐藏头部、panelRef 存储面板的 dom 元素、hidePrevBtn、hideNextBtn、onDateMouseEnter、onDateMouseLeave、onSelect 拣选日期时间后回调、hideRanges、open 面板展开状态、defaultOpenValue 面板默认值。 PickerPanel: 作为弹层内容的公共容器，向上对接 Picker、RangePicker，获得 panelContext、rangeContext；向下对接实际面板 DecadePanel、YearPanel、MonthPanel、WeekPanel、DatePanel、DatetimePanel、TimePanel 等组件。 PickerTrigger、PanelContext 不作介绍。以下仅介绍 PickerPanel。 PickerPanel 以 DatePanel 为例，面板既可选择时间，又可切换展示模式（切换为年面板或月面板）。因此，PickerPanel 内置了四种状态值：innerMode 用于记录面板当前的模式（由模式获得实际的展示面板）；sourceMode 用于记录面板之前的模式；mergedValue 用于存储面板的选中值；viewDate 用于存储当前面板的展示值。 当 DatePanel 等实际面板调用 props.onPanelChange 时，就会执行 PickerPanel 中的 onInternalPanelChange 方法，切换 innerMode 面板模式，并记录历史值 sourceMode，并将时间值和面板模式传递给外围。 当 DatePanel 等实际面板调用 props.onSelect 时，就会执行 PickerPanel 中的 setViewDate、triggerSelect 方法，同步更新 mergedValue、viewDate，并将时间值传递给外围。 PickerPanel 通过赋值 operationRef.current 属性，允许上游的 Picker、RangePicker 组件间接调用实际面板的 onKeyDown、onClose 方法。 PickerPanel 额外负责绘制面板尾部内容。 DatePanel实际面板仅以 DatePanel 举例说明。 DatePanel 面板中 Header 头部使用公共的组件。通过传递 props.onSuperPrev、props.onPrev、props.onNext、props.onSuperNext 控制 Header 头部是否显示上、下一步等按钮。Header 头部文本通过格式化 viewDate 计算获得。 DatePanel 面板中 DateBody 内容基于 viewDate 计算起始日期，然后步进计算展示单元内容。每个单元都会与对应的日期挂钩，点击时会调用 props.onSelect 方法将日期透出外围。 PickerPicker 主要负责组织顶层逻辑、渲染实际的触发器。触发器为 input 输入框，可以包含后缀图标、clearNode 清除图标。 作为顶层容器，Picker 包含四种状态：mergedValue 记录受控模式下的外部传入值以及日期选择器的最终值；selectedValue 记录由 PickerPanel、input、clearNode 引起的动态变更值（表现值），初始值与 mergedValue 等值；text 记录输入框中的展示值，通过 selectedValue 格式化处理后获得；mergedOpen 记录 PickerPanel 的展开折叠状态。 selectedValue 初始值与 mergedValue 等值。当 mergedValue 变更或 mergedOpen 变更为否值时，selectedValue 将被刷新为 mergedValue；PickerPanel、input、clearNode 都将刷新 selectedValue 以及 mergedValue。triggerChange(newValue) 即作为变更 selectedValue、mergedValue 的同一调用接口，它会将选中的时间值以及格式化后的时间值传递给外围。PickerPanel 变更面板表现值时，将调用 triggerOpen(newOpen, preventChangeEvent) 负责变更 mergedOpen。若 newOpen、preventChangeEvent 同时为否值，triggerOpen 内部会调用 triggerChange 更新选中值。 input 与 Picker 的对接较为复杂，需要支持的交互行为包含：鼠标点击时获得焦点并展示 PickerPanel；一般按键时展示 PickerPanel，直到按键结束时调用 triggerChange（Tab 按键行为可传递给 PickerPanel）；失焦时隐藏 PickerPanel，（如果点击发生在输入框外围）调用 setSelectedValue 将 selectedValue 更新为 mergedValue，重新计算输入框展示值。以下为其源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148const [inputProps, &#123; focused, typing &#125;] = usePickerInput(&#123; blurToCancel: needConfirmButton, open: mergedOpen, triggerOpen, forwardKeyDown, isClickOutside: target =&gt; !elementsContains( [panelDivRef.current, inputDivRef.current], target as HTMLElement, ), onSubmit: () =&gt; &#123; triggerChange(selectedValue); triggerOpen(false, true); resetText(); &#125;, onCancel: () =&gt; &#123; triggerOpen(false, true); setSelectedValue(mergedValue); resetText(); &#125;, onFocus, onBlur,&#125;);function usePickerInput(&#123; open, isClickOutside, triggerOpen, forwardKeyDown, blurToCancel, onSubmit, onCancel, onFocus, onBlur,&#125;: &#123; open: boolean; isClickOutside: (clickElement: EventTarget | null) =&gt; boolean; triggerOpen: (open: boolean) =&gt; void; forwardKeyDown: (e: React.KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; boolean; blurToCancel?: boolean; onSubmit: () =&gt; void; onCancel: () =&gt; void; onFocus?: React.FocusEventHandler&lt;HTMLInputElement&gt;; onBlur?: React.FocusEventHandler&lt;HTMLInputElement&gt;;&#125;): [ React.DOMAttributes&lt;HTMLInputElement&gt;, &#123; focused: boolean; typing: boolean &#125;,] &#123; const [typing, setTyping] = React.useState(false); const [focused, setFocused] = React.useState(false); const preventBlurRef = React.useRef&lt;boolean&gt;(false); const inputProps: React.DOMAttributes&lt;HTMLInputElement&gt; = &#123; onMouseDown: () =&gt; &#123; setTyping(true); triggerOpen(true); &#125;, onKeyDown: e =&gt; &#123; switch (e.which) &#123; case KeyCode.ENTER: &#123; if (!open) &#123; triggerOpen(true); &#125; else &#123; onSubmit(); setTyping(true); &#125; e.preventDefault(); return; &#125; case KeyCode.TAB: &#123; if (typing &amp;&amp; open &amp;&amp; !e.shiftKey) &#123; setTyping(false); e.preventDefault(); &#125; else if (!typing &amp;&amp; open) &#123; if (!forwardKeyDown(e) &amp;&amp; e.shiftKey) &#123; setTyping(true); e.preventDefault(); &#125; &#125; return; &#125; case KeyCode.ESC: &#123; setTyping(true); onCancel(); return; &#125; &#125; if (!open &amp;&amp; ![KeyCode.SHIFT].includes(e.which)) &#123; triggerOpen(true); &#125; else if (!typing) &#123; forwardKeyDown(e); &#125; &#125;, onFocus: e =&gt; &#123; setTyping(true); setFocused(true); if (onFocus) &#123; onFocus(e); &#125; &#125;, onBlur: e =&gt; &#123; if (preventBlurRef.current || !isClickOutside(document.activeElement)) &#123; preventBlurRef.current = false; return; &#125; if (blurToCancel) &#123; setTimeout(() =&gt; &#123; if (isClickOutside(document.activeElement)) &#123; onCancel(); &#125; &#125;, 0); &#125; else &#123; triggerOpen(false); &#125; setFocused(false); if (onBlur) &#123; onBlur(e); &#125; &#125;, &#125;; React.useEffect(() =&gt; addGlobalMouseDownEvent((&#123; target &#125;: MouseEvent) =&gt; &#123; if (open) &#123; if (!isClickOutside(target)) &#123; preventBlurRef.current = true; window.setTimeout(() =&gt; &#123; preventBlurRef.current = false; &#125;, 0); &#125; else if (!focused) &#123; triggerOpen(false); &#125; &#125; &#125;), ); return [inputProps, &#123; focused, typing &#125;];&#125; RangePickerRangePicker 包含以下内部状态：activePickerIndex 当前激活的面板；mergedValue 实际值；selectedValue 选中的时间（可能包含不可选的时间）；mergedDisabled、disabledStartDate、disabledEndDate 不可选时间；rangeHoverValue 选中值范围；hoverRangedValue 鼠标悬浮选中范围；mergedModes 面板模式；mergedOpen 面板展开折叠状态。状态或方法会经由 RangeContext、PanelContext 传递给下游的实际面板 DatePanel 等。此处不作详解。 后记因笔者精力有限，这篇文章仅点到为止，以备查用。个中不足处，还望包涵。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"前端规范","slug":"frontend/architecture/前端规范","date":"2020-02-07T16:00:00.000Z","updated":"2020-03-08T10:42:40.983Z","comments":true,"path":"2020/02/08/frontend/architecture/前端规范/","link":"","permalink":"http://xzfyu.com/2020/02/08/frontend/architecture/前端规范/","excerpt":"","text":"git123456cnpm install -g commitizen # cli 工具cnpm install -g conventional-changelog # 基于 commit message 生成 change logcnpm install validate-commit-msg --save-dev # 检查项目的 commit message 是否符合 Angular 规范。基于 husky 添加配置 package.json#scripts -&gt; \"commitmsg\": \"validate-commit-msg\"commitizen init cz-conventional-changelog --save --save-exact # 项目目录，支持 Angular 的 commit message 格式git cz # 提交 commit message，替代 git commitconventional-changelog -p angular -i CHANGELOG.md -w # 生成 change log 参考git commit 规范指南","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"钉钉对接启示录","slug":"踩坑/钉钉对接启示录","date":"2020-02-04T16:00:00.000Z","updated":"2020-03-14T16:27:55.035Z","comments":true,"path":"2020/02/05/踩坑/钉钉对接启示录/","link":"","permalink":"http://xzfyu.com/2020/02/05/踩坑/钉钉对接启示录/","excerpt":"","text":"前端部分须安装 dingtalk-jsapi。 内部应用免登钉钉免登总流程： 使用 dingtalk-jsapi 获取免登授权码 auth_code。 通过应用的唯一标识 appkey 和应用密钥 appsecret 获取 access_token。 通过 auth_code 和 access_token 获取 userid。 通过 userid 和 access_token 获取 userinfo。 前端流程： 获取 auth_code。 auth_code 发送到后台，换区 userinfo。 123456789dd.runtime.permission.requestAuthCode(&#123; corpId, // 企业ID onSuccess(result) &#123; console.log(result); &#125;, onFail(error) &#123; console.log(error); &#125;,&#125;); 鉴权钉钉总流程： 通过应用的唯一标识 appkey 和应用密钥 appsecret 获取 access_token。 根据 access_token 获取 jsapi_ticket。 根据 jsapi_ticket, 随机串 nonceStr, 时间戳 timeStamp, 页面 url 计算签名 signature。 根据 随机串 nonceStr，应用标识 agentId，时间戳 timeStamp，企业ID corpId，签名 signature 进行鉴权（调用 dd.config）。 鉴权后，可调用 dingtalk-jsapi 中的方法。 1234567891011121314151617dd.config(&#123; agentId: '', // 必填，微应用ID corpId: '',//必填，企业ID timeStamp: '', // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '', // 必填，签名 type: 0, // 选填。0表示微应用的jsapi,1表示服务窗的jsapi；不填默认为0 jsApiList: [ 'runtime.info', 'biz.contact.choose',// 鉴权后可调用 'device.notification.confirm', 'device.notification.alert', 'device.notification.prompt', 'biz.ding.post', 'biz.util.openLink', ]// 必填，需要使用的jsapi列表，注意：不要带dd。&#125;); 钉钉机器人对接可使用 dingtalk-robot-sender 发送钉钉机器人消息。消息展示可参考钉钉官方文档，调用方式可参考 bot.js。须注意，当发送的数据内容不符合钉钉消息格式时（如 link 消息缺失 text），响应不会报错。","categories":[{"name":"踩坑","slug":"踩坑","permalink":"http://xzfyu.com/categories/踩坑/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"maven","slug":"backend/java 工程/maven","date":"2020-02-03T16:00:00.000Z","updated":"2020-03-08T11:25:34.213Z","comments":true,"path":"2020/02/04/backend/java 工程/maven/","link":"","permalink":"http://xzfyu.com/2020/02/04/backend/java 工程/maven/","excerpt":"","text":"maven 使用 pom.xml 文件声明依赖；jar 包资源使用 groupId、artifactId、version 定位。maven 下载依赖会先从本地找起，然后私服镜像，最后是 maven 官方的中央仓库。 maven 命令（maven 项目的根目录下执行）如下： mvn compile –src/main/java 编译生成 class（target 目录下） mvn test –src/test/java 编译 mvn clean 删除 target 目录 mvn package 生成压缩文件，java 项目 jar 包，web 项目 war 包（target 目录下） mvn install 将压缩文件（jar 或 war 包）上传到本地仓库 mvn deploy 将压缩文件上传私服 mvn eclipse:eclipse 将 maven java 或 web 项目转成 eclipse 工程 mvn eclipse:clean 清除 eclipse 配置，将 eclipse 工程转成 maven 项目 mvn idea:idea 将 maven java 或 web 项目转成 idea 工程 mvn idea:clean 清除 idea 配置，将 idea 工程转成 maven 项目 idea 配置 maven 下载 apache-maven。 配置 maven 环境变量。 配置 setting.xml 配置，添加 maven 镜像。 修改 idea 配置（通过 setting 面板），应用本地 maven 和 setting.xml。 idea 操作 reimport 导入依赖、 参考maven 到底是个啥玩意maven生命周期","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"java 工程","slug":"backend/java-工程","permalink":"http://xzfyu.com/categories/backend/java-工程/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"}]},{"title":"感悟","slug":"随笔/感悟","date":"2020-01-30T16:00:00.000Z","updated":"2020-03-08T11:36:52.686Z","comments":true,"path":"2020/01/31/随笔/感悟/","link":"","permalink":"http://xzfyu.com/2020/01/31/随笔/感悟/","excerpt":"","text":"清晰的定义有人认为，好的电影可以用一句话概括它所要表达的主题。与此相类，为产品下一个有效的定义能使我们足够聚焦于解决问题的本质，滤除细节上的干扰。 生命周期的视角取舍俗话说，“不以结婚为目的的恋爱都是耍流氓”。事实证明，在工作环境上，技术产物的试金石是，能否高效地解决业务问题。刻意追求技术手段的自主或高明，脱离解决业务问题这个导向标，都是多余的奇技淫巧。这话同样适用于纯技术产物。切回电影这个上下文，能表达同一个意思的说法是：工业化的好莱坞不是新浪潮电影的发祥地；好莱坞也不会给拍摄决斗时的斯皮尔伯格拉排场。工程师不是名声在望的艺术家，他为组织提供合适的技术方案及实现。最好的也许是科学的，但未必是合适的；合适的也许不够科学，却能有效地解决问题。 愿景简单地说，科学是有条理、可验证地表达观点或方法，因此它需要完善闭环流程。但是在企业环境中，光是有限的开发时间这一项就会让我们不得不退而取其次 —— 置于首位的照常是功能实现，而富有远见的规划布景、良好的验收流程总被弃之一边。为此，好的定义可以是指引明媚前路的愿景，不只是崎岖山路上的一种妥协。在艰难开拓的早期，不够优雅的实现往往屈从于技术、时间、人力、环境等要素的制约，但这只是阶段性产物的特征。毕竟市场也有狂热趋于理性的一面，以规划为基石的愿景不至于使我们最终选择在粗制滥造面前缴械。 战略像人类有自我纠错、自我完善的动力，有责任的建设者会为产品赋予生命，他们会在已成型的产品中寻找待解决的问题、寻找演进的策略，直到另一张高维度的画布使它最终变得无从发挥。技术产品的淘汰尤其如此。“吾尝终日不食，终夜不寝，以思，无益，不如学也。” 战略需要跨域，非到高维度的视角最难揣摩，到了高维度的视角也最容易领会。实体经济转向网商经济在今天是耳熟能详的事情，马老师提出的“新制造” —— 将数字化物流的手段带入工业生产，即在于技术手段的可迁移性。遥远的未来是不可知的，懂得弃守舒适区也许是种好的态度。 以上三条的视点大体在于产品生命周期的短期、中长期和遥远的未来。 清晰的定义能设定问题的本源及边界， 限定问题域 限定解空间 参考阿里高级技术专家：整洁的应用架构“长”什么样？学阿里中台，80%的人只学到了皮毛！揭秘阿里中台的12个架构思维和原则2017双11交易系统TMF2.0技术揭秘，实现全链路管理跳开 DDD 和中台概念看阿里巴巴交易平台的问题及解决思路阿里技术大牛：一份架构师成神路线图！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://xzfyu.com/categories/随笔/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"spring cloud 踩点","slug":"backend/spring/spring cloud 踩点","date":"2020-01-30T16:00:00.000Z","updated":"2020-03-08T11:15:20.397Z","comments":true,"path":"2020/01/31/backend/spring/spring cloud 踩点/","link":"","permalink":"http://xzfyu.com/2020/01/31/backend/spring/spring cloud 踩点/","excerpt":"","text":"spring cloud 是一个基于 spring boot 的服务治理框架，它由众多服务治理组件构成： 注册中心：Erueka、Zookeeper、Consul 等用于注册、发现服务。 配置中心：Spring Cloud Config 提供分布式系统的配置管理功能（运行时更新配置文件需要 refresh 才能重新加载配置）。 网关（外部调用）：Zuul、Spring Cloud Gateway 为动态实例提供外部调用入口，可以基于横切关注点实现权限校验、监控指标、负载均衡等功能。 内部调用：OpenFeign 声明式 RESTful 网络请求客户端。 断路器：Hystrix 隔离调用 N 次失败的不可用服务，避免服务级联雪崩。Hystrix-dashboard 查看各 Hystrix Command 的请求响应时间，请求成功率等数据，只能查看单个应用的服务信息。Turbine 能查看系统内多个服务的调用数据。 负载均衡：Ribbon。 分布式消息：Spring Cloud Stream、Spring Cloud Bus。Spring Cloud Bus 可用于促使客户端重新拉取配置，即 Spring Cloud Config 相关配置文件提交到代码库时，webhook 通知 Spring Cloud Bus；由 Spring Cloud Bus 促使订阅消息的客户端重新从 ConfigServer 拉取配置。 安全控件：Spring Cloud Security 基于 OAuth2.0 的安全控件。 链路监控：Zipkin、Dapper、Eagleeye、Spring Cloud Sleuth 通过数据埋点监控微服务性能及调用链路。 spring cloud 公共库spring cloud 上下文spring cloud 有两个上下文：application.yml 应用上下文、bootstrap.yml 引导上下文。依据 spring 层级上下文机制，引导上下文作为应用上下文的父级，具有较低的优先级。 参考基于 Spring Cloud 的分布式架构体系Spring Cloud 微服务架构学习笔记与示例深入理解 Spring Cloud 引导上下文","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"spring","slug":"backend/spring","permalink":"http://xzfyu.com/categories/backend/spring/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"从 nacos 看领域驱动设计","slug":"backend/架构/从 nacos 看领域驱动设计","date":"2020-01-22T16:00:00.000Z","updated":"2020-03-08T11:18:50.270Z","comments":true,"path":"2020/01/23/backend/架构/从 nacos 看领域驱动设计/","link":"","permalink":"http://xzfyu.com/2020/01/23/backend/架构/从 nacos 看领域驱动设计/","excerpt":"","text":"按 Nacos 官网 的说法，它是一个提供便捷的服务发现、管理和配置平台。推敲 Nacos 的出产，首先它基于问题域思考所需实现的功能特性和非功能特性；再由特性思忖到逻辑架构图、领域模型、部署架构图、类视图等架构层面；再结合特性和架构图深入业务场景，完善功能实现策略；然后从开发生态这个宏观视角寻味 Nacos 需要支持的语言、技术栈；最后从市场投放这个目标视角总结 Nacos 的各种优势，并予以战略上的肯定。可以推想，Nacos 基于领域模型设计，比领域模型走得更远。 一句话需求Nacos 充当微服务中的注册中心和配置中心。 当巨石项目被切割成多个支持动态扩展的微服务后，各个微服务的调用地址和数量都是动态可变的，注册中心的核心功能就是维护可调用的服务清单。遵循 C/S 架构，server 服务器维护着 client 可调用服务清单，并提供接口给 client 以查询其他服务信息；client 客户端一方面会将自己注册到 server 上，另一方面会从 server 上获取依赖的其他服务信息。常见的注册中心有 Eureka、Zookeeper、Consul、Dubbo。应用在不同环境中会有不同的配置，配置中心的目的即在于提供不同的配置能力。常见的配置中心有 spring cloud config、Apollo、Disconf、Diamond。 领域模型注册中心注册中心基于以下概念：Service 服务、Service Provider 服务提供者、Service Consumer 服务消费者、Service Metadata 服务元数据、Service Registry 服务注册中心。由服务提供者提供服务、实例和元数据信息，并将这些内容添加到注册中心，再由服务消费者查询消费。服务下割集群，集群下挂载指定 ip、port 的实例（实例默认挂载在默认集群下，也可以创建虚拟集群管理实例）；服务上设分组。元数据包含服务端点、服务标签、服务版本号、服务实例权重、路由规则、安全策略等。Nacos 会对实例进行健康检查；当健康的实例占服务总实例比重小于指定阈值时，Nacos 将不会应用实例权重和路由规则，而是将可能不健康的实例推送给消费者。Nacos 团队在 Nacos服务发现控制台预览 2018.10.2 这篇文章中点明了服务 - 集群 - 实例模型的界面设计。下图是包含模型结构和主要功能的领域模型。 配置中心配置中心基于以下概念：Configuration 配置、Configuration Management 配置管理。配置中心的主要功能在于管理应用所需的配置。单条配置（如日志级别）构成一个配置项；多个配置项通过配置集统筹；一个配置集通过配置集 id 定位；配置集上设分组，以便多个应用使用相同的配置集。对于配置管理，Nacos 还提供或规划了灰度发布、版本管理、快速回滚、监听查询、推送轨迹、权限控制、敏感配置的加密存储等功能。当配置被 client 拉取到时，Nacos 的客户端 SDK 会在本地生成配置快照，以作容灾处理；配置快照会在特定时间进行更新，但不会过期。[Nacos 帮我们解决什么问题？—— 配置管理篇] 这篇文章道明了配置中心的存在价值，上文也有简要说明。下图是包含模型结构和主要功能的领域模型。 命名空间namespace 命名空间用于区分不同租户和不同环境。命名空间下挂服务分组、配置分组。默认的命名空间为 public，分组默认是 DEFAULT_GROUP。Nacos 控制台可以添加新的命名空间，随后在 client 中即可配置命名空间的 id（id 须经解析以获得实际的命名空间名，然后从 server 中获得配置），指定服务所属哪个命名空间或服务使用哪个命名空间的配置。Namespace, endpoint 最佳实践 描述着命名空间的设计背景和方案。下图是命名空间的模型结构。 逻辑流程上节所能感知的是 Nacos 控制台的界面形式（实现了什么），但不能感知 Nacos 的内部（怎么实现的）。本节结合下一节，所要表述的是 Nacos 是怎么实现。本节仅介绍注册中心的逻辑流程。 注册中心的功能分为两部分：服务注册、服务发现。下图下半部分即服务注册的流程，标名的客户端作为服务提供者将自己注册到 Nacos，Nacos 注册中心即会生成对应的一份实例配置；服务注册成功后，服务提供者与注册中心维持心跳，以保证将最新的服务信息推送到注册中心。上半部分即服务发现的流程，其一标名的客户端作为服务消费者可以从注册中心主动获取服务实例信息；其二消费者可以订阅注册中心的服务，那样会在客户端本地维护一份服务列表（通过事件机制予以更新），客户端从本地获取服务实例信息。Nacos 服务注册与发现原理分析 这篇文章道明了服务注册与发现的主流程。 Nacos 注册中心的设计原理详解 这篇文章道明了 Nacos 在数据隔离、数据一致性（多注册中心的前提下）、负载均衡、健康检查、集群扩展性上的设计原理。 整体架构 在 nacos-core 核心中，与上文相关的模块有： 插件机制：实现服务管理、配置管理、元数据管理三个模块可分可合能力，实现扩展点 SPI 服务提供发现机制。 事件机制：实现异步化事件通知，sdk 数据变化异步通知等逻辑。 回调机制：sdk 通知数据，通过统一的模式回调用户处理。接口和数据结构需要具备可扩展性。 推送通道：解决 server 与存储、server 间、server 与 sdk 间推送性能问题。 寻址模式：解决 ip、域名、nameserver、广播等多种寻址模式，需要可扩展。 流量管理：按照租户，分组等多个维度对请求频率，长链接个数，报文大小，请求流控进行控制。 这些核心模块撑起了上文所说的功能模块的逻辑流程。 在接口层之上、数据层之下，是 Nacos 所要支持的生态。 阿里巴巴服务注册中心产品ConfigServer 10年技术发展回顾 这篇文章道明了 Nacos 的前世今生，各阶段致力于解决的问题。Nacos 规划 简述了 Nacos 今后的发展。 后记项目使用了 Nacos，我发现在了解 Nacos 的过程中，最有意思的是探究其破土出芽的过程。虽然这一过程有点自不量力，很多东西都不能消化吸收，但是却能助我看见领域驱动设计的应用。正好最近在看《领域驱动设计 —— 软件核心复杂性的应对之道》，工作中也在接触一个探索型项目，总结一套可交流的建模语言、构建产品的一般流程很有价值似的。通过上述文字，我所能领会到的构建产品的一般流程为： 一句话描述需求，阐明核心功能模块。 构造领域模型，剖析核心流程。 统筹整体架构，宏观上挖掘生态、市场。 分解功能模块，分工、规划、细化。 我觉得这样的流程可以应用工程实践上。整理这篇文章的目的大概在于此吧。至于“细节处见真章”方面，还真是让人愧不自啊。而 Nacos 在 spring 项目中的应用，可以参考官方文档 Nacos Spring Cloud 快速开始，这里不作说明。 参考Nacos 官网Nacos 服务注册与发现原理分析Nacos 注册中心的设计原理详解Nacos 环境隔离Nacos Sync 的设计原理和规划Nacos 权限控制设计方案","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"架构","slug":"backend/架构","permalink":"http://xzfyu.com/categories/backend/架构/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"异步消息","slug":"backend/异步消息/异步消息","date":"2020-01-20T16:00:00.000Z","updated":"2020-03-08T11:22:09.647Z","comments":true,"path":"2020/01/21/backend/异步消息/异步消息/","link":"","permalink":"http://xzfyu.com/2020/01/21/backend/异步消息/异步消息/","excerpt":"","text":"使用 RMI、Hession、Burlap、Http invoker、web 服务等的同步消息需要等待阻塞任务完成，才能运行其他程序。同时，在同步消息模式下，接受消息的客户端与远程服务耦合：客户端需要远程服务接口的变更而变更；客户端需要感知远程服务的网络地址；客户端会随着远程服务的不可用而不可用。异步消息是无阻塞的，且不会造成消息发送者和接受者的强耦合。异步消息通常基于 message broker 消息代理实现，通过代理将消息投放到 destination 目的地。在这过程中，消息发送者会被解析出来，可以处理其他任务。异步消息一般用于四种场景：异步处理（如注册账户后发送邮件）、应用解耦（如下单业务中库存系统通过 MQ 与订单系统关联）、流量削峰（如秒杀系统先将前端消息存入 MQ）、日志处理（如 kafka 缓存采集日志）。 消息代理常见的消息代理有 ActiveMQ、RabbitMQ、Kafka、RocketMQ、ZeroMQ，它们也称为消息中间件。 ActiveMQActiveMQ 使用 Java 语言编写，遵循 JMS 规范。它支持两种消息模型：点对点模型（即队列）、发布/订阅模型（主题）。在这两种模型中，消息发送者均不会关心消息最终会被那个接受者取走。点对点模型可以有多个接受者（通过轮询依次发送向接受者发送消息），因为不知道存储在队列中的消息会被哪个接受者取走，也就意味着接受者必须有相同的实现。发布/订阅模型会将消息发送到一个主题下，订阅该主题的接受者都会接受到消息。ActiveMQ 只支持 KahaDB message store、AMQ message store、JDBC message store、Memory message store 等少量的存储器，不支持 hadoop、hdfs、hbase 等分布式系统。 JMS（Java Message Service） 规范定义了使用消息代理的通用接口，其意义类似于 JDBC。 spring 抽象了 JmsTemplate 模板。在配置类中以 ConnectionFactory 为参数，创建 JmsTemplate 实例，并作为 bean 装填在上下文中。应用中即可使用 jmsOperations.send、jmsOperations.receive 收发消息，且可对消息进行转换。spring 又提供了消息驱动的 POJO，允许以消息监听器的形式调用这个 bean 中的方法。详情可以参考 《spring 实战》。 RabbitMQRabbitMQ 使用 Erlang 语言编写，遵循 AMQP 高级消息队列协议（Advanced Message Queuing Protocol）（一个网络协议）。在 AMQP 协议中，发布者发送的消息会经由交换机转交给消息队列（基于路由规则转发消息），最终消息会被订阅了该消息队列的消费者获取或者主动推送给消息者。此处队列可视为消息通道。交换机有多种类型，并且一个消息队列会和一个交换机进行绑定（同一个交换机可以绑定多个消息队列），再由交换机路由到特定的消息队列中。有直连交换机，通过指定路由键将消息推送到消息队列上；有扇型交换机，将消息广播到与交换机绑定的所有消息队列上；有主题交换机，主题键允许模糊匹配；头交换机，作为路由策略的头属性值可以是整数或字典等。消息队列有两种：持久化队列能将消息固化到磁盘中；暂存队列在消息使用完成后会被销毁。为了避免丢包现象，AMQP 允许使用消息确认机制，在消费者输送确认回执后，才将消息从队列中删除。 AMQP 是一个线路层级的协议，指定消息的格式，这样消息就能跨 AMQP 实现以及跨语言和平台；JMS 只是一个 API 规范。spring AMQP 抽象了 RabbitTemplate 模板用于收发消息。在 spring boot 项目中发送消息时，首先需要在配置类中装配队列、交换机，并将队列和交换机进行绑定；然后通过自动装配的 RabbitTemplate#convertAndSend 发送消息。接受消息既可以通过 RabbitTemplate#receive 或 AMQP POJO，又可以通过 @RabbitListener 注解实现。详情可以参看 Springboot 整合 RabbitMQ。 KafkaKafka 依赖 Zookeeper 注册中心协调生产者和消费者。它自有一套协议，使用 pull 模式处理消息，追求高吞吐量，不支持事务，适合数据采集作业，可视为一个日志系统。消息按主题发送，每个主题可以有多个分区，对应的消息者也以 ConsumerGroup 组合呈现。一个组合下的消费者可以读取多个主题分区，但是一个主题分区在同一个消费者组合中只能被一个消费者处理。kafka 队列中的内容按策略存储一定时间，消费者可以指定偏移量来读取数据，即下次可以接着上次内容后读取。 RocketMQRocketMQ 是阿里开源的消息中间件，前身是 MetaQ，今生是 Aliware MQ（可参考 MetaMQ RocketMQ的前世今生）。它使用 Java 编程，具有高吞吐量、高可用性、适合大规模分布式系统应用等特点。在阿里内部，它被广泛用于交易、充值等业务系统，以及日志流式处理、binglog 分发等数据采集场景。RocketMQ 以 name server 作为注册中心，broker 代理采用主从模式部署，无论 producer 还是 consumer 都会通过发送心跳包的方式从 name server 中读写信息。 RocketMQ 的最大特点是支持分布式事务。首先 RocketMQ 支持事务性消息，即该消息在抵达 consumer 时能保证其与 producer 有相同的数据一致性，实现上是等待 producer 执行完成，consumer 才进行 db 操作。事务开始阶段，producer 会发送半消息给 MQ，执行成功时发送 Commit 全消息或 Rollback 回滚消息。MQ 接受 Commit 全消息时，将消息推送给 consumer；MQ 接受 Rollback 回滚消息时，隔三天删除消息；如果因为网络问题导致 MQ 接受到 Commit 全消息或 Rollback 回滚消息，调用 MQ 的事务状态服务询问 producer 事务执行状态，条件提交或回滚。 其次，若一个主业务系统的操作会通过异步消息引起多个辅业务系统的 db 操作，那么在常规的异步消息之外，RocketMQ 会在这一系列业务操作的预期执行时间之后再发送一个异步消息，以便创建一个用于回滚的任务。该任务会询问主业务系统的事务执行状态，若失败，进一步促使辅业务系统执行回滚操作。 在 spring boot 中使用 RocketMQ 可参考 rocketmq-spring-boot-samples。 ZeroMQZeroMQ 在 socket 之上、MQ 之下，它更是一个处理消息传输的库，适用于作为分布式系统的消息通信工具。 参考深入理解 AMQP 协议MQ概览：ActiveMQ，Kafka，MetaMQ，RocketMQ 消息中间件应用场景关于消息队列的使用—-ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQactivemq、rabbitmq、kafka 原理和比较Java 消息服务-JMSRabbitMQ 指南RabbitMQ基础概念详细介绍MetaMQ 架构原理Rocketmq 原理&amp;最佳实践Aliware-MQ 技术架构与最佳实践分布式事务(3)—RocketMQ实现分布式事务原理","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"异步消息","slug":"backend/异步消息","permalink":"http://xzfyu.com/categories/backend/异步消息/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"数据技术","slug":"数据技术/数据技术","date":"2020-01-17T16:00:00.000Z","updated":"2020-03-08T11:31:52.968Z","comments":true,"path":"2020/01/18/数据技术/数据技术/","link":"","permalink":"http://xzfyu.com/2020/01/18/数据技术/数据技术/","excerpt":"","text":"数据仓库（Data Warehouse）是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。 OLTP：On-Line Transaction Processing，联机事务处理，辅助业务操作，用于产生数据。OLTP 能将源数据即时传送到计算中心进行处理，并在短时间内给出结果。 OLAP：On-Line Analytical Processing，联机分析处理，辅助决策分析，用于分析数据。 ETL：Extract-Transform-Load，数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。 上图为数据仓库架构发展过程中的第二阶段 —— Lambda 架构。第三阶段 Kappa 架构借助 Flink 等实时流处理引擎，移除了离线批处理 etl 任务。数据仓库构架的发展过程可以参看 数据仓库介绍与实时数仓案例。 ODS：OperationalData Store，操作数据层，保存从业务系统或埋点系统采集过来的原始数据。 DWD：Data Warehouse Detail，明细数据层，根据主题定义好事实与维度表，保存最细粒度的事实数据。该层数据的生产作业包含：字段名、枚举等数据标准统一；数据脱敏，专门建设敏感数据库存储敏感数据；分库分表等多源数据整合；数据模型统基于业务流程建模。 DWS：Data Warehouse Summary，汇总数据层，在 DWD 层基础上根据不同的业务需求分主题轻度汇总。DWS 层可拆分为 DWB 轻度汇总数据和 DWS 重度汇总数据。 DM：Data Market，数据集市层，主要为业务需求提供服务，其包含应用产品所需数据、需求报表、指标等，DM 层还可为业务部门创建专用数据库以及数据探索库。 下图为阿里大数据系统的架构图： 数据同步数据同步的方式： 直连同步：通过 ODBC、JDBC 等标准接口将源系统的数据导入到目标系统，对业务系统的性能影响较大（虽然业务系统可以采用主备分离的模式）。 数据文件同步：通过 FTP 服务器将源系统的数据导入到目标系统。为避免丢包或传输错误，业务系统一般还会发送校验文件，并对数据增加压缩和加密功能。 数据库日志解析同步：在操作系统层面获取归档日志，将其解析到目标文件数据文件中，可用于增量更新。日志解析同步需要部署一个 agent 系统从源系统抽取数据。该同步机制会导致增量更新的数据丢失调凌晨附近的数据，即数据飘逸和遗漏。 DataX阿里内部使用 DataX 作离线数据同步。它能实现包括 MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS 等各种异构数据源之间高效的数据同步功能。DataX 面对的主要问题是，从源系统到数仓或从数仓到目标系统，数据流进各个系统时的格式并不统一，因此 Datax 需要将数据转换成格式统一的中间状态。 DataX 采用 Framework + Plugin 开放式架构实现。Plugin 用于转换不同数据库或文件系统的数据格式，包含 ReadPlugin、WritePlugin 两类，作为 Reader 数据采集模块和 Writer 数据写入模块的实现内容。Framework 将数据同步作业拆分成多个子任务，并处理缓冲、流程控制、并发、上下文加载等高速数据交换等技术问题，再通过 Chanel 交换 Reader、Writer 的数据。 更多内容可参考 DataX3.0 简介。 TimeTunnel阿里内部使用 TimeTunnel 作实时数据同步。它所实现的主要功能包含，通过消息订阅模式从源系统的 binlog 日志读取出增量数据，随后订阅数据的目标系统将读取这些数据。 TimeTunnel 是基于生产者、消费者和 Topic 消息标识实现的消息中间件。它通过 HBase 持久化消息数据。在下图的组件架构中：TTManager 负责对外提供队列申请、删除、查询和集群的管理接⼝；对内发现故障，发起队列迁移。Client 是一组访问接口，包含安全认证 api、发布 api 和订阅 api。Router 为 Client、Broker 提供路由服务，路由到 Broker 时须鉴权。Zookeeper 提供状态同步功能，存储 Client、Broker 的状态。Broker 负责消息队列的读写操作，承担实际的流量，它会从 HBase 取发数据。 更多内容可参考 淘宝实时数据传输平台: TimeTunnel介绍。 数据计算收集到原始数据后，数据还需要被整合和计算，才能发挥大数据的商业和业务价值。阿里为数据计算层提供了两大体系：MaxCompute 离线存储及计算平台、StreamCompute 实时计算平台。 MaxComputeMaxCompute 采用分布式计算模型，能满足 100GB 以上规模的存储及计算需求。它支持 SQL 查询、UDF 用户自定义函数、Java MapReduce 编程模型、Graph 图计算处理框架。 MaxCompute 由四部分组成：MaxCompute Client 客户端；MaxCompute Front End 接入层；MaxCompute Server 逻辑层；MaxCompute Core 存储与计算层。其中，客户端提供了 RESTful API、Java SDK、Command Line Tool、为 ETL/BI 提供的可视化 IDE 工具。接入层提供 HTTP 服务、缓存、负载均衡、用户认证等功能。逻辑层负责实现用户空间和对象的管理、命令的解析与执行逻辑、数据对象的访问控制和授权等功能。它有三种角色：Worker 对接 RESTful API、SQL 等，生成 MaxCompute Instance 并交由 Scheduler 处理；Scheduler 负责 MaxCompute Instance 的调度和拆解，询问计算层的资源占用情况；Exector 负责 MaxCompute Instance 的执行，向计算层提交计算任务。计算层即 Apsara Core 飞天内核，运行在和控制层相互独立的计算集群上，它包含 Pangu 分布式文件系统、Fuxi 资源调度系统、Nuwa 命名空间服务、Zhongkui 安全服务、Shennong 监控模块、Open Table Service 开放结构化数据服务（用于存储元数据）等。 更多内容可参考 阿里巴巴飞天大数据平台MaxCompute（原名ODPS）全套攻略、MaxCompute 2.0 生态开放之路及最新发展、MaxCompute 2.0 性能优化揭秘、MaxCompute，基于Serverless的高可靠大数据服务、阿里云大数据计算服务 - MaxCompute (原名 ODPS)、当我们用 MaxCompute 的时候，我们在用什么？。 实时计算数据时效性一般分为三种：延迟以天计算的离线数据、延迟以小时计算的准实时数据、延迟以秒计算的实时数据。离线数据和准实时数据都可以在批处理系统（如 Hadoop、MaxCompute、Spark 等系统）中实现；实时数据则需要流处理系统（如 Storm、S4、Spark Streaming、Flink、StreamCompute 等系统）来实现。区别于批处理系统周期性调度任务，流处理系统的任务是常驻的，并需要满足高时效性、高性能的要求。流处理系统不能完全替代批处理系统，因为它的计算成本加大，且需要解决复杂的业务逻辑（数据处理需要上下文关系，数据抵达时间的不确定性导致流处理系统可能获取不到前置数据）。 流处理系统所需要的数据可以通过 TimeTunnel、Kafka 等数据中间件或 MetaQ、Notify 等消息系统实现。其中，使用数据中间件能获得较高的吞吐量，一般用于应对数据量较大的业务系统；消息系统一般用作业务系统数据库变更的消息中转。 下图是 flink 的架构图： 更多内容可参考 什么是阿里云实时计算、Streaming System 第一章：Streaming 101、Flink架构及其工作原理。 数据服务阿里的数据开放服务经历了四个阶段：DWSOA、OpenAPI、SmartDQ 和 OneService。 DWSOA：烟囱式一个需求一个或者几个接口。 OpenApi：同类数据（如会员数据）合并成一张逻辑表，对外透出一个接口，通过接口参数定位具体数据。 SmartDQ：逻辑表的取数据逻辑通过 SQL （作为领域专用语言 DSL）描述，SmartDQ 通过解析 SQL、生成执行计划、执行 SQL、合并数据、限制结果，最终透出数据。 OneService：在 SmartDQ 基础上，满足不同场景的数据需求，OneService-SmartDQ 简单的查询场景、OneService-Lego 个性化业务场景、 OneService-iPush 实时数据推送场景、OneService-uTiming 定时任务场景。 在 SmartDQ 中，逻辑表通过多个数据源的物理表汇总而成，多个逻辑表挂在一个主题下。服务层主要包含两大模块：元数据配置维护物理表到逻辑表的映射；主处理模块会解析 DSL、构建逻辑 Query、构建物理 Query、拆分 Query、执行 SQL、合并结果。 参考《大数据之路——阿里巴巴大数据实践》数仓说说数仓大数据环境下数仓设计","categories":[{"name":"数据技术","slug":"数据技术","permalink":"http://xzfyu.com/categories/数据技术/"},{"name":"大数据","slug":"数据技术/大数据","permalink":"http://xzfyu.com/categories/数据技术/大数据/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"我看 spring beans","slug":"backend/spring/我看 spring beans","date":"2020-01-11T16:00:00.000Z","updated":"2020-03-08T11:15:56.685Z","comments":true,"path":"2020/01/12/backend/spring/我看 spring beans/","link":"","permalink":"http://xzfyu.com/2020/01/12/backend/spring/我看 spring beans/","excerpt":"","text":"先介绍两个重要的概念（详情可以参看 BeanFactory 和 FactoryBean 的区别）： BeanFactory：作为接口，定义了 Spring IOC 容器最底层的编程规范，职能包含实例化、定位、配置应用程序中的 bean 及建立 bean 之间的依赖。 FactoryBean：用于实例化 bean。Spring 有两种 bean：通过反射机制使用 class 创建的 bean，如添加了 @Component 注解的 bean；通过实现了 FactoryBean 接口的类创建 bean，在 FactoryBean#getObject 会创建所需要的类实例。 在 spring 中，应用上下文 ApplicationContext 在 refresh 方法执行期间，会创建 BeanFactory 实例并注册 BeanDefiniton（定义了 bean 的基础属性：scope 是否单例、lazyInit 是否懒加载等）；然后通过调用 BeanFactory#getBean 方法可以创建 bean。ApplicationContext#getBeanFactory 可用于获取 BeanFactory 实例；ApplicationContext#getBean 可用于获取 bean。 ApplicationContext作为应用上下文，ApplicationContext#refresh 执行过程既会创建 BeanFactory、注册 BeanDefiniton，又集成了国际化、事件广播机制。该接口有以下实现类： AnnotationConfigApplicationContext：从一或多个配置类中加载上下文定义，适用于 java 注解方式加载 bean ClassPathXmlApplicationContext：从类路径下的一或多个 xml 配置文件中加载上下文定义，适用于 xml 配置方式 FileSystemXmlApplicationContext：从文件系统下的一或多个 xml 配置文件中加载上下文定义 AnnotationConfigWebApplicationContext：专门为 web 应用准备的，适用于注解方式 XmlWebApplicationContext：从 web 应用下的一或多个xml配置文件加载上下文定义，适用于 xml 配置方式 以下是 AnnotationConfigApplicationContext 的使用情形： 1234567891011121314151617@Configurationpublic class ManConfig &#123; @Bean public Man man() &#123; return new Man(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 调用 ApplicationContext#refresh 方法，注册 BeanDefiniton ApplicationContext context = new AnnotationConfigApplicationContext(ManConfig.class); // 获取 bean Man man = context.getBean(Man.class); man.driveCar(); &#125;&#125; 实际上，在 AnnotationConfigApplicationContext 实例化过程中，即会调用 refresh 方法。对于非懒加载的 bean，refresh 方法执行期间即会予以加载。当然，在 AnnotationConfigApplicationContext 实例化过程中，它会扫描 basePackages 以便筛选出添加了 @Component 注解的类。refresh 源码见下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123; @Override public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 设置环境变量、容器开关和激活标志等 prepareRefresh(); // 调用子类实现的 refreshBeanFactory 方法创建 BeanFactory 实例，并加载 BeanDefiniton // BeanFactory 实例如 AbstractRefreshableApplicationContext 中的 DefaultListableBeanFactory 实例 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 配置 BeanFactory 所用的类加载器、bean 表达式解析器、属性编辑器等 prepareBeanFactory(beanFactory); try &#123; // 执行子类的 postProcessBeanFactory，可用于（通过应用的配置文件）修改 BeanDefiniton postProcessBeanFactory(beanFactory); // 执行 BeanFactoryPostProcessor#postProcessBeanFactory，可用于修改 BeanDefiniton invokeBeanFactoryPostProcessors(beanFactory); // 注册 bean 初始化钩子 BeanPostProcessor registerBeanPostProcessors(beanFactory); // 加载 MessageSource 这个特殊的 bean，用于国际化处理 initMessageSource(); // 初始化 ApplicationEventMulticaster 这个特殊的 bean，用于事件广播 initApplicationEventMulticaster(); // 执行子类的 onRefresh 方法，初始化特殊的 bean onRefresh(); // 加载 ApplicationListener（特殊的 bean 或通过上下文加载），执行 earlyApplicationEvents 前置事件 registerListeners(); // 加载 ConversionService 这个特殊的 bean // BeanFactory 添加 EmbeddedValueResolver，用于解析配置文件的属性 // 加载 LoadTimeWeaverAware 这个特殊的 bean，允许织入第三方模块，如 AspectJ // 将 BeanFactory 中的 TempClassLoader 置为 null，终止其工作 // 执行 BeanFactory#freezeConfiguration，冻结 BeanDefiniton // 执行 BeanFactory#preInstantiateSingletons，调用 getBean 方法提前加载无需懒加载的 bean finishBeanFactoryInitialization(beanFactory); // 完成刷新过程，发布应用事件 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; destroyBeans(); // 将容器激活标识置为否值 cancelRefresh(ex); throw ex; &#125; finally &#123; // 重置缓存，因为 bean 所用及的元数据将不必使用 resetCommonCaches(); &#125; &#125; &#125;&#125; BeanFactoryBeanFactory 接口的默认实现类的 DefaultListableBeanFactory。以下是相关类图： AbstractBeanFactory 类是 BeanFactory 接口的抽象实现类，在它的 getBean 方法执行期间，如果 bean 还没创建，它就会创建这个 bean；如果已经创建了这个 bean，并且这个 bean 是单例，spring 就会从缓存中获取这个 bean。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory &#123; @Override public Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false); &#125; protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123; final String beanName = transformedBeanName(name); Object bean; // 获取缓存的单例 bean Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isTraceEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName + \"' that is not fully initialized yet - a consequence of a circular reference\"); &#125; else &#123; logger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); &#125; &#125; // （完成 FactoryBean 相关处理，）获取 bean 实例 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 单例正在（循环引用）创建过程中，报错 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // 当 IOC 容器 BeanFactory 中不存在 BeanDefinition，向上查找祖先容器 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) &#123; return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); &#125; else if (args != null) &#123; return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else if (requiredType != null) &#123; return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; else &#123; return (T) parentBeanFactory.getBean(nameToLookup); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; // 合并祖先容器的 BeanDefinition final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 获取（或创建）依赖 bean String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); &#125; registerDependentBean(dep, beanName); try &#123; getBean(dep); &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex); &#125; &#125; &#125; // 创建单例 bean if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, () -&gt; &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; destroySingleton(beanName); throw ex; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; Object scopedInstance = scope.get(beanName, () -&gt; &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // 类型转换 if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType); if (convertedBean == null) &#123; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; return convertedBean; &#125; catch (TypeMismatchException ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(\"Failed to convert bean '\" + name + \"' to required type '\" + ClassUtils.getQualifiedName(requiredType) + \"'\", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean; &#125;&#125; 参考Spring 源码解析：高级容器的扩展内幕SpringBean 工作原理详解Spring-BeanFactory基本工作流程Spring 创建 bean 机制spring容器之创建bean实例使用 BeanPostProcessor 制作 ab 脚本的 bean使用BeanFactoryPostProcessor——这种姿势不要用postProcessBeanFactory方法分析Spring源码分析-MessageSourceApplicationEventMulticaster 事件广播Spring 事件机制初始化流程Spring源码finishBeanFactoryInitialization和getBeanSpring数据转换–ConversionServiceAOP静态代理-代码织入DetaultListableBeanFactory分层关系解析一","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"spring","slug":"backend/spring","permalink":"http://xzfyu.com/categories/backend/spring/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"我看 spring mvc","slug":"backend/spring/我看 spring mvc","date":"2020-01-03T16:00:00.000Z","updated":"2020-03-08T11:16:03.186Z","comments":true,"path":"2020/01/04/backend/spring/我看 spring mvc/","link":"","permalink":"http://xzfyu.com/2020/01/04/backend/spring/我看 spring mvc/","excerpt":"","text":"spring mvc 基于 前端控制器模式 设计，通过 DispatcherServlet 这个前端控制器将请求交给可配置的委托组件处理，这就能支持请求处理的灵活性。DispatcherServlet 中请求映射、视图解析、异常处理等功能所使用的组件都通过 spring 机制发现。 DispatcherServlet 初始化Servlet3 会主动查询 WebApplicationInitializer 接口的实现类，同时会执行 WebApplicationInitializer 实现类的 onStartup 方法。通过该方法，它会创建 spring 应用上下文并加载 bean（两个应用上下文：一个为 DispatcherServlet 加载控制器、视图解析器等 web 组件；一个加载中间层和数据层等非 web 组件），它同时会创建 DispatcherServlet 实例，且将 DispatcherServlet 实例和 web 过滤器挂载到 ServletContext 上。 应用以下示例单纯使用 spring + spring webmvc 的场景，没有使用 spring boot。 12345678910111213141516171819202122232425public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; // 为其中一个 spring 应用上下文（加载数据层组件）指定 RootConfig 配置类或组件 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return null; &#125; // 为其中一个 spring 应用上下文（加载控制器）指定 WebConfig 配置类或组件 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; MyWebConfig.class &#125;; &#125; // 指定 DispatcherServlet 处理的路由 @Override protected String[] getServletMappings() &#123; return new String[] &#123; \"/\" &#125;; &#125; // 指定过滤器 @Override protected Filter[] getServletFilters() &#123; return new Filter[] &#123; new HiddenHttpMethodFilter() &#125;; &#125;&#125; @EnableWebMvc@EnableWebMvc 注解会通过 @Import 加载配置类，配置类又会主动查找 Controller 等 bean，并注册到 HandlerMapping 中，以便在请求触达时使用。 应用配置类可以继承 WebMvcConfigurer，以便配置转换器、拦截器、 cors 映射规则等。以下示例仅展示 cors 规则的配置： 1234567891011121314151617181920212223@Configuration@EnableWebMvc@ComponentScan(\"demo.web\")// 通过组件扫描加载 Controller 等 web 组件public class WebConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/api/**\") .allowedOrigins(\"https://domain2.com\") .allowedMethods(\"PUT\", \"DELETE\") .allowedHeaders(\"header1\", \"header2\", \"header3\") .exposedHeaders(\"header1\", \"header2\") .allowCredentials(true).maxAge(3600); &#125;&#125;// 附注 RootConfig 配置类// @Configuration// @ComponentScan(basePackages=&#123;\"demo.web\"&#125;,// 通过组件扫描加载中间层、数据层等非 web 组件// excludeFilters=&#123;// @Filter(type=FilterType.ANNOTATION, value=EnableWebMvc.class)// &#125;)// public class RootConfig &#123;// &#125; DispatcherServlet 处理请求DispatcherServlet 作为处理请求的中央调度器。它会使用 HandlerMapping 将请求路由到指定的处理器 handler，HandlerMapping 的默认实现类为 BeanNameUrlHandlerMapping 以及 RequestMappingHandlerMapping。它会使用 HandlerAdapter 在 handlerMethod 之前或之后处理请求或响应，默认实现类 RequestMappingHandlerAdapter 能够解析 Controller 上的注解。ViewResolver 可用于指定视图解析策略；在没有指定视图名的情况下，RequestToViewNameTranslator 用于通过请求获取视图名。MultipartResolver 用于解析文件；LocaleResolver 用于实现国际化。错误处理由 HandlerExceptionResolver 完成，它会将错误转交给 handler 或 view。上述 bean（如添加了 @Controller、@RequestMapping 注解的控制器），DispatcherServlet 均通过 applicationContext#refresh 阶段从已加载的 bean 中获取。 请求触达，DispatcherServlet#doGet 等方法接受到请求。 DispatcherServlet#doDispatch 阶段，路由到 Handler（即添加了 @RequestMapping 注解的 Controller）。 DispatcherServlet#doDispatch 阶段，通过 HandlerAdapter 处理请求、执行 handler、转化响应。 DispatcherServlet#doDispatch 阶段，渲染视图（包含 html、xml、pdf、json 等）或错误。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// DispatcherServlet 间接实现了 ApplicationContextAware，可以获得 applicationContextpublic class DispatcherServlet extends FrameworkServlet &#123; // applicationContext#refresh 阶段从 bean 中获取 HandlerMapping 等 bean @Override protected void onRefresh(ApplicationContext context) &#123; initStrategies(context); &#125; // 其他 doPost、doPut、doDelete 等方法最终都会调用 doDispatch protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 从 HandlerMapping 中获取 handler mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 调用拦截器 interceptor.preHandle 方法进行处理 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // 通过 HandlerAdapter 处理请求、执行 handler、转化响应 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器 interceptor.postHandle 方法进行处理 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; // 渲染视图或错误 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; &#125;&#125; @RequestMappingRequestMappingHandlerAdapter 实现了 BeanFactoryAware, InitializingBean 接口。依循 spring bean 的生命周期，RequestMappingHandlerAdapter 首先会找到添加了 @ControllerAdvice 注解的类，并将该类中添加了 @RequestMapping、@ModelAttribute、@InitBinder 等注解的方法存入指定的 cache 中；加载参数解析器、绑定数据解析器、返回值处理器。等到请求触达时，它会按照参数解析器、handlerMethod、返回值处理器的方式处理请求和响应，最终响应以 ModelAndView 实例的形式对外输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; @Nullable protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; // 从 cache 中获取 @InitBinder 注解的方法以及数据绑定解析器，构建 WebDataBinderFactory 实例 // binderFactory 既在 InvocableHandlerMethod#getMethodArgumentValues 阶段处理参数 // 又在 ModelFactory#updateModel 阶段处理响应 WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); // 从 cache 中获取 @RequestMapping、@ModelAttribute 注解的方法，构建 ModelFactory 实例 // binderFactory 既在 InvocableHandlerMethod#getMethodArgumentValues 阶段处理参数 ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); // 添加参数解析器 if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; // 添加返回值处理器 if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; // 添加数据绑定工厂类 invocableMethod.setDataBinderFactory(binderFactory); // 添加参数名辨识器，用于判断参数是否需要经由 binderFactory 处理等 invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); // 管理请求处理过程中所使用到的数据 ModelAndViewContainer mavContainer = new ModelAndViewContainer(); // 在重定向之前从请求返回只读“输入”闪存属性 mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); // 按照以下的顺序填充 mavContainer#defaultModel（ModelMap实例）中 // a. 填充 @SessionAttributes 注解的可使用的会话属性 // b. 通过执行 @ModelAttribute 注解的方法填充数据 // c. 从 @ModelAttribute 注解的参数上找到 @SessionAttributes 指定属性并填充 modelFactory.initModel(webRequest, mavContainer, invocableMethod); // 是否在重定向时忽略默认，默认 false mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); // 处理异步请求 AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); // 如果有并发结果 if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123; String formatted = LogFormatUtils.formatValue(result, !traceOn); return \"Resume with async result [\" + formatted + \"]\"; &#125;); invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; // 依次调用参数解析器、handlerMethod、返回值处理 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; // 使用数据绑定解析器处理响应，响应内容有二：视图 view；视图中使用的模型 model（即 mavContainer#defaultModel） return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125; &#125;&#125; 参数解析器参数解析器均需实现 HandlerMethodArgumentResolver 接口，该接口约定了两个方法：supportsParameter 是否解析器可处理的参数；resolveArgument 解析参数。AbstractNamedValueMethodArgumentResolver 是其抽象实现类。@PathVariable、@MatrixVariable、@RequestParam、@RequestHeader、@CookieValue、@RequestBody、@RequestPart、@ModelAttribute、@SessionAttribute、@SessionAttributes、@RequestAttribute 等注解均基于这个抽象类上解析实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class AbstractNamedValueMethodArgumentResolver implements HandlerMethodArgumentResolver &#123; @Override @Nullable public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; // RequestParam(name = \"a\", required = true, defaultValue = \"3\") =&gt; NamedValueInfo&#123;name=\"a\",required=true,defaultValue=\"3\"&#125; NamedValueInfo namedValueInfo = getNamedValueInfo(parameter); MethodParameter nestedParameter = parameter.nestedIfOptional(); // 处理 name，因为它可能是表达式或占位符 Object resolvedName = resolveStringValue(namedValueInfo.name); if (resolvedName == null) &#123; throw new IllegalArgumentException( \"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\"); &#125; // 从 webRequest 装填实际的参数值，由子类实现 Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest); if (arg == null) &#123; if (namedValueInfo.defaultValue != null) &#123; arg = resolveStringValue(namedValueInfo.defaultValue); &#125; else if (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123; handleMissingValue(namedValueInfo.name, nestedParameter, webRequest); &#125; arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType()); &#125; else if (\"\".equals(arg) &amp;&amp; namedValueInfo.defaultValue != null) &#123; arg = resolveStringValue(namedValueInfo.defaultValue); &#125; // 通过数据绑定器转换值 if (binderFactory != null) &#123; WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name); try &#123; arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter); &#125; catch (ConversionNotSupportedException ex) &#123; throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(), namedValueInfo.name, parameter, ex.getCause()); &#125; catch (TypeMismatchException ex) &#123; throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(), namedValueInfo.name, parameter, ex.getCause()); &#125; &#125; // 调用子类钩子 handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest); return arg; &#125;&#125; 应用1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(\"/spittles\")public class SpittleController &#123; @Resource SpittleRepository spittleRepository; @RequestMapping(value=\"/&#123;spittleId&#125;\", method=RequestMethod.GET) public String spittles(@PathVariable long spittleId, Model model)&#123; Spittle spittle = spittleRepository.findOne(spittleId); if (spittle == null)&#123;// 由 spring mvc 为 404 异常添加 http 状态码 throw new SpittleNotFoundException(); &#125; // 为 spittle 视图传入模型数据 model.addAttributes(spittle); return \"spittle\"; &#125;&#125;@ResponseStatus(value=HttpStatus.NOT_FOUND, reason=\"Spittle Not Found\")public class SpittleNotFoundException extends RuntimeException &#123;&#125;@Testpublic void shouldShowSpittle() throws Exception &#123; SpittleController controller = new SpittleController(); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(get(\"/spittles/10086\")) .addExcept(view().name(\"spittle\"));&#125; 参考spring 官方文档理解SpringMvc架构以及流程Spring MVC源码分析（四）：SpringMVC的HandlerMapping和HandlerAdapter的体系结构设计与实现Spring Web MVC（一）|前端控制器-DispatcherServletSpringMVC之分析RequestMappingHandlerAdapter（一）流程图解Spring Framework（十三）Spring MVC RequestMappingHandlerAdapter 是如何处理@RequestMapping的？","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"spring","slug":"backend/spring","permalink":"http://xzfyu.com/categories/backend/spring/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"TDDL & DRDS","slug":"backend/数据库技术/TDDL & DRDS","date":"2019-12-29T16:00:00.000Z","updated":"2020-03-08T11:17:11.774Z","comments":true,"path":"2019/12/30/backend/数据库技术/TDDL & DRDS/","link":"","permalink":"http://xzfyu.com/2019/12/30/backend/数据库技术/TDDL & DRDS/","excerpt":"","text":"前言有三种技术可以应对不断增大的数据量： 读写分离：将数据库设置成读写分离状态，一个 Master 节点对应多个 Salve 节点。 垂直分区：将不同的业务表拆散，分别存储到不同的数据库中，仍保持 Master/Salve 模式。 水平分区（分库 or 分表，sharding）：将同一个业务表（或库）拆解成多个子表（或库），比如 db0、db1。 数据库中间件详解 这篇文章不只介绍了上述三种技术，还道明了数据库中间件设计的两种方案：基于代理服务器的 proxy 模式（需要对接不同数据源、不同应用技术栈的通信协议，必须保持高可用，隔离租户）；基于封装 连接池或者 driver 为 sdk 的 smart-client 模式（需要对接不同数据源的通信协议，不需要对接不同应用技术栈的通信协议，天然去中心化）。TDDL 基于 smart-client 模式。DRDS 基于 proxy 模式。 TDDL 淘宝分布式数据层 Taobao Distributed Data Layer 位于持久层和数据库之间（持久层只关心对数据源的 CRUD 操作，而多数据源的访问并不应该由它来关心），它直接与数据库进行通信。它属于数据访问层（DAL 层），同类产品有 Hibernate Shards、Ibatis-Sharding 等。它基于集中式配置的 JDBC DataSource 实现，对持久层提交的 sql 只拼装不解析。TDDL 主要解决了以下问题： 数据访问路由，将数据的读写请求发送到对应的数据库。 集中式数据源信息管理和动态变更，支持数据存储的自由扩展。 遵守 JDBC 规范，支持 mysql 和 oracle 等多数据源。 带权重的读写分离，支持分库分表（TDDL 会创建中间状态的逻辑表来整合统一分库分表的访问）。 TDDL 是一个客户端 jar，它的结构主要分为三层： Matrix 层：核心是规则引擎，实现了分库分表逻辑，持有多个 Group 实例。主要功能逻辑为：sql 解析 =&gt; 规则引擎计算（路由） =&gt; 执行 =&gt; 合并结果集。 Group 层：实现了数据库的主备分离逻辑，持有多个 Atom 实例。Group 层和 Atom 层共同组成了动态数据源。主要功能逻辑为：读写分离 =&gt; 权重计算 =&gt; 写 HA 切换（预防节点宕机，需要配置中心配合） =&gt; 读 HA 切换 =&gt; 动态新增 slave 节点（根据访问压力？）。 Atom（TAtomDataSource）层：可以理解为一个数据库。主要功能逻辑为：ip, port, password, connectionProperties 等信息动态修改，动态化 jboss 数据源 =&gt; try catch 模式对线程计数，保护业务处理线程 =&gt; 动态阻止某些 sql 的执行 =&gt; 执行次数的统计和限制。 其他结构包含： tddl-client：应用启动时初始化配置信息（规则信息，各层数据源拓扑结构） tddl-rule：分库分表规则解析 tddl-sequence：统一管理和分配全局唯一 sequence（序列号） tddl-druid-datasource：数据库连接池（高效，可扩展性好），类 dbcp、c3p0 TDDL剖析 这篇文章介绍了基于 TDDL 已开源的模块以及 diamond 实现主备分离、分库分表逻辑的方法。 DRDS分布式关系型数据库服务 Distributed Relational Database Service 的前身是 TDDL。它支持垂直拆分和水平拆分，因此有良好的扩展性；它通过两阶段提交支持分布式事务（此时 DRDS 服务器作为事务管理器，首先等待所有 MySQL 服务器 PREPARE 成功，然后再向各个 MySQL 服务器发送 COMMIT 请求。如果事务中的 SQL 仅涉及单个分片，DRDS 会将其作为单机事务直接下发给 MySQL；反之才会升级为分布式事务）；它允许增加 RDS 实例的数量，以达到平滑扩容的效果；它支持读写分离，强读（显式事务中的读请求和写入操作将在主实例中执行，弱读在只读实例中执行；它支持通过全局二级索引能力创建二级索引表，以应对业务上的快速索引查询需求。计算能力上，DRDS 额外扩展了单机并行处理器（SMP，Symmetric Multi-Processing）和多机并行处理器（DAG），前者完全集成在 DRDS 内核中，后者，DRDS 构建了一个计算集群，运行时动态获取执行计划进行分布式计算，通过增加节点提升计算能力。 参考数据库中间件详解TDDL调研笔记TDDL剖析分布式数据库中间件TDDL、Amoeba、Cobar、MyCAT架构比较TDDL分布式关系型数据库 DRDS","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"数据库技术","slug":"backend/数据库技术","permalink":"http://xzfyu.com/categories/backend/数据库技术/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"我看 spring 事务机制","slug":"backend/spring/我看 spring 事务机制","date":"2019-12-28T16:00:00.000Z","updated":"2020-03-08T11:16:05.256Z","comments":true,"path":"2019/12/29/backend/spring/我看 spring 事务机制/","link":"","permalink":"http://xzfyu.com/2019/12/29/backend/spring/我看 spring 事务机制/","excerpt":"","text":"whatspring 事务机制提供了统一的编程模型来处理不同数据访问操作（local transactions by using JDBC, JPA, or Hibernate），同时支持分布式事务（JTA transactions）；支持声明式事务编程和编程式事务编程，声明式事务编程对代码无侵入性，只需要改变配置类即可应对不同的数据访问技术；与 spring 数据访问抽象完美集成。对于 spring boot 项目，只要显式地对启动类添加 @EnableTransactionManagement 注解，即能为应用注入 PlatformTransactionManager 实例；然后在需要事务支持的方法或类上添加 @Transactional 注解（该注解推荐使用在类和类的公共方法上。如果在保护方法和私有方法上使用，需要配合 AspectJ），spring 就能基于 AOP 机制开启一个事务，当调用无异常时，事务就会被提交了。 samplebasic样例来自 Managing Transactions，基于 spring boot 作了改造： 12345678910111213141516171819202122232425262728293031323334353637@EnableTransactionManagement // 启注解事务管理@SpringBootApplicationpublic class ProfiledemoApplication &#123; @Bean public Object testBean(PlatformTransactionManager platformTransactionManager)&#123; System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + platformTransactionManager.getClass().getName()); return new Object(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ProfiledemoApplication.class, args); &#125;&#125;@Componentpublic class BookingService &#123; private final static Logger logger = LoggerFactory.getLogger(BookingService.class); private final JdbcTemplate jdbcTemplate; public BookingService(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Transactional public void book(String... persons) &#123; for (String person : persons) &#123; logger.info(\"Booking \" + person + \" in a seat...\"); jdbcTemplate.update(\"insert into BOOKINGS(FIRST_NAME) values (?)\", person); &#125; &#125; public List&lt;String&gt; findAllBookings() &#123; return jdbcTemplate.query(\"select FIRST_NAME from BOOKINGS\", (rs, rowNum) -&gt; rs.getString(\"FIRST_NAME\")); &#125;&#125; multiple management当应用中有多种数据库连接方式时，Spring Boot的事务管理注解@EnableTransactionManagement的使用 这篇文章指明了该如何使用声明式事务： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@EnableTransactionManagement@SpringBootApplicationpublic class ProfiledemoApplication implements TransactionManagementConfigurer &#123;// 实现 TransactionManagementConfigurer，指定事务管理器 @Resource(name=\"txManager2\") private PlatformTransactionManager txManager2; // 创建事务管理器1，以数据源 DataSource 为参数 @Bean(name = \"txManager1\") public PlatformTransactionManager txManager(DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; // 创建事务管理器2，不需要指定数据库，需要指定 EntityManagerFactory @Bean(name = \"txManager2\") public PlatformTransactionManager txManager2(EntityManagerFactory factory) &#123; return new JpaTransactionManager(factory); &#125; // 实现接口 TransactionManagementConfigurer 方法，设置默认的事务管理器 @Override public PlatformTransactionManager annotationDrivenTransactionManager() &#123; return txManager2; &#125; public static void main(String[] args) &#123; SpringApplication.run(ProfiledemoApplication.class, args); &#125;&#125;@Componentpublic class DevSendMessage implements SendMessage &#123; // 使用 value 指定事务管理器 @Transactional(value=\"txManager1\") @Override public void send() &#123; // ... &#125; // 使用默认的事务管理器；如果没有默认的事务管理器，就必须制定 value，否则会抛出异常 @Transactional public void send2() &#123; // ... &#125;&#125;// 第二种方式，使用 @TxManager1 注解// @Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)// @Retention(RetentionPolicy.RUNTIME)// @Transactional(\"txManager1\")// public @interface TxManager1 &#123;// &#125; howspring 事务通过 AOP 面向切面编程机制实现，首先从 @Transactional 注解中获取必要的元数据信息，然后构建一个 AOP 代理（spring 事务也支持基于 AspectJ 切面），它使用 TransactionInterceptor 事务拦截器和 PlatformTransactionManager 接口实现类（对接不同数据访问技术的事务操作）来驱动事务。 EnableTransactionManagement@EnableTransactionManagement 注解既会注入默认的 PlatformTransactionManager 实例，又会通过 Spring 的自动机制添加切面（装配 TransactionInterceptor 事务拦截器），自动查询应用上下文中的 @Transactional 注解，并构建 AOP 代理执行事务流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(TransactionManagementConfigurationSelector.class)public @interface EnableTransactionManagement &#123; // 代理模式，基于子类或基于 java 接口 boolean proxyTargetClass() default false; // 切面模式，默认基于代理，可以切换成基于 AspectJ AdviceMode mode() default AdviceMode.PROXY; // 拦截器顺序 int order() default Ordered.LOWEST_PRECEDENCE;&#125;public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector&lt;EnableTransactionManagement&gt; &#123; // 通过 AnnotationMetadata 接口获取注解的元数据 // 由元数据 mode 获取 ProxyTransactionManagementConfiguration 类名等，使用 spring 机制自动装配 @Override protected String[] selectImports(AdviceMode adviceMode) &#123; switch (adviceMode) &#123; case PROXY: // AutoProxyRegistrar 实现 ImportBeanDefinitionRegistrar 接口，会在注册 bean 的时候设置 AOP 代理的方式，基于子类或基于接口 return new String[] &#123;AutoProxyRegistrar.class.getName(), // ProxyTransactionManagementConfiguration 间接实现 ImportAware 接口，可以通过 setImportMetadata 方法获取注解元数据 // ProxyTransactionManagementConfiguration 属性中包含默认的 PlatformTransactionManager 实例 // 通过 ProxyTransactionManagementConfiguration 自动加载 TransactionInterceptor 拦截器 ProxyTransactionManagementConfiguration.class.getName()&#125;; case ASPECTJ: return new String[] &#123;determineTransactionAspectClass()&#125;; default: return null; &#125; &#125;&#125;// 通过 ProxyTransactionManagementConfiguration 自动加载 TransactionInterceptor 拦截器@Configurationpublic class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration &#123; // 设置切点、建言等 @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE)// 声明 Bean 的分类 public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() &#123; BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor(); advisor.setTransactionAttributeSource(transactionAttributeSource()); advisor.setAdvice(transactionInterceptor()); if (this.enableTx != null) &#123; advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber(\"order\")); &#125; return advisor; &#125; // 解析 @Transactional 注解 @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public TransactionAttributeSource transactionAttributeSource() &#123; return new AnnotationTransactionAttributeSource(); &#125; // 事务拦截器 @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public TransactionInterceptor transactionInterceptor() &#123; TransactionInterceptor interceptor = new TransactionInterceptor(); interceptor.setTransactionAttributeSource(transactionAttributeSource()); if (this.txManager != null) &#123; interceptor.setTransactionManager(this.txManager); &#125; return interceptor; &#125;&#125; TransactionInterceptorTransactionInterceptor 事务拦截器的简要实现原理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class TransactionInterceptor extends TransactionAspectSupport implements MethodInterceptor, Serializable &#123; @Override @Nullable public Object invoke(MethodInvocation invocation) throws Throwable &#123; Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed); &#125;&#125;public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean &#123; @Nullable protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass, final InvocationCallback invocation) throws Throwable &#123; // 获取 @transactional 注解属性 // txAttr 与 TranscationStatus 挂钩，作为 PlatformTransactionManager#getTranscation 的参数，返回 TranscationStatus TransactionAttributeSource tas = getTransactionAttributeSource(); final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null); // 通过 beanFactory 以及 @transactional 注解上的 value 元数据获取 PlatformTransactionManager 实例 final PlatformTransactionManager tm = determineTransactionManager(txAttr); final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123; // 构建 TransactionInfo，保存在本地线程中 TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try &#123; // 继续执行拦截器链,当有其他拦截器 match 待执行方法时，则执行该拦截器方法，然后 return retVal = invocation.proceedWithInvocation(); &#125; catch (Throwable ex) &#123; // 根据 @transactional 元数据 rollbackOn 进行回滚或调用 PlatformTransactionManager#commit 提交 completeTransactionAfterThrowing(txInfo, ex); throw ex; &#125; finally &#123; cleanupTransactionInfo(txInfo); &#125; // 调用 PlatformTransactionManager#commit 提交 commitTransactionAfterReturning(txInfo); return retVal; &#125; else &#123; final ThrowableHolder throwableHolder = new ThrowableHolder(); // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in. try &#123; Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&gt; &#123; TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status); try &#123; return invocation.proceedWithInvocation(); &#125; catch (Throwable ex) &#123; if (txAttr.rollbackOn(ex)) &#123; // A RuntimeException: will lead to a rollback. if (ex instanceof RuntimeException) &#123; throw (RuntimeException) ex; &#125; else &#123; throw new ThrowableHolderException(ex); &#125; &#125; else &#123; throwableHolder.throwable = ex; return null; &#125; &#125; finally &#123; cleanupTransactionInfo(txInfo); &#125; &#125;); if (throwableHolder.throwable != null) &#123; throw throwableHolder.throwable; &#125; return result; &#125; catch (ThrowableHolderException ex) &#123; throw ex.getCause(); &#125; catch (TransactionSystemException ex2) &#123; if (throwableHolder.throwable != null) &#123; logger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable); ex2.initApplicationException(throwableHolder.throwable); &#125; throw ex2; &#125; catch (Throwable ex2) &#123; if (throwableHolder.throwable != null) &#123; logger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable); &#125; throw ex2; &#125; &#125; &#125;&#125; PlatformTransactionManagerPlatformTransactionManager 接口定义了事务执行的策略。不同的数据访问技术有各自的实现，如 JDBC 实现了 DataSourceTranscationManager；JPA 实现了 JPATranscationManager；Hibernate 实现了 HibernateTranscationManager；JDO 实现了 JdoTranscationManager；分布式事务实现了 JtaTranscationManager。在 spring boot 项目中，spring-boot-starter-jdbc 会为应用自动注入 DataSourceTransactionManager 实例；spring-boot-starter-data-jpa 会为应用自动注入 JpaTransactionManager 实例。 123456789101112131415161718192021222324public interface PlatformTransactionManager &#123; // 如果当前调用堆栈存在匹配事务，就返回新事务或当前的事务 // TransactionDefinition 定义了事务的元数据，基本与 @Transactional 注解上的元数据相同 TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException;&#125;public interface TransactionStatus extends SavepointManager &#123; boolean isNewTransaction(); boolean hasSavepoint(); // 调用 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly() 实现回滚 void setRollbackOnly(); boolean isRollbackOnly(); void flush(); boolean isCompleted();&#125; Transactional@Transactional 注解元数据包含： propagation（事务传播）：默认值为 REQUIRED，事务方法 A 调用事务方法 B，B 将使用与 A 相同的事务，而不创建新事务；当方法 B 发生异常时，整个事务将回滚。当值为 REQUIRED_NEW 时，方法 B 将构建新的事务，异常只导致 B 事务回滚。当值为 NESTED 时，效果与 REQUIRED_NEW 类似，但只支持 JDBC，不支持 JPA、Hibernate。当赋值为 SUPPORTS 时，声明方法调用时有事务就用事务，没有事务就不用事务（比如某方法没有事务，调用它的方法可能有事务）。当赋值为 NOT_SUPPORTS 时，声明方法不在事务中执行，若有事务，在方法调用结束阶段事务都会被挂起。当赋值为 NEVER 时，声明方法不在事务中执行，若有事务则抛出异常。当赋值为 MANDATORY 时，声明方法在事务中执行，若没有事务则抛出异常。 isolation：指定事务之间的隔离程度。默认值为 DEFAULT，使用当前数据库的默认隔离级别，Oracle、SQL Server 为 READ_COMMITTED，Mysql 为 REPEATABLE_READ。当值为 READ_UNCOMMITTED 时，B 事务可以读取到 A 事务修改但未提交的事务，可能导致脏读、不可重复读、幻读。当值为 READ_COMMITTED 时，B 事务可以读取到 A 事务修改的事务，可能导致不可重复读、幻读，不会导致脏读。当值为 REPEATABLE_READ 时，B 事务可以读取到 A 事务修改的事务，但不可以读取 A 事务已经读取的事务，可能导致不可重复读，不会导致幻读、脏读。当值为 SERIALIZABLE 时，事务顺序执行，不会导致不可重复读、幻读、脏读，但是开销较大。 timeout：指定事务过期时间，默认为当前数据库的事务过期时间。超过超时时间的事务将会被回滚。 readOnly：指定当前事务是否为只读事务，即添加 @Transactional 注解的方法只会读取数据库的值，而不会修改数据库的值。 rollbackFor：指定哪些异常可以引起事务回滚，值为 Throwable 的子类。 noRollbackFor：指定哪些异常不会引起事务回滚，值为 Throwable 的子类。 自定义事务行为。 不支持通过远程调用传播事务上下文。 TransactionTemplate同常见的数据访问技术实现了了两种抽象一样（如较低水平的抽象 DataSourceUtils、较高水平的抽象 JDBCTemplate），spring 事务机制既支持使用 @Transactional 注解作声明式编程，又支持使用 TransactionTemplate 或 PlatformTransactionManager 实现类作编程式编程。除了使用 TransactionTemplate 约束事务的行为以外，spring 事务机制也允许使用 TransactionalEventListener 在事务执行的某个阶段定制事件。 12345678910111213141516171819202122public class SimpleService implements Service &#123; private final TransactionTemplate transactionTemplate; public SimpleService(PlatformTransactionManager transactionManager) &#123; this.transactionTemplate = new TransactionTemplate(transactionManager); this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED); this.transactionTemplate.setTimeout(30); // 30 seconds &#125; public Object someServiceMethod() &#123; return transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; protected void doInTransactionWithoutResult(TransactionStatus status) &#123; try &#123; updateOperation1(); updateOperation2(); &#125; catch (SomeBusinessException ex) &#123; status.setRollbackOnly(); &#125; &#125; &#125;); &#125;&#125; 参考spring 事务官方文档Java中的事务——全局事务与本地事务Spring 事务 – @Transactional的使用@Transactional原理Distributed transactions in Spring, with and without XAJava Transaction Design Strategies","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"spring","slug":"backend/spring","permalink":"http://xzfyu.com/categories/backend/spring/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"docker","slug":"backend/部署/docker","date":"2019-12-28T16:00:00.000Z","updated":"2020-03-08T11:29:41.497Z","comments":true,"path":"2019/12/29/backend/部署/docker/","link":"","permalink":"http://xzfyu.com/2019/12/29/backend/部署/docker/","excerpt":"","text":"虚拟机和容器虚拟机和容器都是为了将实体机拆分成多块，以便分块运行不同的应用。 虚拟机技术（xem、kvm、vmware、virtualbox）需要模拟整台机器，包括硬件、操作系统等。虚拟机一旦开启，预分配给它的资源将全部被占用。虚拟机上再运行应用，并安装必要的二进制包和库。 容器技术能和宿主机共享硬件资源及操作系统，能实现资源的动态分配。容器内部安装依赖和应用，在宿主机中以分离的进程运行。Docker 基于 Linux 容器封装。Linux 容器没有模拟一个操作系统，而是对进程套了一层保护层，它所使用的资源都是虚拟的，这样就能与底层系统进行隔离。Docker 支持将软件编译成镜像（image）（镜像是一个包含一堆只读层的文件系统），并在镜像中做好对软件的配置，镜像经发布后，使用者就可以下载并运行这个镜像（运行中的镜像也被称为容器 Container）（容器也是多层机构的文件系统，只是最上面那层支持读写操作）。通过镜像可以实现交付环境的一致性；Dockerfile 用于记录容器构建过程，可以在集群中实现快速分发和部署。 各大云计算平台（PaaS 平台即服务，提供存储、数据库、网络、负载均衡、自动扩展等功能）均支持 Docker 容器技术，比如阿里云、百度云、Cloud Foundry、HeroKu、DigitalOcean、OpenShift、Apache Stratos、Apache MesOS、Deis、Windows Server、Azure 等。 Docker 命令Docker 使用 C/S 结构（客户端/服务器）打造。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。典型的客户端就是命令行工具。服务端接受到请求后，会使用路由分发工具请求交给具体的处理器，如 graphdriver 用来执行容器镜像的本地化操作；networkdriver 用来执行容器网络环境的配置；execdriver 用来执行容器内部运行的执行工作；或者从 Docker Registry 上获取镜像。 1234567891011121314151617181920212223242526# CentOS 安装 dockersudo yum updatesudo yum install docker# Ubuntu 安装 dockersudo apt-get updatesudo apt-get docker.iodocker -vdocker search image-name # 检索镜像 https://registry.hub.docker.comdocker pull image-name # 下载镜像docker images # 本地镜像列表，包含镜像 iddocker rmi image-id # 通过镜像 id 删除镜像docker rmi $&#123;docker images -g&#125; # 删除所有镜像docker run --name container-name -d image-name # 以指定容器名运行镜像docker ps # 容器列表，包含容器 id、占用端口号docker stop container-name # 停止容器docker stop container-id # 停止容器docker start container-name # 启动容器docker start container-id # 启动容器docker run -d -p 6378:6379 --name port-redis redis # 将 docker 容器的端口映射到宿主机端口 6378，容器端口无法对外提供访问docker rm container-id # 删除容器docker rm $&#123;docker ps -a -q&#125; # 删除所有容器docker logs container-name # 容器日志docker logs container-id # 容器日志docker exec -it container-id bash # 登录容器，执行常规的 linux 操作docker exec -it container-name bash # 登录容器，执行常规的 linux 操作 DockerfileDockerfile 配置文件用于构建 Docker 镜像，包含四大内容： FROM：基础镜像（父镜像）信息指令 MAINTAINER：维护者信息指令 RUN、EVN、ADD、WORKDIR 等：镜像操作指令 CMD、ENTRYPOINT、USER 等：容器启动指令 典型的 Dockerfile 文件如下（编写完 Dockerfile 后，可以通过 docker build 编译创建镜像）（jar 包也可以在应用中添加 docker-maven-plugin 插件，并指定 DOCKER_HOST 环境变量为服务器地址，再使用 mvn clean package docker:build -DskipTests 构建）： 1234567891011121314FROM java:8 # 拉取基础镜像VOLUME /tmp # 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等RUN mkdir /app # 执行命令ADD config-1.0.0-SNAPSHOT.jar /app/app.jar # 赋值ADD runboot.sh /app/ # 赋值RUN bash -c 'touch /app/app.jar' # 执行命令，另一种格式是 RUN [\"bash\", \"-c\", \"touch /app/app.jar\"]WORKDIR /app # 设置当前工作路径RUN chmod a+x runboot.sh EXPOSE 8888 # 指定对外开放的端口CMD /app/runboot.sh # 启动容器时的默认行为，一个 Dockerfile 里只能有一个 CMD 指令# /app/runboot.shsleep 10java -Djava.security.egd=file:/dev/./urandim -jar /app/app.jar Docker ComposeDocker Compose 可用来定义和运行多容器应用，即使用 docker-compose.yml 定义多容器，然后执行 docker-compose up -d 启动多应用。 参考这可能是最为详细的Docker入门吐血总结终于有人把 Docker 讲清楚了，万字详解！Docker教程：Docker入门实践（精讲版）Docker中文文档","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"部署","slug":"backend/部署","permalink":"http://xzfyu.com/categories/backend/部署/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"}]},{"title":"聊聊组件库的测试","slug":"frontend/antd/聊聊组件库的测试","date":"2019-12-27T16:00:00.000Z","updated":"2020-03-08T10:28:46.565Z","comments":true,"path":"2019/12/28/frontend/antd/聊聊组件库的测试/","link":"","permalink":"http://xzfyu.com/2019/12/28/frontend/antd/聊聊组件库的测试/","excerpt":"","text":"antdant-design 基于 jest 断言库、enzyme、react-test-renderer 作测试。有文章认为，enzyme 包含 react-test-renderer 的能力，并且以类 jquery 的方式提供了更便捷的 api 操作。 jest 配置： moduleNameMapper：正则到模块名的 map 映射，这些模块将不会被模拟，无论启动自动模拟与否。 transform：在 ant-design 中，jest 配置的转译器主要使用 babel-jest 实现，只是混入了与启动开发服务器相同的 babel 配置，参见 codePreprocessor.js。对于 markdown 文件，转译器将先使用 mark-twain 进行解析，然后获取 markdown 文件中的代码，然后进行转译，参见 demoPreprocessor.js。对于图片，转译器使用 url-loader 进行处理，参见 imagePreprocessor.js。 setup.js 启动文件配置 Enzyme，即执行 const Adapter = require(‘enzyme-adapter-react-16’); Enzyme.configure({ adapter: new Adapter() })。 ant-design 所做的全局测试包含对导出的模块列表作快照测试（生成的快照均在 snapshots 文件夹内）、组件库版本号是否与 package.json 中一致、使用 dekko 库 校验打包文件是否正确输出、测试 lib 以及语言包是否正常输出。 组件测试包含功能测试、快照测试。快照测试基于遍历 components 文件夹中的 demo 文档（加载的 markdown 经过 demoPreprocessor.js 转译器处理，快照中移除 aria-control 属性。以下是快照测试的主要代码： 12345678910111213141516171819202122232425262728import glob from 'glob';import &#123; render &#125; from 'enzyme';import MockDate from 'mockdate';import moment from 'moment';export default function demoTest(component, options = &#123;&#125;) &#123; const files = glob.sync(`./components/$&#123;component&#125;/demo/*.md`); files.forEach(file =&gt; &#123; let testMethod = options.skip === true ? test.skip : test; if (Array.isArray(options.skip) &amp;&amp; options.skip.some(c =&gt; file.includes(c))) &#123; testMethod = test.skip; &#125; testMethod(`renders $&#123;file&#125; correctly`, () =&gt; &#123; MockDate.set(moment('2016-11-22')); const demo = require(`../.$&#123;file&#125;`).default; const wrapper = render(demo); ariaConvert(wrapper);// 快照移除 aria-control 属性 expect(wrapper).toMatchSnapshot(); MockDate.reset(); &#125;); &#125;);&#125;// 执行组件 demo 测试demoTest(\"affix\"); 组件的功能测试包含：挂载、设置 props、卸载无异常；基本的快照测试，使用 enzyme 判断是否包含某样式类、交互事件是否正常触发、更新 props 等。 12345678910111213// 挂载、设置 props、卸载无异常import &#123; mount &#125; from 'enzyme';function mountTest(Component) &#123; describe(`mount and unmount`, () =&gt; &#123; it(`component could be updated and unmounted without errors`, () =&gt; &#123; const wrapper = mount(&lt;Component /&gt;); expect(() =&gt; &#123; wrapper.setProps(&#123;&#125;); wrapper.unmount(); &#125;).not.toThrow(); &#125;); &#125;);&#125; 以下仅展示 Typography 组件的部分测试脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// 模拟 copy-to-clipboardjest.mock('copy-to-clipboard');describe('Typography', () =&gt; &#123; // 挂载、设置 props、卸载无异常测试 mountTest(Paragraph); mountTest(Base); mountTest(Title); const LINE_STR_COUNT = 20; // 模拟 console.error const errorSpy = jest.spyOn(console, 'error').mockImplementation(() =&gt; &#123;&#125;); // 模拟 offsetHeight const originOffsetHeight = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight') .get; Object.defineProperty(HTMLElement.prototype, 'offsetHeight', &#123; get() &#123; let html = this.innerHTML; html = html.replace(/&lt;[^&gt;]*&gt;/g, ''); const lines = Math.ceil(html.length / LINE_STR_COUNT); return lines * 16; &#125;, &#125;); // 模拟 getComputedStyle const originGetComputedStyle = window.getComputedStyle; window.getComputedStyle = ele =&gt; &#123; const style = originGetComputedStyle(ele); style.lineHeight = '16px'; return style; &#125;; beforeAll(() =&gt; &#123; // Typography 使用了 raf，模拟 microTask、macroTask jest.useFakeTimers(); &#125;); afterEach(() =&gt; &#123; errorSpy.mockReset(); &#125;); afterAll(() =&gt; &#123; jest.useRealTimers();// 重新使用实际的 microTask、macroTask errorSpy.mockRestore();// 重置模拟 Object.defineProperty(HTMLElement.prototype, 'offsetHeight', &#123; get: originOffsetHeight, &#125;); window.getComputedStyle = originGetComputedStyle; &#125;); // 校验 level 传参必须是 1、2、3、4 describe('Title', () =&gt; &#123; it('warning if `level` not correct', () =&gt; &#123; mount(&lt;Title level=&#123;false&#125; /&gt;); expect(errorSpy).toHaveBeenCalledWith( 'Warning: Title only accept `1 | 2 | 3 | 4` as `level` value.', ); &#125;); &#125;); describe('Base', () =&gt; &#123; describe('trigger ellipsis update', () =&gt; &#123; const fullStr = 'Bamboo is Little Light Bamboo is Little Light Bamboo is Little Light Bamboo is Little Light Bamboo is Little Light'; it('should trigger update', () =&gt; &#123; const wrapper = mount( &lt;Base ellipsis component=\"p\" editable&gt; &#123;fullStr&#125; &lt;/Base&gt;, ); jest.runAllTimers();// 执行 microTask、macroTask，以便更新渲染内容 wrapper.update();// 更新渲染内容 expect(wrapper.find('span').text()).toEqual('Bamboo is Little ...'); wrapper.setProps(&#123; ellipsis: &#123; rows: 2 &#125; &#125;); jest.runAllTimers(); wrapper.update(); expect(wrapper.find('span').text()).toEqual('Bamboo is Little Light Bamboo is Litt...'); wrapper.setProps(&#123; ellipsis: &#123; rows: 99 &#125; &#125;); jest.runAllTimers(); wrapper.update(); expect(wrapper.find('p').text()).toEqual(fullStr); wrapper.unmount(); &#125;); it('should expandable work', () =&gt; &#123; const onExpand = jest.fn(); const wrapper = mount( &lt;Base ellipsis=&#123;&#123; expandable: true, onExpand &#125;&#125; component=\"p\" copyable editable&gt; &#123;fullStr&#125; &lt;/Base&gt;, ); jest.runAllTimers(); wrapper.update(); wrapper.find('.ant-typography-expand').simulate('click');// 模拟点击展开图标 expect(onExpand).toHaveBeenCalled(); jest.runAllTimers(); wrapper.update(); expect(wrapper.find('p').text()).toEqual(fullStr); &#125;); // 测试 css 文本省略 it('can use css ellipsis', () =&gt; &#123; const wrapper = mount(&lt;Base ellipsis component=\"p\" /&gt;); expect(wrapper.find('.ant-typography-ellipsis-single-line').length).toBeTruthy(); &#125;); &#125;); &#125;);&#125;); fusionfusion 基于 karma、mocha、enzyme、axe-core 作测试。 启动测试脚本（仅全量测试部分）的过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// test/index.jsconst &#123; Server &#125; = require('karma');// karma 配置const config = &#123; configFile: join(__dirname, 'karma.js'), component: componentName, runAll: false,&#125;;const runAllTest = (a11y = false) =&gt; &#123; config.runAll = true; config.a11y = a11y; server = new Server(config); server.start();&#125;;// test/karam.jsfunction(config) &#123; // ... const options = &#123; frameworks: ['mocha'], browsers: ['Chrome'], customLaunchers: &#123; ChromeTravis: &#123; base: 'ChromeHeadless', flags: ['--no-sandbox'], &#125;, &#125;, reporters: ['spec', 'coverage'], // 全量测试范围为 test 文件夹下 *-spec.js 文件，并作预处理 preprocessors: &#123; [specPath]: ['webpack', 'sourcemap'], &#125;, files: [ path.join(__dirname, 'animation-polyfill.js'), require.resolve('babel-polyfill/dist/polyfill.js'), require.resolve('console-polyfill/index.js'), require.resolve('es5-shim/es5-shim.js'), require.resolve('es5-shim/es5-sham.js'), require.resolve('html5shiv/dist/html5shiv.js'), specPath, ], coverageReporter: &#123;// 覆盖率报告 dir: coveragePath, reporters: [ &#123; type: 'lcov', subdir: '.' &#125;, &#123; type: 'json', subdir: '.' &#125;, &#123; type: 'text-summary', subdir: '.', file: 'coverage.txt' &#125;, ], &#125;, client: &#123; mocha: &#123; timeout: 10000, reporter: 'html', ui: 'bdd', &#125;, &#125;, hostname: 'localhost', browserNoActivityTimeout: 100000, port: 9877, colors: true, autoWatch: !singleRun, singleRun: singleRun, concurrency: Infinity, // 在启动开发环境的 webpack 配置的基础上，额外添加 babel-plugin-istanbul、babel-plugin-espower 插件 webpack: getWebpackConfig(componentName, runAll), webpackMiddleware: &#123; stats: 'errors-only', &#125;, plugins: [ 'karma-chrome-launcher', 'karma-mocha', 'karma-webpack', 'karma-spec-reporter', 'karma-sourcemap-loader', 'karma-coverage', ], &#125;; if (process.env.TRAVIS) &#123; options.browsers = ['ChromeTravis']; &#125; config.set(options);&#125; fusion 对组件没有快照测试，而是借助 axe-core 做可访问性（a11y）测试，即测试渲染 react 的过程无异常。典型如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 组件的测试脚本describe('Paragraph A11y', () =&gt; &#123; let wrapper; afterEach(() =&gt; &#123; if (wrapper) &#123; wrapper.unmount(); wrapper = null; &#125; unmount(); &#125;); it('should not have any violations', async () =&gt; &#123; wrapper = await testReact( &lt;div&gt; &lt;Paragraph&gt;&#123;content&#125;&lt;/Paragraph&gt; &lt;br /&gt; &lt;Paragraph size=\"small\"&gt;&#123;content&#125;&lt;/Paragraph&gt; &lt;/div&gt; ); return wrapper; &#125;);&#125;);// 借助 enzyme 将渲染内容挂载到指定节点下，然后作访问性测试const testReact = async function(node, options = &#123;&#125;) &#123; const wrapper = await mountReact(node, A11Y_ROOT_ID); await delay(options.delay || 200); await test(`#$&#123;A11Y_ROOT_ID&#125;`, options); return wrapper;&#125;;// 使用 axe-core 测试渲染内容的可访问性const test = function(selector, options = &#123;&#125;) &#123; options.rules = Object.assign(&#123; 'color-contrast': &#123; enabled: false, &#125;, &#125;, options.rules); return Axe.run(selector, &#123; rules: options.rules &#125;) .catch(error =&gt; &#123; assert(!error); &#125;) .then(results =&gt; &#123; if (options.debug) &#123; console.error(formatViolations(results.violations, true)); return; &#125; if (results.violations.length) &#123; console.error(formatViolations(results.violations)); &#125; assert(results.violations.length === 0); if (options.incomplete) &#123; if (results.incomplete.length) &#123; console.error(formatViolations(results.incomplete)); &#125; assert(results.incomplete.length === 0); &#125; &#125;);&#125;; elementelement 同样使用 karma、mocha、enzyme 作测试。只是 element 直接使用 karma 命令行启动测试，fusion 使用 karma.Server 实例启动测试。以下 Button 组件的测试脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 创建 vue 实例const createVue = function(Compo, mounted = false) &#123; if (Object.prototype.toString.call(Compo) === '[object String]') &#123; Compo = &#123; template: Compo &#125;; &#125; return new Vue(Compo).$mount(mounted === false ? null : createElm());&#125;;// 创建测试组件实例const createTest = function(Compo, propsData = &#123;&#125;, mounted = false) &#123; if (propsData === true || propsData === false) &#123; mounted = propsData; propsData = &#123;&#125;; &#125; const elm = createElm();// 在 document 下创建节点 const Ctor = Vue.extend(Compo); return new Ctor(&#123; propsData &#125;).$mount(mounted === false ? null : elm);&#125;;// 销毁const destroyVM = function(vm) &#123; vm.$destroy &amp;&amp; vm.$destroy(); vm.$el &amp;&amp; vm.$el.parentNode &amp;&amp; vm.$el.parentNode.removeChild(vm.$el);&#125;;// Button 组件测试describe('Button', () =&gt; &#123; let vm; afterEach(() =&gt; &#123; destroyVM(vm); &#125;); // 样式测试 it('create', () =&gt; &#123; vm = createTest(Button, &#123; type: 'primary' &#125;, true); let buttonElm = vm.$el; expect(buttonElm.classList.contains('el-button--primary')).to.be.true; &#125;); // 交互测试 it('click', done =&gt; &#123; let result; vm = createVue(&#123; template: ` &lt;el-button @click=\"handleClick\"&gt;&lt;/el-button&gt; `, methods: &#123; handleClick(evt) &#123; result = evt; &#125; &#125; &#125;, true); vm.$el.click(); setTimeout(_ =&gt; &#123; expect(result).to.exist; done(); &#125;, 20); &#125;);&#125;); 参考 使用jest+enzyme进行react项目测试 - 介绍篇","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"jest测试","slug":"frontend/工程化/jest测试","date":"2019-12-25T16:00:00.000Z","updated":"2020-03-08T10:58:02.378Z","comments":true,"path":"2019/12/26/frontend/工程化/jest测试/","link":"","permalink":"http://xzfyu.com/2019/12/26/frontend/工程化/jest测试/","excerpt":"","text":"jest 断言库 支持两种测试模式：功能测试、快照测试。通过添加 babel-jest 依赖以及 babel.config.js 配置，可以在工程中使用 babel 转译 es6 语法或者 ts 语法，可参看 Getting Started。jest 也可以用于使用 webpack 来管理资源、 样式和编译的项目，可参看 Using with webpack。jest 支持的断言方法可参见 Expect。以下仅以异步 async/await 函数说明功能测试用例的编写： 123456789101112131415161718192021test('the data is peanut butter', async () =&gt; &#123; const data = await fetchData(); expect(data).toBe('peanut butter');&#125;);test('the fetch fails with an error', async () =&gt; &#123; expect.assertions(1); try &#123; await fetchData(); &#125; catch (e) &#123; expect(e).toMatch('error'); &#125;&#125;);test('the data is peanut butter', async () =&gt; &#123; await expect(fetchData()).resolves.toBe('peanut butter');&#125;);test('the fetch fails with an error', async () =&gt; &#123; await expect(fetchData()).rejects.toThrow('error');&#125;); 快照测试的功能在于当期望每次渲染的 ui 内容一致时，可以使用快照进行对比。第一次执行测试时，就会生成一个快照；下次测试时，重新生成的快照就会与之前的快照进行对比，如果两份快照有差别，就表示测试失败；如果无差别，就标识测试成功。为了避免 ui 的实际渲染，可以使用 react-test-renderer 等模拟渲染库来生成虚拟的 react 渲染树。jest –updateSnapshot 命令可用于重新生成快照。快照测试也可以用于测试 json 数据；对于动态 json 数据，可以使用匹配器的方式进行快照测试。快照测试可参看 Snapshot Testing、Testing with Jest Snapshots: First Impressions、Jest 14.0: React Tree Snapshot Testing。 12345678910import React from 'react';import Link from '../Link.react';import renderer from 'react-test-renderer';it('renders correctly', () =&gt; &#123; const tree = renderer .create(&lt;Link page=\"http://www.facebook.com\"&gt;Facebook&lt;/Link&gt;) .toJSON(); expect(tree).toMatchSnapshot();&#125;); jest 允许使用 beforeEach、afterEach、beforeAll、afterAll 函数在测试之前或之后作一些前置或后置处理。beforeEach、afterEach 在每个测试用例执行前都会调用；beforeAll、afterAll 在每个测试用例执行前只会被调用一次。test 函数可以用来构建测试用例；describe 函数可以用来构建多个 test 构成的测试套件。beforeEach、afterEach、beforeAll、afterAll 函数如果写在 describe 测试套件内，则只对这个测试套件有效。可参考 Setup and Teardown。 jest.fn 可用于构建一个模拟函数（模拟函数的功能，如 jest.fn(x =&gt; 42 + x)，可作为回调测试功能脚本）；可用于构建一个模拟类（如 new jest.fn()），测试实例；可使用 mockReturnValueOnce、mockReturnValue 直接构建返回值。jest.mock(modulePath) 可用于模拟模块（如 jest.mock(‘axios’).get.mockResolvedValue(resp) 用于模拟 ajax 请求返回值）。可参考 Mock Functions。编写模拟脚本可参考 Manual Mocks。 jest-changed-files 库可用于查看哪些文件作了修改或项目中包含的 git 仓库。jest-diff 库可用于比较对象。jest-docblock 可抽取并解析 js 脚本头部的注释。jest-get-type 库可用于获取数据的类型。jest-validate 库可用于校验用户提交。jest-worker 库可用于并行化执行任务。pretty-format 库可用于对象格式转换。可参考 Jest Platform。jest 社区提供了 vscode-jest、jest-extended、eslint-plugin-jest、awesome-jest 库。 配置 verbose：每个测试脚本是否独立打印。 setupFiles：指定测试脚本执行前用于构建测试环境的模块。 moduleFileExtensions：测试脚本所加载的模块扩展名。 modulePathIgnorePatterns：忽略的模块正则。 testPathIgnorePatterns：忽略的测试正则。 testRegex：测试文件正则。 collectCoverageFrom：覆盖率测试所需包含的文件。 moduleNameMapper：正则到模块名的 map 映射，这些模块将不会被模拟，无论启动自动模拟与否。 transform：正则到 transformer 转译器的 map 映射。转译器负责将使用最新语法写成的脚本（包含 ts、es6）转换成 es5 语法。jest 官网提供的自定义转译器如 babel-transformer，用于替换 babel-jest。 transformIgnorePatterns：转译器忽略的文件正则。 snapshotSerializers：快照序列化模块。 testURL：测试用的 jsdom 环境，应用于获取 location.href。 globals：测试用的全局变量。 apiGlobals beforeAll(fn, timeout)、afterAll(fn, timeout)：测试脚本调用前执行一次。 beforeEach(fn, timeout)、afterEach(fn, timeout)：每个测试脚本调用时均执行一次。 describe(name, fn)、describe.each(table)(name, fn, timeout)、describe.only(name, fn)、describe.only.each(table)(name, fn)、describe.skip(name, fn)、escribe.skip.each(table)(name, fn)：测试套件。 test(name, fn, timeout)、test.each(table)(name, fn, timeout)：编写测试脚本，test 可以使用 it 替换。 test.only(name, fn, timeout)、test.only.each(table)(name, fn)：只执行某测试脚本。 test.skip(name, fn)、test.skip.each(table)(name, fn)：跳过的测试脚本。 test.todo(name)：待添加的测试脚本，高亮显示。 Expect expect.extend(matchers)：设置额外的匹配器 { [matcherName]: () =&gt; ({ message: Function, pass: boolean }) }，匹配器可以是 async 函数。匹配器可以通过 expect(value)[matcherName] 调用。 expect.addSnapshotSerializer(serializer)：添加快照序列化函数。 expect(value)：value 为实际值。 expect(value).resolves、expect(value).rejects：promise 返回值。 expect(value).not：取反，如 expect.not.arrayContaining(array)。 except(mockFn).toBe(value)：判断相符。 except(mockFn).toHaveBeenCalled()、except(mockFn).toBeCalled()：判断模拟函数被调用。 except(mockFn).toHaveBeenCalledTimes(number)、except(mockFn).toBeCalledTimes(number)：判断模拟函数以指定参数被调用次数。 except(mockFn).toHaveBeenCalledWith(arg1, arg2, …)、except(mockFn).toBeCalledWith(arg1, arg2, …)：判断模拟函数以指定参数调用。 except(mockFn).toHaveBeenLastCalledWith(arg1, arg2, …)、except(mockFn).lastCalledWith(arg1, arg2, …)：判断模拟函数最后一次以指定参数调用。 except(mockFn).toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)、except(mockFn).nthCalledWith(nthCall, arg1, arg2, …)：判断模拟函数以指定参数形式调用。 except(mockFn).toHaveReturned()、except(mockFn).toReturn()：判断模拟函数正常返回。 except(mockFn).toHaveReturnedTimes(number)、except(mockFn).toReturnTimes(number)：判断模拟函数返回值次数。 except(mockFn).toHaveReturnedWith(value)、except(mockFn).toReturnWith(value)：判断模拟函数返回了指定值。 except(mockFn).toHaveLastReturnedWith(value)：判断模拟函数的最后一个返回值。 except(mockFn).toHaveNthReturnedWith(nthCall, value)：判断模拟函数第 n 次返回结果是否为某值。 except(value).toHaveLength(number)：判断长度。 except(value).toHaveProperty(keyPath, value?)：判断对象是否包含某属性。 except(value).toBeCloseTo(number, numDigits?)、except(value).toBeGreaterThan(number)、except(value).toBeGreaterThanOrEqual(number)、except(value).toBeLessThan(number)、except(value).toBeLessThanOrEqual(number)：比较数值。 except(value).toBeInstanceOf(Class)：判断是否实例。 except(value).toBeNull()、except(value).toBeTruthy()、except(value).toBeFalsy()、except(value).toBeDefined()、except(value).toBeUndefined()、except(value).toBeNaN()：匹配 null、true、false、undefined 或 NaN 等。 except(value).toContain(item)、except(value).toContainEqual(item)：判断数组是否包含某元素。 except(value).toMatch(regexpOrString)：匹配正则或字符串。 except(value).toMatchObject(object)：匹配对象。 except(value).toMatchSnapshot(propertyMatchers?, hint?)、except(value).toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)：匹配快照。 expect(value).toEqual(value)、expect(value).toStrictEqual(value)：期望等值，toStrictEqual 方法额外会比较 undefined 值等。 expect(value).toThrow(error?)：期望报错。 expect(value).toThrowErrorMatchingSnapshot(hint?)、expect(value).toThrowErrorMatchingInlineSnapshot(inlineSnapshot)：期望报错内容与快照相符。 Mock Functions模拟函数 Mock Functions 也被称为 spies，它可用于监控函数的行为，不止于测试输出。jest.fn() 可用于创建模拟函数，如果参数没有传入实现，那么将返回默认值 undefined。以下 api 列表中，mockFn 等价于 jest.fn()： mockFn.mockImplementation(fn)、mockFn.mockImplementationOnce(fn)：设置模拟函数的实现，等价于 jest.fn(fn)。 mockFn.mockReturnThis()：模拟返回 this。 mockFn.mockReturnValue(value)、mockFn.mockReturnValueOnce(value)：模拟返回值。 mockFn.mockResolvedValue(value)、mockFn.mockResolvedValueOnce(value)：模拟 promise 返回值。 mockFn.mockRejectedValue(value)、mockFn.mockRejectedValueOnce(value)：模拟 promise 拒绝值。 mockFn.mockName(value)、mockFn.getMockName()：作为引用替代 jest.fn()。 mockFn.mock.calls：获取 jest.fn 调用时获得的参数，[[ arg1, arg2 ], [arg3]] 形式。 mockFn.mock.results：获取 jest.fn 的返回值，[{ type, value }] 形式。type 值可以是 ‘return’、’throw’、’incomplete’。 mockFn.mock.instances：获取以 jest.fn 作为构造函数的实例。 mockFn.mockClear：重置 mockFn.mock.calls、mockFn.mock.instances。 mockFn.mockReset：重置 mockFn.mock.calls、mockFn.mock.instances 以及返回值或实现 implementation。 mockFn.mockRestore：重置 mockFn.mock.calls、mockFn.mock.instances 以及返回值和实现 implementation。 Jest Object jest.disableAutomock、jest.enableAutomock：是否对外部引入的模块开启自动模拟功能。自动模拟功能一旦开启，模块导出方法将包含 _isMockFunction 属性，测试时须为真值；若非真值，则测试失败。 jest.genMockFromModule(modulePath)：加载模块，模块在加载时会按自动模拟机制带上 mock 属性，测试时须为真值。该方法通常可配合制作模拟模块，然后使用该方法进行加载。对于函数，该方法会创建模拟函数（该函数没有形参，且返回值也是 undefined）（该方法对 async 函数也有效）；对于类，该方法会创建新的类，且保留原有接口；对于对象，该方法会以深拷贝的方式模拟该对象；对于数组，该方法会创建一个与原数组长度相同、但元素为空值的数组；对于 string, number, bigint, boolean, null, undefined, symbol 原始类型，该方法会创建相同的模拟值。 jest.mock(moduleName, factory, options)：模拟一个模块，jest 会使用自动模拟机制为模块添加模拟版本号。如果没有传入 factory，模拟模块将是返回 undefined 的函数；factory 可以作为模拟函数。 jest.unmock(moduleName)：加载模块时不会使用自动模拟机制。 jest.doMock(moduleName, factory, options)：当使用 babel-jest 转译时，jest.mock 会提升到测试脚本的顶部，jest.doMock 不会。jest.doMock 适合用于模拟同一模块的不同导出，该模块在测试脚本中仍需要加载。 jest.dontMock(moduleName)：当使用 babel-jest 转译时，jest.unmock 会提升到测试脚本的顶部，jest.dontMock 不会。 jest.setMock(moduleName, moduleExports)：指定模块返回的模拟对象。 jest.requireActual(moduleName)：获取实际的模块，用于构建模拟对象。 jest.requireMock(moduleName)：为模块构建一个模拟对象。 jest.resetModules()：重置所有加载的模块。 jest.isolateModules(fn)：创建沙箱，用于以回调形式加载模块。 jest.fn(implementation)、jest.isMockFunction(fn)：创建模拟函数。 jest.spyOn(object, methodName)：追踪 object[methodName] 方法的调用情况。若想为 object[methodName] 创建模拟函数，可以使用 jest.spyOn(object, methodName).mockImplementation(() =&gt; customImplementation)、object[methodName] = jest.fn(() =&gt; customImplementation)。 jest.spyOn(object, methodName, accessType?)：监听访问器的调用情况，accessType 可以是 get 或者 set。 jest.clearAllMocks()、jest.resetAllMocks()：重置 mock.calls、mock.instances。 jest.restoreAllMocks()：将模拟函数重置为初始值。 jest.useFakeTimers()：模拟 setTimeout, setInterval, clearTimeout, clearInterval, nextTick, setImmediate, clearImmediate。 jest.useRealTimers()：采用实际的 setTimeout, setInterval, clearTimeout, clearInterval, nextTick, setImmediate, clearImmediate。 jest.runAllTicks()：等价于使用 process.nextTick 执行 micro-task 队列。 jest.runAllTimers()：等价于使用 setTimeout, setInterval, setImmediate 执行 macro-task 队列以及 process.nextTick 执行 micro-task 队列。 jest.runAllImmediates()：等价于调用 setImmediate。 jest.advanceTimersByTime(msToRun)、jest.runTimersToTime(msToRun)：等价于使用 setTimeout, setInterval, setImmediate 执行 macro-task 队列。 jest.runOnlyPendingTimers()：等价于使用 setTimeout, setInterval 执行被中断的 macro-task 队列（新添加的 macro-task 依旧不会执行）。 jest.advanceTimersToNextTimer(steps)：提前执行下一个 timeout 或 interval。 jest.clearAllTimers()：中止所有计时器。 jest.getTimerCount()：获取待执行的计时器个数。 jest.setTimeout(timeout)：设置计时。 jest.retryTimes(count)：定时器重试。 参考React应用下的单元测试JavaScript – 使用Jest和Webpack别名进行测试在vue中如何配置Jest","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"}]},{"title":"聊聊组件库中样式文件组织","slug":"frontend/antd/聊聊组件库中样式文件组织","date":"2019-12-21T16:00:00.000Z","updated":"2020-03-08T10:25:19.291Z","comments":true,"path":"2019/12/22/frontend/antd/聊聊组件库中样式文件组织/","link":"","permalink":"http://xzfyu.com/2019/12/22/frontend/antd/聊聊组件库中样式文件组织/","excerpt":"","text":"antdantd 基于 normalize.css 制作了重置样式 base.less。 按 babel-plugin-import 按需加载功能的实现机制，样式文件须放在 style 文件夹下，并以 index 文件形式导出。 色彩模式antd 定义了一套 色彩模式（Color Palettes）。可以发现，antd 中的 colorPalette.less 与 @ant-design/color 有相同的实现：基于 tinycolor2 以 Hue - Saturation - Value （色调-饱和度-明度）模型处理颜色，通过旋转色相、增减饱和度、增减亮度的方式生成色板。基本原理可以参考 Ant Design 色板生成算法演进之路。通过这篇文章，也能了解到 antd 中提供 颜色的贝塞尔曲线算法 的意义，贝塞尔曲线的算法实现来自于 bezier-easing。。有所差别的是，在 antd 组件库中，基于主色生成色板的 generate 函数使用 less 函数制作。关于 less 函数，可参考 less-mixin 之 @functions 趣谈。 动效antd 使用 make-motion(@className, @keyframeName, @duration) 混入 制作动效，动效的样式类为 @{className}-enter、@{className}-enter-active、@{className}-appear、@{className}-appear-active、@{className}-leave、@{className}-leave-active，动画名为 @{keyframeName}In、@{keyframeName}Out。除此之外，make-motion 混入限定了 animation-duration、animation-fill-mode、animation-play-state 样式。在 make-motion 混入之上，antd 提供 fade 显隐、move 移动、slide 滑动、swing 抖动、zoom 缩放 动效，以及 loadingCircle 加载、点击动画等。 混入除了上文提到的 make-motion 混入以外，antd 还提供了以下混入：clearfix、reset-component、placeholder（用于解决兼容性问题）、iconfont-mixin（字体样式）、operation-uni（可操作的链接文案样式）、size、square、typography-paragraph（段落） 等。 主题antd 基于 less 的 modifyVars 机制实现了定制主题功能，即将可定制的样式定义为 less 变量，随后以 less-loader 引用外部 less 文件的形式实现定制。可定制的样式见于 base.less。 fusion fusion 的重置样式同样来自于 normalize.css。 fusion 的基本样式变量基本如 Design Tokens 设计标注 所示，样式文件可参考 style。 fusion 提供了以下函数：strip-units（移除单位）、is-length（校验是否为合法的 css 长度）、em（将 px 像素转化为 em 单位）、unpack（转化为四值属性，适用于 margin、padding、position）、corner-maker（圆角生成器）、shadow-maker（阴影生成器），可参考 function.scss。 fusion 支持的混入包含 clearfix、ellipsis、multi-line-ellipsis（单多行截取文本）、hide-text、center-tl、center-td、size、position、triangle（三角形生成器）、box-sizing（边框模式）、icon-size、icon-square-size、font-face-handler、button-color、button-size，可参考 mixin.scss。 fusion 又定义了表单控件、蒙层、弹层的基本样式，可参考 utility。 fusion 的组件样式基本由 main.scss、rtl.scss、scss/mixin.scss（混入）、scss/normalize.scss、scss/variable.scss（变量）等文件构成。 elementelement 依循 BEM 规范制作样式。BEN 规范可参考 前端领域的BEM到底是什么。 element 将样式单独抽出为 element-theme-chalk。element 可定制的样式定义在 var.scss 中。 element 支持的混入包含 res（根据断点作媒体查询）、scroll-bar（滚动条）、placeholder、b、e、m、configurable-m、spec-selector、meb、when、extend-rule、share-rule、pseudo（伪类）；utils-user-select、utils-clearfix、utils-vertical-center、utils-ellipsis；button-plain、button-variant、button-size。 element 支持的动画包含 model 显隐、显隐、zoom 缩放等。 组件的样式均由一个 scss 文件编写。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"java 知识点","slug":"backend/java/Java知识点","date":"2019-12-20T16:00:00.000Z","updated":"2020-03-08T11:20:36.633Z","comments":true,"path":"2019/12/21/backend/java/Java知识点/","link":"","permalink":"http://xzfyu.com/2019/12/21/backend/java/Java知识点/","excerpt":"","text":"注解java 注解与 js 装饰器拥有相当不同的实现方式：java 有编译过程，因此可以使用语法约定注解的意义，脱离了编译过程，注解将毫无意义；js 引擎却没有对装饰器给予有效支持，因此 js 装饰器在 babel 等工具中表现为使用高阶函数封装原类或方法。java 注解本质上都是集成了 java.lang.Annotation 的接口，接口名前加 @interface 标识声明。有以下四种元注解可以标识注解的目标、生命周期、是否包含在 JavaDoc 文档中、是否允许子类继承，分别是 @Target、@Retention、@Documented、@Inherited。 @Target 注解包含以下值： ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上 ElementType.FIELD：允许作用在属性字段上 ElementType.METHOD：允许作用在方法上 ElementType.PARAMETER：允许作用在方法参数上 ElementType.CONSTRUCTOR：允许作用在构造器上 ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上 ElementType.ANNOTATION_TYPE：允许作用在注解上 ElementType.PACKAGE：允许作用在包上 @Retention 注解包含以下值： RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件 RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件 RetentionPolicy.RUNTIME：永久保存，可以反射获取 更多内容参考 JAVA 注解的基本原理。 类加载器java 文件经编译器编译成 class 文件，class 文件由虚拟机加载并创建对应的 java.lang.Class 对象实例。虚拟机提供了三种类加载器：Bootstrap 启动类加载器、Extension 扩展类加载器、System 系统类加载器。启动类加载器主要加载的虚拟机自身所需的类（使用 C++ 实现），包含 &lt;JAVA_HOME&gt;/lib 路径下的核心类库以及 -Xbootclasspath 参数指定路径下的 jar 包。扩展类加载器负责加载”标准的扩展“，包含 &lt;JAVA_HOME&gt;/lib/ext 目录下或者由系统变量 -Djava.ext.dir 指定路径中的类库。系统类加载器负责加载系统类路径 java -classpath 或 -D java.class.path 指定路径下的类库。虚拟机对 class 文件采用按需加载的方式，并使用双亲委派模式，即先有父类加载器处理，如果加载失败，再交由子类加载器处理。类加载器的典型使用如下： 123456// 1. 创建 URL 资源URL url = new URL(\"file:///path/to/plugin.jar\");// 2. 创建 URLClassLoader 实例，URLClassLoader 会通过给定的 URL 加载类URLClassLoader pluginLoader = new URLClassLoader(new URL[] &#123; url &#125;);// 3. 加载指定包下的类Class&lt;?&gt; cl = pluginLoader.loadClass(\"mypackage.MyClass\"); 自定义的加载器可以通过集成 ClassLoader 实现。ClassLoader#loadClass 方法的职责是将类的加载操作委托给父类加载器，当父类加载器无法加载时，就会转而使用 ClassLoader#findClass。因此自定义的加载逻辑推荐实现在 ClassLoader#findClass 方法中。 每个线程都由对类加载器的引用，称为上下文类加载器。主线程的上下文加载器是系统类加载器。当新线程创建时，它的上下文类加载器会被设置成创建该线程的上下文类加载器。线程的上下文类加载器可以通过 thread#setContextClassLoader 方法改写。 更多内容参考 深入理解Java类加载器。 反射java 的反射机制用于动态获取任意一个对象的方法和属性等信息以及动态调用对象方法。更多内容参考 Java高级特性——反射。 代理","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"java","slug":"backend/java","permalink":"http://xzfyu.com/categories/backend/java/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"}]},{"title":"RMI","slug":"backend/远程通信/RMI","date":"2019-12-20T16:00:00.000Z","updated":"2020-03-08T11:20:09.048Z","comments":true,"path":"2019/12/21/backend/远程通信/RMI/","link":"","permalink":"http://xzfyu.com/2019/12/21/backend/远程通信/RMI/","excerpt":"","text":"RMI分布式编程即当客户端调用某方法时，产生一个请求发送到服务器上，然后取回响应。RMI（远程方法调用）的实现思路植根于：在客户端和服务端均安装代理，由客户端代理将客户端方法调用转换成请求（包含服务器地址、所调用方法、传参等信息），服务端代理通过请求执行服务端方法，并向客户端发送响应。服务端接口实例（实现 Remote 接口、扩展 UnicastRemoteObject 类）须通过 InitialContext 实例注册到 RMI 注册表中，客户端就可以通过 InitialContext#list 或 InitialContext#lookup 方法获取到代理对象（称为存根）。 RPCweb 服务参考RMI与RPC的区别Java RMI 简介及其优劣势总结EJB到底是什么？什么是RPC？","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"远程通信","slug":"backend/远程通信","permalink":"http://xzfyu.com/categories/backend/远程通信/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"}]},{"title":"聊聊 antd 网站是怎么制作的","slug":"frontend/antd/聊聊 antd 网站是怎么制作的","date":"2019-12-20T16:00:00.000Z","updated":"2020-03-08T10:25:21.460Z","comments":true,"path":"2019/12/21/frontend/antd/聊聊 antd 网站是怎么制作的/","link":"","permalink":"http://xzfyu.com/2019/12/21/frontend/antd/聊聊 antd 网站是怎么制作的/","excerpt":"","text":"翻看 ant-design 仓库，可以发现以下形式的 markdown 文档，这篇文章旨在于解答这样一个问题：ant design 是怎样把这些文档渲染成页面的。 12345678910111213141516171819202122232425262728293031// ant-design Button 组件 demo// 注释：元数据内容---order: 0title: zh-CN: 按钮类型 en-US: Type---// 注释：主体内容## zh-CN按钮有五种类型：主按钮、次按钮、虚线按钮、危险按钮和链接按钮。主按钮在同一个操作区域最多出现一次。## en-USThere are `primary` button, `default` button, `dashed` button, `danger` button and `link` button in antd.```jsximport &#123; Button &#125; from 'antd';ReactDOM.render( &lt;div&gt; &lt;Button type=\"primary\"&gt;Primary&lt;/Button&gt; &lt;Button&gt;Default&lt;/Button&gt; &lt;Button type=\"dashed\"&gt;Dashed&lt;/Button&gt; &lt;Button type=\"danger\"&gt;Danger&lt;/Button&gt; &lt;Button type=\"link\"&gt;Link&lt;/Button&gt; &lt;/div&gt;, mountNode,); 在深入具体实现之前，先简要描述下 ant-design 的大致处理思路。为了将 markdown 文档渲染成静态网页，我们可以使用 webpack 加载器逐个加载 markdown 文件，在加载器中借助 markdown-it 解析这些文件（element-ui 就是基于 markdown-it-chain 实现的）（fusion 通过 node 服务在服务端使用 remark 解析 markdown 文件）。与此不同的是，ant-design 并没有采用显式逐个加载 markdown 文件的方式，而是制作 entry 入口文件。入口文件使用 import 语句导入了占位用的 data.js 文件；在 data.js 文件加载过程中，ant-design 借助 webpack 加载器机制将指定目录的 markdown 文件解析成数据，作为 data.js 占位文件的加载内容。这一部分工作由 bisheng 完成。以下是 bisheng 启动开发服务器的主要流程。 我们把 ant-design 网站的渲染机制分为两个部分：markdown 数据生成、markdown 数据渲染。 markdown 数据生成mark-twainmark-twain 首先借助 yaml-front-matter 将 markdown 解析成 json 对象（该对象的 _content 属性为 markdown 中的主体内容），然后通过 remark 将 _content 内容解析成抽象语法树，最后由 mark-twain 的 转换器 将抽象语法树中的 root 等节点替换成可渲染的 html 节点。 yaml-front-matter 自身借助 js-yaml 实现。 1234567891011121314151617181920&#123; \"meta\": &#123; \"order\": 0, \"title\": &#123; \"zh-CN\": \"按钮类型\", \"en-US\": \"Type\" &#125; &#125;, \"content\": [ \"article\", [\"h2\", \"zh-CN\"], [\"p\", \"按钮有五种类型：主按钮、次按钮、虚线按钮、危险按钮和链接按钮。主按钮在同一个操作区域最多出现一次。\"], [\"h2\", \"en-US\"], [\"p\", \"There are `primary` button, `default` button, `dashed` button, `danger` button and `link` button in antd.\"], [ \"pre\", &#123; \"lang\": \"jsx\" &#125;, &#123; \"code\": \"import &#123; Button &#125; from 'antd';...\" &#125; ]&#125; bishengbisheng 在 mark-twain 的基础上，使用 child-process 启动多进程解析 markdown 文件，编译任务通过 node 进程的通信机制从主进程流入到子进程中，编译结果也通过 node 进程的通信机制从子进程带出到主进程中，详情可以参看 boss.js。实际的编译操作见于 source-data.js 文件，即如下： 1234567891011121314151617181920212223242526272829// process 方法会在子进程被使用exports.process = ( filename,// markdown 文件名 fileContent,// markdown 文件内容 plugins,// 插件 transformers = [],// 转换函数，包含内置的 transformers/markdown（使用 mark-twain 编译） isBuild,// 是否生产环境) =&gt; &#123; let transformerIndex = -1; // 对于不同的文件使用不同的 transformer transformers.some((&#123; test &#125;, index) =&gt; &#123; transformerIndex = index; return eval(test).test(filename); // eslint-disable-line no-eval &#125;); const transformer = transformers[transformerIndex]; // 编译 const markdown = require(transformer.use)(filename, fileContent); // 使用插件进行处理，包含内置插件 bisheng-plugin-highlight 用于处理 jsx 等脚本 // 以及 bisheng-plugin-description、bisheng-plugin-toc、bisheng-plugin-antd、bisheng-plugin-react const parsedMarkdown = plugins.reduce( (markdownData, plugin) =&gt; require(plugin[0])(markdownData, plugin[1], isBuild === true), markdown, ); return parsedMarkdown;&#125;; 上文解释了 markdown 文件一旦被加载，它就会通过 process 方法被编译成 json 数据并输出。那么，markdown 文件是怎么被加载的呢？我们可以在 updateWebpackConfig.js 文件中找到如下代码： 1234567webpackConfig.module.rules.push(&#123; test(filename) &#123; return filename === path.join(bishengLib, 'utils', 'data.js') || filename === path.join(bishengLib, 'utils', 'ssr-data.js'); &#125;, loader: path.join(bishengLibLoaders, 'bisheng-data-loader'),&#125;); 即在加载占位用的 data.js 文件时，bisheng 会使用内置的 bisheng-data-loader 加载器加以处理。这个加载器的作用无他，就是扫描 bishengconfig 配置的 source 源文件夹下的 markdown 文件（bisheng 通过 ramda 将 markdown 文件解析成树形结构），并调用 boss.js 进行解析。这里干脆贴出附带说明的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970module.exports = function bishengDataLoader(/* content */) &#123; if (this.cacheable) &#123; this.cacheable(); &#125; const &#123; bishengConfig, themeConfig &#125; = context; // markdown 全量文件 const markdown = sourceData.generate(bishengConfig.source, bishengConfig.transformers); const browserPlugins = resolvePlugins(themeConfig.plugins, 'browser'); const pluginsString = browserPlugins .map(plugin =&gt; `[require('$&#123;plugin[0]&#125;'), $&#123;JSON.stringify(plugin[1])&#125;]`) .join(',\\n'); const callback = this.async(); const picked = &#123;&#125;; const pickedPromises = []; // Flag to remind loader that job is done. if (themeConfig.pick) &#123; const nodePlugins = resolvePlugins(themeConfig.plugins, 'node'); // 遍历 markdown 文件并作解析 sourceData.traverse(markdown, (filename) =&gt; &#123; const fileContent = fs.readFileSync(path.join(process.cwd(), filename)).toString(); pickedPromises.push(new Promise((resolve) =&gt; &#123; boss.queue(&#123; filename, content: fileContent, plugins: nodePlugins, transformers: bishengConfig.transformers, isBuild: context.isBuild, // 回调处理解析内容，包含 pick 分块 callback(err, result) &#123; const parsedMarkdown = eval(`($&#123;result&#125;)`); // eslint-disable-line no-eval Object.keys(themeConfig.pick).forEach((key) =&gt; &#123; if (!picked[key]) &#123; picked[key] = []; &#125; const picker = themeConfig.pick[key]; const pickedData = picker(parsedMarkdown); if (pickedData) &#123; picked[key].push(pickedData); &#125; &#125;); resolve(); &#125;, &#125;); &#125;)); &#125;); &#125; // 将数据内容回写到 data.js 占位文件中 Promise.all(pickedPromises) .then(() =&gt; &#123; const sourceDataString = sourceData.stringify(markdown, &#123; lazyLoad: themeConfig.lazyLoad, &#125;); callback( null, 'module.exports = &#123;' + `\\n markdown: $&#123;sourceDataString&#125;,` + `\\n picked: $&#123;JSON.stringify(picked, null, 2)&#125;,` + `\\n plugins: [\\n$&#123;pluginsString&#125;\\n],` + '\\n&#125;;', ); &#125;);&#125;; markdown 数据渲染路由信息解析后的 markdown 数据会经由入口文件流入到路由信息获取函数中。入口文件负责直接调用路由信息获取函数，以供 react-router 使用。一般情况下，仅需要根据访问路径获取到对用的 markdown 数据，并使用配置约定的 React 组件进行渲染即可；特殊情况下，需要对流入组件的 props 数据进行转换（比如 Button 组件的 demo 数据就需要先添加到 props 中），这时会使用 collector 收集齐加以处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// ant-design 中的路由配置module.exports = &#123; routes: &#123; path: '/', component: './template/Layout/index', indexRoute: &#123; component: homeTmpl &#125;, childRoutes: [ &#123; path: 'app-shell', component: appShellTmpl, &#125;, &#123; path: 'index-cn', component: homeTmpl, &#125;, &#123; path: 'docs/react/:children', component: contentTmpl, &#125;, &#123; path: 'changelog', component: contentTmpl, &#125;, &#123; path: 'changelog-cn', component: contentTmpl, &#125;, &#123; path: 'components/:children/', component: contentTmpl, &#125;, &#123; path: 'docs/spec/:children', component: contentTmpl, &#125;, ], &#125;&#125;// bisheng 中的路由信息获取函数，data 为解析后的 markdown 全量数据function getRoutes(data) &#123; // 根据路由配置中的渲染组件以及 location 中的路由参数获得渲染函数 function templateWrapper(template, dataPath = '') &#123; const Template = require(`&#123;&#123; themePath &#125;&#125;/template$&#123;template.replace(/^\\.\\/template/, '')&#125;`); return (nextState, callback) =&gt; &#123; // 生成实际访问路径信息 const propsPath = calcPropsPath(dataPath, nextState.params); // 从全量的 markdown 数据中获取访问路径对应的 markdown 数据 const pageData = exist.get(data.markdown, propsPath.replace(/^\\//, '').split('/')); // utils.exist 判断 markdown 数据是否包含指定 key 键的信息 // utils.toReactComponent 根据 markdown 数据获得渲染组件 const utils = generateUtils(data, nextState); // collector 用于处理 props const collector = (Template.default || Template).collector || defaultCollector; const dynamicPropsKey = nextState.location.pathname; const nextProps = &#123; ...nextState, themeConfig, data: data.markdown,// 全量 markdown 数据 picked: data.picked,// 分块的 markdown 数据 pageData, utils, &#125;; collector(nextProps) .then((collectedValue) =&gt; &#123; try &#123; const Comp = Template.default || Template; Comp[dynamicPropsKey] = &#123; ...nextProps, ...collectedValue &#125;; callback(null, Comp); &#125; catch (e) &#123; console.error(e) &#125; &#125;) .catch((err) =&gt; &#123; const Comp = NotFound.default || NotFound; Comp[dynamicPropsKey] = nextProps; callback(err === 404 ? null : err, Comp); &#125;); &#125;; &#125; // 获取 theme 配置中的路由配置 const themeRoutes = JSON.parse('&#123;&#123; themeRoutes | safe &#125;&#125;'); const routes = Array.isArray(themeRoutes) ? themeRoutes : [themeRoutes]; // 基于路由配置生成 react-router 中可用的路由信息 function processRoutes(route) &#123; if (Array.isArray(route)) &#123; return route.map(processRoutes); &#125; return Object.assign(&#123;&#125;, route, &#123; onEnter: () =&gt; &#123; if (typeof document !== 'undefined') &#123; // 加载进度条 NProgress.start(); &#125; &#125;, component: undefined, getComponent: templateWrapper(route.component, route.dataPath || route.path), indexRoute: route.indexRoute &amp;&amp; Object.assign(&#123;&#125;, route.indexRoute, &#123; component: undefined, getComponent: templateWrapper( route.indexRoute.component, route.indexRoute.dataPath || route.indexRoute.path, ), &#125;), childRoutes: route.childRoutes &amp;&amp; route.childRoutes.map(processRoutes), &#125;); &#125; const processedRoutes = processRoutes(routes); processedRoutes.push(&#123; path: '*', getComponents: templateWrapper('./template/NotFound'), &#125;); return processedRoutes;&#125;;// ant-design 中获取组件文档的 collectorcollect(async nextProps =&gt; &#123; const &#123; pathname &#125; = nextProps.location; // 访问路径 const pageDataPath = pathname.replace('-cn', '').split('/'); // 根据访问路径获取对应的 markdown 数据 const pageData = isChangelog(pathname) ? nextProps.data.changelog.CHANGELOG : nextProps.utils.get(nextProps.data, pageDataPath); if (!pageData) &#123; throw 404; // eslint-disable-line no-throw-literal &#125; const locale = utils.isZhCN(pathname) ? 'zh-CN' : 'en-US'; const pageDataPromise = typeof pageData === 'function' ? pageData() : (pageData[locale] || pageData.index[locale] || pageData.index)(); const demosFetcher = nextProps.utils.get(nextProps.data, [...pageDataPath, 'demo']); // 获取组件 demo 数据 if (demosFetcher) &#123; const [localizedPageData, demos] = await Promise.all([pageDataPromise, demosFetcher()]); return &#123; localizedPageData, demos &#125;; &#125; return &#123; localizedPageData: await pageDataPromise &#125;;&#125;)(MainContent); 组件面板以下仅贴示 ant-design 组件的渲染类源码，不再详作介绍。想要在 codepen 中访问组件 demo，需要把特定数据内容提交到 https://codepen.io/pen/define；同样的，将特定数据提交到 https://codesandbox.io/api/v1/sandboxes/define，组件 demo 就能在 codesandbox 中访问了；通过使用 @stackblitz/sdk 能使组件 demo 在 stackblitz 中访问。在上述三个第三方应用访问组件 demo 的过程中，ant design 会使用 Google Analytics 作记录。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class ComponentDoc extends React.Component &#123; render() &#123; // ... // 组件 demo 处理 showedDemo .sort((a, b) =&gt; a.meta.order - b.meta.order) .forEach((demoData, index) =&gt; &#123; const demoElem = ( &lt;Demo &#123;...demoData&#125; key=&#123;demoData.meta.filename&#125; utils=&#123;utils&#125; expand=&#123;expandAll&#125; location=&#123;location&#125; /&gt; ); if (index % 2 === 0 || isSingleCol) &#123; leftChildren.push(demoElem); &#125; else &#123; rightChildren.push(demoElem); &#125; &#125;); // ... return ( &#123; /* ... */ &#125; &lt;Row gutter=&#123;16&#125;&gt; &#123; /* 左侧 demo 面板，或者一屏展示 demo */ &#125; &lt;Col span=&#123;isSingleCol ? 24 : 12&#125; className=&#123;isSingleCol ? 'code-boxes-col-1-1' : 'code-boxes-col-2-1'&#125; &gt; &#123;leftChildren&#125; &lt;/Col&gt; &#123; /* 右侧 demo 面板 */ &#125; &#123;isSingleCol ? null : ( &lt;Col className=\"code-boxes-col-2-1\" span=&#123;12&#125;&gt; &#123;rightChildren&#125; &lt;/Col&gt; )&#125; &lt;/Row&gt; &#123; /* ... */ &#125; ) &#125;&#125;class Demo extends React.Component &#123; render() &#123; // 组件 demo 文档经 bisheng 插件处理后会生成 preview 渲染函数，渲染函数注入 React, ReactDOM 完成渲染 // 或组件 demo 文档直接输出 src 进行渲染 if (!this.liveDemo) &#123; this.liveDemo = meta.iframe ? ( &lt;BrowserFrame&gt; &lt;iframe src=&#123;src&#125; height=&#123;meta.iframe&#125; title=\"demo\" /&gt; &lt;/BrowserFrame&gt; ) : ( preview(React, ReactDOM) ); &#125; return ( &#123; /* ... */ &#125; &#123; /* 组件 demo 渲染，ErrorBoundary 组件会使用 componentDidCatch 捕获错误 */ &#125; &lt;section className=\"code-box-demo\"&gt; &lt;ErrorBoundary&gt;&#123;this.liveDemo&#125;&lt;/ErrorBoundary&gt; &#123;style ? ( &lt;style dangerouslySetInnerHTML=&#123;&#123; __html: style &#125;&#125; /&gt; // eslint-disable-line ) : null&#125; &lt;/section&gt; &#123; /* ... */ &#125; ) &#125;&#125; ssr 渲染bisheng 会使用启动开发环境同样的流程制作入口文件以及入口 html 模板，与此同时，对于页面级的 markdown 文件，bisheng 会制作 ssr 函数基于 react-router 函数生成其他页面模板。以下是部分源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 打包函数exports.build = function build(program, callback) &#123; // ... webpack(webpackConfig, (err, stats) =&gt; &#123; // 入口文件加载的 js、csss const manifest = getManifest(stats.compilation)[bishengConfig.entryName]; // html 模板 const template = fs.readFileSync(bishengConfig.htmlTemplate).toString(); webpack(ssrWebpackConfig, (ssrBuildErr, ssrBuildStats) =&gt; &#123; if (ssrBuildErr) throw ssrBuildErr; if (ssrBuildStats.hasErrors()) throw ssrBuildStats.toString('errors-only'); require('./loaders/common/boss').jobDone(); const &#123; ssr &#125; = require(path.join(tmpDirPath, `$&#123;entryName&#125;-ssr`)); const fileCreatedPromises = filesNeedCreated.map((file) =&gt; &#123; const output = path.join(bishengConfig.output, file); mkdirp.sync(path.dirname(output)); return new Promise((resolve) =&gt; &#123; const pathname = filenameToUrl(file); ssr(pathname, (error, content, params = &#123;&#125;) =&gt; &#123; if (error) &#123; console.error(error); process.exit(1); &#125; const templateData = Object.assign( &#123; root: bishengConfig.root, content, hash: bishengConfig.hash, manifest, ...params, &#125;, bishengConfig.htmlTemplateExtraData || &#123;&#125;, ); const fileContent = nunjucks.renderString(template, templateData); fs.writeFileSync(output, fileContent); console.log('Created: ', output); resolve(); &#125;); &#125;); &#125;); Promise.all(fileCreatedPromises).then(() =&gt; &#123; if (callback) &#123; callback(); &#125; &#125;); &#125;); &#125;);&#125;;function ssr(url, callback) &#123; ReactRouter.match(&#123; routes, location: url &#125;, (error, redirectLocation, renderProps) =&gt; &#123; if (error) &#123; callback(error, ''); &#125; else if (redirectLocation) &#123; callback(null, ''); // TODO &#125; else if (renderProps) &#123; const helmetContext = &#123;&#125;; try &#123; const content = ReactDOMServer.renderToString( &lt;ReactRouter.RouterContext &#123;...renderProps&#125; createElement=&#123;(Component, props) =&gt; createElement(Component, &#123; ...props, helmetContext &#125;)&#125; /&gt;, ); const helmet = helmetContext.helmet || Helmet.renderStatic(); const documentTitle = DocumentTitle.rewind(); const helmetTitleTmp = helmet.title.toString(); const htmlAttributes = helmet.htmlAttributes.toString(); const meta = helmet.meta.toString(); const link = helmet.link.toString(); const helmentTitle = helmetTitleTmp.match(/&lt;title.*&gt;([^&lt;]+)&lt;\\/title&gt;/) ? helmetTitleTmp.match(/&lt;title.*&gt;([^&lt;]+)&lt;\\/title&gt;/)[1] : ''; // 兼容 DocumentTitle ，推荐使用 react-helmet const title = documentTitle || helmentTitle; // params for extension callback(null, content, &#123; title, meta, link, htmlAttributes, &#125;); &#125; catch (e) &#123; callback(e, ''); &#125; &#125; else &#123; callback(null, ''); // TODO &#125; &#125;);&#125;;function createElement(Component, props) &#123; NProgress.done(); const dynamicPropsKey = props.location.pathname; return &lt;Component &#123;...props&#125; &#123;...Component[dynamicPropsKey]&#125; /&gt;;&#125;;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"我看 spring boot","slug":"backend/spring/我看 spring boot","date":"2019-12-13T16:00:00.000Z","updated":"2020-03-08T11:15:58.619Z","comments":true,"path":"2019/12/14/backend/spring/我看 spring boot/","link":"","permalink":"http://xzfyu.com/2019/12/14/backend/spring/我看 spring boot/","excerpt":"","text":"why &amp; what介于 spring 应用配置较为复杂，spring boot 就应运而生了，其目的即在于简化 spring 项目中依赖的配置流程。因此 spring boot 集成了 spring 的以下能力，或者通过定制 starter 的方式简化了以下能力的配置形式： Web Applications：spring boot 内嵌 Tomcat、Jetty、Undertow、Netty 服务器，便于一键启动；支持使用 spring-boot-starter-webflux 模块启动响应式 web 应用。借助于 spring mvc，spring boot 将自动注册 Converter，用于转换请求和响应；支持通过 JsonSerializer、JsonDeserializer 转化 json 数据；支持使用 FreeMarker、Groovy、Thymeleaf、Mustache 等模板引擎；支持通过 WebMvcConfigurer 定制静态资源位、提供 cors 跨域能力等。可参考 文档。 SQL：提供使用 SQL 数据库的广泛支持，从 JDBC 到对象关系映射框架（如 Hibernate、Mybatis）等。 NoSQL：支持 Redis、MongoDB、Neo4j、Elasticssearch、Solr Cassandra、Couchbase、LDAP 等 NoSQL 数据库。 Caching：允许在方法上使用 @Cachable，该注解将根据请求参数作缓存。默认使用内存缓存，也支持 Generic、JCache、EhCache、Hazelcast、Infinispan、Couchbase、Redis、Caffeine、Simple 等缓存服务（spring boot 会自动检测）。 Hazelcast：支持 Hazelcast 基于内存的数据存储方案。 Quartz Scheduler：支持通过引入 spring-boot-starter-quartz 启用定时器任务，详情可参考 Quartz 定时任务（Scheduler）的 3 种实现方式。 Task Execution and Scheduling：在 Executor 缺席的情况下，spring boot 会自动装配 ThreadPoolTaskExecutor 用于处理异步任务（通过 @EnableAsync 注解使用）或异步请求，线程池的使用也可以通过配置文件约束。可参考 Quartz 定时任务（Scheduler）的 3 种实现方式。 Message：支持 JMS、RabbitMQ、Kafka、WebSocket 等消息系统。 Web Services：自动装配 WebServiceTemplateBuilder，便于创建 WebServiceTemplate 实例以调用远程 web 服务。 Rest Services：自动装配 RestTemplateBuilder，凭此可以创建 RestTemplate 实例，然后调用 rest 服务；同样的，WebClientBuilder 可用于创建 WebClient 实例，然后调用 rest 服务。 WebSockets：会为内置的 Tomcat、Jetty、Undertow 容器自动装配 WebSockets，也允许通过 spring-boot-starter-webflux 模块为响应式应用提供 WebSocket 编程能力。 Validation：借助于 bean 校验机制 —— JSR-303 规范的实现（如 Hibernate validator），spring boot 允许使用 @Validated 对 bean 作校验。 Distributed Transactions：通过使用 Atomikos 或 Bitronix 嵌入式事务管理器，spring boot 支持 JTA 分布式事务编程规范。当探知到 JTA 环境时，JtaTransactionManager 接口就会用于管理事务，JMS、DataSource、JPA 等 bean 也会被自动装配。编码时使用 @Transactional 就可以实现事务管理。可参考 Spring的全局事务JTA。 Logging：支持 Commons Logging、Java Util Logging、Log4J2、Logback 等日志服务。 Testing：支持通过 spring-boot-starter-test 测试应用。spring-boot-starter-test 包含 JUnit 5、Spring Test &amp; Spring Boot Test、AssertJ、Hamcrest、Mockito、JSONassert、JsonPath。 Monitoring：监控，更好地掌握应用的运行状态。 以上能力的大集成或者配置的简化，均借助于 spring boot 的如下特性： SpringApplication：通过劫持 spring 应用启动过程的方式，集中管理配置项。 Externalized Configuration：允许通过 properties、yaml 文件或环境变量、命令行参数等外部配置启动 spring 应用，并能通过 spring.profiles.active 区分不同环境。这些配置项也能通过 @Value、@ConfigurationProperties 绑定到 bean 或结构化对象中。外部配置抽象为 PropertySource，其优先级大体为命令行参数、环境变量、指定 profile 环境的 properties 或 yaml 文件、不含 profile 环境的 properties 或 yaml 文件。 Auto Configuration：允许通过自动配置的定制 starter，用以简化配置流程、自动注入 bean 等。 sampleBasic pom.xml 添加依赖。 123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加启动类和控制类。 1234567891011@SpringBootApplication@RestControllerpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @GetMapping(\"/hello\") public String hello() &#123; return \"hello world\"; &#125;&#125; Auto-configuration通过自动装配技术开发一个 starter，用于在控制台打印每次访问的 URI。示例来自 《Spring Cloud 微服务架构进阶》。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 定义过滤器public class LogFilter implements Filter &#123; private Logger logger = LoggerFactory.getLogger(LogFilter.class); @Override public void init(FilterConfig filterConfig) throws ServletException &#123; logger.info(\"logFilter init...\"); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; logger.info(\"uri () is working.\", request.getRequestURI()); filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destory() &#123; logger.info(\"logFilter destory...\"); &#125;&#125;// 将 LogFilter 封装成 spring beanpublic class LogFilterRegistrationBean extends FilterRegistrationBean&lt;LogFilter&gt;&#123; public LogFilterRegistrationBean()&#123; super(); this.setFilter(new LogFilter()); this.addUrlPatterns(\"/*\"); this.setName(\"LogFilter\"); this.setOrder(1); &#125;&#125;// 定义自动配置类@Configuration@ConditionalOnClass(&#123;LogFilterRegistrationBean.class, LogFilter.class&#125;)public class LogFilterAutoConfiguration &#123; @Bean @ConditionalOnMissingBean(LogFilterRegistrationBean.class) public LogFilterAutoConfiguration logFilterAutoConfiguration() &#123; return new LogFilterRegistrationBean(); &#125;&#125;// 方法 1. 通过注解将配置类引入 spring 扫描范围内，在工程中只要对启动类使用 @EnableLogFilter 注解即可@Target(&#123;ElementType.class&#125;)@Retention(RetentionPolicy.RUNTIME)@Import(LogFilterAutoConfiguration.class)// 引入自动配置类public @interface EnableLogFilter &#123;&#125;// 方法 2. 通过解析 resource/META-INF/spring.factories 加载自动配置类，在工程中同样使用 @EnableLogFilter 注解// org.springframework.boot.autoconfigure.EnableLogFilter=\\// com.mycorp.libx.autoconfigure.LogFilterAutoConfigurationpublic class EnableLogFilterImportSelector implements DeferredImportSelector, BeanClassLoaderAware, EnvironmentAware &#123; private static final Logger logger = LoggerFactor.getLogger(EnableLogFilterImportSelector.class); private Class annotationClass = EnableLogFilter.class; @Override public String[] selectImports(AnnotationMetadata metadata) &#123;// 由 @EnableLogFilter 注解名决定解析属性 if (!isEnabled()) &#123; return new String[0]; &#125; AnnotationAttributes attributes = AnnotationAttributes.fromMap( metadata.getAnnotationAttributes(this.annotationClass.getName(), true) ); Assert.notNull(attributes, \"can not be null...\"); List&lt;String&gt; factories = new ArrayList&lt;&gt;(new LinkedHashSet&lt;&gt;( SpringFactoriesLoader.loadFactoryNames(this.annotationClass, this.beanClassLoader) )); if (factories.isEmpty() &amp;&amp; !hasDefaultFactory()) &#123; throw new IllegalStateException(\"...\"); &#125; if (factories.size() &gt; 1) &#123; logger.warn(\"More than one implemetion\"); &#125; return factories.toArray(new String(factories.size())); &#125;&#125;@Target(&#123;ElementType.class&#125;)@Retention(RetentionPolicy.RUNTIME)@Import(EnableLogFilterImportSelector.class)// 引入自动配置类public @interface EnableLogFilter &#123;// 同步修改 EnableLogFilter&#125; howSpringApplication为了简化 spring 的配置流程，spring boot 通过 SpringApplication 劫持了 spring 的启动过程（通过显式调用 SpringApplication#run 方法启动）。在启动过程中，可定制的 FailureAnalyzer 将分析启动失败的原因并打印在日志上。如果没有错误提示日志，可以尝试 debug 模式启动。SpringApplication 包含但不限于如下功能点： 在 spring 机制的基础上，spring boot 支持 bean 的懒初始化（即在请求到达时才创建 bean），这样可以节省应用启动的时间。缺点是没法在启动过程中发现 bean 的配置问题，也没法保证运行时创建的 bean 不会造成 jvm 内存不足。懒初始化默认禁用，可以使用 java 编码或 lazy-initialization 配置项启用。 允许通过 SpringApplicationBuilder 创建多个 ApplicationContext 实例（构成父子结构的层级关系），环境变量会在 ApplicationContext 实例中共享，web 组件只能运行在子 ApplicationContext 实例上。 spring boot 会根据应用类型是否为 servlet、webflux 或上述两者之外选用不同的 ApplicationContext 实现类。 通过 spring 事件机制，SpringApplication#addListeners 方法或 META-INF/spring.factories 配置可用于添加启动时的事件监听器。子 ApplicationContext 实例的事件会冒泡到父级，需要区分 ApplicationContext。一般不使用事件。 允许使用 ApplicationArguments 接口访问启动参数 args。 以下源码仅简要地展示 SpringApplication 的执行逻辑，其深入部分另作专题分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class SpringApplication &#123; // 首参默认为 null，次参为应用的启动类 public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, \"PrimarySources must not be null\"); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // 判断应用类型：基于 spring mvc 的 servlet 应用、基于 webflux 的响应式应用、以上两种之外 this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 加载 ApplicationContextInitializer，使用类加载机制加载 META-INF/spring.factories 配置中的类 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // 加载 ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 通过 RuntimeException 执行堆栈获取到 ApplicationClass this.mainApplicationClass = deduceMainApplicationClass(); &#125; public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch();// 计算执行时间 stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // environment 实例可用于获取 PropertySources 配置信息、Profiles 环境信息 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment);// 打印 banner // 根据 webApplicationType 应用类型选用 ApplicationContext 实现类并创建实例 // spring 机制：ApplicationContext 实例中的 getBeanFactory 可用于获取 BeanFactory 实例，以便注册 bean context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 调用 ApplicationContext 实例的 refresh 方法 refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context; &#125;&#125;public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123; @Override public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125; &#125;&#125; Auto-configuration自动配置技术通常会用于制作公司内部的公共库或开源库，即如上文 smaple 一节中的制作 starter 部分。配置类通过 @Configuration 注解声明；@ConditionalOnClass、@ConditionalOnMissingBean 等注解声明配置类加载的条件。@ConditionalOnClass 在某个类存在于类路径时予以自动配置；@ConditionalOnMissingBean 在某个 bean （如用户配置类）不存在于 spring 上下文中时予以自动配置。@AutoConfigureAfter、@AutoConfigureBefore、@AutoConfigureOrder、@Order 可用于约束配置类加载的顺序。 自动配置类的加载与否取决于用户配置或其他条件，因此测试自动配置类就会变得困难。因此 spring boot 提供了对自动配置类的测试方法，即通过 ApplicationContextRunner 予以测试。详情可参考 文档。 配置类有两种，spring-boot 内置的配置类、开源库等提供的配置类。对于开源库，上文已经表明，基于 @import 实现 @EnableXxx 注解，就可以自动加载配置类（对于 jar 包，通过自动扫描的方式加载 bean 是无效的，需要使用 @Import 注解去加载这些 bean）。对于内置配置类，spring-boot-autoconfigure 包提供了 @SpringBootApplication 注解，它用于加在启动类上。该注解基于 @EnableAutoConfiguration 注解实现，其能力就是自动加载 META-INF/spring.factories 文件中声明的配置类： 12345678910111213141516171819202122232425262728293031// 通过 @Import、AutoConfigurationImportSelector 自动装配 META-INF/spring.factories 中的配置类@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;&#125;class ImportAutoConfigurationImportSelector extends AutoConfigurationImportSelector implements DeterminableImports &#123;&#125;public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; // 通过 ClassLoader 获取 META-INF/spring-autoconfigure-metadata.properties 资源的 URL，然后解析获取配置信息（默认配置） AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); // 加载 META-INF/spring.factories 配置文件中的自动配置类（即上文中的 LogFilterAutoConfiguration 自动配置类） AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry( autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125;&#125; 后记解读 java 技术属于自不量力，因此文章题名“我看 XXX”，用于表明这些文章既是个性化解读的，又会存在很多错谬。 参考spring boot 官方文档spring boot 启动原理SpringBoot源码研究之StartWebflux 核心深究Spring中Bean的生命周期","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"spring","slug":"backend/spring","permalink":"http://xzfyu.com/categories/backend/spring/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"}]},{"title":"企业应用架构模式","slug":"读书笔记/企业应用架构模式","date":"2019-11-30T16:00:00.000Z","updated":"2019-11-28T13:47:54.865Z","comments":true,"path":"2019/12/01/读书笔记/企业应用架构模式/","link":"","permalink":"http://xzfyu.com/2019/12/01/读书笔记/企业应用架构模式/","excerpt":"","text":"少即是多。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xzfyu.com/categories/读书笔记/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"spring security","slug":"backend/spring/spring security","date":"2019-11-30T16:00:00.000Z","updated":"2020-03-08T11:15:23.072Z","comments":true,"path":"2019/12/01/backend/spring/spring security/","link":"","permalink":"http://xzfyu.com/2019/12/01/backend/spring/spring security/","excerpt":"","text":"认证和授权认证即校验用户的身份。认证的方式有： 使用回话 ID 作匿名认证，此时用户不需要登录，使用场景如论坛中匿名访问帖子； 密码认证（对所有用户，密码都是相同的）；用户名 + 密码认证； 使用 WWW-Authenticate、Authenticate 作基本认证。当服务器接收到一个缺少凭证请求，返回 WWW-Authenticate 响应头；接收响应的浏览器就会弹出模拟窗口，促使用户输入用户名和密码；用户名和密码又会以 base64 编码，并作为 Authenticate 请求头的内容，发送到服务器；等认证成功后，服务器就会返回一个正常的响应。基本认证允许用户将凭证内嵌在 URL 或命令行客户端中，形式如 Wget 或 cURL，具体的值如 http://username:password@www.example.com，那么凭证会自动转换成 Authenticate 头。基本认证可以使用 https 协议提高安全性。 摘要认证。首先客户端发起请求，服务端返回 WWW-Authenticate 响应头中会包含 algorithm（创建哈希值的算法，”MD5” 或 “MD5-sess”）、qop（保护的质量，”auth” 或 “auth-int” 或 “auth,auth-int）、opaque（随机字符串数据，作完整性校验）、nonce（服务器随机数，在两个 401 响应之间永远不会重复，客户端需要发送相同的随机数）。然后客户端再次发送请求，Authenticate 请求头中会包含 algorithm、qop、opaque、nonce 以及 username、uri、nc、cnonce（期望值，每次请求都会重新生成，且不能与 nc 重复）、response。当服务端接受到请求时，将重新计算所有的哈希值，如果最后的哈希值能匹配 response 参数中的值时，认证就通过了。nc、cnonce 在每次发送的请求均会不同，这样可以阻止重放，避免被黑客获知信息。 windows 认证，即使用 windows 域控制器进行验证。IE、Chrome 支持 windows 验证。这一技术已过时，这里列举的目的在于可以使用终端凭证验证用户。 客户端证书认证，最安全的认证协议之一。首先在注册（通常是创建用户名和密码）时，服务器将告知浏览器生成公钥和私钥，浏览器存储私钥，将公钥发送给服务器。自此之后，公钥可以作为服务器识别浏览器的标识，且浏览器会使用私钥对通信进行签名。服务器接收到 https 请求后，将使用服务器 SSL 证书标识自身，并将自己的公钥和使用私钥签名的数据发送给浏览器。 智能卡，就是一个特殊的集成电路，如 ID 卡或磁性员工卡。 生物识别，就是使用指纹、声纹、虹膜扫描、DNA 或用户的其他生物身份去认证用户。 基于声明的认证，如 OAuth、SAML 协议都基于声明的认证机制。用户在访问应用时，应用将重定向到 Auth URL，然后用户携带凭证访问第三方认证提供者（如登录），第三方提供者将提供令牌给用户；用户再携带令牌访问应用，应用会将令牌发送给第三方认证机构作验证，通过认证后便能获取到应用上的资源。基于声明的认证将在下文详解。 多因素认证，即在以上认证的基础上，添加随机数验证（如手机校验码）等手段。 权限模型通常基于活动（用户可操作行为）、角色（用户可操作行为集）、用户组（某类用户可操作行为），阿里的 ACL 权限模型即基于此设计。详细内容另作专题剖析。java.security.Principal 接口可用于实现鉴权操作。当用户通过认证后，程式将用户身份标识存入 Principal 中，应用代码就可以通过检查 Principal（存在于安全上下文中）包含的标识来判断用户是否通过了认证。Principal 也可以保存用户被授权操作的活动，应用代码就可以通过检查 Principal 获得用户的可执行行为。基于声明的授权指的是由第三方认证用户的身份，再由应用识别用户的权限。 Spring SecuritySpring Security 提供了认证和授权服务，也可以防止 csrf 攻击，并提供 jsp 或 Thymeleaf 模板展示用户授权内容等。它基于 spring AOP 以及 servlet 规范中的 filter 机制实现，能够在 Web 请求和方法调用级别处理身份认证和授权。说到底，Spring Security 处理 web 请求的过滤器仍是基于 spring 框架实现的，即通过 AbstractSecurityWebApplicationInitializer 实现 WebApplicationInitializer 接口，并在 onStartup 方法执行过程中使用 servletContext.addFilter 挂载过滤器，内置过滤器是使用 DelegatingFilterProxy 挂载的 SecurityFilterChain，允许用户添加定制的过滤器。 以下是 spring security 加载和配置过滤器的主要实现源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 利用 spring 机制将 SpringSecurityFilterChain 等过滤器注册到 servlet 中public abstract class AbstractSecurityWebApplicationInitializer implements WebApplicationInitializer &#123; public final void onStartup(ServletContext servletContext) throws ServletException &#123; this.beforeSpringSecurityFilterChain(servletContext); if (this.configurationClasses != null) &#123; AnnotationConfigWebApplicationContext rootAppContext = new AnnotationConfigWebApplicationContext(); rootAppContext.register(this.configurationClasses); servletContext.addListener(new ContextLoaderListener(rootAppContext)); &#125; if (this.enableHttpSessionEventPublisher()) &#123; servletContext.addListener(\"org.springframework.security.web.session.HttpSessionEventPublisher\"); &#125; servletContext.setSessionTrackingModes(this.getSessionTrackingModes()); this.insertSpringSecurityFilterChain(servletContext); this.afterSpringSecurityFilterChain(servletContext); &#125; private void insertSpringSecurityFilterChain(ServletContext servletContext) &#123; String filterName = \"springSecurityFilterChain\"; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy(filterName); String contextAttribute = this.getWebApplicationContextAttribute(); if (contextAttribute != null) &#123; springSecurityFilterChain.setContextAttribute(contextAttribute); &#125; this.registerFilter(servletContext, true, filterName, springSecurityFilterChain); &#125; private final void registerFilter(ServletContext servletContext, boolean insertBeforeOtherFilters, String filterName, Filter filter) &#123; Dynamic registration = servletContext.addFilter(filterName, filter); if (registration == null) &#123; throw new IllegalStateException(\"Duplicate Filter registration for '\" + filterName + \"'. Check to ensure the Filter is only configured once.\"); &#125; else &#123; registration.setAsyncSupported(this.isAsyncSecuritySupported()); EnumSet&lt;DispatcherType&gt; dispatcherTypes = this.getSecurityDispatcherTypes(); registration.addMappingForUrlPatterns(dispatcherTypes, !insertBeforeOtherFilters, new String[]&#123;\"/*\"&#125;); &#125; &#125;&#125;// 通过 @Configuration 为 spring-security 添加过滤器、权限规则等@Order(100)public abstract class WebSecurityConfigurerAdapter implements WebSecurityConfigurer&lt;WebSecurity&gt; &#123; public void init(final WebSecurity web) throws Exception &#123; final HttpSecurity http = this.getHttp(); web.addSecurityFilterChainBuilder(http).postBuildAction(new Runnable() &#123; public void run() &#123; FilterSecurityInterceptor securityInterceptor = (FilterSecurityInterceptor)http.getSharedObject(FilterSecurityInterceptor.class); web.securityInterceptor(securityInterceptor); &#125; &#125;); &#125; protected final HttpSecurity getHttp() throws Exception &#123; if (this.http != null) &#123; return this.http; &#125; else &#123; DefaultAuthenticationEventPublisher eventPublisher = (DefaultAuthenticationEventPublisher)this.objectPostProcessor.postProcess(new DefaultAuthenticationEventPublisher()); this.localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher); AuthenticationManager authenticationManager = this.authenticationManager(); this.authenticationBuilder.parentAuthenticationManager(authenticationManager); this.authenticationBuilder.authenticationEventPublisher(eventPublisher); Map&lt;Class&lt;? extends Object&gt;, Object&gt; sharedObjects = this.createSharedObjects(); this.http = new HttpSecurity(this.objectPostProcessor, this.authenticationBuilder, sharedObjects); if (!this.disableDefaults) &#123; ((HttpSecurity)((DefaultLoginPageConfigurer)((HttpSecurity)((HttpSecurity)((HttpSecurity)((HttpSecurity)((HttpSecurity)((HttpSecurity)((HttpSecurity)((HttpSecurity)this.http.csrf().and()).addFilter(new WebAsyncManagerIntegrationFilter()).exceptionHandling().and()).headers().and()).sessionManagement().and()).securityContext().and()).requestCache().and()).anonymous().and()).servletApi().and()).apply(new DefaultLoginPageConfigurer())).and()).logout(); ClassLoader classLoader = this.context.getClassLoader(); // 通过 AbstractHttpConfigurer 子类加载过滤器 List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers = SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader); Iterator var6 = defaultHttpConfigurers.iterator(); while(var6.hasNext()) &#123; AbstractHttpConfigurer configurer = (AbstractHttpConfigurer)var6.next(); this.http.apply(configurer); &#125; &#125; // 执行 configure(HttpSecurity http) 加载用户配置 this.configure(this.http); return this.http; &#125; &#125; protected AuthenticationManager authenticationManager() throws Exception &#123; if (!this.authenticationManagerInitialized) &#123; // 执行 configure(AuthenticationManagerBuilder auth) 加载用户配置 this.configure(this.localConfigureAuthenticationBldr); if (this.disableLocalConfigureAuthenticationBldr) &#123; // 构建 AuthenticationManagerBuilder 实例，AuthenticationManagerBuilder 实例拥有 authenticationProviders 属性管理 AuthenticationProvider 实例 this.authenticationManager = this.authenticationConfiguration.getAuthenticationManager(); &#125; else &#123; this.authenticationManager = (AuthenticationManager)this.localConfigureAuthenticationBldr.build(); &#125; this.authenticationManagerInitialized = true; &#125; return this.authenticationManager; &#125;&#125; 实际上，HttpSecurity 也是基于 filter 实现的，通过 configure 方法配置规则就是配置过滤器。基于 filter，Spring Security 提供以下三个接口用于鉴权： Authentication：扩展自 Principal，包含 getIdentity 方法返回一个代表 Principal 标识的 Object（通常是用户名）；getCredentials 方法返回用于验证用户身份的凭证（只在认证过程中使用，认证结束后被擦除）；isAuthenticated 方法返回是否通过认证；setAuthenticated 修改认证结果（通常也只在认证过程中使用）。 GrantedAuthentication：用以判断用户包含的角色、权限信息。Authentication 接口中的 getAuthorities 方法可用于获取用户的 GrantedAuthentication。 AuthenticationProvider：认证服务的提供者，包含 authenticate 方法以未认证的 Authentication 作为参数，该方法将把 Authentication 标识为已认证，并返回已认证的但完全不同的 Authentication。 Spring Security 既能使用内建的系统如 CAS、JAAS、LDAP、OpenID 鉴权，又能对接 JDBC 或自己的服务或仓库用于鉴权。 结语因为对 spring 机制的不熟悉以及 Spring Security 应用场景有限，笔者的行文仅点到为止。 参考Spring高级篇—Spring Security入门原理及实战Spring Boot Security 详解springSecurity安全框架的学习和原理解读","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"spring","slug":"backend/spring","permalink":"http://xzfyu.com/categories/backend/spring/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"redis","slug":"backend/缓存/redis","date":"2019-11-30T16:00:00.000Z","updated":"2020-03-08T11:18:53.998Z","comments":true,"path":"2019/12/01/backend/缓存/redis/","link":"","permalink":"http://xzfyu.com/2019/12/01/backend/缓存/redis/","excerpt":"","text":"redis 缓存数据库通过 redis-cli 工具操控；并支持使用 EVAL、EVALSHA 命令执行脚本。缓存的数据格式支持字符串、哈希、列表、无序集合、有序集合以及 HyperLogLog，支持使用 EXPIRE 设置某键的过期时间、备份数据和恢复数据。redis 本身是基于客户端-服务端模型以及请求-响应协议实现的 TCP 服务，通过管道（pipeline）的技术可以批量发送并处理请求，节省响应时间。redis 支持基于频道的发布、订阅功能，发布者将消息推送到频道上，就会触发该频道的订阅者执行特定的程式。redis 支持事务和基于 WATCH 实现的乐观锁（当 WATCH 监听的键被其他命令修改时，事务将被打断）。通过主键取模或哈希取模，可以在 redis 服务器上使用多个 redis 实例分区存取数据。等等。 spring-data-redisspring-data-redis 提供了四种创建 redis 数据库连接的连接工厂，即 JedisConnectionFactory、JredisConnectionFactory、LettuceConnection、SrpConnectionFactory，所有的连接工厂都包含 setHostName、setPort、setPassword、getConnection 方法。各连接工厂的 getConnection 方法用于获取 RedisConnection 接口的各种实现类。通过对接 RedisKeyCommands 等 redis 命令的抽象接口，RedisConnection 接口的实现类封装了操纵 redis 数据库的方法，比如 conn.get(“greeting”.getBytes())，进出 redis 数据库的 key、value 键值对都是字节数组形式。详情可以参看 DefaultedRedisConnection 的实现。 为了规避字节数组，spring-data-redis 以模板形式提供了较高等级的数据访问方案，包含的模板有 RedisTemplate、StringRedisTemplate，这些模板用于对出入库的数据执行序列化操作、获取数据出入库的操纵方法 ValueOperations 实现类等。首先基于 ConnectionFactor，spring-data-redis 提供了 RedisConnectionUtils 用于指定连接工厂、创建连接、关闭连接、创建代理连接、管理连接事务等。其次在使用 RedisConnectionUtils 获取 redis 连接的基础上，RedisTemplate 可以设置不同数据类型的序列化工具；抽象了执行脚本或 lambda 表达式的 execute、executePipeline 方法；抽象了 set、get、delete、hasKey、expire、multi、match 操纵出入库数据的方法；抽象了操纵不同数据类型的 ValueOperations、ListOperations、SetOperations、ZSetOperations、HashOperations、BoundValueOperations、BoundValueOperations、BoundListOperations、BoundSetOperations、BoundZSetOperations、BoundHashOperations 等操作对象。操作对象既可能会调用 RedisTemplate 实例中的 set、get 方法，又可能调用 redisTemplate.execute 执行 lambda 表达式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class RedisTemplate&lt;K, V&gt; extends RedisAccessor implements RedisOperations&lt;K, V&gt;, BeanClassLoaderAware &#123; @Override public RedisSerializer&lt;?&gt; getHashValueSerializer() &#123; return hashValueSerializer; &#125; public void setHashValueSerializer(RedisSerializer&lt;?&gt; hashValueSerializer) &#123; this.hashValueSerializer = hashValueSerializer; &#125; // 执行脚本 @Override public &lt;T&gt; T execute(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args) &#123; return scriptExecutor.execute(script, keys, args); &#125; @Override public BoundValueOperations&lt;K, V&gt; boundValueOps(K key) &#123; return new DefaultBoundValueOperations&lt;&gt;(key, this); &#125; @Override public ValueOperations&lt;K, V&gt; opsForValue() &#123; if (valueOps == null) &#123; valueOps = new DefaultValueOperations&lt;&gt;(this); &#125; return valueOps; &#125;&#125;class DefaultBoundValueOperations&lt;K, V&gt; extends DefaultBoundKeyOperations&lt;K&gt; implements BoundValueOperations&lt;K, V&gt; &#123; private final ValueOperations&lt;K, V&gt; ops; DefaultBoundValueOperations(K key, RedisOperations&lt;K, V&gt; operations) &#123; super(key, operations); this.ops = operations.opsForValue(); &#125; @Override public V get() &#123; return ops.get(getKey()); &#125; @Override public String get(long start, long end) &#123; return ops.get(getKey(), start, end); &#125; @Override public void set(V value, long timeout, TimeUnit unit) &#123; ops.set(getKey(), value, timeout, unit); &#125; @Override public void set(V value) &#123; ops.set(getKey(), value); &#125; @Override public void set(V value, long offset) &#123; ops.set(getKey(), value, offset); &#125;&#125; 有了 RedisTemplate，我们就可以使用如下的方式在 redis 数据库中存取数据： 1234567891011121314151617181920212223// 简单的值redisTemplate.opsForValue().set(product.getSku(), product);// 使用序列化工具将 product 实体转化成字符串redisTemplate.opsForValue().get(\"123456\");// 取出 product// listredisTemplate.opsForList().rightPush(\"cart\", product);// 尾部插入redisTemplate.opsForList().leftPush(\"cart\", product);// 顶部插入Product first = redisTemplate.opsForList().leftPop(\"cart\");// 顶部取值Product last = redisTemplate.opsForList().rightPop(\"cart\");// 尾部取值List&lt;Product&gt; products = redisTemplate.opsForList().range(\"cart\", 2, 12);// 范围取值// setredisTemplate.opsForSet().add(\"cart1\", product);// 添加redisTemplate.opsForSet().remove(product);// 移除redisTemplate.opsForSet().randomMember(\"cart1\");// 随机取元素List&lt;Product&gt; diff = redisTemplate.opsForSet().difference(\"cart1\", \"cart2\");// 差集List&lt;Product&gt; union = redisTemplate.opsForSet().union(\"cart1\", \"cart2\");// 并集List&lt;Product&gt; isect = redisTemplate.opsForSet().isect(\"cart1\", \"cart2\");// 交集// 嫁接BoundListOperations&lt;String, Product&gt; cart = redisTemplate.boundListOpts(\"cart\");cart.rightPush(cart1);cart.rightPush(cart2); 参考redis 文档中心RedisTemplate使用方法归纳","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"缓存","slug":"backend/缓存","permalink":"http://xzfyu.com/categories/backend/缓存/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"swagger","slug":"frontend/工程化/swagger","date":"2019-11-27T16:00:00.000Z","updated":"2020-03-08T10:57:56.697Z","comments":true,"path":"2019/11/28/frontend/工程化/swagger/","link":"","permalink":"http://xzfyu.com/2019/11/28/frontend/工程化/swagger/","excerpt":"","text":"OpenAPI SpecificationOpenAPI 规范（OAS）为 RESTful API 定义了一套标准的、跨语言的接口，以便人类和计算机均无需通过源码、文档或网络流量检测探知和理解服务器提供的能力。OAS 可用于制作文档生成器、代码生成器、测试工具等等。OpenAPI 以 json 对象形式呈现，因此它基本遵循 json schema 规范，可以用 json 或 yaml 格式编写。 在 OpenAPI 规范的基础上，Swagger 提供了一套开源工具用于为服务端和客户端设计、制作 api 文档以及代码，包含 Swagger Editor、Swagger UI、Swagger Codegen。基于 Swagger，开发流程可能是这样的：设计 api，使用 Swagger Codegen 制作服务端代码，稍后再实现业务逻辑；使用 Swagger Codegen 生成客户端脚本库；使用 Swagger UI 制作交互式文档界面等等。 OpenAPI 文档的基础数据包含： openapi: OAS 版本号，影响解析策略。 info: RESTful API 的元信息，包含标题、描述、联系方式、许可证、版本号、服务条款链接。 servers: 服务器信息。当 servers 未指定时，将使用 url 为 ‘/‘ 的服务器对象。 paths: RESTful API 的路径。单个路径包含相同配置时会造成冲突，这时会由工具决定选用哪一个。路径下挂操作对象。 components: 在 OAS 中作为可重用的部件，被引用时才生效。 security: RESTful API 的安全机制，可以在操作对象层级进行改写。 tags: 标签列表，即针对操作对象打标签。 externalDocs: 扩展文档。 123456789101112131415161718192021222324252627282930313233penapi: 3.0.0info: title: Sample API description: Optional multiline or single-line description in [CommonMark](http://commonmark.org/help/) or HTML. version: 0.1.9servers: - url: https://api.example.com/v1 description: Production server (uses live data) - url: https://sandbox-api.example.com:8443/v1 description: Sandbox server (uses test data)paths: /users: get: summary: Returns a list of users. description: Optional extended description in CommonMark or HTML. security: - OAuth2: [read] # &lt;------ 使用 oauth2 认证 responses: '200': # status code description: A JSON array of user names content: application/json: schema: type: array items: type: stringcomponents: securitySchemes: BasicAuth: type: http scheme: basicsecurity: - BasicAuth: [] OAS 使用 end point、operation object 描述 api。以上 schema 中，/users 是一个 end point，get 是一个 operation object。end point 下可以包含如下的 operation object：put、post、delete、options、head、patch、trace。operation object 可以配置 tags、summary、description、externalDocs、operationId、parameters、requestBody、responses、callbacks、deprecated、security、servers 属性。典型如下： 1234567891011121314151617181920212223242526272829303132333435363738394041paths: /users/&#123;id&#125;: # 正则格式 get: tags: - Users summary: Gets a user by ID. description: A detailed description of the operation. Use markdown for rich text representation, such as **bold**, *italic*, and [links](https://swagger.io). operationId: getUserById parameters: - name: id in: path description: User ID required: true schema: type: integer format: int64 responses: '200': description: Successful operation content: application/json: schema: $ref: '#/components/schemas/User' # 使用 $ref 引用 components 中定义的实体 externalDocs: description: Learn more about user operations provided by this API. url: http://api.example.com/docs/user-operations/components: schemas: User: type: object properties: id: type: integer format: int64 name: type: string required: - id - name 后端接入 swagger2java 中介入 swagger2 可按以下方式进行： pom.xml 添加 springfox-swagger2、springfox-swagger-ui 依赖。 使用 @Configuration、@EnableSwagger2 注解编写 Swagger 配置类。 在 Controller 中使用 Swagger 注解接口。 访问 swagger-ui.html 查看接口文档。 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142// configuration@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket customDocket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; Contact contact = new Contact(\"团队名\", \"www.my.com\", \"my@my.com\"); return new ApiInfoBuilder() .title(\"文档标题\") .description(\"文档描述\") .contact(contact) // 联系方式 .version(\"1.1.0\") // 版本 .build(); &#125;&#125;// controller@RestController@Api(tags=\"接口所在的类\")public class HelloController &#123; @RequestMapping(value = \"/hello\", method = RequestMethod.GET) @ApiOperation(value = \"接口名\", notes = \"接口描述\", httpMethod = \"POST\") @ApiImplicitParams(&#123; @ApiImplicitParam(name = \"length\",value = \"参数1\", required = true, paramType = \"path\"), @ApiImplicitParam(name = \"size\",value = \"参数2\", required = true, paramType = \"query\"), @ApiImplicitParam(name = \"page\",value = \"参数3\", required = true, paramType = \"header\"), @ApiImplicitParam(name = \"total\",value = \"参数4\", required = true, paramType = \"form\"), @ApiImplicitParam(name = \"start\",value = \"参数5\",dataType = \"string\", paramType = \"body\") &#125;) public String index()&#123; return \"Hello World!\"; &#125;&#125; 生成前端接口这里以 openapi-generator 为例，说明一下怎么根据 swagger-ui 生成前端服务层调用代码和实体类接口。通过后端应用接入 swagger2 之后，访问 /v2/api-docs 即可查看复合 OAS 规范的全量接口信息，openapi-generator 就是在这份接口数据的基础上，通过解析并使用 nunjucks 模板生成 js 脚本的。下图即为 /v2/api-docs 数据内容。 openapi-generator 的核心代码见于 ServiceGenerator 类，该类的作用即是解析 /v2/api-doc 数据内容并使用模板生成服务层调用及接口文件。除了解析 OAS 数据外，它基于以下流程实现： 基于 config.requestLib 配置为真生成服务层调用基类，文件名为 base.js 或 base.ts。 基于 config.type 配置为 ‘ts’ 生成实体类接口，文件名为 typings.d.ts。 基于 config.serviceType 生成服务层调用脚本，类或函数形式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class ServiceGenerator &#123; // 生成服务层调用代码和实体类接口文件 genFile() &#123; // 基于 openapi-generator 内置的 template/base.njk 生成服务层调用基类 this.genRequestLib(); // 基于 openapi-generator 内置的 template/interface.njk 或外部模板生成实体类接口 if (this.config.type === 'ts') &#123; debug('[GenSDK] gen interface.'); this.genFileFromTemplate('typings.d.ts', 'interface', &#123; namespace: this.config.namespace, list: this.getInterfaceTP(),// 获取 /v2/api-doc 数据内容中的 definitions &#125;); &#125; // 基于 openapi-generator 内置的 template/interface.njk 或外部模板生成实体类接口 this.getServiceTP()// 获取 /v2/api-doc 数据内容中的 paths（经 ServiceGenerator.constructor 处理） .filter(tp =&gt; &#123; tp.list = tp.list.filter( item =&gt; !this.config.filter || this.config.filter.some(f =&gt; &#123; return f instanceof RegExp ? f.test(item.path) : typeof f === 'function' ? f(item) : true; &#125;) ); return tp.list.length; &#125;) .map(tp =&gt; &#123; debug('[GenSDK] generate service:', tp.className); this.genFileFromTemplate( this.getFinalFileName(`$&#123;tp.className&#125;.$&#123;this.config.type&#125;`), 'service', &#123; namespace: this.config.namespace, ...tp, &#125; ); &#125;); &#125; protected genFileFromTemplate(fileName: string, type: 'interface' | 'service', params: any) &#123; try &#123; const template = this.getTemplate(type); this.writeFile(fileName, nunjucks.renderString(template, params)); &#125; catch (error) &#123; console.warn('[GenSDK] file gen fail:', fileName, 'type:', type); throw error; &#125; &#125; protected getTemplate(type: 'interface' | 'service') &#123; const configFilePath = type === 'interface' ? this.config.interfaceTemplatePath : this.config.templatePath; try &#123; if (configFilePath) &#123; this.mkdir(path.dirname(configFilePath)); if (fs.existsSync(configFilePath)) &#123; return fs.readFileSync(configFilePath, 'utf8'); &#125; &#125; const fileContent = fs.readFileSync( path.join( __dirname, 'template', type === 'service' ? `$&#123;type&#125;.$&#123;this.config.serviceType&#125;.njk` : `$&#123;type&#125;.njk` ), 'utf8' ); if (configFilePath) &#123; fs.writeFileSync(configFilePath, fileContent, 'utf8'); &#125; return fileContent; &#125; catch (error) &#123; console.warn(`[GenSDK] get &#123;$&#123;type&#125;&#125; template fail:`, configFilePath); throw error; &#125; &#125;&#125; 在 ServiceGenerator 类的基础上，openapi-generator 支持基于接口、文件获取 OAS 数据并生成前端脚本。 12openapi-generator url http://xxx/v2/api-docs -c true # 基于接口openapi-generator config ./xxx.js # 基于文件 后记写作本文的目的本意在于探究怎样通过后端脚本生成前端 service 层代码。我曾接触过的 midway 前端框架可以生成 hsf 服务中使用的代理层文件（实现与后端服务的参数对接和类型转换），前端也能根据 swagger 文档生成 service 层代码。也许，midway 中生成的代理文件也是基于 hsf 平台上标准化的接口文档。在这次探寻过程上，我发现了一个新的思考点：既可以根据 OAS 生成 service 脚本，也可以根据 OAS 提供 mock 服务。OAS 规范也使人思忖：在团队能力较弱或应用场景较小的情况下，探讨逻辑流程的紧要程度高于制定输入输出文档；在应用场景达到规模化或团队能力可信赖的情况下，规范化的输入输出文档高于逻辑实现。“路漫漫而修远兮，吾将上下而求索”。 参考Swagger Codegen 高效开发客户端对接服务端代码开源小工具 - swagger API访问代码生成器（js/typescript）","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"密码技术","slug":"backend/其他/密码技术","date":"2019-11-24T16:00:00.000Z","updated":"2020-03-08T11:24:38.709Z","comments":true,"path":"2019/11/25/backend/其他/密码技术/","link":"","permalink":"http://xzfyu.com/2019/11/25/backend/其他/密码技术/","excerpt":"","text":"常见的密码技术与安全概念","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"其他","slug":"backend/其他","permalink":"http://xzfyu.com/categories/backend/其他/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"自动化部署","slug":"frontend/architecture/自动化部署","date":"2019-11-24T16:00:00.000Z","updated":"2020-03-08T10:42:40.983Z","comments":true,"path":"2019/11/25/frontend/architecture/自动化部署/","link":"","permalink":"http://xzfyu.com/2019/11/25/frontend/architecture/自动化部署/","excerpt":"","text":"参考Jenkins本地搭建遇到的问题 for Mac使用git做服务器端代码的部署Git Hooks、GitLab CI持续集成以及使用Jenkins实现自动化任务持续集成 の 使用 git hook 部署代码前端自动化发布实战总结","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"我看 mybatis","slug":"backend/数据库技术/我看 mybatis","date":"2019-11-22T16:00:00.000Z","updated":"2020-03-08T11:17:28.018Z","comments":true,"path":"2019/11/23/backend/数据库技术/我看 mybatis/","link":"","permalink":"http://xzfyu.com/2019/11/23/backend/数据库技术/我看 mybatis/","excerpt":"","text":"按我的理解，可以在现代前端技术找到与 Mybatis 相类的解决方案。虽然浏览器开列了 DOM API 用于操纵节点，但是存在以下两个主要问题：不同的浏览器使用不同的接口；操纵节点的开发成本高昂。jQuery 等节点操作型类库解决了第一个问题，但没有解决第二个问题。到了模板引擎 + 虚拟 dom 的技术实现方案后，由虚拟 dom 统一封装节点操纵接口，并作性能优化，再由模板引擎对接虚拟 dom，前端只需要关心模板，达到声明式编程的效果。话题切回到 Mybatis，在此之前，JDBC 解决了不同数据库的对接问题，但是需要反复的创建和关闭 Statement、ResultSet；sql 语句散落，且不能复用，频繁书写对象关系模型的转换逻辑；动态 sql 以参数序号拼接，造成它与业务逻辑有较高的耦合度等。针对这些问题，我们能想象到的处理方式是：抽象 sql 执行流程；使用模板描述 sql 语句。前者的意义就在于组装 sql 操作的流水线工厂，包含但不限于：创建 Connection，根据 sql 预备语句创建 PreparedStatement，通过关系对象模型获得参数，执行 sql，将结果转换成关系对象模型，关闭 Connection 等。可以说，JDBC 的焦点在于流水线的某个节点，Mybatis 的焦点在于整条流水线，这样一来，应用开发者就不大需要关心流水线上的某个节点该怎么操作，而只需关心整条流水线的输入输出（当然，若要关心流水线上的特定节点，也可以使用钩子或拦截器等手段处理）。有了流水线工厂，输入等表现形式可以是多样的，正如 Mybatis 既可以使用 xml 配置声明待执行的 sql 语句，也可以使用 Java 语句约定该执行的 sql 语句。在使用模板约定 sql 语句的基础上，sql 语句是既可以组装和复用的，又会特定的对象关系模型达成相互转换关系。 上述 Mybatis 架构图中，Mybatis 首先会从 MybatisConfig.xml 加载基本的配置信息，包含环境信息、数据库的驱动程序、数据库地址、账号和密码等，构建 Configuration 对象；然后注册 Mapper.xml 映射器，Mapper.xml 描述了待执行的 sql、及其与关系对象模型的映射关系等。在取得配置信息以后，Mybatis 会通过 SqlSessionFactoryBuilder 创建 SqlSessionFactory；sqlSessionFactory 保有 configuration 配置信息；SqlSessionFactory 允许使用 sqlSessionFactory.openSession 方法创建 SqlSession（openSession 方法用于设定 sqlSession 的自动提交模式、执行模式等）。因为全量映射器信息已经存在内存中，SqlSession 允许我们直接使用 sqlSession.getMapper 形式获取映射器的可用形态，继而执行映射器中约定的方法；使用 sqlSession.select 能直接执行颗粒度更细的映射器方法。SqlSessionFactory 的最佳作用域是应用作用域；SqlSession 不是线程安全的，不能作为一个类的静态属性或实例属性，每当有请求时才予以创建，且需要及时关闭。与上图表述不尽相同的是，在创建 SqlSession 属性的过程中，Mybatis 会根据 execType 选用不同的 Exector 实现类，Exector 实例本身作为 SqlSession 实例的一个属性。当我们调用 sqlSession.select 时，Mybatis 首先会从 configuration 中选用相关的 MappedStatement，然后调用 executor.query，由 exector 实际消费 MappedStatement 作出入参数转换。MappedStatement 通过解析 Mapper.xml 获得，它约定了 sql 语句的处理方式。在 executor.query 执行期间，Mybatis 会通过 MappedStatement 获得 StatementHandler；StatementHandler 用于预处理 statement，执行实际的 sql 语句。 以下是 sqlSession.select 的执行逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class DefaultSqlSession implements SqlSession &#123; @Override public void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) &#123; try &#123; MappedStatement ms = configuration.getMappedStatement(statement); executor.query(ms, wrapCollection(parameter), rowBounds, handler); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125;&#125;public abstract class BaseExecutor implements Executor &#123; // BoundSql 用于获取真实的 sql 语句 @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId()); if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123; clearLocalCache(); &#125; List&lt;E&gt; list; try &#123; queryStack++; list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null; if (list != null) &#123; handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); &#125; else &#123; list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); &#125; &#125; finally &#123; queryStack--; &#125; if (queryStack == 0) &#123; for (DeferredLoad deferredLoad : deferredLoads) &#123; deferredLoad.load(); &#125; // issue #601 deferredLoads.clear(); if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123; // issue #482 clearLocalCache(); &#125; &#125; return list; &#125; private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; List&lt;E&gt; list; localCache.putObject(key, EXECUTION_PLACEHOLDER); try &#123; list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); &#125; finally &#123; localCache.removeObject(key); &#125; localCache.putObject(key, list); if (ms.getStatementType() == StatementType.CALLABLE) &#123; localOutputParameterCache.putObject(key, parameter); &#125; return list; &#125;&#125;public class SimpleExecutor extends BaseExecutor &#123; @Override public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; // 获取顶层 Configuration 配置信息 Configuration configuration = ms.getConfiguration(); // 获取具体的 StatementHandler，如 SimpleStatement，PreparedStatement 或 CallableStatement StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 创建 statement stmt = prepareStatement(handler, ms.getStatementLog()); // 执行实际的 sql，并处理结果集 return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125; &#125;&#125;public class Configuration &#123; public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123; // 根据 ms.getStatementType 选用具体的 StatementHandler StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql); // 使用拦截器插件对 StatementHandler 进行封装 statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler); return statementHandler; &#125;&#125;public abstract class BaseStatementHandler implements StatementHandler &#123; protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123; this.configuration = mappedStatement.getConfiguration(); this.executor = executor; this.mappedStatement = mappedStatement; this.rowBounds = rowBounds; this.typeHandlerRegistry = configuration.getTypeHandlerRegistry(); this.objectFactory = configuration.getObjectFactory(); if (boundSql == null) &#123; // issue #435, get the key before calculating the statement generateKeys(parameterObject); // 根据动态参数输出实际的 sql，实现见下文 boundSql = mappedStatement.getBoundSql(parameterObject); &#125; this.boundSql = boundSql; this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql); this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql); &#125; @Override public Statement prepare(Connection connection, Integer transactionTimeout) throws SQLException &#123; ErrorContext.instance().sql(boundSql.getSql()); Statement statement = null; try &#123; statement = instantiateStatement(connection); setStatementTimeout(statement, transactionTimeout); setFetchSize(statement); return statement; &#125; catch (SQLException e) &#123; closeStatement(statement); throw e; &#125; catch (Exception e) &#123; closeStatement(statement); throw new ExecutorException(\"Error preparing statement. Cause: \" + e, e); &#125; &#125;&#125;public class SimpleStatementHandler extends BaseStatementHandler &#123; // 使用实际的 sql 连接 Connection 创建 statement @Override protected Statement instantiateStatement(Connection connection) throws SQLException &#123; if (mappedStatement.getResultSetType() != null) &#123; return connection.createStatement(mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY); &#125; else &#123; return connection.createStatement(); &#125; &#125; // 执行实际的 sql，并处理结果集 @Override public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; String sql = boundSql.getSql(); statement.execute(sql); return resultSetHandler.&lt;E&gt;handleResultSets(statement); &#125;&#125; 上文更多的是简要地表明了 sqlSession.select 发起的一个查询过程，这个过程相当于前端 handlebars 模板引擎的第二个阶段 —— 通过解析函数处理参数并获得实际的 html。可是 handlebars 还有第一个阶段 —— 通过模板获得解析函数。两个阶段拼合在一起，才合成一个完成的过程 const parse = Handlebars.compile(template); const html = parse(data)。与此相同，Mybatis 同样需要先将 Mapper.xml 配置转换成 MappedStatement，这样才能通过 MappedStatement 获得 BoundSql，再通过 BoundSql 获得实际待执行的 sql 语句。下图既表明了 Mybatis 的架构，也说明了解析和执行正是虎符的两半。 通过回溯源码，我们发现在 spring 工程中，Mybatis 利用 spring 的机制加载 Mapper.xml 文件。正是在 org.mybatis.spring 包调用了 xmlMapperBulder.parse 方法，configuration 中才会有 XMLStatementBuilder 实例。而通过 XMLStatementBuilder 实例解析 xml 文件中的相关节点，MappedStatement 实例才得以被添加到 configuration 中。同样采用回溯法，我们发现，BoundSql 的创建过程依循这样一条路线：在 xml 解析过程中，会创建 xmlScriptBuilder 实例，再由 xmlScriptBuilder 解析 xml 配置中的 sql 语句节点，获得 rawSqlSource 或 dynamicSqlSource 实例（两者的 getBoundSql 方法即可用于获得 boundSql 实例）。以下源码仅以简要说明 mappedStatement.getBoundSql(parameterObject) 方法为什么能完成动态参数的拼接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class RawSqlSource implements SqlSource &#123; // rootSqlNode 为 sql 语句节点 public RawSqlSource(Configuration configuration, SqlNode rootSqlNode, Class&lt;?&gt; parameterType) &#123; this(configuration, getSql(configuration, rootSqlNode), parameterType); &#125; public RawSqlSource(Configuration configuration, String sql, Class&lt;?&gt; parameterType) &#123; SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; clazz = parameterType == null ? Object.class : parameterType; sqlSource = sqlSourceParser.parse(sql, clazz, new HashMap&lt;String, Object&gt;()); &#125;&#125;public class DynamicSqlSource implements SqlSource &#123; @Override public BoundSql getBoundSql(Object parameterObject) &#123; DynamicContext context = new DynamicContext(configuration, parameterObject); rootSqlNode.apply(context); SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass(); SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); BoundSql boundSql = sqlSource.getBoundSql(parameterObject); for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123; boundSql.setAdditionalParameter(entry.getKey(), entry.getValue()); &#125; return boundSql; &#125;&#125;public class SqlSourceBuilder extends BaseBuilder &#123; public SqlSource parse(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters) &#123; ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType, additionalParameters); GenericTokenParser parser = new GenericTokenParser(\"#&#123;\", \"&#125;\", handler); String sql = parser.parse(originalSql); return new StaticSqlSource(configuration, sql, handler.getParameterMappings()); &#125;&#125;// 将 \"#&#123;\", \"&#125;\" 中间替换以动态参数public class GenericTokenParser &#123; public String parse(String text) &#123; if (text == null || text.isEmpty()) &#123; return \"\"; &#125; // search open token int start = text.indexOf(openToken, 0); if (start == -1) &#123; return text; &#125; char[] src = text.toCharArray(); int offset = 0; final StringBuilder builder = new StringBuilder(); StringBuilder expression = null; while (start &gt; -1) &#123; if (start &gt; 0 &amp;&amp; src[start - 1] == '\\\\') &#123; // this open token is escaped. remove the backslash and continue. builder.append(src, offset, start - offset - 1).append(openToken); offset = start + openToken.length(); &#125; else &#123; // found open token. let's search close token. if (expression == null) &#123; expression = new StringBuilder(); &#125; else &#123; expression.setLength(0); &#125; builder.append(src, offset, start - offset); offset = start + openToken.length(); int end = text.indexOf(closeToken, offset); while (end &gt; -1) &#123; if (end &gt; offset &amp;&amp; src[end - 1] == '\\\\') &#123; // this close token is escaped. remove the backslash and continue. expression.append(src, offset, end - offset - 1).append(closeToken); offset = end + closeToken.length(); end = text.indexOf(closeToken, offset); &#125; else &#123; expression.append(src, offset, end - offset); offset = end + closeToken.length(); break; &#125; &#125; if (end == -1) &#123; // close token was not found. builder.append(src, start, src.length - start); offset = src.length; &#125; else &#123; builder.append(handler.handleToken(expression.toString())); offset = end + closeToken.length(); &#125; &#125; start = text.indexOf(openToken, offset); &#125; if (offset &lt; src.length) &#123; builder.append(src, offset, src.length - offset); &#125; return builder.toString(); &#125;&#125;public class StaticSqlSource implements SqlSource &#123; private final String sql; private final List&lt;ParameterMapping&gt; parameterMappings; private final Configuration configuration; public StaticSqlSource(Configuration configuration, String sql) &#123; this(configuration, sql, null); &#125; public StaticSqlSource(Configuration configuration, String sql, List&lt;ParameterMapping&gt; parameterMappings) &#123; this.sql = sql; this.parameterMappings = parameterMappings; this.configuration = configuration; &#125; @Override public BoundSql getBoundSql(Object parameterObject) &#123; return new BoundSql(configuration, sql, parameterMappings, parameterObject); &#125;&#125; 后记因为半路出家的缘故，我很难用精准的词汇去描述所思所想，表达也就会大打折扣。很多时候，我想把编程比喻为整理抽屉，需要把东西摆放得足够整齐，需要知道哪个格子藏了什么东西（后一条会显得很有经验）。但是茴香豆有几种写法，Mybatis 设计了多少种 xml 配置项，这不是我所关心的重点。 参考Mybatis 文档MyBatis的工作原理终结篇：MyBatis原理深入解析Mybatis架构与原理","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"数据库技术","slug":"backend/数据库技术","permalink":"http://xzfyu.com/categories/backend/数据库技术/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"JDBC","slug":"backend/数据库技术/JDBC","date":"2019-11-20T16:00:00.000Z","updated":"2020-03-08T11:17:07.560Z","comments":true,"path":"2019/11/21/backend/数据库技术/JDBC/","link":"","permalink":"http://xzfyu.com/2019/11/21/backend/数据库技术/JDBC/","excerpt":"","text":"Java 数据库连接（JDBC）API 用于对接不同的数据库 —— 由遵守不同网络协议的数据库厂商提供第三方驱动程序，再由 Java 提供一个驱动管理器和一套 API，驱动程序就会注册到驱动管理器中，在此基础上，调用 API 即能访问驱动管理器，最后通过驱动程序与实际的数据库通信。驱动程序的实现经历过多次演进，目前以纯 Java 语言实现，它能将 JDBC 请求直接翻译成数据库相关的协议。 使用 JDBC 的前置操作包含：获悉数据库 url 地址如 jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8；下载驱动程序 jar 文件并注册到驱动管理器上（部分驱动不需要注册）；下载并启动特定数据库。完成前置操作后，就可以连接数据库并执行 sql 了。典型的 JDBC 调用操作如下： 12345678// 用户名或密码可以放在配置文件中或远程管理中心中String url = \"jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8\";String username = \"admin\";String password = \"123456\";Connection conn = DriverManager.getConnection(url, username, password);Statement stat = conn.createStatement();stat.executeUpdate(\"CREATE TABLE Greeting (Message CHAR(20))\"); JDBC 接口设计包含如下内容： 以 Connection 抽象数据库连接，通过 DriverManager.getConnection 创建。连接通过 connection.close 关闭，避免长连接占用有限的数据库资源（数据库有最大并发连接数、最大并发语句数）（与此同时，频繁建立和关闭数据库连接也是高昂的消耗，因此 web 容器或应用服务器开发商会提供连接池机制。连接池保持与数据库的长连接，不存在物理关闭，sql 操作可以重用连接池）。 以 Statement 抽象针对数据库的表操作，通过 connection.createStatement 创建，同样能通过调用 close 方法关闭。Statement 对象实现 executeQuery, executeUpdate, execute 方法用于增删改查操作。 以 ResultSet 抽象查询结果集，并缓存在 Statement 对象中，可通过 statement.getResultSet 获取（每个结果集只能获取一次）。部分结果集允许单条 Select 语句查出多个结果集，通过 statement.getMoreResults 使 getResultSet 指向下一条数据。 ResultSet 可以便捷地访问列数据，主要抽象操作包含 getXxx(int columnNumber), getXxx(String columnName), getObject(int columnNumber, Classtype), getObject(String columnLabel, Classtype) 等。Xxx 为 String, Int, Double, Date, Blob, Clob。 Statement 再进一步，以 PreparedStatement 抽象预编译的表操作，通过 connection.PrepareStatement 创建。它能复用基本的 sql 语句（此时为预备语句）并对编译结果作缓存，? 部分语句可在特定场合下填充为实际值（如 where name = ? 查询特定人员）。preparedStatement.setXxx, preparedStatement.clearParameters 可用于设置或清除参数（即实际值）。 支持通过 ResultSet 滚动查询、更新操作。 以 RowSet 缓存查询结果。 支持查询元数据。 支持事务操作。6、7、8、9 均见下文。 JDBC 另外解决的问题包含：（日期格式等出入库时）转义；获取自动生成的主键。 可滚动、可更新部分数据库的驱动程序支持结果集可滚动、可更新，即直接通过 ResultSet 翻查上一条或下一条数据，更新 ResultSet 数据内容即可更新表数据。在执行结果集滚动、更新操作前，首先需要通过 DatabaseMetaData 接口的 supportsResultSetType, supportsResultSetConcurrency 方法进行判断。 行集可滚动、可更新操作需要与数据库保持连接，消耗数据库资源，因此 JDBC 又推出了扩展自 ResultSet 的行集 RowSet 接口。RowSet 接口有以下子接口：CachedRowSet 缓存行集、WebRowSet 缓存行集（保存为 XML）、FilteredRowSet / JoinRowSet 可操作行集（select、join 操作）、JdbcRowSet 继承 get、set 方法的 “bean”。RowSet 允许将 ResultSet 数据填充到行集中；直接执行 sql 语句；设置分页；重新与数据库建立连接，并将数据回写到数据库中（回写时会校验原始值是否与数据库中存储值相同，保证一致性；回写复杂结果一般是不允许的）。RowSet 的典型操作如下： 123456// 或 CachedRowSet crs = new com.sun.rowset.CachedRowSetImpl();RowSetFactory factory = RowSetProvider.newFactory();CachedRowSet crs = factory.createCachedRowSet();crs.setCommand(\"SELECT * FROM Books WHERE PUBLISHER = ?\");crs.setString(1, publisherName);crs.execute(); 元数据JDBC 可用于获取元数据：数据库元数据信息、结果集的元数据信息以及预备语句的元数据信息。数据库元数据信息包含表及字段信息、数据库支持的功能。典型操作如下： 123Connection conn = DriverManager.getConnection(url, username, password);DatabaseMetaData meta = conn.getMetaData();ResultSet mrs = meta.getTables(null, null, null, new String[]&#123; \"Table\" &#125;);// 获取所有表信息 事务一组语句构成一个事务。在一组语句执行过程中，如果中间某个语句执行失败，那么就需要对之前的所有操作进行回滚 rollback。数据库连接默认处于自动提交模式，即 sql 语句一旦被执行就会被提交 commit，无法对其回滚。因此在使用之前，首先需要关闭自动提交模式 setAutoCommit(false)。部分数据库支持更为细致的回滚操作：通过在一组语句执行过程中设置保存点 setSavepoint，就允许后续的回滚操作撤回到保存点位置。同时 JDBC 允许对数据库进行批量更新操作，通过 conn.addBatch, conn.executeBatch 执行。 参考《Java 核心技术卷二》JDBC Developer’s Guide","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"数据库技术","slug":"backend/数据库技术","permalink":"http://xzfyu.com/categories/backend/数据库技术/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"}]},{"title":"mysql 使用文档","slug":"数据技术/mysql使用指南","date":"2019-11-17T16:00:00.000Z","updated":"2020-03-08T11:32:05.484Z","comments":true,"path":"2019/11/18/数据技术/mysql使用指南/","link":"","permalink":"http://xzfyu.com/2019/11/18/数据技术/mysql使用指南/","excerpt":"","text":"数据类型 TINYINT：1 字节整数 SMALLINT：2 字节整数 MEDIUMINT：3 字节整数 INT、INTEGER：4 字节整数 BIGINT：8 字节整数 FLOAT：4 字节单精度浮点数 FLOAT：8 字节双精度浮点数 DECIMAL(M,D)：小数 DATE：年月日日期 TIME：时分秒时间 YEAR：年份 DATETIME：年月日时分秒 TIMESTAMP：年月日时分秒 + 时间戳 CHAR：定长字符串，0-255 字节 VARCHAR：变长字符串，0-65535 字节 TINYBLOB：不超过 255 个字符的二进制字符串，0-255 字节 TINYTEXT：短文本字符串，0-255 字节 BLOB：二进制形式的长文本数据，0-65535 字节 TEXT：长文本数据，0-65535 字节 MEDIUMBLOB：二进制形式的中等长度文本数据，0-16777215 字节 MEDIUMTEXT：中等长度文本数据，0-16777215 字节 TLONGBLOB：二进制形式的极大文本数据，0-4294967295 字节 LONGTEXT：极大文本数据，0-4294967295 字节 命令CREATE、DROPCREATE、DROP 语句用来创建或删除数据库、建表或删表。 123456789101112/** 创建数据库 **/DROP DATABASE RUNOOB;CREATE DATABASE RUNOOB;/** 建表 **/DROP TABLE `runoob_tbl`;CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` )) ENGINE=InnoDB DEFAULT CHARSET=utf8; SELECT、INSERT、UPDATE、DELETEWHERE 语句为 sql 语句设置条件。可选的条件操作符包含 =、&lt;&gt;（不等于）、!=、&gt;、&lt;、&gt;=、&gt;=、LIKE 等。LIKE 语句需要与 % 配合使用，% 表示通配符。没有结合 % 的 LIKE 语句与 = 效果等同。 1234567891011/** 查 **/SELECT * from runoob_tbl WHERE runoob_author LIKE '%COM';/** 增 **/INSERT INTO runoob_tbl (runoob_title, runoob_author, submission_date) VALUES (\"JAVA 教程\", \"RUNOOB.COM\", '2016-05-06');/** 改 **/UPDATE runoob_tbl SET runoob_title='学习 C++' WHERE runoob_id=3;/** 删 **/DELETE FROM runoob_tbl WHERE runoob_id=3; ORDER BY 排序ORDER BY 语句设定按哪个字段哪种方式来进行排序。默认排序方式 ASC 升序排列，可选 DESC 降序排列。 123456789101112# 创建雇员表DROP TABLE IF EXISTS `employee_tbl`;CREATE TABLE `employee_tbl` ( `id` int(11) NOT NULL, `name` char(10) NOT NULL DEFAULT '', `date` datetime NOT NULL, `singin` tinyint(4) NOT NULL DEFAULT '0' COMMENT '登录次数', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;# 从雇员表中检索数据，按日期升序排列SELECT * from employee_tbl ORDER BY date ASC; UNION 求并集UNION 语句用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。UNION ALL 语句可查出重复数据；UNION DISTINCT 语句会剔除重复的数据。UNION 语句默认采用 UNION DISTINCT 查询模式。 1234567# 从 Websites、apps 汇总查询数据，结果集包含 country、name 字段，name 字段的值可能是 app_nameSELECT country, name FROM WebsitesWHERE country='CN'UNION ALLSELECT country, app_name FROM appsWHERE country='CN'ORDER BY country; GROUP BY 分组GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上可以使用 COUNT, SUM, AVG 等函数。 1234567891011121314151617# 创建雇员表DROP TABLE IF EXISTS `employee_tbl`;CREATE TABLE `employee_tbl` ( `id` int(11) NOT NULL, `name` char(10) NOT NULL DEFAULT '', `date` datetime NOT NULL, `singin` tinyint(4) NOT NULL DEFAULT '0' COMMENT '登录次数', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;# 从雇员表中检索数据，按姓名分组，统计每个人有多少条SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;# 从雇员表中检索数据，按姓名分组，统计登录总次数# WITH ROLLUP 在分组的基础上再进行统计，登录总次数一行的 name 值为 NULL# coalesce(column_name_a, column_name_b, column_name_c) 如果 column_name_a 为 NULL，以 column_name_b 代替SELECT coalesce(name, '总数'), SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP;","categories":[{"name":"数据技术","slug":"数据技术","permalink":"http://xzfyu.com/categories/数据技术/"},{"name":"sql","slug":"数据技术/sql","permalink":"http://xzfyu.com/categories/数据技术/sql/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"我看 spring framework","slug":"backend/spring/我看 spring framework","date":"2019-11-15T16:00:00.000Z","updated":"2020-03-08T11:16:01.417Z","comments":true,"path":"2019/11/16/backend/spring/我看 spring framework/","link":"","permalink":"http://xzfyu.com/2019/11/16/backend/spring/我看 spring framework/","excerpt":"","text":"前言在我所知的前端脚手架中，dawn 使用中间件的方式串联任务流，nowa 使用子命令的方式串联任务流，umi 使用插件的方式串联任务流。三者中较为特别的是，umi 在提供打包构建、测试、mock 服务器等能力之外，它还以根据配置制作入口文件的方式，集成了路由、限定了前端代码的结构。umi 中的集成意识也许来自于 dva。无论从 dva （由状态管理器入手的）前端应用框架到 umi 脚手架，还是从 antd 组件库到 ant pro 模板工程，蚂蚁工程师们抛出的命题总是一环扣一环。我只觉得，问题会引导人去解决，开阔的应用场景会激发问题，这是一条良性的道路。如果应用场景受限，问题得不到暴露，那就要凭技术上的储备去探知下一个去脉。因此，我学习 spring 的目的在于寻找创新点，手法也是不求甚解。 IoC在 spring 中，控制反转就是依赖注入。当 Class B 作为 Class A 的依赖时，控制反转会将 B 实例注入到 A 实例中。其实现过程是可以推想的：首先使用 Bean 容器管理 bean 的生命周期，然后从 xml、注解或 java 配置构成的元数据中解析出 bean 的依赖关系，最后按照依赖关系将 B 实例组装到 A 实例中。在 spring 中，作为 Bean 容器的是 BeanFactory；ApplicationContext 作为 BeanFactory 的超类，额外提供对 AOP、资源加载、国际化、事件发布（通过 ApplicationContext 中转提供 bean 之间消息通信的能力）、特定应用层上下文的支持。在这套机制的基础上，spring 既对 bean 注入的多种情形作了适配（也就是以超强的模式解析能力获取元数据），又可以通过 ApplicationContext 实例访问 bean。由此 spring 提供了声明式编程的能力。 在上述过程中，spring 需要解决的问题包含：通过 xml、注解或 java 配置 bean 的依赖关系；通过构造函数、静态工厂函数、setter 方法注入依赖；注入时须对依赖 bean 作类型转换和顺序处理，并管理 bean 的实例化、销毁等生命周期；解决 bean 的循环依赖问题（通过预实例化或使用 setter 注入）；实现 bean 的自动装配；扫描文件夹以获取 bean；支持元数据的各种便捷、组合、继承、复杂配置（抽象为 BeanDefinition）；以 @Scope 限定 bean 的作用域（singleton 单例、prototype 调用时创建、request 针对请求创建 bean、session 针对 session 创建 bean、globalSession、自定义作用域等）；以 @Profile 区分不同环境。spring 允许 bean 实现 BeanNameAware、BeanFactoryAware、ApplicationContextAware 等接口，回调或访问 IoC 容器的能力。 在 bean 实例化、初始化、依赖解析等过程中，BeanPostProcessor、BeanFactoryPostProcessor、FactoryBean 实现类会以钩子形态被执行。BeanPostProcessor 用于在 bean 实例化后定制 bean；BeanFactoryPostProcessor 用于定制 bean 的配置元数据；FactoryBean 用于定制 bean 的实例化逻辑。以 BeanPostProcessor 为例，其核心处理流程为：在 IoC 容器实例化 bean 后，再由 BeanPostProcessor 处理这些 bean，比如进行校验或者封装（包含 AOP 逻辑）。 ResourceResource 接口抽象了对资源访问的操作，其实现类包含 UrlResource、ClassPathResource、FileSystemResource、ServletContextResource、InputStreamResource、ByteArrayResource 等。ApplicationContext 接口的实现类同时实现了 Resource 接口，加载资源时通过前缀使用不同的 Resource 实现类。 Beanspring 为 Bean 提供了以下组件能力：Validator 校验器（Validator 本身与 bean 解耦，需要通过 DataBinder 绑定；校验错误由 spring 机制国际化）、BeanWrapper（用于设置或获取 bean 的属性，支持属性变更时的事件绑定）、PropertyEditor（用于作类型转换）、Converter（用于作类型转换）、Formatter（用于作类型转换，支持国际化）、DataBinder（用于为 bean 绑定 Validator 等）。 SpELSpring 表达式语言（简称 SpEL）由 spring 解析字符串表达式，可用于查询和操作数据，其应用点在于 @Value 值设置、解析表达式等。 AOPAOP 框架为 spring 提供了强力的中间件解决方案。spring 切面基于代理实现，因此可以在目标对象方法执行前后执行额外的拦截器方法（或建议 advice）。如下图所示，先执行代理方法，期间调用目标对象的实际方法。 后记本文聚焦于解读一个成熟框架在设计上包含了哪些功能，以期拓展思维，因此所述内容不免点到为止。从延伸面上，依赖注入见于 angular、redux-react；模式解析见于 schema form/page；bean 校验和转换可应用于前端数据模型；表达式语言见于模板引擎；AOP 可应用于设计中间件、拦截器。 参考The IoC ContainerIoC容器和BeanSpring Resource框架体系介绍属性编辑器PropertyEditor","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"spring","slug":"backend/spring","permalink":"http://xzfyu.com/categories/backend/spring/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"spring测试","slug":"backend/spring/spring测试","date":"2019-11-10T16:00:00.000Z","updated":"2020-03-08T11:15:25.568Z","comments":true,"path":"2019/11/11/backend/spring/spring测试/","link":"","permalink":"http://xzfyu.com/2019/11/11/backend/spring/spring测试/","excerpt":"","text":"在 spring mvc 中，可使用 JUnit 作单元测试、Spring Test 作集成测试。测试过程不需要启动项目，可借助 Servlet 相关的模拟对象如 MockMVC、MockHttpServletResquest、MockHttpServletResponse、MockHttpSession 进行模拟。在 spring boot 中，编写测试用例前先加载依赖如下： 123456&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;!-- 在 test 周期中有效 --&gt;&lt;/dependency&gt; JUnit4 为了保证每个测试方法都是单元测试，是独立的互不影响。所以每个测试方法执行前都会重新实例化测试类，它提供了如下注解： @BeforeClass 和 @AfterClass 在类被实例化前后执行，且只执行一次，通常用来初始化或关闭资源 @Before 和 @After 在每个 @Test 执行前后都会被执行一次 使用 @Test 标记测试方法单元，被 @Ignore 标记的测试方法不会被执行 测试脚本编写完成后，可直接运行 run 跑测试用例。 1234567891011121314151617181920212223242526272829303132333435363738394041@RunWith(SpringRunner.class)// 运用 junit4 进行测试，SpringRunner.class 等同 SpringJUnit4ClassRunner.class@SpringBootTest(classes = &#123;YourApplication.class&#125;)public class DemoControllerTest &#123; @Autowired private MockMvc mockMvc; @Autowired private DemoController demoController; @Autowired WebApplicationContext wac;// 可注入 WebApplicationContext @Autowired MockHttpSession session;// 可注入 http session @Autowired MockHttpServletRequest request;// 可注入 request @Before public void setup() &#123; // 初始化 mockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build(); &#125; @Test public void testPageController() throws Exception &#123; mockMvc.perform(get(\"/normal\")) .andExpect(status().isOk()) .andExpect(view().name(\"page\"))// 预期 view 的名称为 page .andExpect(forwardedUrl(\"/WEB-INF/classes/views/page.jsp\"))// 预期页面转向的真正路径为 /WEB-INF/classes/views/page.jsp .andExpect(model().attribute(\"msg\", demoService.saySomething()));// 预期 model 里的值为 demoService.saySomething 方法的返回结果 &#125; @Test public void testRestController() throws Exception &#123; mockMvc.perform(get(\"/testRest\")) .andExpect(status().isOk()) .andExpect(content().contentType(\"text/plain;charset=UTF-8\"))// 期望返回值的媒体类型是 text/plain、UTF-8 .andExpect(content().string(demoService.saySomething()));// 期望返回值内容为 demoService.saySomething 方法的返回结果 &#125;&#125; 参考Spring Boot测试","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"spring","slug":"backend/spring","permalink":"http://xzfyu.com/categories/backend/spring/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"前端监控","slug":"frontend/architecture/前端监控","date":"2019-11-09T16:00:00.000Z","updated":"2020-03-08T10:42:40.982Z","comments":true,"path":"2019/11/10/frontend/architecture/前端监控/","link":"","permalink":"http://xzfyu.com/2019/11/10/frontend/architecture/前端监控/","excerpt":"","text":"前端监控前端监控包含 js 错误统计、js 错误诊断、api 统计监控、前后端链路追踪、文件加载失败监控、页面访问速度、慢回话追踪等。 js 错误统计可以借助 try…catch、window.onerror 实现。try…catch 能捕获到错误信息描述、堆栈、行号、列号、具体的出错文件信息等，但是它只能在单一的作用域内捕获错误，不能捕获异步函数的错误，如 setTimeout 函数就需要在其内部使用 try…catch 语句，才能捕获定时器回调函数的错误内容。这时候想要使用 try…catch 捕获错误，就需要对 setTimeout 等函数进行封装。window.onerror 可以在任何执行上下文中执行，也能捕获脚本语法错误、运行时错误（出错信息、出错文件、行号等），但不能捕获跨域脚本的错误（跨域脚本只会简单报 script error 错误）。 文件加载失败可以通过加载节点的 onreadystatechange 或 onload 事件加以统计。 页面访问性能可以通过 Performance API 加以统计。 retcoderetcode 是阿里云 ARMS 前端监控平台配套的 jssdk。其压缩代码地址为 https://retcode.alicdn.com/retcode/bl.js。这里不作详解。 BombayBombay 通过 xhr 对象或者 window.navigator.sendBeacon 上报数据。上报数据类型包含 error、behavior、health 以及其他，除了 health 尝试使用 window.navigator.sendBeacon 上报以外，其他全部使用 xhr 对象。上报数据的功能实现由 reporter 模块承担；在 reporter 模块的基础上，handlers 模块用于实际上报不同类型的数据，如 pv、health（页面停留时长）、click 点击事件、blur 失焦事件（点击和失焦事件的上报内容包含节点的路径）、performance 性能（首屏渲染时各操作的处理时长）、resource（资源加载时长）、navigation（页面跳转情况）、hashChange（单页应用跳转情况）、caughtError（js 报错，通过 window.addEventListener(‘error’, …) 实现）、promiseError（promise 错误，通过 window.addEventListener(‘unhandledrejection’, …) 实现）、resourceError（资源加载错误）、api（ajax 处理情况）、message（window.postMessage 发送消息）等。在处理单页应用的页面跳转或 ajax 请求等时，Bombay 通过 hack 机制劫持了 window.console、history.pushState、history.replaceState、window.fetch、window.XMLHttpRequest、window.onpopstate 等原生语法，以在封装后的函数执行过程中上报数据。最后，Bombay 根据用户配置项启用功能。 与 mixpanel 一样，Bombay 在上报数据时需要设置 token，即避免其他应用调用上报接口。 参考监控平台前端SDK开发实践","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"前端调试","slug":"frontend/architecture/前端调试","date":"2019-11-09T16:00:00.000Z","updated":"2020-03-08T10:42:40.983Z","comments":true,"path":"2019/11/10/frontend/architecture/前端调试/","link":"","permalink":"http://xzfyu.com/2019/11/10/frontend/architecture/前端调试/","excerpt":"","text":"基本调试可以借助 chrome 控制台实现。 同步刷新browser-syncbrowser-sync 通过 web-socket 将变更内容透出到页面侧，因此无须刷新页面。browser-sync 提供了两个方法：init({ server }) 启动本地静态服务器，init({ proxy }) 启动代理服务器（当本地服务器通过其他方式启动时，browser-sync 选用代理模式启动）；reload 实时更新页面变动内容。 emmet livestyleemmet livestyle 扩展程序（浏览器、编辑器有各自的扩展程序）允许将编辑器的变更内容自动反应在页面上，又将浏览器的变更内容自动反应在编辑器上。 抓包工具charles 是 mac os 中的抓包工具，fiddler 是 windows 中的抓包工具，两者都通过将自己设置成系统的网络访问代理服务器实现。即所有请求先经过 charles、fiddler，然后再发送到远程服务器中，因此可以拦截请求、修改请求、修改响应，甚至将响应内容替换成本地资源。fiddler 还可以通过 tools - options - connection 设置监听端口，然后手机代理到该端口，就可以将手机端获得的响应资源替换成本地文件，详情可参阅 fiddler手机抓包配置方法。 charles官方网址：https://www.charlesproxy.com/破解jar包获取地址：https://www.zzzmode.com/mytools/charles/charles 参考文档：CharlesMac破解版安装以及使用 模拟器Genymotion 参考手机web前端调试页面的几种方式","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"前端埋点","slug":"frontend/architecture/前端埋点","date":"2019-11-02T16:00:00.000Z","updated":"2020-03-08T10:42:40.982Z","comments":true,"path":"2019/11/03/frontend/architecture/前端埋点/","link":"","permalink":"http://xzfyu.com/2019/11/03/frontend/architecture/前端埋点/","excerpt":"","text":"埋点统计数据用户访问统计用户访问统计包含 PV（Page View）、UV（Unique Visitor）、VV（Visit View）、IP 等。PV 用来统计一天之内页面的被访问次数，机刷也可以造成 PV 数据提升。UV 用来统计一天之内访问页面的用户数量，一般使用 IP 统计（IP 统计并不谨慎，同一个办公区或校园公用一个 IP）；使用 cookie + IP 统计（cookie 会被刷新，造成用户数被重复统计）；使用 userAgent + API 统计（userAgent + API 相同的情况也常有发生）。UV 统计的细化点是新访客数、新访客比率等。VV 用来统计一天之内网站被用户访问的次数；用户访问网站到结束访问视为 1 次，因此同一个用户在一天之内可能造成多条 VV。IP 用来统计一天之内访问网站的不重复 IP 数。 用户行为分析用户行为分析包含页面点击量、用户点击流、用户访问路径、用户点击热力图、用户转化率、导流转化率、用户访问时长分析和用户访问内容分析等。用户点击量用来统计用户在某个可点击或可操作区域的点击或操作次数。用户点击流用来统计用户在页面中发生点击或操作动作的顺序；埋点过程中，可先用 localStorage 存储用户点击或操作行为的唯一 id，然后在一次 VV 结束或下一次 VV 开始时上报。用户访问路径用来统计用户访问页面的路径。用户点击热力图用来统计用户在一张页面中的点击热衷区域；埋点过程中，可以对 document 点击绑定 click 事件，并上报 e.pageX、e.pageY 数据。用户转化率指的是访问页面的注册用户数和页面 PV 的比值。导流转化率指的是导流页面 PV 和源页面 PV 的比值。用户访问时长用来统计用户在关键内容页面的停留时长，以便分析用户是否对内容感兴趣。 埋点方案前端埋点分为：代码埋点、可视化埋点、无痕埋点三种。代码埋点即侵入式埋点，可以在任意时刻、任意位置精确地发送数据，但是工作量较大，对业务代码也有较大影响。可视化埋点即以业务代码为输入，通过可视化系统配置埋点，最后以耦合的形式输出业务代码和埋点代码，但是可视化系统的埋点控件有限，并不能充分满足埋点需求。无痕埋点即无差别地对所有事件等进行全埋点，但是没法定制埋点需求。 埋点上报数据上报的主要数据包含：appid、userAgent、timestamp（上报的时间戳）、currentUrl（用户当前的 url）、fromUrl（前一个页面的 url）、type（上报事件的类型）、element（触发上报事件的元素）、data（自定义数据）等。数据可通过 OpenSSL 或 crypto 模块进行加密。 123456789101112131415161718&#123; // 上报接口本身提供 currentUrl, fromUrl, timestamp, userAgent: &#123; os, netWord, &#125; // 业务代码配置和自定义上报数据 type, appid, element, data: &#123; uid, uname &#125;&#125; mixpanel 按我的个性化解读，mixpanel 分为三层结构： 基本工具层：提供类型判断、遍历、继承、bind 等基本的工具函数；json、base64、utf8 编解码能力；url 参数读写函数；cookie、localStorage 读写能力；dom 事件绑定能力；dom 节点查询能力；info 浏览器信息获取能力。 功能模块层：提供基于 DomTracker 实现的 LinkTracker 跳链接埋点、FormTracker 提交数据埋点功能；autotrack 自动埋点功能；基于 cookie 或 localStorage 的 MixpanelPersistence 持久化功能；MixpanelNotification 提示功能；gdbr 依据欧盟《通用数据保护条例》，首先判断用户是否设置了 navigator.doNotTrack 避免数据被追踪，其次判断持久层是否禁止数据被追踪，当两者同时允许追踪埋点数据时，mixpanel 才会上报埋点数据。 核心实现层：MixpanelLib 串联功能、处理选项、发送埋点数据等；MaxpanelGroup；MaxpanelPeople。 mixpanel 根据用户配置项，分别使用 img、script 节点、XHR 对象上报数据，这一逻辑实现在 mixpanelLib._send_request(url, data, callback) 方法中。_send_request 方法会附加上报 ip 地址、时间戳等；callback 回调用于处理服务端响应及上传数据。一般而言，在 _send_reques 方法执行前，mixpanel 会调用 gdbr 模块校验用户或持久层的 token 是否禁止数据被追踪；在 _send_reques 方法执行后，mixpanel 会调用 _check_and_handle_notifications 上报用户的唯一标识，并根据返回结果触发弹窗。基于 _send_request，MixpanelLib 封装了 track(event_name, properties, callback)、_dom_loaded 等方法。其中，track 方法附加上持久层的数据，并以 { event, properties } 格式发送到远程服务器中；track_pageview 方法（上报浏览器和页面信息）、LinkTracker、FormTracker 均基于 track 实现（LinkTracker、FormTracker 在上报数据完成后，再触发原始的跳链接、提交操作）。_dom_loaded 在 DOMContentLoaded 事件中触发执行，为 LinkTracker、FormTracke 相关节点绑定事件。autotrack 自动埋点先须由用户开启，其次请求服务器是否允许自动埋点，然后以事件委托的方式在 document 节点层面收集数据并上报。 mixpanel 有其成熟后的复杂度，个别内容不作详解，另作专题剖析。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"umi-hooks、hox","slug":"frontend/library/umi-hooks、hox","date":"2019-11-01T16:00:00.000Z","updated":"2020-03-08T10:45:48.826Z","comments":true,"path":"2019/11/02/frontend/library/umi-hooks、hox/","link":"","permalink":"http://xzfyu.com/2019/11/02/frontend/library/umi-hooks、hox/","excerpt":"","text":"这篇文章仅整理蚂蚁金服的 umi-hooks、hox 的大致实现原理，以说明 react-hooks 的探索空间和实践场景。循着蚂蚁金服体验技术部的足迹，自觉很能开拓眼界和思路。 umi-hooksuseAsyncuseAsync 用于处理异步请求，它支持的功能点包含暂停、撤销、重启、轮询。 在实现上，umi-hooks 首先构造 Timer 类以定时器方式执行指定函数，timer.stop、timer.pause、timer.resume 方法可用于终止、暂停、重启定时器（初次启动也通过 resume 方法执行）。以定时器处理异步请求一方面能便于实现轮询，另一方面也是由于请求库未必都实现撤销功能。因为定时器并不能真正打断异步请求，所以 useAsync 只是不去处理响应，而不是撤销请求。另外，对于已卸载的组件，也不需要处理响应。因此是否处理响应的状态标识通过 useEffect 处理，在组件卸载时使其失效，通过 timer.stop 终止时也使其失效。这个状态标识通过 useRef 构造： 1234567891011121314// 是否处理响应标识// 1. 在异步流程前首先将 count.current 赋值给 runCount 变量// 2. 异步流程后再判断再判断 count.current 与 runCount 是否等值// 3. 组件卸载、终止、撤销处理时均将 count.current 自增 1const count = useRef(0);const init = useRef(true);useEffect(() =&gt; &#123; count.current += 1; init.current = true; return () =&gt; &#123; count.current += 1; &#125;;&#125;, _deps); umi-hooks 在 useAsync 函数内部首先通过 useCallback 实现了 run、stop、pause、resume、start 等基础功能（其中，run 方法只是单纯地调用用户传入的异步请求函数 fn）；其次构造 intervalAsync 作为定时器的回调，实现轮询逻辑；其次实现 reload 方法用于重启请求或轮询，cancel 方法取消；最后使用 useEffect 判断选项，分别启用单次请求或轮询功能。以下仅贴示 intervalAsync 的实现： 1234567891011121314151617181920212223242526const intervalAsync = useCallback( async (...args: any[]) =&gt; &#123; const runCount = count.current; let ret: Result | undefined; if (!_options.manual || !init.current) &#123; ret = await run(...(args || [])); &#125; if (count.current === runCount) &#123; // 只初始化定时器，不开始计时 timer.current = new Timer&lt;Result&gt;( () =&gt; intervalAsync(...args), _options.pollingInterval as number, ); // 如果设置了 manual，则默认不开始计时 if (init.current &amp;&amp; _options.manual) &#123; // await run(...(args || [])); init.current = false; &#125; else &#123; // 开始计时 ret = await timer.current.resume(...(args || [])); &#125; &#125; return ret; &#125;, [_options.pollingInterval, _options.manual, run],); useAPIuseAPI 在 useAsync 的基础上，以选项指定了远程请求的 url 等参数、异步调用方法。如果没有指定 opt.method 异步调用方法，也可以使用 configRequest 指定或直接使用 window.fetch 方法。 useEventEmitteruseEventEmitter 用于组织多个组件间的通信逻辑。在实现上，useEventEmitter 基于事件模型。但是绑定事件随着组件的卸载，需要得到解绑，因此 useEventEmitter 使用 useEffect 处理这一逻辑。以下是其源码： 123456789101112131415161718192021222324252627282930313233class EventEmitter&lt;T&gt; &#123; private subscriptions = new Set&lt;Subscription&lt;T&gt;&gt;(); emit = (val: T) =&gt; &#123; for (const subscription of this.subscriptions) &#123; subscription(val); &#125; &#125;; useSubscription = (callback: Subscription&lt;T&gt;) =&gt; &#123; const callbackRef = useRef&lt;Subscription&lt;T&gt;&gt;(); callbackRef.current = callback; useEffect(() =&gt; &#123; function subscription(val: T) &#123; if (callbackRef.current) &#123; callbackRef.current(val); &#125; &#125; this.subscriptions.add(subscription); return () =&gt; &#123; this.subscriptions.delete(subscription); &#125;; &#125;, []); &#125;;&#125;function useEventEmitter&lt;T&gt;() &#123; const ref = useRef&lt;EventEmitter&lt;T&gt;&gt;(); if (!ref.current) &#123; ref.current = new EventEmitter(); &#125; return ref.current;&#125; useUpdateEffectuseUpdateEffect 效果等同 useEffect，只是执行阶段在 didMount 之后（即更新阶段）。 useLocalStorageStateuseLocalStorageState 用于实时从 localStorage 读写值，又借助 useState 实时更新视图层。 useControllableValueuseControllableValue 用于处理受控值，它首先通过 props 属性读取初始值和实时值（实时值通过 useUpdateEffect 存入 state 中），随后输出 state、handleSetState 以供视图层使用。在 handleSetState 方法执行期间，useControllableValue 还允许执行 props.onChange 等方法。 useSelectionsuseSelections 借助 Set 类以及 useMemo 实现，用于处理选择逻辑。 useDynamicListuseDynamicList 用于管理列表的增删改查逻辑，除了使用 setState 维护列表元素外，还维护了 key 键列表（用于存储原数组元素在 state 中的新的索引）。 usePaginationusePagination 在 useAsync 的基础上，用于处理分页逻辑。 useSearchuseSearch 在 useAsync 的基础上，用于在表单或字段内容改变时，自动或手动发送请求获取相应。这一过程通过定时器防抖（避免频繁请求）。 useLoadMoreuseLoadMore 在 useAsync 的基础上，实现了下拉或点击加载更多的处理逻辑。其 reload 逻辑的实现是，使用 state 记录加载次数 count，当这个 count 变更时，再使用 useEffect 远程获取数据。 useAntdTableuseAntdTable 用于组织 antd-table 表格的逻辑，支持远程请求、分页、筛选、排序、搜索表单等功能。在实现上，useAntdTable 使用 useReducer 管理状态。当表格页面切换时，为了重新加载之前访问的页面数据，useAntdTable 使用 cacheData 缓存数据。在状态变更后，useAntdTable 借助 useUpdateEffect 重新发起请求。当表单数据改变时，useAntdTable 使用定时器获取表单数据，随后更新 state.count 值，最后通过 useUpdateEffect 重新发起请求。以下是部分方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758useEffect(() =&gt; &#123; // 如果存在 options.id，在切换页面时缓存页面数据，切回表格页面时重新加载 if (id &amp;&amp; cacheData[id]) &#123; const cache = cacheData[id]; /* 修改完 formData 和 searchType 之后，会触发 useUpdateEffect，给当前表单赋值 */ dispatch(&#123; type: 'updateState', payload: &#123; current: cache.current, pageSize: cache.pageSize, searchType: cache.searchType, activeFormData: cache.activeFormData, formData: cache.formData, filters: cache.filters, sorter: cache.sorter, count: state.count + 1, &#125;, &#125;); &#125; else if (form) &#123; /* 如果有 form，需要走 searchSubmit，为了初始化的时候，拿到 initialValue */ searchSubmit(); &#125; else &#123; refresh(); &#125; if (id) &#123; return () =&gt; &#123; cacheData[id] = stateRef.current; &#125;; &#125; return () =&gt; &#123;&#125;;&#125;, []);const searchSubmit = useCallback( (e?: string | React.MouseEvent&lt;HTMLElement&gt; | React.KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; &#123; if (!form) &#123; return; &#125; if (e &amp;&amp; (e as React.MouseEvent&lt;HTMLElement&gt;).preventDefault) &#123; (e as React.MouseEvent&lt;HTMLElement&gt;).preventDefault(); &#125; setTimeout(() =&gt; &#123; const activeFormData = getCurrentFieldsValues(); dispatch(&#123; type: 'updateState', payload: &#123; activeFormData, formData: &#123; ...state.formData, ...activeFormData &#125;, &#125;, &#125;); // reload 更新 state 中的 current、count reload(); &#125;); &#125;, [form, reload],); useResponsiveuseResponsive 通过监听 resize 事件，及时更新屏幕尺寸状态（屏幕尺寸分为 xs、sm、md、lg、xl 五种），提供一种绘制响应式视图的能力。 useSizeuseSize 借助 resize-observer-polyfill 库，实时获取 dom 节点的尺寸大小变更。useSize 监听的 dom 节点可以通过首参传入；在不传入首参的情况下，umi-hooks 可以通过 useRef 设置 dom 节点。 useVirtualListuseVirtualList 用于解决展示海量数据渲染时首屏渲染缓慢和滚动卡顿问题，采用的方式是逐屏滚动。在实现上，useVirtualList 使用滚动容器包裹列表，列表全量展示，通过 onScroll 事件实时设置 scrollTop 设置偏移量。以下是 useVirtualList 的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;T = any&gt;(list: T[], options: OptionType) =&gt; &#123; const [size, containerRef] = useSize&lt;HTMLElement&gt;(); // 暂时禁止 cache // const distanceCache = useRef&lt;&#123; [key: number]: number &#125;&gt;(&#123;&#125;); const [state, setState] = useState(&#123; start: 0, end: 10 &#125;); const &#123; itemHeight, overscan = 5 &#125; = options; if (!itemHeight) &#123; console.warn('please enter a valid itemHeight'); &#125; // 获取滚动容器能展示的元素数 const getViewCapacity = (containerHeight: number) =&gt; &#123; if (typeof itemHeight === 'number') &#123; return Math.ceil(containerHeight / itemHeight); &#125; const &#123; start = 0 &#125; = state; let sum = 0; let capacity = 0; for (let i = start; i &lt; list.length; i++) &#123; const height = (itemHeight as ((index: number) =&gt; number))(i); sum += height; if (sum &gt;= containerHeight) &#123; capacity = i; break; &#125; &#125; return capacity - start; &#125;; // 计算滚动隐藏内容的元素数 const getOffset = (scrollTop: number) =&gt; &#123; if (typeof itemHeight === 'number') &#123; return Math.floor(scrollTop / itemHeight) + 1; &#125; let sum = 0; let offset = 0; for (let i = 0; i &lt; list.length; i++) &#123; const height = (itemHeight as ((index: number) =&gt; number))(i); sum += height; if (sum &gt;= scrollTop) &#123; offset = i; break; &#125; &#125; return offset + 1; &#125;; // 计算列表的起止元素 const calculateRange = () =&gt; &#123; const element = containerRef.current; if (element) &#123; const offset = getOffset(element.scrollTop); const viewCapacity = getViewCapacity(element.clientHeight); const from = offset - overscan; const to = offset + viewCapacity + overscan; setState(&#123; start: from &lt; 0 ? 0 : from, end: to &gt; list.length ? list.length : to &#125;); &#125; &#125;; // 在滚动容器变更时，重新计算列表的起止元素 useEffect(() =&gt; &#123; calculateRange(); &#125;, [size.width, size.height]); // 计算列表总高度 const totalHeight = useMemo(() =&gt; &#123; if (typeof itemHeight === 'number') &#123; return list.length * itemHeight; &#125; return list.reduce((sum, _, index) =&gt; sum + itemHeight(index), 0); &#125;, [list.length]); // 获取 index 元素与顶部的距离 const getDistanceTop = (index: number) =&gt; &#123; if (typeof itemHeight === 'number') &#123; const height = index * itemHeight; return height; &#125; const height = list.slice(0, index).reduce((sum, _, i) =&gt; sum + itemHeight(i), 0); return height; &#125;; const scrollTo = (index: number) =&gt; &#123; if (containerRef.current) &#123; containerRef.current.scrollTop = getDistanceTop(index); calculateRange(); &#125; &#125;; return &#123; // 通过 state 待展示的元素 list: list.slice(state.start, state.end).map((ele, index) =&gt; (&#123; data: ele, index: index + state.start, &#125;)), scrollTo, containerProps: &#123; ref: (ele: any) =&gt; &#123; containerRef.current = ele; &#125;, // 通过滚动事件重新设置偏移量 onScroll: (e: any) =&gt; &#123; e.preventDefault(); calculateRange(); &#125;, style: &#123; overflowY: 'auto' &#125;, &#125;, wrapperProps: &#123; style: &#123; width: '100%', height: totalHeight, paddingTop: getDistanceTop(state.start) &#125;, &#125;, &#125;;&#125;; hoxhox 号称“下一代状态管理器”，因此它的意图还是在于使用 hooks 抽象 ViewModel 层，将 hooks 的使用过程从与视图组件的强关联中解放出来，同时支持在类组件中也能使用 hooks。那么，它是怎么做到的呢？它的代码逻辑很简单，即使用 Exector 虚拟组件来运作 hooks 逻辑，hooks 返回值通过绑定事件的方式通知到 Exector 虚拟组件外层，然后使用 setState 接值，传入实际渲染的视图组件中。 以下是其实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function createModel&lt;T&gt;(hook: ModelHook&lt;T&gt;) &#123; const element = document.createElement(\"div\"); // Container 提供事件绑定、触发的机制 const container = new Container(hook); // 通过虚拟组件承载 hooks 执行逻辑，每次重绘时执行 hooks 并 onUpdate 钩子 ReactDOM.render( &lt;Executor onUpdate=&#123;val =&gt; &#123; container.data = val; container.notify(); &#125;&#125; hook=&#123;hook&#125; /&gt;, element ); const useModel: UseModel&lt;T&gt; = depsFn =&gt; &#123; const [state, setState] = useState&lt;T | undefined&gt;(() =&gt; container ? (container.data as T) : undefined ); const depsFnRef = useRef(depsFn); depsFnRef.current = depsFn; const depsRef = useRef&lt;unknown[]&gt;([]); useEffect(() =&gt; &#123; if (!container) return; // 作为绑定函数，承接 hooks 返回值，并使用 useState 机制传给实际的视图组件 function subscriber(val: T) &#123; if (!depsFnRef.current) &#123; setState(val); &#125; else &#123; const oldDeps = depsRef.current; const newDeps = depsFnRef.current(val); if (compare(oldDeps, newDeps)) &#123;// 比较依赖 setState(val); &#125; depsRef.current = newDeps; &#125; &#125; container.subscribers.add(subscriber); return () =&gt; &#123; container.subscribers.delete(subscriber); &#125;; &#125;, [container]); return state!; &#125;; Object.defineProperty(useModel, \"data\", &#123; get: function() &#123; return container.data; &#125; &#125;); return useModel;&#125; 当一个视图组件需要多个 model 时，hox 像 redux 一样提供了 withModel 方法用于将多个 model 内容传输给类组件的 props。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"hybird app","slug":"frontend/architecture/hybird app","date":"2019-10-28T16:00:00.000Z","updated":"2020-03-08T10:42:40.983Z","comments":true,"path":"2019/10/29/frontend/architecture/hybird app/","link":"","permalink":"http://xzfyu.com/2019/10/29/frontend/architecture/hybird app/","excerpt":"","text":"hybird app 介于 native app、web app 之间，性能比 web app 好，比 native app 差，但是适应了更多的移动开发场景。hybird app 具有如下特点：因为受到移动设备CPU、内存、网卡、网络连接等限制，hybird app 可用的系统网络资源有限；hybird app 支持更新的浏览器特性；hybird app 可实现离线应用，即借助浏览器最新的特性或 Native 的文件读取机制进行文件级的文件缓存或离线更新；hybird app 需要考虑不同设备机型的兼容性问题；hybird app 支持唤起 Native 的能力，如摄像头、定位、传感器、本地文件访问等。理想情况下，hybird app 须唤起 native 能力绘制通用导航菜单、系统 UI、核心动效等，这样能充分利用 native 的性能优势（WebView 的执行性能只有移动端浏览器的 1/3 ~ 1/4）。 web 到 native 通信协议通过 urlNative 应用在移动端系统中注册一个 Schema 协议的 URI，这个 URI 可在系统的任意地方授权访问来掉漆一段原生方法或一个原生的界面。在此基础上，Native 应用的 WebView 控件中的 js 脚本也可以远程请求匹配 Schema 协议的 URI，如通过 iframe 的 src 属性，这个请求就能被 Native 应用的系统捕获并调起 Native 应用注册匹配的 Schema 协议内容，以唤起原生能力。 1234let iframe = document.createElement('iframe');iframe.setAttribute('style', 'display: none');document.appendChild(iframe);iframe.setAttribute('src', 'myApp://className/method?args'); 通过 addJavascriptInterfaceNative 应用也可以通过 addJavascriptInterface 方法将 Native 的一个对象方法注入到页面 window 对象中，供 js 调用。 1234567891011Websettings websettings = webView.getSettings();websettings.setJavascriptEnabled(true);// 设置 webView 允许执行 js 脚本webView.loadUrl('file:///android_asset/index.html');// 加载页面到 webView 中webView.addJavascriptInterface(new JsInterface(), 'native');// window 加入 native 对象public class JsInterface &#123; @JavascriptInterface public void showToast(String toast) &#123; Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show(); &#125;&#125; addJavascriptInterface 在 Android 4.2 以下版本有安全漏洞。另一种可行的方法时，当 js 调用 alert 或 prompt 方法时，会执行 Native 中的 onJsAlert 或 onJsPrompt 方法，因此就可以用这两个方法加以监听 html5 传递的消息。 12345678webView.setWebChromeClient(new WebChromeClient() &#123; @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; result.confirm(JSBridge.callJsPrompt(MainActivity.this, view, message)); return true; &#125;&#125;) native 到 web 通信协议首先在 html5 页面的全局作用域下声明一个方法；其次在 Android 中使用 loadUrl 唤起这个方法，或者在 iOS 中使用 stringByEvaluatingJavaScriptFromString 唤起这个方法，这样就能使 Native 应用主动调用 html5 中的 js 方法。 1234567891011121314151617Websettings websettings = webView.getSettings();websettings.setJavascriptEnabled(true);// 设置 webView 允许执行 js 脚本webView.loadUrl('file:///android_asset/index.html');// 加载页面到 webView 中JsInterface jsInterface = new JsInterface();jsInterface.log('hello world');public class JsInterface &#123; public void log(final String msg) &#123; webView.post(new Runnable() &#123;// 创建一个新线程执行 js 中的 log 方法 @Override public void run() &#123; // 调用 html5 中 window.log 方法 webView.loadUrl('javascript: log(' + '\"' + msg + '\"' + ')') &#125; &#125;) &#125;&#125; 通信协议目前较多使用的通信协议方案为 jsbridge://className:callbackMethod/methodName?jsonObj。jsbridge 为 Native 注册的协议头；className 为调用 Native 的类；methodName 为类中的方法名；jsonObj 为传递的参数；callbackMethod 为 Native 回调 js 的方法名，即 Native 调用 webView.loadUrl(‘javascript: callbackMethod()’)。以 html5 中请求 jsbridge://Util:success/toString?{“msg”: “hello world”} 为例，Native 使用 Util 类中的 toString 方法处理参数 {“msg”: “hello world”}，完成后再回调 html5 中的 success 方法。 通常 jsBridge 中会使用公共方法发送请求。如下： 12345678910111213141516171819JsBridge.call = function(className, methodName, params, callback) &#123; let bridgeStr; let paramsStr = JSON.stingify(params || &#123;&#125;); if (className &amp;&amp; methodName)&#123; bridgeStr = `jsbridge://$&#123;className&#125;:$&#123;callback&#125;/$&#123;methodName&#125;?$&#123;paramsStr&#125;`; try &#123; sendToNative(bridgeStr); &#125; catch(e) &#123; console.log(e); &#125; &#125; else &#123; console.log('Invalid className or methodName'); &#125;&#125;function setToNative(url, data)&#123; window.prompt(url, JSON.stringify(data || &#123;&#125;));&#125; 离线缓存与更新ServiceWorker使用 ServiceWorker 作离线缓存可参考 Service Worker —— 这应该是一个挺全面的整理，ServiceWorker 有兼容性问题。 localeStorage使用 localeStorage 作离线缓存就是带版本号形式缓存静态资源、页面内容、响应。典型如下： 123456789101112const newVersion = document.getElementById('versionStore').getAttribute('data-version');const oldVersion = localeStorage.getItem('version');if (newVersion &gt; (oldVersion || 0))&#123; loadScript(`scriptpath/$&#123;newVersion&#125;.js`).then(content =&gt; &#123; localeStorage.setItem('scriptpath', content); &#125;)&#125; else &#123; const script = document.createElement('script'); script.innerHtml = localeStorage.getItem('scriptpath'); document.appendChild(script);&#125; 使用 localeStorage 有以下缺点：大小有限制（同域一般认为 5M 以内）；用户手动清空会使 localeStorage 失效；读取 localeStorage 较慢。 文件增量更新文件增量更新指的是：客户端通过 localeStorage 获取本地缓存资源的版本号，与 html 页面中最新版本号对比，如果本地版本号较小，则加载增量的静态资源，如本地为 1.1.js，远程最新版本为 1.4.js，则增量获取 1.1-1.4.js。有两种机制可以实现文件的增量更新：基于代码分块、基于编辑距离。基于代码分块的思路是，以增量描述说明代码块的变动内容，新增、删除、修改、保持原样；然后根据原文件和增量描述产生新文件。基于编辑距离（Levenshtein Distance）是计算从一个字符串变更到另一个字符串的最少操作步骤，适合于少量字符串变更的文件内容。 使用文件增量更新机制，有必要埋点统计不同版本号的用户覆盖率。 native 离线资源当用户访问页面，native 首先会检查离线资源包中是否存在本地目录中的文件，然后将其与线上资源对比：如果线上有最新资源，则拉取线上资源并缓存，没有，就使用本地资源。这样当再次访问页面时，WebView 就可以读取本地资源了。 支付宝 jssdkalipayjsapi 首先添加 es6-promise 垫片。 核心流程alipayjsapi 通过 addJavascriptInterface 为 window 对象注入 AlipayJSBridge 对象，html5 页面中即可以用如 AlipayJSBridge.call(‘alert’,{message: 12345}) 形式唤起 native 能力。alipayjsapi 另外构造了一个 _JSAPI 对象。_JSAPI 约定了各方法是怎样处理入参、唤起 native 能力、处理出参等的。下面以 redirectTo 说明 _JSAPI 对象的构造： 12345678910111213141516171819202122var _JSAPI = &#123; compressImage: &#123; b: function b(opt) &#123; opt.level = __isUndefined(opt.level) ? 4 : opt.level; // _mapping 将 opt._ 更名为 opt.apFilePaths return _mapping(opt, &#123; _: 'apFilePaths', level: 'compressLevel%d' &#125;); &#125;, d: function d(_opt, cb) &#123; if (__isAndroid()) &#123; _JS_BRIDGE.call('compressImage', _opt, cb); &#125; else &#123; // _fakeCallBack 使用定时器直接调用 cb _fakeCallBack(cb, &#123; apFilePaths: _opt.apFilePaths || [] &#125;); &#125; &#125; &#125;&#125; 在 _JSAPI 对象中，每个 api 可能包含以下方法或属性：m，即 mapping 的缩写，指定 native 端实际的接口名；b，即 before 的缩写，前置处理函数，用于转化入参；d，即 doing 的缩写，指定实际的执行流程（在不指定的情况下，将使用 AlipayJSBridge.call 的形式唤起 native 能力）；a，即 after 的缩写，后置处理函数，用于转化出参；e 或者 extra，指定 handleEventData 等扩展字段。在上面一段代码中，compressImage.b 就在转换选项，compressImage.d 就在执行图片压缩操作或不作任何处理。 在 _JSAPI 的基础上，alipayjsapi 的核心流程即使用 _JSAPI 处理出入参数，再使用 AlipayJSBridge.call 唤起 native 能力；偶然绑定事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142var AP = &#123; call: function call() &#123; var args = __argumentsToArg(arguments); if (__isSupportPromise()) &#123; return AP.ready().then(function () &#123; return new Promise(realCall); &#125;); &#125; else &#123; //如果直接加到 ready 事件里会有不触发调用的情况 //AP.ready(realCall); if (_isBridgeReady()) &#123; realCall(); &#125; else &#123; //保存在待执行队列 _WAITING_QUEUE.push(args); &#125; &#125; function realCall(resolve, reject) &#123; var apiName; var opt; //原始 option var cb; //原始 callback var _opt; //处理过的 option var _cbSFC; //不同状态回调 var _cb; //处理过的 callback var onEvt; var offEvt; var doingFn; var logOpt; //强制转为 name + object + function 形式的入参 apiName = args[0] + ''; opt = args[1]; cb = args[2]; //处理 cb 和 opt 的顺序 if (__isUndefined(cb) &amp;&amp; __isFunction(opt)) &#123; cb = opt; opt = &#123;&#125;; &#125; //接口有非对象入参，设为快捷入参 if (!__isObject(opt) &amp;&amp; args.length &gt;= 2) &#123; //before、doing、after 方法中直接取 opt._ 作为参数 opt = &#123; _: opt &#125;; &#125; //兜底 if (__isUndefined(opt)) &#123; opt = &#123;&#125;; &#125; // 处理入参，使用 _JSAPI[apiName].b 处理 opt _opt = _getApiOption(apiName, opt, cb); // 获取回调，_opt 以 success、fail、complete 属性约定回调 _cbSFC = _getApiCallBacks(apiName, _opt); if (__isUndefined(_opt)) &#123; console.error('please confirm ' + apiName + '.before() returns the options.'); &#125; // 获取 _JSAPI[apiName].d 方法 doingFn = _getApiDoing(apiName); // 输出入参 logOpt = __hasOwnProperty(opt, '_') ? opt._ : opt; // AP.debug 置为真值时，在控制台打印信息 _apiLog(apiName, logOpt, _opt); // 是否是事件监听，apiName 以 on 起始 onEvt = _getApiOnEvent(apiName); // 是否是事件移除，apiName 以 off 起始 offEvt = _getApiOffEvent(apiName); // 处理回调 _cb = function _cb(res) &#123; var _res = void 0; res = res || &#123;&#125;; if (onEvt &amp;&amp; _getApiExtra(apiName, 'handleEventData') !== false) &#123; _res = _handleEventData(res); &#125; // 使用 _JSAPI[apiName].a 处理结果 _res = _getApiResult(apiName, _res || res, _opt, opt, cb); if (__isUndefined(_res)) &#123; console.error('please confirm ' + apiName + '.after() returns the result.'); &#125; // 处理错误码及相应，即处理 _res.error 及 res _res = _handleApiError(apiName, _res); // 打印 debug 日志 _apiLog(apiName, logOpt, _opt, res, _res); if (__hasOwnProperty(_res, 'error') || __hasOwnProperty(_res, 'errorMessage')) &#123; if (__isFunction(reject)) &#123; reject(_res); &#125; if (__isFunction(_cbSFC.fail)) &#123; _cbSFC.fail(_res); &#125; &#125; else &#123; if (__isFunction(resolve)) &#123; resolve(_res); &#125; if (__isFunction(_cbSFC.success)) &#123; _cbSFC.success(_res); &#125; &#125; if (__isFunction(_cbSFC.complete)) &#123; _cbSFC.complete(_res); &#125; // 执行用户的回调 if (__isFunction(cb)) &#123; cb(_res); &#125; &#125;; // 如果存在 d 直接执行，否则执行 AlipayJSBridge.call if (__isFunction(doingFn)) &#123; doingFn(_opt, _cb, opt, cb); &#125; else if (onEvt) &#123; // 将事件、处理函数等存入 _CACHE.EVENTS _cacheEventHandler(onEvt, cb, _cb, _cbSFC); // 使用 document.addEventListener 绑定事件 AP.on(onEvt, _cb); &#125; else if (offEvt) &#123; _removeEventHandler(offEvt, cb); &#125; else &#123; // 执行 AlipayJSBridge.call _JS_BRIDGE.call(_getApiName(apiName), _opt, _cb); &#125; // 埋点，发送日志到远程服务器 _apiRemoteLog(apiName); &#125; &#125;,&#125; 埋点alipayjsapi 先收集调用的 api，当收集的 api 到 6 个时，再使用定时器上报。alipayjsapi 兜底使用返回按钮的 back 事件上报日志。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var _apiRemoteLog = function () &#123; var apiInvokeQueue = []; var timerId = void 0; var isTimerActived = false; //发送日志 function triggerSendLog() &#123; setTimeout(function () &#123; if (apiInvokeQueue.length &gt; 0) &#123; var param1 = apiInvokeQueue.join('|'); AP.ready(function () &#123; _JS_BRIDGE.call('remoteLog', &#123; type: 'monitor', bizType: 'ALIPAYJSAPI', logLevel: 1, // 1 - high, 2 - medium, 3 - low actionId: 'MonitorReport', seedId: 'ALIPAYJSAPI_INVOKE_COUNTER', param1: param1 &#125;); &#125;); AP.debug &amp;&amp; console.info('REMOTE_LOG_QUEUE&gt;', apiInvokeQueue); apiInvokeQueue = []; &#125; // 停止计时器 clearTimer(); &#125;, 0); &#125; // 计时器 function timer() &#123; // 计时激活标致 isTimerActived = true; // 启动计时器 timerId = setTimeout(function () &#123; // 日志发送 triggerSendLog(); &#125;, 5000); // 5 秒上报 &#125; // 清除计时器 function clearTimer() &#123; !__isUndefined(timerId) &amp;&amp; clearTimeout(timerId); isTimerActived = false; &#125; // back 事件上报日志，作为兜底 AP.on('back', function () &#123; triggerSendLog(); &#125;); return function (apiName) &#123; apiInvokeQueue.push(apiName); // 6 个上报 if (apiInvokeQueue.length &gt;= 6) &#123; triggerSendLog(); &#125; else if (!isTimerActived) &#123; timer(); &#125; &#125;;&#125;(); 参考《现代前端技术解析》 —— 张成文","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"uform","slug":"frontend/editor/uform","date":"2019-10-26T16:00:00.000Z","updated":"2020-03-08T10:56:11.404Z","comments":true,"path":"2019/10/27/frontend/editor/uform/","link":"","permalink":"http://xzfyu.com/2019/10/27/frontend/editor/uform/","excerpt":"","text":"通常对表单的抽象分为状态管理和视图组件两部分。按我的理解，uform 的三层结构与 redux + redux-react + react 组件或 mobx + mobx-react + react 组件的构成模式相仿。 @uform/core：状态管理层，抽象通用 form 表单、field 字段的状态管理逻辑。 @uform/react：抽象视图层，其一桥接状态管理器和视图组件，其二用于注册组件或容器等。 @uform/antd, @uform/next：视图组件层，对接特定的视图组件库。 @uform/core在不借助 redux 等状态管理器的前提下，针对业务逻辑抽象状态管理的做法是：OOP 编程方式抽象状态管理类，并提供统一的副作用接口驱动视图重绘。多个 store 之间可以通过消息总线通信；或者相互持有实例；或者在视图层组织交互逻辑。在这种设计思想下，store 状态管理类和 view 视图组件类即如下图： 不同于 redux 等适用于全领域的状态管理器，表单的状态管理有其特点，所涉及的状态包含表单数据、脏值状态、校验状态、错误状态、编辑状态（在表单编辑器中）、props 等。表单状态管理分为两层：Form 表单层级、Field 字段层级。rc-form 的状态管理没有到字段层级，FormItem 组件从子字段中获取校验信息等数据。更为精细的状态管理需要到字段层级，这样就可以不用重绘表单，而是重绘字段组件。因为字段组件的类型众多，业务实体也可能以字段组件的形式呈现，所以，一般使用通用的 Field 模型抽象字段的状态管理逻辑。 在 uform 中，Field 实例以 field.context 属性持有 Form 实例。Form、Field 实例对外通信均可以通过 Broadcast 绑定订阅函数达成，典型的订阅函数即利用 setState 以驱动组件重绘。不同的是，Form 实例用于构造对外交互接口，允许用户挂载多个订阅函数；Field 实例只允许挂载一个订阅函数 —— 变异的 setState，既驱动字段组件重绘，又驱动表单状态更新。Form 内部的事件机制通过 rxjs 的 Subject 实现，支持通过初始化选项绑定事件回调，其被称为 effect 副作用，包含 onFormReset、onFormSubmit、onFieldInit、onFieldChange、onFieldInputChange 这几类。 表单数据状态变更只有一种模式：通过 Form 提供的接口更新，Field 接口不对外暴露。因为字段组件的绑定事件挂载了 mutators.change（mutators 由封装 Form 接口实现），所以当用户交互行为驱动字段更新时，首先会更新 Form 表单数据，其次间接更新相关的 Field 数据，其次 Field 数据变更引起字段组件重绘，最后触发表单层面 onFieldChange 副作用执行。通过 effect 副作用更新字段数据的执行逻辑也是这样的。uform 通过 syncUpdateMode 属性区分同步更新字段和异步更新字段两种模式：同步模式直接使用 raf 更新字段；异步模式通过 raf 在下一次绘制时批量更新字段。 Form 实例提供三种更新状态的方式： 用于构造 mutators 的 form.setValue；在 effect 场景中使用的 form.setFormState、form.setFieldState。setValue 较为简单，即首先使用 Field 实例更新字段的状态，其次当字段存在脏值时予以重绘，其次触发 onFieldInputChange 副作用，最后校验表单并触发执行表单层面的订阅函数、onFieldChange 副作用。setFormState、setFieldState 并不会触发 onFieldInputChange 副作用，但这两个方法都会通过 formNotify 触发 onFieldChange 副作用。 setFormState 流程图： setFieldState 流程图： 如上文所说，uform 不止于管理表单数据、校验状态等状态（两者均通过 field.notify 驱动字段组件的重绘），还包含 props、editable 可编辑状态等数据。在提升性能方面，精准的字段状态管理可以只驱动字段的重绘，而不是表单的重绘；uform 又使用 raf 在启动重绘。至于功能上的联动显示隐藏，uform 一方面可以通过 setFieldState 更新字段的 visible, display 状态；另一方面可以通过 react 语法在特定条件下构建字段组件实例（通过 props.onChange 方法监听并插入字段组件）。在后一种情况下，uform 允许使用 updateFieldStateFromBuffer 更新新增字段的状态。 @uform/react与 rc-form 一样，uform 也使用高阶组件 StateForm、StateField 将状态管理器注入到表单及字段组件中；但是子组件表单没法通过 props.form 访问 Form 实例，StateForm 会通过 context 将 Form 实例直接传给字段 StateField。表单的高阶组件主要在于将 Form 实例的订阅函数等通过 props 透出到表单外围、通过 props 更新 Form 实例的状态、将 Form 实例透传给内部子组件；字段的高阶组件主要在于通过 props 更新 Field 实例的状态、构建 mutators 监听字段组件的变更以实时更新字段的状态。 StateForm 会通过 registerFormWrapper 函数注册成原始表单的外层容器；registerFormWrapper 函数还可用于注册其他容器。注册完成后，通过 OriginForm 可以获取集成外围容器的表单组件。与 registerFormWrapper 功能相仿，registerFieldMiddleware 用于为字段组件添加外围容器（外围容器的功能如在 antd 中为字段组件包裹上 FormItem 组件）。registerFormField 用于注册字段组件，如 input，radio 等。因为对于不同的字段组件，其值可能会有不同的 props 属性表现（如 props.value、props.checked 等），编辑状态与不可编辑状态也可能会使用不同的字段组件，@uform/react 提供 connect 用于转换 props 或处理 schema。在 registerFormField 时，一般会配合使用 connect。 uform 中的字段渲染比较特别，分为两种模式：SchemaMarkup 传入 props.schema，直接予以渲染；通过 SchemaField 描述 SchemaForm 包含的字段组件，收集 schema 后予以渲染。@uform/antd 透出的 SchemaForm 即基于 SchemaMarkup；Field 即基于 SchemaField。以下是源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899const SchemaForm = SchemaMarkup()( React.forwardRef((props: ISchemaFormProps, ref: React.Ref&lt;any&gt;) =&gt; &#123; // 这个时候就有 schema 数据 const &#123; children, className, ...others &#125; = props return ( &lt;OriginForm className=&#123;`rs-uform $&#123;className || &apos;&apos;&#125;`&#125; &#123;...others&#125; ref=&#123;ref&#125; &gt; &lt;div className=&quot;rs-uform-content&quot;&gt; &#123;/* 从 schema 取出数据渲染 */&#125; &lt;FormField name=&quot;&quot; path=&#123;[]&#125; schemaPath=&#123;[]&#125; /&gt; &lt;/div&gt; &#123;children&#125; &lt;/OriginForm&gt; ) &#125;))// 虚拟组件，仅用于收集 schemaconst SchemaField = props =&gt; &#123; const parent = useContext(MarkupContext) if (schemaIs(parent, &apos;object&apos;)) &#123; const name = props.name || getRadomName() parent.properties = parent.properties || &#123;&#125; parent.properties[name] = clone( props, filterSchemaPropertiesAndReactChildren ) return ( &lt;MarkupContext.Provider value=&#123;parent.properties[name]&#125;&gt; &#123;props.children&#125; &lt;/MarkupContext.Provider&gt; ) &#125; else if (schemaIs(parent, &apos;array&apos;)) &#123; parent.items = clone(props, filterSchemaPropertiesAndReactChildren) return ( &lt;MarkupContext.Provider value=&#123;parent.items&#125;&gt; &#123;props.children&#125; &lt;/MarkupContext.Provider&gt; ) &#125; else &#123; return props.children || &lt;React.Fragment /&gt; &#125;&#125;const SchemaMarkup = createHOC((options, SchemaForm) =&gt; &#123; return class extends Component&lt;ISchemaFormProps&gt; &#123; public static displayName = &apos;SchemaMarkupParser&apos; public portalRoot = document.createElement(&apos;div&apos;) public render() &#123; const &#123; children, initialValues, defaultValue, value, schema, ...others &#125; = this.props let alreadyHasSchema = false let finalSchema = &#123;&#125; if (schema) &#123; alreadyHasSchema = true finalSchema = schema &#125; else &#123; finalSchema = &#123; type: &apos;object&apos; &#125; &#125; nonameId = 0 return ( &lt;React.Fragment&gt; &#123;!alreadyHasSchema &amp;&amp; // 只是为了去收集 schema 数据 createPortal( &lt;MarkupContext.Provider value=&#123;finalSchema&#125;&gt; &#123;children&#125; &lt;/MarkupContext.Provider&gt;, this.portalRoot )&#125; &#123;/* 收集后的 schema 用于渲染 */&#125; &lt;SchemaForm &#123;...others&#125; defaultValue=&#123;defaultValue&#125; value=&#123;value&#125; initialValues=&#123;initialValues&#125; schema=&#123;finalSchema&#125; &gt; &#123;children&#125; &lt;/SchemaForm&gt; &lt;/React.Fragment&gt; ) &#125; &#125;&#125;) @uform/react 封装了三种抽象组件：array 列表组件、object 多属性组件、slot 插槽组件（渲染 schema.renderChildren）。registerFieldRenderer 函数用于增强 schema 的解析能力，默认 schema[‘x-render’] 可以作为字段组件的渲染函数。 借助于通过 createContext 机制传递 Broadcast 实例，StateForm、StateField 会持有相同的 Broadcast 实例。这个 Broadcast 实例可以作为组件层级的通信总线。@uform/react 另外借助了 react-eva 可用于以 actions、effects 形式操控表单。 @uform/antd@uform/antd、@uform/next 主要利用 @uform/react 提供的 registerFormWrapper、registerFieldMiddleware、registerFormField + connect 完成表单外围容器、字段外围容器、字段组件的注册。如在 @uform/antd 中，会通过 registerFormWrapper 为表单包裹上 antd 的 Form 组件；通过 registerFieldMiddleware 为字段包裹上 FormItem 组件；通过 registerFormField + connect 注册 input，radio 等字段组件。 后记uform 有其设计和实现上的复杂性，本文暂未深入挖掘子字段、path、列表组件等内容。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"editor","slug":"frontend/editor","permalink":"http://xzfyu.com/categories/frontend/editor/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"大数据之路读后 —— 数据服务章","slug":"数据技术/数据服务","date":"2019-10-24T16:00:00.000Z","updated":"2020-03-08T11:35:40.447Z","comments":true,"path":"2019/10/25/数据技术/数据服务/","link":"","permalink":"http://xzfyu.com/2019/10/25/数据技术/数据服务/","excerpt":"","text":"架构演进阿里巴巴的数据开放服务经历了四个阶段：DWSOA、OpenAPI、SmartDQ 和 OneService。 DWSOA：将业务方对数据的需求通过 SOA 服务提供除去（接口内部实现数据计算逻辑）。接口开发、测试、上线繁复，灵活性不高，扩展性差，复用率低。 OpenApi：同类数据（如会员数据）合并成一张逻辑表，对外透出一个接口，通过接口参数定位具体数据。接口数量随着类目数量也逐渐增多。 SmartDQ：逻辑表的取数据逻辑通过 SQL （作为领域专用语言 DSL）描述，SmartDQ 通过解析 SQL、生成执行计划、执行 SQL、合并数据、限制结果，最终透出数据。SmartDQ 通过跨异构数据源适配器对接不同的数据库，并且封装了分布式查询功能，无需关心底层物理表是不是分库分表。应用层，SmartDQ 提供接口配置管理，且集成监控、限流、计费、权限能力。缺点是 SQL 无法解决复杂的业务逻辑，即提供个性化的数据内容。 OneService：OneService 在 SmartDQ 的基础上，切分数据使用场景，主要包含以下几类：个性化的垂直业务场景、实时数据推送服务、定时任务服务。介于此，OneService 提供多种服务类型满足不同场景，分别是 OneService-SmartDQ、OneService-Lego、OneService-iPush、OneService-uTiming。OneService-Lego 采用插件化开发模式，一类需求一个插件，用于满足个性化的垂直业务场景。OneService-iPush 通过 websocket 或 long-polling 实时推送数据。OneService-uTiming 提供定时任务、即时任务两种模式。 在 OneService 阶段；数据生产者推送数据入库，服务提供者根据规范快速创建、发布、监控、下线服务；服务调用者可以在门户网站中快速检索、申请、调用服务。 SmartDQ 架构图： OneService 架构图： 架构细节 逻辑表通过多个数据源的物理表汇总而成，多个逻辑表挂在一个主题下。服务层元数据中心用于进行元数据配置，并维护物理表到逻辑表的映射。同时，服务层会把元数据加载到本地缓存中，以便进行后续的模型解析。 元数据分三套环境：日常、预发、线上。元数据经预发布经验证后，才可以正式发布。元数据的权限级别在逻辑表层级。当某用户修改逻辑表及其下的物理表资源时，禁止其他用户修改。技术上，元数据缓存采用增量更新。 主处理模块首先会通过解析 DSL（即 SQL 描述）获得查询树；其次遍历查询树，混入元数据模型中的逻辑表信息，获得逻辑 Query；其次通过元数据模型中物理表和逻辑表的映射关系，将逻辑 Query 转成物理 Query；其次按所涉及的物理表拆分为 SubQuery；其次将 SubQuery 组装成 SQL 语句并交给 DB 执行；最后将执行结果合并，返回调用者。 对于 Get 快查询和 List 慢查询，分配两套线程池，避免 Get 快查询前面有一个 List 慢查询，导致等待时间过长。在查询优化过程中，引擎会将不必要的 List 慢查询转成 Get 快查询。 查询服务器分组，每个分组有明确的服务对象和保障等级。分组隔离使 A 分组的异常不会影响到 B 分组。分组策略会进行动态调整，以实现资源的最大化利用。 数据安全方面，查询强制带上 LIMIT 限制，并设定必传字段，防止全表扫描。 日志采集方面，采集内容包含调用时间、接口名、方法名、返回记录数等基础信息；调用者应用名、来源 IP 地址等调用者信息；调用指标、查询筛选条件等调用信息；响应时间、是否走缓存等性能指标信息；出错原因、错误类型、数据源、错误堆栈等错误信息。在有了日志的基础上，可以监控系统的健康：总体、分组或单机的性能；逻辑表被调用情况（零调用酌情予以下线处理）；慢 SQL 查找并优化；错误排查。","categories":[{"name":"数据技术","slug":"数据技术","permalink":"http://xzfyu.com/categories/数据技术/"},{"name":"读书笔记","slug":"数据技术/读书笔记","permalink":"http://xzfyu.com/categories/数据技术/读书笔记/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"HSF服务","slug":"backend/远程通信/HSF服务","date":"2019-10-22T16:00:00.000Z","updated":"2020-03-08T11:28:09.273Z","comments":true,"path":"2019/10/23/backend/远程通信/HSF服务/","link":"","permalink":"http://xzfyu.com/2019/10/23/backend/远程通信/HSF服务/","excerpt":"","text":"前言此前用 node 对接过一段时候的 HSF 服务，不知分寸地一头扎进 node 模块源码里，也没得出个所以然。直到今天偶然在《企业IT架构转型之道：阿里巴巴中台战略思想与架构实战》这本书读到有关 HSF 的内容，才理解了 HSF 实现的大致原理。看来还是要多读书、多看文档。谨以这篇短文留念。 HSFHSF 全称 High Speed Framework 高速服务框架，是阿里内部广泛使用的 RPC 框架。不同于 ESB 企业服务总线，HSF 实现了服务调用方（Consumer）和服务提供方（Provider）的点对点通信。在 HSF 框架中，地址服务器用于维护全量服务器（包含服务调用方和服务提供方）和 Diamond 服务器列表信息；配置服务器用于记录服务发布（服务提供方发布了哪些服务）和服务订阅（服务调用方需要哪些服务）信息，并将相关信息推送到对应的服务器上，如配置服务器会将服务提供方的相关信息推送给服务调用方。配置服务器与服务提供方、服务调用方均保持长连接，采用心跳的方式监控各服务运行节点的状况，以便剔除故障的服务提供方。HSF 通过 ip 和端口号锁定服务提供方或服务调用方；通过服务名和版本号定位服务（因此，通过指定服务名和版本号可以直连本地服务器）。首先服务提供方会在配置服务器中完成服务的注册发布，然后服务调用方会在配置服务器中订阅服务，以便配置服务器即时推送服务提供方的 ip 和端口。为了服务发布、订阅、推送的负载均衡，生产环境上的配置服务器一般会配置多台，且在不同的配置服务器之间会作实时的数据同步。 每一个 HSF 的应用均以 War 包形式存在，运行在 Ali-Tomcat 容器中。Ali-Tomcat 容器层已经集成了 HSF 服务框架对服务提供者或服务调用者进行配置服务器发现、服务注册、订阅、失效转移等相关功能，所以不管是在服务提供者还是调用者开发时，只需要进行服务相关的配置操作，应用中无需引入任何 HSF 相关的 Jar 包。 在服务提供方和服务调用方的点对点通信中，服务调用者会从服务提供者列表中随机选择一台进行通信，无需通过 ESB 中转，因此就形成“去中心化”的服务架构。当请求的服务提供方故障时，服务调用者会获得失败反馈，继而从剩下的服务提供者列表中选择一台再次通信，这就是 HSF 服务的容错机制；同时配置服务器与服务提供方的长连接通信，允许配置服务器及时剔除故障的服务提供方并推送到服务调用方。HSF 的线性扩展能力在于，只要启动一台新的服务提供方服务器，并由配置服务器推送给服务调用方，即可以分摊服务调用的压力。 DiamondDiamond 服务器用于推送统一的配置服务。在 HSF 中，Diamond 主要用于： 通过设置白名单使某些服务调用方的服务只被特定 IP 地址的服务器调用。 通过用户认证的方式控制服务是否能被调用。 按照不同的服务路由权重设置服务调用方对多个服务提供方服务节点的访问。 设置某些服务的 QPS 能力上限值，实现限流。 Diamond 会将这些规则保存在在自身的 MySql 中，并将这些规则推送到相关的服务节点上，使这些规则能立即在服务运行环境中生效。 通信和序列化协议HSF 框架使用网络通信框架 Netty、Hession 数据序列化协议实现服务器键的交互。这类 RPC 协议采用多路复用的 TCP 长连接方式，即在服务提供方和调用方点对点通信期间会共用同一个长连接，以传输不同的请求块。Hessian 数据序列化协议精简高效，同时可以跨语言使用。另外 Hessian 可以充分利用 Web 容器的成熟功能，在处理大量用户访问时很有优势，在资源分配、线程排队、异常处理等方面都可以由 Web 容器保证。 参考HSF简介（摘自《企业IT架构转型之道》）HSF 概述","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"远程通信","slug":"backend/远程通信","permalink":"http://xzfyu.com/categories/backend/远程通信/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"web安全机制","slug":"frontend/architecture/web安全机制","date":"2019-10-19T16:00:00.000Z","updated":"2020-03-08T10:42:40.983Z","comments":true,"path":"2019/10/20/frontend/architecture/web安全机制/","link":"","permalink":"http://xzfyu.com/2019/10/20/frontend/architecture/web安全机制/","excerpt":"","text":"常见的前端安全问题包含 XSS（Cross Site Script，跨站脚本攻击）、CSRF（Cross-site Request Forgery，跨站请求伪造）、点击劫持等。 浏览器安全同源策略浏览器的同源策略限制了 document 或脚本的跨源读写能力。若域名、子域名、端口、协议其中一个有所不同，浏览器就会认为两个站点是跨源的。当 script、img、iframe、link 等包含 src 属性的标签加载远程资源，即便资源提供的域名和页面的域名不一致，浏览器还是会认为资源的 origin 为当前页面的所在域。与 xhr 不同的是，通过 src 加载的资源，浏览器限制了 js 读写响应的能力。在不启用 CORS 功能的站点中，xhr 只能发起同源请求。除 xhr 外，cookie 也会受同源策略的限制，即，理论上不能在非源站点中获取原站点的 cookie。 sandbox浏览器采用多进程架构隔离多个功能模块、tab。Chrome 的主要进程为：浏览器进程、渲染进程、插件进程、扩展进程。插件进程与浏览器进程严格隔离。渲染进程通过沙箱隔离，网页代码与浏览器内核进程通信、与操作系统通信都需要通过 IPC channel。沙箱使不可信的代码运行在一定的环境中，限制不可信的代码访问隔离区外的资源；如果一定要访问隔离区外的资源，就必须通过指定的数据通道，由特定的 API 校验数据的合法性。浏览器主要用于限制 js 在安全区内执行；多进程架构也使一个 tab 挂掉后，不会影响另一个 tab。 恶意网址拦截基于页面特征模型，浏览器厂家会将恶意网址加入黑名单中，并推送到客户端，保障用户访问的安全性。网址黑名单并不一定由浏览器厂家收集获得，也可以借助第三方安全厂商提供。 XSSXSS 由可解析执行的代码插入到页面中引起；在页面渲染过程中，这段代码会被执行，从而引起安全问题（如盗取数据、伪造账号等）。因为恶意代码可能是加载特定 js 资源的 script 标签，所以 XSS 攻击引起的问题包含通过 js 代码劫持 cookie、伪造请求等；XSS 也可以通过 js 画出登录框，把用户的提交数据发送给黑客电脑，从而造成账号密码的泄漏；XSS 可以通过 window.name 在非源站点中获取源站点的 cookie 信息（window 为浏览器窗体，不像 document 那样受同源策略的影响，因此将 cookie 赋值给 window.name 就可以在非源站点获取到 cookie 信息）；XSS 攻击也能通过 UserAgent 获取用户的操作系统和浏览器版本等信息，并逐步挖掘到用户安装的软件、浏览器的扩展程序，再通过浏览器漏洞植入木马。XSS 甚至可以通过 Java Applet、Flash、iTunes、Office Word、QuickTime 等第三方软件获取用户的 ip 地址。更有甚者，XSS Worm 蠕虫会利用社交平台的好友列表，能使恶意代码迅速扩散。 测试 XSS 攻击平台有 Attack API、BeFF、XSS-Proxy、 XSS 分为存储型 XSS、反射型 XSS、DOM XSS（MXSS）三种。存储型 XSS 是指恶意代码随着提交数据入库，再从数据库读取回显时引起恶意代码的执行。因此，存储型 XSS 能引起稳定持续的安全问题。反射型 XSS 是指将用户输入“反射给”浏览器，即需要一个交互行为才能使攻击成功。典型的交互行为如点击一个恶意链接，通过 url 参数植入恶意脚本，url 参数在使用过程时将执行恶意脚本（所以 react 设置了 dangerouslySetInnerHTML 属性，es6 提供模板字符串处理变量）。黑客也可以通过 location.hash 构造 url 参数，因为 hash 路由不会造成发包请求，这样服务器日志也不会留有记录，也就隐藏了黑客的真实意图。MXSS 由恶意代码段代插入 DOM 属性中引起，效果等同反射型 XSS。 XSS 的防范方式有以下几种： 在 cookie 中设置 httpOnly 标识，禁止通过 js 访问 cookie，以免 cookie 被劫持。 提交表单时通过验证码等交互行为限制接口调用的成功率，这样就能在一定程度上避免 XSS 伪造请求。 验证所有输出到页面上的数据，并对必要的内容作转义处理（成熟的模板引擎需要防范使用模板变量进行 XSS 攻击）。 服务端使用开源的 XSS Filter 检查输入。 对 url 参数进行加密，避免攻击者伪造（加密后的 url 不利于用户收藏）。 以下是常见的转义处理： 1234567891011121314151617181920212223function htmlEncode(str)&#123; if (str.length === 0) return ''; return str.replace(/&amp;/g, '&amp;amp;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;') .replace(/ /g, '&amp;nbsp;') .replace(/\\'/g, '&amp;#39;') .replace(/\\\"/g, '&amp;quot;') .replace(/\\n/g, '&lt;br&gt;');&#125;;function htmlDecode(str)&#123; if (str.length === 0) return ''; return str.replace(/&amp;amp;/g, '&amp;') .replace(/&amp;lt;/g, '&lt;') .replace(/&amp;gt;/g, '&gt;') .replace(/&amp;nbsp;/g, ' ') .replace(/&amp;#39;/g, '\\'') .replace(/&amp;quot;/g, '\\\"') .replace(/&lt;br&gt;/g, '\\n');&#125;; CSRFCSRF 是非源站点携带着源站点的 cookie 数据，继而调用源站点的接口，这样就容易避过用户校验，并使请求执行成功（如篡改金额后调用支付接口）。浏览器 cookie 分为两种：指定失效时间的本地 cookie，浏览器在切换 tab 到子域时不会将该 cookie 带入另一个 tab；未指定失效时间的临时 cookie，在浏览器进程的生命周期中有效，且可以在不同 tab 子域中传播。部分浏览器并未禁止不同域的 iframe, img, script, link 等标签携带本地 cookie，但是所有浏览器允许携带临时 cookie。为嵌入第三方广告等 iframe，W3C 指定的 P3P 头允许 iframe 等标签携带本地 cookie，这样做既使第三方广告能获得 cookie 信息，也增加了遭受 CSRF 攻击的风险。在 CSRF 攻击中，攻击者会伪造嵌入源站点 iframe 的非源站点获取 cookie 信息，同时可以使用 js 脚本伪造 post 请求等。 CSRF 的防范方式有以下几种： 提交表单时通过验证码等交互行为限制接口调用的成功率，这样就能在一定程度上避免 CSRF 伪造请求。 校验 Referer 头是不是指定的页面，但是服务器未必能获取到 Referer 头。 对 url 参数进行加密，避免攻击者伪造（加密后的 url 不利于用户收藏）。 添加随机且加密且有一定实效的 token。token 由后端生成，可通过 html 模板变量、session、cookie 传给前端；再由前端添加到请求体或请求头中；提交数据后，后端将验证 Token 以判断用户的准确性。 点击劫持 点击劫持：在非源站点中使用隐藏的 iframe 加载源站点页面，再通过诱导用户点击源站点的按钮等，产生恶意行为。 图片覆盖攻击：与点击劫持相类，仍是用 iframe 加载源站点页面，再诱导用户点击绝对定位的图片。 拖拽劫持：拖拽不受同源策略的限制，在使用 ifame 加载源站点页面的情况下，就能通过拖拽脚本窃取源站点的信息。 触屏劫持：与点击劫持相类。 防御点击劫持的手段其一是禁止 iframe 嵌套，这种做法叫做 frame busting。frame busting 是可以被绕过的，详情参看 “Busting frame busting: a study of clickjacking vunlnerabilities at popluar site”。以下是 frame busting 的简单示例。防御点击劫持的手段其二是通过 X-Frame-Options 限制 iframe 加载，这样可以回避 frmae busting 的被绕过。 123456789101112131415161718192021222324252627282930313233343536373839404142// frame busting 条件语句if (top != self)if (top.location != self.location)if (top.location != location)if (parent.frames.length &gt; 0)if (window != top)if (window.top !== window.self)if (window.self != window.top)if (parent &amp;&amp; parent != window)if (parent &amp;&amp; parent.frames &amp;&amp; parent.frames.length&gt;0)if((self.parent&amp;&amp;!(self.parent===self))&amp;&amp;(self.parent.frames.length!=0))// frame busting 纠正错误语句top.location = self.locationtop.location.href = document.location.hreftop.location.href = self.location.hreftop.location.replace(self.location)top.location.href = window.location.hreftop.location.replace(document.location)top.location.href = window.location.hreftop.location.href = \"URL\"document.write('')top.location = locationtop.location.replace(document.location)top.location.replace('URL')top.location.href = document.locationtop.location.replace(window.location.href)top.location.href = location.hrefself.parent.location = document.locationparent.location.href = self.document.locationtop.location.href = self.locationtop.location = window.locationtop.location.replace(window.location.pathname)window.top.location = window.self.locationsetTimeout(function()&#123;document.body.innerHTML='';&#125;,1);window.self.onload = function(evt)&#123;document.body.innerHTML='';&#125;const url = window.location.href; top.location.replace(url)// 示例if(top.location != location)&#123; top.location = self.location;&#125; html5在 html5 中，新标签可能会产生 XSS 攻击，比如通过 video 的绑定事件执行恶意代码。为此，HTML5 Security Cheatsheet 项目统计了一些安全问题。 html5 为 iframe 添加了 sandbox 属性，可选值 allow-same-origin 允许同源访问、allow-top-navigation 允许访问顶层窗口、allow-forms 允许提交表单、allow-scripts 允许执行脚本。这样就大大提高了使用 iframe 的安全性。 html5 为 a、area 的 rel 属性添加了 noreferer 值，即在跳转链接时不携带源站点的地址信息，以免敏感信息的泄漏。 html5 的其他安全问题包含：利用 canvas 可以破解图片验证码；CORS 当后端设置 Access-Control-Allow-Origin: * 时，源站点允许任意的跨域请求；window.postMessage 在不检验 domain 域的前提下，可以接受来自任何页面的消息；localStorage、sessionStorage 提供了保存恶意代码的可能，容易引起 XSS 攻击。 参考《白帽子讲安全》Busting Frame Busting: a Study of Clickjacking Vulnerabilities on Popular Sites","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"MV* 架构","slug":"frontend/architecture/MV*架构","date":"2019-10-12T16:00:00.000Z","updated":"2020-03-08T10:42:40.983Z","comments":true,"path":"2019/10/13/frontend/architecture/MV*架构/","link":"","permalink":"http://xzfyu.com/2019/10/13/frontend/architecture/MV*架构/","excerpt":"","text":"前言曾听人说起“前端没有架构”，我心里时常也有这种困惑。当框架、脚手架划定了前端代码的组织模式后，一方面使前端更聚焦于业务代码的编写，提升了工作时的投入产出比；另一方面也使前端更容易陷在琐碎的业务点上，压抑了饱含灵性的智力作业。但若仔细思索，我会认为前端也有其架构空间：比如设计复杂的业务模块、编辑器、工具库等；比如规划多应用构成的站点。一个人困于所见、所识、所遇，就会产生望洋兴叹、嗟伤时物的情绪。当前端从业者说“前端没有架构”的时候，也许是他的境界还没有达到一定高度，也许是他困于拧螺丝的活而没有出路。这篇文章写在分析 UForm 源码之前，目的在于逐步提炼对前端技术的系统化认知。介于水平的有限，这篇文章难免错谬。 MVC 架构MVC 架构源自桌面应用，在前后端领域均有见及。Model 为模型层，负责与外通信、对接数据；View 为视图层，负责构建视图内容；Controller 为控制器层，负责串联模型层和视图层。MVC 架构最常用见于单应用的组织形态。个人理解，在后端 Spring MVC 应用编码过程中，services 层可用于提供原子级的数据服务；controller 层可用于组合原子级的数据服务，并向页面模板注入内容；view 层以备模板引擎输出 html。controller 层在串联 service 和 view 层时，所采用的关键连接点是路由信息等。到了前端 SPA 应用中，路由仍旧是一个关键连接点，通过 controller 为不同页面输送数据。如果 controller 层进一步对接视图中的交互逻辑，那么 controller 层就与 Presenter 表现层表现相同，构成 MVP 架构（视图层和表现层双向通信）。本文并不区分 MVC 和 MVP 这两种架构。 与 jQuery 等 DOM 交互框架相比，采用 MVC 架构实现的应用和组件形态都更聚合，编码模式更为清晰，因此也更容易复用和维护。成熟的 MVC 框架一般通过事件监听或观察者模式实现，比如 backbone.js 等。 以下分别是采用 MVC 架构组织 SPA 应用、前端组件的简单设想，仅以说明 MVC 架构在前端中的应用形态。 单页应用中的 MVC 架构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 引擎类，管理控制器、视图、模型 */class Engine &#123; controllers: Controller[]; views: &#123; [key: string]: View &#125;; models: &#123; [key: string]: Model &#125;; /* 注册视图 */ registerView(name: string, view: View): void; /* 注册控制器 */ registerController(controller: Controller): void; /* 注册模型 */ registerModel(name: string, model: Model): void; /* 根据 hash 路由变更，调用控制器渲染视图 */ onHashChange(): void;&#125;/* 模型装饰器，用于为控制器类属性注入相应的 model，从引擎实例中获取 */function model(name: string): Model;/* 控制器装饰器，用于为视图类属性注入相应的 controllerl，从引擎实例中获取 */function controller(name: string): Controller;/** * 视图类，通过 @controller 为其属性装填特定的 controller */class View &#123; /* 页面模板 */ tpl: string; /* 绑定事件，绑定函数可以是特定 controller 的方法 */ binds(): void; /* 使用模板引擎渲染页面 */ render(model): html;&#125;/** * 控制器类，通过 @model 为其属性装填特定的 model */class Controller &#123; /* 路由 */ route: string; /* 处理异步请求，变更模型数据，使用 view 渲染视图 */ handler(): void; /* 仅举例视图交互逻辑的抽象 */ onClick(event: any): void;&#125;/** * 模型类 */class Model &#123; /* 包含数据 */ data: any; /* 仅举例异步请求的抽象 */ get(params: Params): void; /* 仅举例业务处理逻辑的抽象 */ add(item: any): void;&#125; 前端组件中的 MVC 架构123456789101112131415161718class Component &#123; /* 渲染内容模板 */ tpl: string; /* 数据模型 */ model: any; /* 构建 dom 节点，并绑定事件 */ view(): DOMElement; /* 将内容渲染到特定节点 */ renderTo(data: any, elm: DOMElement): void; /* 控制器方法 */ controllers: &#123; [key: string]: Function, &#125;;&#125; MVVM 架构MVVM 架构中的 VM 指的是 ViewModel，它实现了双向绑定，视图层的变更会自动通知到数据模型层，反之亦然。因此，MVVM 架构可以认为是一种自动化的 MVP 架构。典型的 MVVM 框架有 Vue, Angular 等。承接上文，以下是采用 MVVM 架构组织前端组件的简单设想。 1234567891011121314151617181920212223class ViewModel &#123; /* 声明指令、绑定函数的渲染内容模板 */ tpl: string; /* 数据模型 */ data: any; /* 方法，可作为绑定函数 */ methods: &#123; [key: string]: Function, &#125;; /* 指令解析方式 */ derectives: &#123; [key: string]: Function, &#125;; /* 将模板解析成渲染函数，渲染函数以当前 ViewModel 为首参 */ parse(): (vm: ViewModel) =&gt; DOMElement; /* 将内容渲染到特定节点 */ render(data: any, elm: DOMElement): DOMElement;&#125; 典型的 tpl 模板如下： 1234&lt;div&gt; &lt;input type=\"text\" v-model=\"newName\"/&gt; &lt;p&gt;&#123;&#123;newName&#125;&#125;&lt;/p&gt;&lt;/div&gt; 解析 tpl 模板时，首先需要将节点建模成约定属性集合的树形节点；其次，在解析过程中，将模板中的标签内容转化为模型节点；然后，针对模型节点的特殊属性，通过可扩展的程式加以处理（如对于 v-model 指令，需要将 vm.data 数据与 input 节点进行双向绑定）；最后，通过递归下钻又回升的机制获得 dom 节点树，以供插入页面。我们就可以解释为什么 v-on 指令能将 vm.methods 能成为真实 dom 节点的绑定函数了。vm.data 数据又是怎么驱动视图重绘的呢？数据驱动视图更新的机制主要有手动调用、脏值检测、对象劫持、Proxy 代理。手动调用即抽象一般的数据变更方法，在该方法执行的尾部主动重新渲染组件（React 实现机制）。脏值检测即主动轮询树节点的数据属性，当发现其与 vm.data 数据不符时，即重新渲染组件（Angular 实现机制）。对象劫持即通过 Object.defineProperty 使数据变更的处理流程包含重绘组件这一过程（Vue 实现机制）。Proxy 与 Object.defineProperty 异曲同工（Mobx 实现机制）。组件绘制或重绘过程，可以使用虚拟 dom 提升效能，避免节点的全量渲染。这里仅点到为止，不再深入。想要了解更多，可以翻阅张成文的《现代前端技术解析》或各框架的相关文章。 后记架构犹如轮廓，有助于理解成熟框架的设计和实现，不至于迷失在细节里。理想情况下，先定架构，再完善功能点也是一种高效的工作模式。现实中却不乏认知不到位、历史原因、项目工期短等问题，心态也需要有相当的韧性。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"决战大数据读后","slug":"随笔/决战大数据读后","date":"2019-10-07T16:00:00.000Z","updated":"2020-03-08T11:34:49.210Z","comments":true,"path":"2019/10/08/随笔/决战大数据读后/","link":"","permalink":"http://xzfyu.com/2019/10/08/随笔/决战大数据读后/","excerpt":"","text":"很长一段时间，业务是让我感到困惑的两个字。记得第一次被面试官问及业务的意义时，当时我还在做阿里云营销中台的前端开发工作，我只能较为笼统地答复前置校验器到商品优惠的流程。因为在我参与项目之先，校验器的模型已经大致成熟，剩下的只是实现以及不伤筋骨地调整，所以我能确切感知到的是校验器模型的普适性，至于其设计过程的磕绊终归没有多少体感。第二次被面试官问及业务的意义是在上海的一间会议室，我所理解的考题是能不能接受产品设计上繁复的再斟酌过程；我也记得，那时有过复杂动态表单的编码经历使我感到欣慰，而我所关心的焦点还在技术层面。可惜的是，在上海的经历也失衡地倒向技术上那一侧。我发觉，产品更多的是在模仿淘宝，摆在他嘴边的是“淘宝的页面也是这么设计的”；在整体设计上，那么一款平台级的产品却尴尬地任由第三方规则牵引着。那时我还专注于动态表单的编码体验，没有用愚笨的口舌参与讨论。 直到近来经历的坑多了，我才有种觉悟用自己惯常的思维去衡量业务。一个人的分析有赖于他的阅历。我想，构成我的阅历的，绝大部分都是历史读物，因此我习惯使用类推的方式去思考。我记得，当现有法典不足以裁断一桩案件时，钟繇和王朗会比对有汉以来的另一桩案件，然后再结合情理地作出判决。这里有两个内容，基于大量事实抽象的典章，还有就是一件具体的情事。换言之，一个是普适于一般业务场景的框架型产物；一个是只适用于特定业务场景的定制型产物。据此可以推演的是，孙子兵法这样的纯军事理论著作好比一个思考框架，它有指导意义，却脱离具体的场景；而百战奇略那样大量 case 的集合，倒是具体问题具体分析。也许是因为听多了假大空的废话套话，我现在额外看重从具体场景中演化得来的经验，更倾向于看见那些范式是通过大量经验堆叠起来的，真刀真枪打出来的。虽然按照科学的法门，罗马不是一朝建成的，系统是演进迭代出来的。 说了那么多，和《决战大数据》这本书又有什么关系呢？尽管在这本书里，很多跨专业的知识是我一时不能消化的，但是我很荣幸地在车品觉的字里行间看到一种精神上的光辉：务实，从具体场景出发。范式总教导人约定俗成地接受事实，只有深入具体的事情才会发现新的问题、新的矿藏。在这样的基础上，stay foolish、保持嗅觉就会变得相当有拓展力。车品觉用 6 年时间刻意锻炼对数据的嗅觉，后来他是那样幸福地处在一种有料可抖、有的放矢的状态，摆脱了空泛。“养数据”一说也不正是建基于对具体问题的判断力？缺失了这种判断力，才会不知轻重地什么数据都想攥在手里。具体问题可以很小，一个标签，一个按钮；也可以很大，一个产品，一个领域。从延伸义上，理解业务不是为了有的放矢吗？车品觉不单在务实光辉的笼罩下，他也有全域大数据的理想，这种理想因为务实变得可信；他也有不少科学素养，对数据的评判会基于检验这一闭环流程，尾章会展望大数据的诸多应用领域；他也有他的朴实。 因为某种尿性，我用拗口兼务虚的文字写就这篇文章，以资备忘。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://xzfyu.com/categories/随笔/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"GGEdiotr","slug":"frontend/editor/GGEditor源码","date":"2019-10-06T16:00:00.000Z","updated":"2020-03-08T10:56:16.152Z","comments":true,"path":"2019/10/07/frontend/editor/GGEditor源码/","link":"","permalink":"http://xzfyu.com/2019/10/07/frontend/editor/GGEditor源码/","excerpt":"","text":"","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"editor","slug":"frontend/editor","permalink":"http://xzfyu.com/categories/frontend/editor/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"ajax、web sockets 及跨域","slug":"frontend/architecture/ajax和跨域","date":"2019-10-05T16:00:00.000Z","updated":"2020-03-08T10:42:40.982Z","comments":true,"path":"2019/10/06/frontend/architecture/ajax和跨域/","link":"","permalink":"http://xzfyu.com/2019/10/06/frontend/architecture/ajax和跨域/","excerpt":"","text":"ajaxajax 全称 “Asynchronous Javascript + XML”，它利用浏览器原生的通信能力，能实现页面的局部更新。ajax 请求可以通过 XMLHttpRequest 对象发送；在兼容性上，IE7+, Firefox, Opera, Chrome 和 Safari 均支持原生的 XHR 对象。以下是 XHR 对象的基本使用样例： 1234567891011121314151617181920212223242526272829const xhr = new XMLHttpRequest();// readyState 四种状态// 0: 未初始化，即尚未调用 xhr.open 方法// 1: 启动，已调用 xhr.open 方法，但未调用 xhr.send 方法// 2: 发送，已调用 xhr.send 方法，但未接收到响应// 3: 接收，已接收到部分响应数据// 4: 完成，接收到全部响应数据，且可以在客户端使用了xhr.onreadystatechange = () =&gt; &#123; // 响应数据自动填充到 xhr 对象上 // responseText 响应主体返回的文本 // responseXML 如果响应的内容类型为 \"text/xml\" 或 \"application/xml\"。responseXML 会保存响应数据的 XML DOM 文档 // status 响应的 HTTP 状态 // statusText HTTP 状态的说明 if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(\"Request was unsuccessful: \"+ xhr.status); &#125; &#125;&#125;// 准备发送请求// 第三个参数表示是否发送异步请求xhr.open(\"get\", \"test.json\", false);// 发送请求xhr.send(null); CometComet 指服务器推送，促使浏览器持续不断地接受服务端响应。基本的 Comet 实现可借助 XHR 对象长轮询：服务端每发回一波响应，xhr.readyState 状态值都会被置为 3；直到服务端发送完响应内容后，xhr.readyState 才会被置为 4。使用 XHR 对象实现长轮询的样例代码如下： 12345678910111213141516171819202122// 通过 progress, finished 回调处理接受到的内容function createStreamingClient(url, progress, finished) &#123; const xhr = new XMLHttpRequest(); let received = 0; xhr.open(\"get\", url, true); xhr.onreadystatechange = () =&gt; &#123; let result; if (xhr.readyState == 3) &#123; result = xhr.responseText.substring(received); received += result.length; progress(result); &#125; else if (xhr.readyState == 4) &#123; finished(xhr.responseText); &#125;; &#125; xhr.send(null); return xhr;&#125; SSESSE 全称 Server-Sent Event，服务器发送事件。SSE 适用于处理只读 Comet 交互。在兼容性上，Firefox 6+, Safari 5+, Opera 11+, Chrome 和 iOS 4+ 版 Safari 支持 SSE。SSE 的基本使用样例如下： 1234567// 参数 url 必须与页面同源const source = new EventSource(\"test.json\");// 通过 onmessage 事件持续不断的接受数据source.onmessage = (event) =&gt; &#123; console.log(event.data);&#125; Web SocketsWeb Sockets 可用于实现浏览器和服务端的全双工、双向通信。创建 WebSocket 对象后，首先会发送 http 请求到服务端；取得响应后，建立的连接会从 http 协议升级成 Web Sockets 协议，以支持双向通信。Web Sockets 没有同源策略，因此可以跨域通信。支持 Web Sockets 的浏览器有：Firefox 6+, Safari 5+, Chrome 和 iOS 4+ 版 Safari。Web Sockets 的使用样例如下： 12345const socket = new WebSocket(\"ws://www.example.com/socket\");// 必须是绝对路径socket.send(data);socket.onmessage = (event) =&gt; &#123; console.log(event.data);&#125;; 跨域CORSCORS 全称 Cross-Origin Resource Sharing，跨域资源共享。服务器通过设置 Access-Control-Allow-Origin 头，开启跨域访问资源的可能。此时浏览器若想跨域访问资源，需要设置 Origin 请求头为许可的请求页面地址信息。在跨域请求的过程中，当浏览器接受到响应时，会根据 Access-Control-Allow-Origin 判断这次请求是不是有效的。注意，请求和响应都不包含 cookie 信息。 IE 8~9 需要使用 XDomainRequest 对象发送跨域请求。 Firefox 3.5+, Safari 4+, Chrome, iOS 版 Safari 和 Android 平台中的 Webkit 都可以通过 XHR 对象发送跨域请求，而不需要其他处理。该跨域请求默认不会携带 cookie 和 http 认证信息，此时可以将 xhr.withCredentials 置为 true，这样就会携带 cookie 和 http 认证信息。有些浏览器默认会发送 cookie，此时通过设置 xhr.withCredentials = false，可以禁止携带 cookie 信息。 非简单请求的跨域，会执行一次预检请求，详情可参看跨域资源共享 CORS 详解。 检测浏览器是否支持 XHR 对象的跨域请求，可以通过判断 XHR 对象是否包含 withCredentials 属性。在此基础上，再判断 XDomainRequest 对象是否存在，就可以覆盖所有浏览器。 图像 Ping鉴于加载图像不存在跨域问题，图像 Ping 技术通过动态的 Image 实例进行跨域通信。它只能将请求通知给服务器，不能接受响应，最常用于收集点击信息。 JSONP与图像 Ping 技术相仿，JSONP 通过插入动态的 script 节点进行跨域通信，因此也只适用于 get 请求。在 JSONP 中，服务端返回的脚本信息会被执行，因此可用于处理响应。为了处理上的灵活性，JSONP 请求会携带回调函数的名称作为请求参数，以便服务器拼接响应，约束浏览器在执行脚本时调用特定的函数处理响应。 Web Sockets见上文。 axios在设计上，axios 采用适配器模式切换发送请求的模块（分别为浏览器端的 XHR 对象、服务器端的 http, https 模块），该发送请求的模块作为 axios 的主流程。在主流程之外，axios 借助 Promise 对象装配拦截器（包含在主流程前的请求拦截器、在主流程后的响应拦截器），其实现等同一条链式处理的中间件机制。其核心流程如下图，首先由请求拦截器处理请求，然后通过选用特定的适配器发送请求，最后由响应拦截器处理响应。 在代码中的表现为： 12345678910111213141516171819202122232425262728293031323334353637383940Axios.prototype.request = function request(config) &#123; /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API if (typeof config === 'string') &#123; config = arguments[1] || &#123;&#125;; config.url = arguments[0]; &#125; else &#123; config = config || &#123;&#125;; &#125; config = mergeConfig(this.defaults, config); // Set config.method if (config.method) &#123; config.method = config.method.toLowerCase(); &#125; else if (this.defaults.method) &#123; config.method = this.defaults.method.toLowerCase(); &#125; else &#123; config.method = 'get'; &#125; // Hook up interceptors middleware // dispatchRequest 本质使用特定的适配器发送请求 var chain = [dispatchRequest, undefined]; var promise = Promise.resolve(config); this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123; chain.unshift(interceptor.fulfilled, interceptor.rejected); &#125;); this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123; chain.push(interceptor.fulfilled, interceptor.rejected); &#125;); while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift()); &#125; return promise;&#125;; 在这条链式的处理流程中，随处流动的实体是 config 对象。对于 get 和 post 请求，在适配器 xhr 以及 http 模块中，config.url, config.params 将被转化成实际请求路径，config.data 将作为请求数据。config.params 也能在 post 请求中使用。此外，get 和 post 请求中不同的头部信息通过策略模式处理；传输数据和头部 content-type 值的联动关系则通过 config.transformRequest 方法处理。 xhr 模块对请求头的处理包含防 csrf 攻击的机制：同源或 request.withCredentials 为真值时，将 cookie 中 xsrf 相关内容写入请求头中。 http 模块包含代理机制的实现，即使用 config.proxy 配置项制作实际的请求地址等值。 此外，axios 使用 Promise 实现了撤销请求的机制。cancel 操作会为 token 令牌注入标识，同时通过 resolvePromise 方法间接调用 xhr.abort 或 req.abort，从而取消请求。详情可参看源码。 umi-requestumi-request 与 axios 不同的是：采用如 koa 的中间件机制应用拦截器；使用 isomorphic-fetch 库切换客服端、服务端的请求模块；对 get 请求实现缓存机制。因为 isomorphic-fetch 没有实现超时、撤销请求这两个功能，umi-request 使用 Promise.race 权衡正常请求、超时请求、撤销请求的优先级，最终实现这两个功能。 参考跨域资源共享 CORS 详解传统 Ajax 已死，Fetch 永生","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"library一句话","slug":"frontend/library/library一句话","date":"2019-09-26T16:00:00.000Z","updated":"2020-03-08T11:08:40.987Z","comments":true,"path":"2019/09/27/frontend/library/library一句话/","link":"","permalink":"http://xzfyu.com/2019/09/27/frontend/library/library一句话/","excerpt":"","text":"yargs[猜测]首先注册命令及其选项，再解析用户输入，执行命令。 同类库：command, command-bin。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"踩坑","slug":"frontend/guide/踩坑","date":"2019-09-13T16:00:00.000Z","updated":"2020-03-08T11:09:04.137Z","comments":true,"path":"2019/09/14/frontend/guide/踩坑/","link":"","permalink":"http://xzfyu.com/2019/09/14/frontend/guide/踩坑/","excerpt":"","text":"typescript 使用 export = 导出的模块，需要使用 typescript 提供的特定语法 import let = require(“module”) 导入。参考 Typescript学习笔记（五） 模块机制。 其类型缺少调用或构造签名的表达式无法使用 “new”：在 .d.ts 文件中声明包含 new 方法的接口。 webpack webpack_require(…) is not a function 报错，你可能需要在 babal 选项中添加 exclude: [/node_module/]。 node fork 的意义在于，改变 cwd。 报错 413 Request Entity Too Large。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"guide","slug":"frontend/guide","permalink":"http://xzfyu.com/categories/frontend/guide/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"}]},{"title":"webpack-dev-server 一些设计点","slug":"frontend/工程化/webpack/webpack-dev-server一些设计点","date":"2019-09-13T16:00:00.000Z","updated":"2020-03-08T10:54:12.816Z","comments":true,"path":"2019/09/14/frontend/工程化/webpack/webpack-dev-server一些设计点/","link":"","permalink":"http://xzfyu.com/2019/09/14/frontend/工程化/webpack/webpack-dev-server一些设计点/","excerpt":"","text":"整体流程webpack-dev-server 通过 express 构建服务，以下是它的整体流程： validateOptions：使用 schema-utils 校验配置选项。 normalizeOptions：处理选项，混入默认配置。 updateCompiler：酌情为 webpack 添加 HotModuleReplacementPlugin 插件，socket 通信客户端脚本。 将选项内容赋值给 Server 实例。 绑定 webpack 钩子，在编译结束后通过 socket 通信将编译信息发送到客户端。 创建 express 实例，挂载 webpack-dev-middleware 中间件。 应用 features 特性，参见下文。 启动 express 服务。 features 特性webpack-dev-server 首先通过封装 features 特性添加操作集合，然后根据 options 选项将本次启用的特性添加到 runnableFeatures 特性列表中，最后依次执行特性添加操作函数，为 express 服务添加特性。关于代理，可参阅 http-proxy-middleware 源码解读。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class Server &#123; setupFeatures() &#123; const features = &#123; compress: () =&gt; &#123;// 压缩静态资源 if (this.options.compress) &#123; this.setupCompressFeature(); &#125; &#125;, proxy: () =&gt; &#123;// 代理 if (this.options.proxy) &#123; this.setupProxyFeature(); &#125; &#125;, historyApiFallback: () =&gt; &#123;// history 跳转 if (this.options.historyApiFallback) &#123; this.setupHistoryApiFallbackFeature(); &#125; &#125;, contentBaseFiles: () =&gt; &#123;// 静态资源 this.setupStaticFeature(); &#125;, contentBaseIndex: () =&gt; &#123;// 静态资源目录服务 this.setupServeIndexFeature(); &#125;, watchContentBase: () =&gt; &#123;// 监测静态资源 this.setupWatchStaticFeature(); &#125;, before: () =&gt; &#123;// pre-action if (typeof this.options.before === 'function') &#123; this.setupBeforeFeature(); &#125; &#125;, middleware: () =&gt; &#123;// 应用 webpack-dev-middleware this.setupMiddleware(); &#125;, after: () =&gt; &#123;// post-action if (typeof this.options.after === 'function') &#123; this.setupAfterFeature(); &#125; &#125;, headers: () =&gt; &#123;// 变更响应头 this.setupHeadersFeature(); &#125;, magicHtml: () =&gt; &#123;// 为 js 资源添加访问页面 this.setupMagicHtmlFeature(); &#125;, &#125;; const runnableFeatures = []; if (this.options.compress) &#123; runnableFeatures.push('compress'); &#125; runnableFeatures.push('before', 'headers', 'middleware'); if (this.options.proxy) &#123; runnableFeatures.push('proxy', 'middleware'); &#125; if (this.options.contentBase !== false) &#123; runnableFeatures.push('contentBaseFiles'); &#125; if (this.options.historyApiFallback) &#123; runnableFeatures.push('historyApiFallback', 'middleware'); if (this.options.contentBase !== false) &#123; runnableFeatures.push('contentBaseFiles'); &#125; &#125; this.serveIndex = this.serveIndex || this.serveIndex === undefined; if (this.options.contentBase &amp;&amp; this.serveIndex) &#123; runnableFeatures.push('contentBaseIndex'); &#125; if (this.options.watchContentBase) &#123; runnableFeatures.push('watchContentBase'); &#125; runnableFeatures.push('magicHtml'); if (this.options.after) &#123; runnableFeatures.push('after'); &#125; (this.options.features || runnableFeatures).forEach((feature) =&gt; &#123; features[feature](); &#125;); &#125;&#125; socket 通信webpack-dev-server 根据 options.transportMode 选项分别采用 sockjs, websocket 或用户自定义实现类通信。sockjs 是一种实现，它首先会尝试使用 websocket 协议通信；在不支持 websocket 协议的浏览器中，它会降级采用长轮询的方式进行通信。webpack-dev-server 的服务端整体处理流程为（客户端需要添加对应的 socket 脚本）： 根据 options.transportMode.server 选取 SocketServer 的实现类。 在 express 服务启动期间，创建 SocketServer 实例，并监听事件的方式收集每个连接 app.sockets = [connection]。 通过 app.sockWrite 为每个连接 connection 推送消息。 使用 socket 通信的场景主要有以下几类： webpack 编译 stats，包含日志级别信息。 overlay 页面显示编译错误。 通过 webpack.ProgressPlugin 获得的编译进度。 hot 热更新，包含 liveReload 页面是否刷新标识。 通过 chokidar 监测 contentBase 静态资源更新（小提示：webpack-dev-server 通过 serve-index 为静态资源提供目录信息）。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"webpack","slug":"frontend/webpack","permalink":"http://xzfyu.com/categories/frontend/webpack/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"webpack加载器编程","slug":"frontend/工程化/webpack/webpack加载器编程","date":"2019-08-05T16:00:00.000Z","updated":"2020-03-08T10:54:19.616Z","comments":true,"path":"2019/08/06/frontend/工程化/webpack/webpack加载器编程/","link":"","permalink":"http://xzfyu.com/2019/08/06/frontend/工程化/webpack/webpack加载器编程/","excerpt":"","text":"原理loader 是导出为函数的 js 模块，它支持同步模式、异步模式。同步模式有两种编程方式，其一使用 return 返回结果作为下一个加载器的资源，其二使用 this.callback 传入结果。异步模式使用 this.async 开启，在 this.async 执行过程中再调用 this.callback 语句，以启用下一个加载器的执行逻辑。官方推荐使用异步模式，这样可以提升 webpack 在 node 单线程环境中的执行性能。 12345678910111213141516171819// 同步模式一module.exports = function(content, map, meta) &#123; return someSyncOperation(content);&#125;;// 同步模式二module.exports = function(content, map, meta) &#123; this.callback(null, someSyncOperation(content), map, meta); return; // 当调用 callback() 时总是返回 undefined&#125;;// 异步模式module.exports = function(content, map, meta) &#123; var callback = this.async(); someAsyncOperation(content, function(err, result, sourceMaps, meta) &#123; if (err) return callback(err); callback(null, result, sourceMaps, meta); &#125;);&#125;; 加载器在 loader runner 环境中被调用，参数包含错误 err，资源 content，source-map，以及任何数据（可以是元数据 meta）。当 module.exports.raw 被赋值为 true 时，参数 content 可以是 buffer。loader runner 提供了如下上下文： this.version：loader API 的版本号。 this.context：资源文件所在的目录。 this.request：解析后的查询字符串。 this.query：options 选项或查询字符串。 this.callback(err, content, sourceMap?, meta?: any)：调用下一个加载器。 this.async：启用异步模式。 this.data：在 pitch 阶段和正常阶段之间共享的 data 对象。 this.cacheable(flag)：是否可缓存。一个可缓存的 loader 在输入和相关依赖没有变化时，必须返回相同的结果。这意味着 loader 除了 this.addDependency 里指定的以外，不应该有其它任何外部依赖。 this.loaders：所有 loader 组成的数组。它在 pitch 阶段的时候是可以写入的。 this.loaderIndex：loader 的索引。 this.resource：包括查询字符串的资源路径。 this.resourcePath：不包括查询字符串的资源路径。 this.resourceQuery：查询字符串。 this.target：编译目标，从配置选项中传递过来的。 this.webpack：是否由 webpack 编译。loader 最初被设计为可以同时当 Babel transform 用。 this.sourceMap：是否生成 source-map。 this.emitWarning：发出警告。 this.emitError：发出错误。 this.loadModule：解析给定的 request 到一个模块，应用所有配置的 loader ，并且在回调函数中传入生成的 source 、sourceMap 和 模块实例（通常是 NormalModule 的一个实例）。 this.resolve(context, request, callback)：像 require 表达式一样解析一个 request。 this.addDependency(directory)：加入一个文件作为产生 loader 结果的依赖，使它们的任何变化都可以被监听到。 this.addContextDependency：把文件夹作为 loader 结果的依赖加入。 this.clearDependencies：移除 loader 结果的所有依赖。甚至自己和其它 loader 的初始依赖。考虑使用 pitch。 this.emitFile(name, content)：产生一个文件。 this.fs：用于访问 compilation 的 inputFileSystem 属性。 pitch 阶段指 webpack 预先自左向右调用加载器的 pitch 方法，然后再自右向左调用加载器本身。pitch 阶段可用于跳过部分 loader，其如果有返回值，就将跳过余下的 loader。其次 pitch 方法的参数 data 可以在 loader 本体中通过 this.data 共享访问。 loader-utils, schema-utilsloader-utils, schema-utils 用于辅助加载器编程。 1234567891011121314151617181920import &#123; getOptions &#125; from 'loader-utils';import validateOptions from 'schema-utils';const schema = &#123; type: 'object', properties: &#123; test: &#123; type: 'string' &#125; &#125;&#125;;export default function(source) &#123; const options = getOptions(this); validateOptions(schema, options, 'Example Loader'); // 对资源应用一些转换…… return `export default $&#123; JSON.stringify(source) &#125;`;&#125; 测试官方文档中使用 jest 测试案例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// compiler.jsimport path from 'path';import webpack from 'webpack';import memoryfs from 'memory-fs';export default (fixture, options = &#123;&#125;) =&gt; &#123; const compiler = webpack(&#123; context: __dirname, entry: `./$&#123;fixture&#125;`, output: &#123; path: path.resolve(__dirname), filename: 'bundle.js', &#125;, module: &#123; rules: [&#123; test: /\\.txt$/, use: &#123; loader: path.resolve(__dirname, '../src/loader.js'), options: &#123; name: 'Alice' &#125; &#125; &#125;] &#125; &#125;); // 使用 https://github.com/webpack/memory-fs 内存文件 compiler.outputFileSystem = new memoryfs(); return new Promise((resolve, reject) =&gt; &#123; compiler.run((err, stats) =&gt; &#123; if (err || stats.hasErrors()) reject(err); resolve(stats); &#125;); &#125;);&#125;;// loader.test.jsimport compiler from './compiler.js';test('Inserts name and outputs JavaScript', async () =&gt; &#123; const stats = await compiler('example.txt'); const output = stats.toJson().modules[0].source; expect(output).toBe('export default \"Hey Alice!\\\\n\"');&#125;); 典型 loadersvgrsvgr 是 umi/af-webpack 中的一个模块，用于解析 svg 模块。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &#123; getOptions &#125; from 'loader-utils';import &#123; transform as babelTransform &#125; from '@babel/core';import convert from '@svgr/core';function svgrLoader(source) &#123; const callback = this.async(); const &#123; babel = true, ...options &#125; = getOptions(this) || &#123;&#125;;// 获取选项 const readSvg = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; this.fs.readFile(this.resourcePath, (err, result) =&gt; &#123; if (err) reject(err); resolve(result); &#125;); &#125;); &#125;; const exportMatches = source .toString('utf-8') .match(/^module.exports\\s*=\\s*(.*)/); const previousExport = exportMatches ? exportMatches[1] : null; // es6 降级 const pBabelTransform = async jsCode =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; babelTransform( jsCode, &#123; babelrc: false, // Unless having this, babel will merge the config with global 'babel.config.js' which may causes some problems such as using react-hot-loader/babel in babel.config.js configFile: false, presets: [ require.resolve('@babel/preset-react'), [require.resolve('@babel/preset-env'), &#123; modules: false &#125;], ], plugins: [ require.resolve('@babel/plugin-transform-react-constant-elements'), ], &#125;, (err, result) =&gt; &#123; if (err) reject(err); else resolve(result.code); &#125;, ); &#125;); &#125;; const tranformSvg = svg =&gt; &#123; // svg 转转成 js return convert(svg, options, &#123; webpack: &#123; previousExport &#125;, filePath: this.resourcePath, &#125;) .then(jsCode =&gt; (babel ? pBabelTransform(jsCode) : jsCode)) .then(result =&gt; callback(null, result)) .catch(err =&gt; callback(err)); &#125;; if (exportMatches) &#123; readSvg().then(tranformSvg); &#125; else &#123; tranformSvg(source); &#125;&#125; 参考loader API编写一个 loader","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"webpack","slug":"frontend/webpack","permalink":"http://xzfyu.com/categories/frontend/webpack/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"$PATH, nvm, npm, lerna","slug":"frontend/guide/$PATH, nvm, npm, lerna","date":"2019-07-26T16:00:00.000Z","updated":"2020-03-08T10:59:43.543Z","comments":true,"path":"2019/07/27/frontend/guide/$PATH, nvm, npm, lerna/","link":"","permalink":"http://xzfyu.com/2019/07/27/frontend/guide/$PATH, nvm, npm, lerna/","excerpt":"","text":"mac 环境变量命令一旦添加到环境变量中，系统就知道从哪个路径中取出文件并执行。mac 有多个环境变量文件，不同的环境变量文件的作用域和加载时间也不同。在 mac 中，不同的 shell 所对应的配置文件也不同：bash 命令对应的配置文件是 .bash_profile；zsh 命令对应的配置文件是 .zshrc。 rc 即为 run command，一般为脚本类文件的后缀，这些脚本通常在程序启动的时候被调用，比如 .bashrc 就会在 bash shell 启动时调用。 mac 中环境变量配置文件的默认加载顺序如下： 1234567/etc/profile # 系统级环境变量，任何用户登陆时都会读取该文件/etc/bashrc # 系统级环境变量，bash shell执行时，不管是何种方式，读取该文件/etc/paths # 系统级环境变量，任何用户登陆时都会读取该文件~/.bash_profile # 包含用户专有的 bash 信息，当登录时以及每次打开新的 shell 时，该文件被读取；文件存在时，后面的几个文件都会被忽略~/.bash_login # 系统级环境变量，任何用户登陆时都会读取该文件~/.profile # 为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行；重启后生效~/.bashrc # 每一个运行 bash shell 的用户执行该文件 添加或修改环境变量可使用如下语法（$PATH 即原始的环境变量）： 123export PATH=\"$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:...:&lt;PATH N&gt;\" # 修改环境变量的一般语法export PATH='/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/alfred/apache-maven-3.5.0/bin'echo $PATH # 查看环境变量 QAQ: spawnSync npm ENOENT 报错问题？A: 导致该问题有两个原因：其一是在 windows 环境下，实际制定的命令为 ‘npm.cmd’，当遇到这种情况时，可借助于 cross-spawn 库加以解决；其二是深度嵌套的子进程在执行 require(‘child_process’).spawn 脚本时，如果父进程重写了 process.env，那么该子进程就会丢失 process.env.path 配置，导致 npm 命令无法找到，这时可以拷贝根进程下的 process.env 配置。 brewhomebrew 是 linux 环境下的包管理工具。 123456789101112131415161718# 安装 brew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"# 更新 brew，先卸载，再安装/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"# 更新sudo brew updatebrew install nodejsbrew uninstall nodejsbrew upgrade nodejsbrew search nodejsbrew remove nodejsbrew list # 列出当前安装的软件brew search nodejs # 查询与 nodejs 相关的可用软件brew info nodejs # 查询 nodejs 的安装信息 nvmnvm 是 Mac 环境下 node 版本管理工具。Windows 平台下推荐 nvmw 或 nvm-windows。 安装123456curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash# .bash_profile 添加以下代码，须重启终端export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm 更新12345( cd \"$NVM_DIR\" git fetch --tags origin git checkout `git describe --abbrev=0 --tags --match \"v[0-9]*\" $(git rev-list --tags --max-count=1)`) &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" 卸载123456sudo rm -rf ~/.nvm# 移除 .bash_profile 中以下代码，卸载后须重启电脑export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion 命令12345678910111213141516nvm debug # 查看 nvm 及 node 信息nvm ls # 展示本地安装的所有 node 版本nvm ls-remote # 展示所有可用的 node 版本；windows 环境下使用 nvm ls availablenvm install node # 安装 node 最新版本；'node' 是最新版本的别名nvm install 6.14.4 # 安装 node 指定版本nvm uninstall 6.14.4 # 卸载 node 指定版本nvm use node # node 命令使用指定版本nvm current # 查看正在使用的 node 版本nvm run node --version # 使用指定版本执行指定命令nvm exec 4.2 node --version # 使用指定版本执行指定命令nvm which 5.0 # 查看指定版本的安装位置nvm install 6 --reinstall-packages-from=5 # 将 5 版本中安装的全局模块安装到 6 版本中nvm alias awesome-version 4.2.2 # 为指定版本的 node 起别名nvm unalias awesome-version # 移除别名 npm命令123456789101112131415161718npm install -g npm@3 # npm 升级到 v3 版本npm install -g cnpm --registry=https://registry.npm.taobao.org # 安装 cnpmnpm publish # 发布包；npm 发布内容优先级为 package.json 中 files 选项，.npmignore, .gitignorenpm unpublish # 撤销发布npm home $package # npm home loadsh 访问 lodash 主页npm repo $package # 访问 github 仓库npm outdate # 检索过时的依赖npm prune # 剔除未在 package.json 中注明的 node_modules 依赖npm version &lt;update_type&gt; # npm version patch,minor,major 自动升级版本号；patch 小改动或bug修复，minor 添加新特性，major 大改动且无法向后兼容npm shrinkwrap # 生成 npm-shrinkwrap.json 文件，锁定依赖版本号npm config set prefix $dir # 变更安装目录为$dir；chown -R $USER $dir改变$dir目录的操作权限；再将$dir/bin加入环境变量，可以不用 sudonpm config set save-prefix=“~” # 改变默认保存前缀；波浪号~，表示当信赖的副版本号有更新时，允许使用npm update进行安装；脱字符^，表示当依赖的主版本号有更新时，允许使用 npm update 进行安装npm config set init.author.name $name，npm config set init.author.email $email # npm init初始化项目时启用特定值配置 package.jsonnpm config set init-module ~/.npm-init.js # 以特定脚本配置 package.json 备忘 安装依赖包时携带 –production 参数，将不予安装devDependencies依赖；若设置N ODE_ENV 环境变量为production，devDependencies 依赖也不会被安装。 项目中若不存在 .npmignore 文件，将取用 .gitignore 设定以及一些默认配置。 QAQ: 在执行 npm link 命令时，遇到 Unhandled rejection RangeError: Maximum call stack size exceededill install loadIdealTree 报错，该如何处理？A: 尝试清空工程目录中的 node_modules 依赖，再次执行 npm link，参考 Maximum call stack size exceeded on npm install。 lernalerna 是面向 js 的多包管理器。 安装1cnpm install lerna -g 参考Mac的环境变量和nvm的使用","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"guide","slug":"frontend/guide","permalink":"http://xzfyu.com/categories/frontend/guide/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"test","slug":"test","permalink":"http://xzfyu.com/tags/test/"}]},{"title":"前端代码检查及美化","slug":"frontend/工程化/前端代码检查及美化","date":"2019-07-20T16:00:00.000Z","updated":"2020-03-08T10:57:40.917Z","comments":true,"path":"2019/07/21/frontend/工程化/前端代码检查及美化/","link":"","permalink":"http://xzfyu.com/2019/07/21/frontend/工程化/前端代码检查及美化/","excerpt":"","text":"lintlint 检查可借助 eslint, tslint, stylelint，这里暂时不作详解。 prettierprettier 库 用于代码格式化。官方说法，prettier 的美化方案比较武断；因为它在改动代码期间并未执行 lint 检查。在使用 prettier 时，首先需要安装 prettier；然后创建 .prettierrc, .prettierignore 配置文件；最后执行 prettier –write “src/*/.js” 命令重写代码。配置文件可如下： 1234567891011121314&#123; \"printWidth\": 120,// 单行最大宽度。默认 80 \"tabWidth\": 2,// tab 按钮占多少个空格。默认 2 \"indent\": false,// 是否使用 tab 缩进。默认否 \"noSemi\": false,// 在引起 ASI 语法错误时在行首引入分号。默认 true，在行尾添加分号 \"singleQuota\": false,// 使用单引号。默认否。优先级低于 jsxSingleQuota \"quotaProps\": \"as-needed\",// 对必要的对象属性添加引号。默认 \"as-needed\" \"jsxSingleQuota\": false,// 将 jsx 中的双引号转为单引号。默认否 \"trailingCommas\": \"none\",// 多行时移除尾随逗号。默认 \"none\" \"bracketSpacing\": true,// 对象中括号之间添加空格。默认是 \"jsxBracketSameLine\": false,// 多行jsx元素的闭合标签换行处理。默认否，换行 \"arrowParens\": \"aviod\",// 箭头函数参数以括号包围。默认 \"aviod\"，单参数不包围 \"endOfLine\": \"lf\"// 指定换行符。默认 \"auto\"。linux 文件 \"lf\"，windows 文件 \"crlf\"&#125; 结合eslint当 prettier 结合 eslint 使用时，可借助 eslint-plugin-prettier 检测代码风格，eslint-config-prettier 避免 lint 配置冲突。无论是 prettier 插件需要放置在最后。典型配置如下： 123456789101112131415// .eslintrc&#123; \"extends\": [\"plugin:prettier/recommended\"], \"rules\": &#123; \"prettier/prettier\": [\"error\", &#123; \"printWidth\": 120, \"tabWidth\": 2, \"jsxBracketSameLine\": false &#125;], \"indent\": \"off\", \"react/jsx-indent\": \"off\", \"react/jsx-indent-props\": \"off\", \"react/jsx-curly-new-line\": \"off\",// 避免 preitter 对三元运算符作处理 &#125;&#125; huskyhusky 库 通过 git 钩子执行额外的 shell 脚本。在 npm install husky –save-dev 执行期间，husky 会向工程中的 .git/hooks 文件夹写入钩子文件。若 package.json 文件添加如下配置： 1234567891011&#123; \"scripts\": &#123; \"lint\": \"eslint --ext **/*.js src\", \"lint:fix\": \"eslint --fix **/*.js src\" &#125;, \"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"npm run lint:fix\" &#125; &#125;&#125; 那么，在执行 git commit -m “this is a message” 时，就会预先执行 lint 检查。 机理husky 在安装期间通过 npm 钩子执行 node husky install 内部命令，以此生成 git 钩子文件。然后在执行 git 命令时，husky 就会借由 git 钩子调用 husky-run 命令，并执行用户侧设置的 shell 脚本。 husky 所使用的类库： cosmiconfig: 读取配置文件。 execa: 执行 shell 脚本。 read-pkg: 读取 package.json 文件。 get-stdin: 获取用户 echo 输入。 pkg-dir: 获取工程目录。 基于相同的实现原理，pre-commit 是构建工程时的另一种选择。 lint-stagedlint-staged 库 用于仅对本次提交内容执行动作，以节省运行时间。典型配置如下： 12345678910&#123; \"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125; &#125;, \"lint-staged\": &#123; \"src/**/*.js\": [\"npm run lint\", \"git add\"] &#125;&#125; 机理lint-staged 基于 execa 库执行 git diff –staged 获知变更文件，然后再借助 execa 执行用户侧配置的命令。 lint-staged 所使用的类库： log-symbols: 控制台带颜色输出。 micromatch: glob 形式匹配文件名。 onchangeonchange 库 通过 chokidar 监听文件变更。在指定文件变更后，onchange 会触发用户侧配置命令的执行。典型配置如下： 12345&#123; \"scripts\": &#123; \"format\": \"onchange 'src/**/*.js' -- prettier --write &#123;&#123;changed&#125;&#125;\" &#125;&#125; 在实现上，onchange 使用了 @blakeembrey/deque 双端队列。 editorConfigEditorConfig 可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格。典型的 .editorconfig 配置文件如下： 1234567891011root = true[*]end_of_line = lfinsert_final_newline = true[*.(js,jsx,ts,tsx,css,scss,less)]charset = utf-8indent_style = spaceindent_size = 2trim_trailing_whitespace = true # 自动删除行尾空格 参考更新版-梳理前端开发使用eslint和prettier来检查和格式化代码问题使用ESlint+Prettier统一前端代码风格npm package.json scripts前端代码风格自动化系列（三）之Lint-staged","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"lint","slug":"lint","permalink":"http://xzfyu.com/tags/lint/"},{"name":"prettier","slug":"prettier","permalink":"http://xzfyu.com/tags/prettier/"}]},{"title":"webpack动态导入","slug":"frontend/工程化/webpack动态导入","date":"2019-07-13T16:00:00.000Z","updated":"2020-03-08T10:57:43.465Z","comments":true,"path":"2019/07/14/frontend/工程化/webpack动态导入/","link":"","permalink":"http://xzfyu.com/2019/07/14/frontend/工程化/webpack动态导入/","excerpt":"","text":"代码分割webpack 官方文档 动态导入 部分已指示我们，可使用 es 提案中的 import() 或 webpack 提供的 require.ensure 语法懒加载代码。我们按下 require.ensure 不表，只介绍 import()。webpack 官方所提供的示例如下： 1234567891011async function getComponent() &#123; var element = document.createElement('div'); const _ = await import(/* webpackChunkName: \"lodash\" */ 'lodash'); element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;&#125;getComponent().then(component =&gt; &#123; document.body.appendChild(component);&#125;); 使用 import() 语法首先需要添加 @babel/plugin-syntax-dynamic-import 插件。同时，import() 返回值是 promise，因此需要添加 ployfill 垫片或者借助 @babel/plugin-transform-runtime 插件自动添加垫片。需要注意的是，@babel/preset-env 的选项 modules 不能置为 ‘commonjs’，免得将 es6 模块转换成 commonjs 模块，造成通过 import() 加载的模块没法独立打包出来。 output.chunkFilename 选项用于设置运行时 chunk 文件的名称，默认为 ‘[id].js’。webpackChunkName 可以指定该 chunk 文件的 [name] 占位符内容。详情可参看 模块方法 import()。 结合路由以 react-router 为例，Route 组件下的 component 属性可用于设置渲染内容。因此，我们可以制作一个 AsyncComponent 公共组件，在该组件中通过 import() 动态导入待渲染的组件，在 promise.then 方法变更 AsyncComponent 的状态值：等动态组件加载完成后，渲染动态组件内容；否则渲染占位元素。react-async-component, react-loadable, @loadable/component 无不基于此种思路实现。 上述三个类库无不提供了 webpack, babel 插件。在设计上，react-loadable 使用 props.render 渲染导出的模块。与此同时，react-loadable 还允许同时懒加载多个模块，预加载等功能，详情可参见源码。next.js, umi 的 dynamic 函数 对 react-loadable 作了进一步封装。 123456789import Loadable from 'react-loadable';import Loading from './my-loading-component';const LoadableComponent = Loadable(&#123; loader: () =&gt; import('./my-component'), loading: Loading,&#125;);&lt;Route path=\"/xx\" component=&#123;LoadableComponent&#125; /&gt; 参考webpack4.0各个击破（4）—— Javascript &amp; splitChunk基于Webpack4使用懒加载分离打包React代码","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"双向数据绑定","slug":"frontend/vue/双向数据绑定","date":"2019-06-23T16:00:00.000Z","updated":"2020-03-08T10:53:30.601Z","comments":true,"path":"2019/06/24/frontend/vue/双向数据绑定/","link":"","permalink":"http://xzfyu.com/2019/06/24/frontend/vue/双向数据绑定/","excerpt":"","text":"有幸在公司里做了几次面试官，当我每次问及 Vue 双向绑定的实现机制时，被问者通常只会点到 Object.defineProperty，很少能提到观察者模式。因此，写作本文的目的一方面在于深入了解 Vue 的实现原理，另一方面在于增强有关 ViewModel 双向绑定、前端数据流等的提问能力。众所周知的，当我们阅读技术文章或源码时，如果不能持续有效地发问，那我们会陷入复刻他人思维的僵局里。言归正传，下面我将逐步揭开 Vue 双向绑定实现机制的面纱。 Object.defineProperty 方法充其量提供了对访问器进行 AOP 编程的可能性。Vue 在 get 访问器中绑定数据的订阅者 watcher；在 set 访问器中触发订阅者执行回调。为数据绑定订阅者，首先仰赖于 get 访问器在 watcher 执行期间被调用，然后缓存当前执行的 watcher，最后在 get 访问器被调用期间绑定数据和订阅者的依赖关系。对于当前处于执行期间的 watcher 的记录机制，Vue 所采用的方式类同 React 对当前实例的记录，这样就能使 get 访问器易于感知 watcher 的复杂性。在实现上，Vue 以闭包形式为每个响应式属性创建一个 Dep 实例，这样就能有效地避免对响应式数据的污染（即在响应式数据上使用隐藏属性存储订阅数据的 watcher 列表）。下图是为响应式属性添加监听者、响应式属性变更时执行订阅者的机制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 响应式属性处理Object.defineProperty(obj, key, &#123; // ... get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123;// Dep.target 当前执行的 watcher，作为订阅者 dep.depend()// 收集订阅者 Dep.target if (childOb) &#123;// 收集子项的订阅者 Dep.target childOb.dep.depend() if (Array.isArray(value)) dependArray(value) &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; // ... childOb = !shallow &amp;&amp; observe(newVal)// 使新数据称为被观察对象，响应式数据 dep.notify()// 触发执行订阅者 &#125;&#125;)// 依赖管理器，一个响应式属性对应一个 Dep 实例class Dep &#123; addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; // 通过 watcher.addDep(dep) 调用 dep.addSub(watcher)，添加订阅者 depend () &#123; if (Dep.target) Dep.target.addDep(this) &#125; // 执行订阅者 notify () &#123; // ... for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;// 订阅者处理class Watcher &#123; addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123;// 避免重复绑定 this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) dep.addSub(this) &#125; &#125;&#125; 与观察者模式所对应的是：Dep 即观察者模式中的 Subject，其实例桥接了响应式数据和订阅者；Watcher 即观察者模式中的 Observer，其实例用于实际执行订阅者。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"vue","slug":"frontend/vue","permalink":"http://xzfyu.com/categories/frontend/vue/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"vue","slug":"vue","permalink":"http://xzfyu.com/tags/vue/"}]},{"title":"umi中的插件和路由机制","slug":"frontend/工程化/umi中的插件和路由机制","date":"2019-06-21T16:00:00.000Z","updated":"2020-03-08T10:57:48.774Z","comments":true,"path":"2019/06/22/frontend/工程化/umi中的插件和路由机制/","link":"","permalink":"http://xzfyu.com/2019/06/22/frontend/工程化/umi中的插件和路由机制/","excerpt":"","text":"上图是 umi 的架构图，本文聚焦于解读 umi 的插件和路由机制。umi 中的插件机制支撑了插拔式命令、嵌套插件、运行时插件、文件生成器、生命周期钩子系统等功能；路由机制用于将 src/pages 解析为路由信息，又支持配置路由、运行时动态扩展。插件和路由机制的核心源代码都由 umi-build-dev 包提供。文中所给代码均经过一定程度的删减，只保留核心代码部分。 af-webpack同大多数二次封装 webpack 构建的脚手架一样，af-webpack 主要功能点集中于获取 webpack 配置、启动本地调试环境、打包编译代码、监听配置文件变更以重启编译流程等。以下是它的主要功能模块： dev.js: 基于 webpack, webpack-dev-server, react-dev-utils 启动本地调试服务器。 build.js: 基于 webpack, react-dev-utils 打包文件。 getConfig: 约定大于配置形式获取 webpack 选项。 getUserConfig: 提供工具函数解析用户配置，并使用 chokidar 监听配置文件。当配置文件变更后，af-webpack 会通过主进程向子进程发送消息的方式，驱动子进程重启编译流程。 readRc.js: 基于 strip-json-comments 读取 json 配置文件，该 json 文件允许添加注释。 registerBabel.js: 基于 @babel/register 编译后续 require 加载的模块。 webpackHotDevClient.js: react-dev-utils 库中关于模块热更新功能实现的客户端脚本，服务器端功能由 webpack-dev-server 库透出 sockWrite 方法实现。 插件机制常规的插件系统包含内置和外置插件两类；插件在调用过程中又会由插件系统注入执行上下文。在 umi 中，内置和外置插件都会被解析成 { id, apply, opts } 形式。apply 即插件的执行函数（外置插件会通过 registerBabel 编译）；opts 即插件的选项。umi 中的执行上下文使用 api 标识。api 首先包含如下注册方法： register 注册钩子，注入 service.pluginHooks。钩子用于新增、修改配置项，以及作为事件或其他处理函数。 registerCommand 注册命令，注入 service.commands。命令用于作为 umi 的启动命令，包含 dev 等命令。 registerGenerator 注册生成器，注入 service.generators。生成器用于生成模板文件等。 registerPlugin 注册额外的插件，注入 service.extraPlugins。额外的插件通常由插件发起注册，也就是嵌套插件形式。 registerMethod 注册插件方法，注入 service.pluginMethods。service.pluginMethods 中的方法执行时会调用 register 注册钩子，且可以通过 api 进行访问。因此，如果在某一个插件中使用 registerMethod 注册 service.pluginMethods 方法，该方法可被另一个插件所使用，用于实际注册 service.pluginHooks 钩子。 除了上述注册方法之外，api 还包含如下内容： changePluginOption 变更插件的选项，并调用 plugin.onOptionChange 方法。 applyPlugins 并行调用 service.pluginHooks 中指定钩子。 _applyPluginsAsync 串行调用 service.pluginHooks 中指定钩子。 writeFileSync 创建临时文件。 cwd 项目路径。 config 用户配置。 webpackConfig webpack 配置。 pkg 项目 package.json 文件内容。 paths 项目相关路径。 routes 项目路由。 restart 重启 dev 开发环境。 refreshBrowser 刷新网页。 rebuildTmpFiles 重新创建临时文件。 rebuildHTML 重新创建 html 模板。 12345678910111213141516171819202122232425262728293031323334353637383940class Service &#123; initPlugin(plugin) &#123; const &#123; id, apply, opts &#125; = plugin; try &#123; const api = new Proxy(new PluginAPI(id, this), &#123; get: (target, prop) =&gt; &#123; if (this.pluginMethods[prop]) &#123; return this.pluginMethods[prop]; &#125; if ( [ 'changePluginOption', 'applyPlugins', '_applyPluginsAsync', 'writeTmpFile', 'cwd', 'config', 'webpackConfig', 'pkg', 'paths', 'routes', // dev methods 'restart', 'printError', 'printWarn', 'refreshBrowser', 'rebuildTmpFiles', 'rebuildHTML', ].includes(prop) ) &#123; if (typeof this[prop] === 'function') &#123; return this[prop].bind(this); &#125; else &#123; return this[prop]; &#125; // 提供 register, registerCommand, registerGenerator, registerPlugin, registerMethod 方法 &#125; else &#123; return target[prop]; &#125; &#125;, &#125;); api.onOptionChange = fn =&gt; &#123; assert( typeof fn === 'function', `The first argument for api.onOptionChange should be function in $&#123;id&#125;.`, ); plugin.onOptionChange = fn; &#125;; apply(api, opts); plugin._api = api; &#125; &#125;&#125; 在整套插件的执行过程中，umi 首先会 service.reslovePlugins 方法解析获得插件，并挂载 api 执行上下文；然后在 service.run 方法调用期间，umi 会调用 service.initPlugins 方法调用插件注册钩子、命令等，然后再从通过注册生成的 service.commands 选取指定命令并执行。下面以 dev 插件作为示例： dev 插件dev 插件的功能在于注册 dev 命令。因此它涵盖了 umi dev 命令的主要执行逻辑： 解析路由信息，并根据 service.routes, config.mountElementId 创建临时入口文件。 为 service 注入 restart, refreshBrowser, rebuildTmpFiles, rebuildHTML 等方法。 监听配置文件和临时文件的变更，在变更后重启 dev 开发环境。 启动 dev 开发环境，且通过钩子注入 express 中间件或触发钩子函数的执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function(api) &#123; const &#123; service, config, log, debug &#125; = api; const &#123; cwd &#125; = service; api.registerCommand( 'dev', &#123; webpack: true, description: 'start a dev server for development', &#125;, (args = &#123;&#125;) =&gt; &#123; // 通过执行 modifyRoutes 钩子获取路由，然后注入到 service.routes 中 const RoutesManager = getRouteManager(service); RoutesManager.fetchRoutes(); const &#123; port &#125; = args; process.env.NODE_ENV = 'development'; service.applyPlugins('onStart'); service._applyPluginsAsync('onStartAsync').then(() =&gt; &#123; // 创建临时的入口文件和路由文件 const filesGenerator = getFilesGenerator(service, &#123; RoutesManager, mountElementId: config.mountElementId, &#125;); debug('generate files'); filesGenerator.generate(); let server = null; // 省略，service 中注入restart, printError, printWarn, refreshBrowser, rebuildTmpFiles, rebuildHTML 方法 function startWatch() &#123; filesGenerator.watch(); service.userConfig.setConfig(service.config); service.userConfig.watchWithDevServer(); &#125; service ._applyPluginsAsync('_beforeDevServerAsync') .then(() =&gt; &#123; debug('start dev server with af-webpack/dev'); require('af-webpack/dev').default(&#123; cwd, port, base: service.config.base, webpackConfig: service.webpackConfig, proxy: service.config.proxy || &#123;&#125;, contentBase: './path-do-not-exists', // 通过钩子注入中间件 afterMiddlewares: service.applyPlugins('addMiddleware', &#123; initialValue: [ ...(process.env.ROUTE_MIDDLEWARE !== 'none' ? [createRouteMiddleware(service)] : []), ], &#125;), // ... &#125;); &#125;) &#125;); &#125;, );&#125; 在以上过程中，有必要说明的是入口文件生成的机制。umi 使用 Mustache 类库将模板文件解析为 js 文件并存入临时文件夹。以下几个小节就解释了：umi 是怎样借助 Mustache 模板引擎生成 window.g_history 属性，再怎样通过 window.g_history 属性创建路由容器组件，最后怎样通过路由容器组件生成入口文件的全过程。 history 属性window.g_history 属性即使用 history/createBrowserHistory 等模块创建的 history 对象。将 history 对象写入 window 属性中，首先能方便开发者操控路由；其次，history 对象可能是 createHashHistory 或 createMemoryHistory 模块创建。因此，对于动态可变的 history 对象，单纯的 import 方式并不能载入它，而需要通过 window 属性加以读取。以下代码中的 modifyEntryHistory 钩子就用于视 config.history 选项构造不同的 history 对象。 1234567891011121314151617181920212223242526272829303132333435363738394041// history 模板window.g_history = &#123;&#123;&#123; history &#125;&#125;&#125;;// 生成 window.g_history 内容class FilesGenerator &#123; generateHistory() &#123; const &#123; paths &#125; = this.service; const tpl = readFileSync(paths.defaultHistoryTplPath, 'utf-8'); const initialHistory = ` require('umi/_createHistory').default(&#123; basename: window.routerBase, &#125;) `.trim(); const content = Mustache.render(tpl, &#123; history: this.service.applyPlugins('modifyEntryHistory', &#123; initialValue: initialHistory, &#125;), &#125;); writeFileSync( join(paths.absTmpDirPath, 'initHistory.js'), `$&#123;content.trim()&#125;\\n`, 'utf-8', ); &#125;&#125;// umi 包中的 history 模块function(opts) &#123; const history = createHistory(opts); if (__UMI_HTML_SUFFIX) &#123; const oldPush = history.push; const oldReplace = history.replace; history.push = (path, state) =&gt; &#123; oldPush(normalizePath(path), state); &#125;; history.replace = (path, state) =&gt; &#123; oldReplace(normalizePath(path), state); &#125;; &#125; return history;&#125; 路由容器在有了 service.routes 路由信息和 window.g_history 对象的基础上，创建路由容器组件就显得很简单了。让我们撇过 umi 中完善的功能点，看一下路由容器组件的生成过程。除了下方代码所展示的内容，实际上，umi 支持在路由容器组件外围包裹 Provider, LocaleProvier 等状态管理容器或国际化容器，详情可参见源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 路由模板import React from 'react';import &#123; Router as DefaultRouter, Route, Switch &#125; from 'react-router-dom';import dynamic from 'umi/dynamic';// umi 包中的 renderRoutes 模块，用于将路由信息解析为路由容器import renderRoutes from 'umi/_renderRoutes';let Router = &#123;&#123;&#123; RouterRootComponent &#125;&#125;&#125;;let routes = &#123;&#123;&#123; routes &#125;&#125;&#125;;window.g_routes = routes;// 调用运行时插件中的 patchRoutes 方法，以支持在运行时变更路由window.g_plugins.applyForEach('patchRoutes', &#123; initialValue: routes &#125;);function routeChangeHandler(location, action) &#123; window.g_plugins.applyForEach('onRouteChange', &#123; initialValue: &#123; routes, location, action, &#125;, &#125;);&#125;window.g_history.listen(routeChangeHandler);routeChangeHandler(window.g_history.location);export default function RouterWrapper() &#123; return ( &#123;&#123;&#123; routerContent &#125;&#125;&#125; );&#125;// 生成路由容器class FilesGenerator &#123; generateRouterJS() &#123; const &#123; paths &#125; = this.service; const &#123; absRouterJSPath &#125; = paths; this.RoutesManager.fetchRoutes(); const routesContent = this.getRouterJSContent(); // 避免文件写入导致不必要的 webpack 编译 if (this.routesContent !== routesContent) &#123; writeFileSync(absRouterJSPath, `$&#123;routesContent.trim()&#125;\\n`, 'utf-8'); this.routesContent = routesContent; &#125; &#125; getRouterJSContent() &#123; const &#123; paths &#125; = this.service; const routerTpl = readFileSync(paths.defaultRouterTplPath, 'utf-8'); const routes = stripJSONQuote( this.getRoutesJSON(&#123; env: process.env.NODE_ENV, &#125;), ); const routerContent = ` &lt;Router history=&#123;window.g_history&#125;&gt; &#123; renderRoutes(routes, &#123;&#125;) &#125; &lt;/Router&gt; `.trim();; return Mustache.render(routerTpl, &#123; routes, routerContent, RouterRootComponent: this.service.applyPlugins( 'modifyRouterRootComponent', &#123; initialValue: 'DefaultRouter', &#125;, ), &#125;); &#125;&#125; 入口文件有了路由容器组件，入口文件所完成的功能就是将路由容器组件渲染到指定的 dom 节点上。入口文件最终会表现成临时文件夹下的 umi.js 文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 入口文件模板import '@tmp/initHistory';// 使用 webpack 别名机制将临时文件约定为通过 @tmp 加载import React from 'react';import ReactDOM from 'react-dom';&#123;&#123;&#123; imports &#125;&#125;&#125;window.g_plugins = require('umi/_runtimePlugin');window.g_plugins.init();&#123;&#123;#plugins&#125;&#125;window.g_plugins.use(require('&#123;&#123;&#123; . &#125;&#125;&#125;'));&#123;&#123;/plugins&#125;&#125;// renderlet oldRender = () =&gt; &#123; &#123;&#123;&#123; render &#125;&#125;&#125;&#125;;const render = window.g_plugins.compose('render', &#123; initialValue: oldRender &#125;);&#123;&#123;&#123; code &#125;&#125;&#125;// hot module replacementif (module.hot) &#123; module.hot.accept('./router', () =&gt; &#123; oldRender(); &#125;);&#125;// 生成入口文件class FilesGenerator &#123; generateEntry() &#123; const &#123; paths &#125; = this.service; const entryTpl = readFileSync(paths.defaultEntryTplPath, 'utf-8'); // 入口文件中的渲染逻辑 const initialRender = this.service.applyPlugins('modifyEntryRender', &#123; initialValue: ` const rootContainer = window.g_plugins.apply('rootContainer', &#123; initialValue: React.createElement(require('./router').default), &#125;); ReactDOM.render( rootContainer, document.getElementById('$&#123;this.mountElementId&#125;'), ); `.trim(), &#125;); // 运行时插件。运行时插件调用过程由 umi 包中的 runtimePlugin 模块完成 // 执行机制如中间件 const plugins = this.service .applyPlugins('addRuntimePlugin', &#123; initialValue: [], &#125;) .map(plugin =&gt; &#123; return winPath(relative(paths.absTmpDirPath, plugin)); &#125;); if (findJS(paths.absSrcPath, 'app')) &#123; plugins.push('@/app'); &#125; // 生成入口文件 const entryContent = Mustache.render(entryTpl, &#123; code: this.service .applyPlugins('addEntryCode', &#123; initialValue: [], &#125;) .join('\\n\\n'), imports: importsToStr( this.service.applyPlugins('addEntryImport', &#123; initialValue: '', &#125;), ).join('\\n'), render: initialRender, plugins, &#125;); // 入口文件写入临时文件夹下的 umi.js 中 writeFileSync(paths.absLibraryJSPath, `$&#123;entryContent.trim()&#125;\\n`, 'utf-8'); &#125;&#125; 路由机制umi 默认会根据 src/pages 文件夹内容生成路由信息；同时也支持配置路由，以及在运行时按需变更路由。通过上一节，我们也能发现，umi 允许在插件中调用 api.addRuntimePlugin 在运行时按需变更路由。因此本节主要在于说明 umi 是怎样根据 src/pages 文件夹内容生成路由信息，以及怎么使用路由的配置信息的。 在 umi 中，service.routes 路由信息通过 umi-build-dev 包所提供的 getRouteConfig 模块生成，分为三种情形： 当开发者配置路由信息时，src/pages 文件夹只用于获取组件。 当项目中存在 _routes.json 配置文件时，路由信息只通过这份配置文件获取。 以上两种情况之外，只根据 src/pages 文件夹解析获得路由信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// umi-build-dev 包中的 getRouteConfig 模块(paths, config = &#123;&#125;, onPatchRoute) =&gt; &#123; let routes = null; const routeConfigFile = join(paths.absSrcPath, '_routes.json'); if (config.routes) &#123; // 向 config.routes 中注入组件 routes = getRouteConfigFromConfig(config.routes, paths.pagesPath); &#125; else if (existsSync(routeConfigFile)) &#123; routes = getRouteConfigFromConfigFile(routeConfigFile); &#125; else &#123; routes = getRouteConfigFromDir(paths); &#125; // 监听插件对路由的变更，并调用钩子 patchRoutes( routes, config, /* isProduction */ process.env.NODE_ENV === 'production', onPatchRoute, ); return routes;&#125;;// 根据 src/pages 文件夹解析获得路由function getRouteConfigFromDir(paths) &#123; const &#123; cwd, absPagesPath, absSrcPath, dirPath = '' &#125; = paths; const absPath = join(absPagesPath, dirPath); const files = readdirSync(absPath); // 酌情递归解析路由 const routes = files.reduce(handleFile.bind(null, paths, absPath), []); if (dirPath === '' &amp;&amp; absSrcPath) &#123; const globalLayoutFile = findJS(absSrcPath, 'layouts/index') || findJS(absSrcPath, 'layout/index'); if (globalLayoutFile) &#123; const wrappedRoutes = []; addRoute( wrappedRoutes, &#123; path: '/', component: `./$&#123;winPath(relative(cwd, globalLayoutFile))&#125;`, routes, &#125;, &#123; componentFile: globalLayoutFile, &#125;, ); return wrappedRoutes; &#125; &#125; return routes;&#125;// 获取单文件或单文件夹路由，酌情递归解析子路function handleFile(paths, absPath, memo, file) &#123; const &#123; cwd, absPagesPath, dirPath = '' &#125; = paths; const absFilePath = join(absPath, file); const stats = statSync(absFilePath); const isParamsRoute = file.charAt(0) === '$';// 动态路由 if (stats.isDirectory()) &#123; const newDirPath = join(dirPath, file); const routes = getRouteConfigFromDir(&#123; ...paths, dirPath: newDirPath, &#125;); // 布局容器 const absLayoutFile = findJS(join(absPagesPath, newDirPath), '_layout'); if (absLayoutFile) &#123; addRoute( memo, &#123; path: normalizePath(newDirPath), exact: false, component: `./$&#123;winPath(relative(cwd, absLayoutFile))&#125;`, routes, isParamsRoute, &#125;, &#123; componentFile: absLayoutFile, &#125;, ); &#125; else &#123; memo = memo.concat( routes.map(route =&gt; &#123; return &#123; ...route, _sorted: true, &#125;; &#125;), ); &#125; &#125; else if (stats.isFile() &amp;&amp; isValidJS(file)) &#123; const bName = basename(file, extname(file)); const path = normalizePath(join(dirPath, bName)); addRoute( memo, &#123; path, exact: true, component: `./$&#123;winPath(relative(cwd, absFilePath))&#125;`, isParamsRoute, &#125;, &#123; componentFile: absFilePath, &#125;, ); &#125; return memo;&#125;// 通过注释扩展路由function addRoute(memo, route, &#123; componentFile &#125;) &#123; const code = readFileSync(componentFile, 'utf-8'); debug(`parse yaml from $&#123;componentFile&#125;`); const config = getYamlConfig(code); ['path', 'exact', 'component', 'routes'].forEach(key =&gt; &#123; assert(!(key in config), `Unexpected key $&#123;key&#125; in file $&#123;componentFile&#125;`); &#125;); memo.push(&#123; ...route, ...config, &#125;);&#125;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"webpack插件编程","slug":"frontend/工程化/webpack/webpack插件编程","date":"2019-06-19T16:00:00.000Z","updated":"2020-03-08T10:54:24.706Z","comments":true,"path":"2019/06/20/frontend/工程化/webpack/webpack插件编程/","link":"","permalink":"http://xzfyu.com/2019/06/20/frontend/工程化/webpack/webpack插件编程/","excerpt":"","text":"babel-preset-umibabel-preset-umi 是 umi 中的一个模块。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889function(context, opts = &#123;&#125;) &#123; const nodeEnv = process.env.NODE_ENV; const &#123; useBuiltIns = false, loose = false, targets = &#123; browsers: ['last 2 versions'] &#125;, env = &#123;&#125;, &#125; = opts; const transformRuntime = 'transformRuntime' in opts ? opts.transformRuntime : &#123; absoluteRuntime: dirname(require.resolve('../package')), &#125;; const exclude = [ 'transform-typeof-symbol', 'transform-unicode-regex', 'transform-sticky-regex', 'transform-new-target', 'transform-modules-umd', 'transform-modules-systemjs', 'transform-modules-amd', 'transform-literals', ]; const plugins = [ require.resolve('babel-plugin-react-require'), require.resolve('@babel/plugin-syntax-dynamic-import'), [ require.resolve('@babel/plugin-proposal-object-rest-spread'), &#123; loose, useBuiltIns &#125;, ], require.resolve('@babel/plugin-proposal-optional-catch-binding'), require.resolve('@babel/plugin-proposal-async-generator-functions'), // 下面两个的顺序的配置都不能动 [require.resolve('@babel/plugin-proposal-decorators'), &#123; legacy: true &#125;], [ require.resolve('@babel/plugin-proposal-class-properties'), &#123; loose: true &#125;, ], require.resolve('@babel/plugin-proposal-export-namespace-from'), require.resolve('@babel/plugin-proposal-export-default-from'), [ require.resolve('@babel/plugin-proposal-nullish-coalescing-operator'), &#123; loose &#125;, ], [require.resolve('@babel/plugin-proposal-optional-chaining'), &#123; loose &#125;], [ require.resolve('@babel/plugin-proposal-pipeline-operator'), &#123; proposal: 'minimal', &#125;, ], require.resolve('@babel/plugin-proposal-do-expressions'), require.resolve('@babel/plugin-proposal-function-bind'), require.resolve('babel-plugin-macros'), ]; if (nodeEnv !== 'test' &amp;&amp; transformRuntime) &#123; plugins.push([ require.resolve('@babel/plugin-transform-runtime'), transformRuntime, ]); &#125; if (nodeEnv === 'production') &#123; plugins.push( require.resolve('babel-plugin-transform-react-remove-prop-types'), ); &#125; return &#123; presets: [ [ require.resolve('@babel/preset-env'), &#123; targets, loose, modules: 'commonjs', exclude, ...env, &#125;, ], require.resolve('@babel/preset-react'), ], plugins, &#125;;&#125;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"webpack","slug":"frontend/webpack","permalink":"http://xzfyu.com/categories/frontend/webpack/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"snabbdom 实现原理","slug":"frontend/vue/snabbdom实现原理","date":"2019-06-15T16:00:00.000Z","updated":"2020-03-08T10:53:24.940Z","comments":true,"path":"2019/06/16/frontend/vue/snabbdom实现原理/","link":"","permalink":"http://xzfyu.com/2019/06/16/frontend/vue/snabbdom实现原理/","excerpt":"","text":"Vue 的 patch 机制基于 snabbdom 类库实现。snabbdom 类库本身就是一个专注于简洁、模块化且高效的虚拟 dom 库。因此，解读 snabbdom 类库可以辅助理解虚拟 dom 以及 Vue 的实现机制。下面我们慢慢揭开它的面纱。 整体结构有了对 Vue 虚拟 dom 的理解，我们很容易理解 snabbdom 类库的整体结构： 工具函数层：is, htmldomapi 提供底层辅助函数。is 用于判断数据类型；htmldomapi 封装了 dom 接口。 dom 钩子层：attributes 等用于在节点创建、更新时调整节点相关属性。 vnode 模型层：VNode 为虚拟 dom 模型；VNodeData 为虚拟 dom 的数据模型；Hooks 为 vnode 的钩子模型。vnode 函数用于创建 VNode 对象。 对外接口层：patch 采用深度遍历模式将 vnode 树填入到实际 dom 树中；h 创建 vnode 的渲染函数，可用于模板解析渲染过程；thunk 用于桥接 Vue 等第三方组件实例，采用定制的 fn 生成 vnode；attachto 函数用于装饰 vnode，该 vnode 会脱离真实的 dom 树，将被挂载到指定的节点下，如同 react 中 Portal 组件的效果。 有了这些功能模块以后，整体的渲染流程如下： 备注：htmldomapi，dom 钩子，Hooks 可参见附录。 VNodesnabbdom 使用对象构造 vnode。在 vnode 中，data 表示从模板解析到的或者通过组件实例构建的原生节点属性。通过继承 VNodeData，snabbdom 允许扩展 VNodeData 模型。 12345678910111213141516171819202122232425export interface VNode &#123; sel: string | undefined;// 虚拟节点的唯一标识 data: VNodeData | undefined;// 虚拟节点的相关数据属性 children: Array&lt;VNode | string&gt; | undefined;// 虚拟节点的子节点 elm: Node | undefined;// 虚拟节点所对应的真实节点，文本节点除外 text: string | undefined;// 虚拟节点所对应的真实节点，限于文本节点和注释节点 key: Key | undefined;// 虚拟节点构成数组时的唯一标识&#125;export interface VNodeData &#123; props?: Props;// 节点属性 attrs?: Attrs;// 节点 attribute 属性 class?: Classes;// 样式类 style?: VNodeStyle;// 样式 dataset?: Dataset;// data- 属性 on?: On;// 事件 hero?: Hero;// 节点切换时执行 css 放大缩小、移位动效，用于记录节点id attachData?: AttachData; hook?: Hooks;// vnode 钩子 key?: Key; ns?: string; // 命名空间 fn?: () =&gt; VNode; // thunk vnode 渲染函数 args?: Array&lt;any&gt;; // thunk vnode 渲染参数 [key: string]: any; // 接受第三方扩展&#125; h 渲染函数h 渲染函数实际上只用于创建 vnode，并没有将 vnode 绘制到文档中。作为接口，h 渲染函数本身也只包含参数多态的处理，再借助 vnode 函数创建 vnode 对象。 thunk vnodethunk vnode 不同于普通 vnode 的地方在于，thunk vnode 由 data.fn 渲染出普通 vnode，然后将该 vnode 数据拷贝给 thunk vnode 节点，这样就能实现真实 dom 的渲染逻辑。拷贝过程通过 thunk 模块内置的 init, prepatch 钩子（vnode 钩子）完成。thunk vnode 本身的创建过程则通过 h 渲染函数完成（由 thunk 函数发起调用），作为参数 data 中包含内置的 init, prepatch 钩子，用于在指定生命周期中将普通 vnode 的数据拷贝给 thunk vnode 节点。详情可参见源码。 attachToattachTo 函数用于装饰 vnode。经装饰后的 vnode 在 patch 过程中会被装填到指定 target 节点下，从而脱离 vnode 树所对应的真实 dom 树（真实 dom 树下使用空的 span 节点代替）。详情参见源码。 patchpatch 函数由 init 高阶函数创建。通过将 dom 钩子注入到 init 函数中，snabbdom 就能在节点创建、更新或卸载过程中调用这些钩子函数了。以下是 init 高阶函数内各函数的依赖关系图： 从依赖关系图中也能看出，patch 通过逻辑分支实现 dom 节点的插入、更新和移除；同时以递归调用的形式实现深度遍历算法，完成子孙节点的插入、更新。在上述过程的执行期间，snabbdom 又会调用特定的 dom 钩子更新节点的属性、样式或事件等，或者 vnode 钩子实现一些特殊处理。 patch 函数作为总的逻辑入口，主要处理以下两种情形： 当 oldVnode 和 vnode 节点相同，即包含相同的 sel, key 属性时，使用 patchVnode 函数更新节点及其子孙节点。 其他情形，创建并插入 vnode.elm 节点，并移除 oldVnode 对应的 dom 节点。 从这两种处理逻辑也能看出，patch 主要用于实现虚拟 dom 的 diff 逻辑并更新响应的 dom 树，但不包含 vnode 节点挂载及卸载的逻辑（snabbdom 允许使用空节点等价完成这一效果）。 123456789101112131415161718192021222324252627282930313233343536function patch(oldVnode: VNode | Element, vnode: VNode): VNode &#123; let i: number, elm: Node, parent: Node; const insertedVnodeQueue: VNodeQueue = []; // dom-pre 钩子 for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i](); // oldVnode 作为原生 dom，通过 emptyNodeAt 转换成 vnode if (!isVnode(oldVnode)) &#123; oldVnode = emptyNodeAt(oldVnode); &#125; // 节点相同，使用 patchVnode 更新 if (sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode, insertedVnodeQueue); // 节点不同，创建新的 dom 节点并插入文档，移除 oldVnode &#125; else &#123; elm = oldVnode.elm as Node; parent = api.parentNode(elm); createElm(vnode, insertedVnodeQueue); if (parent !== null) &#123; api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm)); removeVnodes(parent, [oldVnode], 0, 0); &#125; &#125; // 在 vnode 插入文档后，调用 vnode 树中每个节点的 insert 方法 for (i = 0; i &lt; insertedVnodeQueue.length; ++i) &#123; (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]); &#125; // dom-post 钩子 for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i](); return vnode;&#125;; createElmcreateElm 函数的主要逻辑在于创建真实的 dom 节点 vnode.elm。其处理逻辑分为以下三种情形： 当 vnode.sel 等于 ‘!’ 时，创建注释节点。 当 vnode.sel 不等于 ‘!’ 和 undefined 时，创建元素节点，并酌情递归创建子节点，或创建文本节点。 当 vnode.sel 等于 undefined 时，创建文本节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node &#123; let i: any, data = vnode.data; // vnode-init 钩子 if (data !== undefined) &#123; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.init)) &#123; i(vnode); data = vnode.data; &#125; &#125; let children = vnode.children, sel = vnode.sel; // 创建注释节点 if (sel === '!') &#123; if (isUndef(vnode.text)) &#123; vnode.text = ''; &#125; vnode.elm = api.createComment(vnode.text as string); // 创建元素节点 &#125; else if (sel !== undefined) &#123; const hashIdx = sel.indexOf('#'); const dotIdx = sel.indexOf('.', hashIdx); const hash = hashIdx &gt; 0 ? hashIdx : sel.length; const dot = dotIdx &gt; 0 ? dotIdx : sel.length; const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel; const elm = vnode.elm = isDef(data) &amp;&amp; isDef(i = (data as VNodeData).ns) ? api.createElementNS(i, tag) : api.createElement(tag); if (hash &lt; dot) elm.setAttribute('id', sel.slice(hash + 1, dot)); if (dotIdx &gt; 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\\./g, ' ')); for (i = 0; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode); // 深度遍历创建子孙节点 if (is.array(children)) &#123; for (i = 0; i &lt; children.length; ++i) &#123; const ch = children[i]; if (ch != null) &#123; api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue)); &#125; &#125; // 添加文本节点 &#125; else if (is.primitive(vnode.text)) &#123; api.appendChild(elm, api.createTextNode(vnode.text)); &#125; i = (vnode.data as VNodeData).hook; if (isDef(i)) &#123; // vnode-create 钩子 if (i.create) i.create(emptyNode, vnode); // 将插入 dom 树的 vnode 填入 insertedVnodeQueue // 在 patch 过程结尾调用这些 vnode 节点的 vnode-insert 钩子 if (i.insert) insertedVnodeQueue.push(vnode); &#125; // 创建文本节点 &#125; else &#123; vnode.elm = api.createTextNode(vnode.text as string); &#125; return vnode.elm;&#125; patchVnodepatchVnode 函数的主要逻辑在于更新节点。其处理逻辑分为以下五种情形： 当 vnode 本身就是 oldVnode 时，无需更新，直接返回。 当 vnode 为元素节点，且 vnode, oldVnode 同样包含子节点并不等值时，更新子节点簇。 当 vnode 为元素节点，且仅有 vnode 包含子节点时，为 vnode.elm 中灌入子节点。 当 vnode 为元素节点，且仅有 oldVnode 包含子节点或文本内容时，移除 vnode.elm 中的子节点或设置空文本。 当 vnode 为文本节点时，移除 oldVnode 对应的 dom 节点，并设置 vnode.elm 元素的文本内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243function patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) &#123; let i: any, hook: any; // vnode-prepatch 钩子 if (isDef(i = vnode.data) &amp;&amp; isDef(hook = i.hook) &amp;&amp; isDef(i = hook.prepatch)) &#123; i(oldVnode, vnode); &#125; const elm = vnode.elm = (oldVnode.elm as Node); let oldCh = oldVnode.children; let ch = vnode.children; if (oldVnode === vnode) return; // dom-update 钩子，vnode-update 钩子 if (vnode.data !== undefined) &#123; for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode); i = vnode.data.hook; if (isDef(i) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode); &#125; // vnode 不是文本节点，更新子节点或插入子节点或移除 oldVnode 的子节点或文本 if (isUndef(vnode.text)) &#123; if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) updateChildren(elm, oldCh as Array&lt;VNode&gt;, ch as Array&lt;VNode&gt;, insertedVnodeQueue); &#125; else if (isDef(ch)) &#123; if (isDef(oldVnode.text)) api.setTextContent(elm, ''); addVnodes(elm, null, ch as Array&lt;VNode&gt;, 0, (ch as Array&lt;VNode&gt;).length - 1, insertedVnodeQueue); &#125; else if (isDef(oldCh)) &#123; removeVnodes(elm, oldCh as Array&lt;VNode&gt;, 0, (oldCh as Array&lt;VNode&gt;).length - 1); &#125; else if (isDef(oldVnode.text)) &#123; api.setTextContent(elm, ''); &#125; // vnode 是文本节点，移除 oldVnode 的子节点，并设置 vnode 节点的文本内容 &#125; else if (oldVnode.text !== vnode.text) &#123; if (isDef(oldCh)) &#123; removeVnodes(elm, oldCh as Array&lt;VNode&gt;, 0, (oldCh as Array&lt;VNode&gt;).length - 1); &#125; api.setTextContent(elm, vnode.text as string); &#125; // vnode-postpatch 钩子 if (isDef(hook) &amp;&amp; isDef(i = hook.postpatch)) &#123; i(oldVnode, vnode); &#125;&#125; updateChildrenupdateChildren 函数针对子节点簇进行更新操作。对于具有相同 key 键的节点，snabbdom 会使用 patchVnode 局部更新该节点或节点树；除此之外，snabbdom 所采用的操作就是创建新节点、移除旧节点。 在处理逻辑上，snabbdom 使用 startIndex, endIndex 双索引收敛法快速在 vnode.children, oldVnode.children 找到相同的节点并基于 patchVnode 函数更新。如果 vnode.children, oldVnode.children 首尾索引节点均不存在相同节点时，那就访问 vnode.children 首位索引节点，判断 oldVnode.children 是否存在相同 key 键的节点，如存在，使用 patchVnode 更新；如不存在，创建 dom 节点并完成插入。当 vnode.children 的 startIndex, endIndex 双索引产生收敛冲突时，意味着新的子节点簇在 oldVnode.children 均已找到并使用了相同的节点（如存在），oldVnode.children 双索引区间内为待移除的节点或 undefined（原始节点在 vnode.children 中具有相同节点）。当 oldVnode.children 的 startIndex, endIndex 双索引产生收敛冲突时，意味着老的子节点簇在 vnode.children 均已被使用（如存在相同节点），vnode.children 双索引区间内为待新增的节点。 不得不说，updateChildren 函数的处理手法显得晦奥，可参看源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function updateChildren(parentElm: Node, oldCh: Array&lt;VNode&gt;, newCh: Array&lt;VNode&gt;, insertedVnodeQueue: VNodeQueue) &#123; let oldStartIdx = 0, newStartIdx = 0; let oldEndIdx = oldCh.length - 1; let oldStartVnode = oldCh[0]; let oldEndVnode = oldCh[oldEndIdx]; let newEndIdx = newCh.length - 1; let newStartVnode = newCh[0]; let newEndVnode = newCh[newEndIdx]; let oldKeyToIdx: any; let idxInOld: number; let elmToMove: VNode; let before: any; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left &#125; else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx]; &#125; else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx]; // 从前往后遍历查找相同节点，若存在相同节点，使用 patchVnode 更新该节点 &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; // 从后往前遍历查找相同节点，若存在相同节点，使用 patchVnode 更新该节点 &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; // 原始节点右移到最末端，使用 patchVnode 更新该节点 &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldStartVnode.elm as Node, api.nextSibling(oldEndVnode.elm as Node)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; // 原始节点左移到最顶端，使用 patchVnode 更新该节点 &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldEndVnode.elm as Node, oldStartVnode.elm as Node); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; // 根据 vnode.children 中顺序子节点是否在 oldVnode.children，采用不同的策略：更新或创建 &#125; else &#123; if (oldKeyToIdx === undefined) &#123; // oldKeyToIdx 是原始子节点的 key 键及其 index 序号的映射 oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125; idxInOld = oldKeyToIdx[newStartVnode.key as string]; // 处理新添加的节点 if (isUndef(idxInOld)) &#123; // New element api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node); newStartVnode = newCh[++newStartIdx]; &#125; else &#123; elmToMove = oldCh[idxInOld]; // 节点变更，根据新的 newStartVnode 创建 dom 节点 if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node); // 节点移位，更新并移位 &#125; else &#123; patchVnode(elmToMove, newStartVnode, insertedVnodeQueue); oldCh[idxInOld] = undefined as any; api.insertBefore(parentElm, (elmToMove.elm as Node), oldStartVnode.elm as Node); &#125; newStartVnode = newCh[++newStartIdx]; &#125; &#125; &#125; if (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123; // oldVnode.children 双索引冲突，vnode.children 双索引区间为待新增节点 if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx+1] == null ? null : newCh[newEndIdx+1].elm; addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); // vnode.children 双索引冲突，oldVnode.children 双索引区间为待移除节点 &#125; else &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125; &#125;&#125; 附录htmldomapidom 接口集合。 1234567891011121314151617export interface DOMAPI &#123; createElement: (tagName: any) =&gt; HTMLElement; createElementNS: (namespaceURI: string, qualifiedName: string) =&gt; Element; createTextNode: (text: string) =&gt; Text; createComment: (text: string) =&gt; Comment; insertBefore: (parentNode: Node, newNode: Node, referenceNode: Node | null) =&gt; void; removeChild: (node: Node, child: Node) =&gt; void; appendChild: (node: Node, child: Node) =&gt; void; parentNode: (node: Node) =&gt; Node; nextSibling: (node: Node) =&gt; Node; tagName: (elm: Element) =&gt; string; setTextContent: (node: Node, text: string | null) =&gt; void; getTextContent: (node: Node) =&gt; string | null; isElement: (node: Node) =&gt; node is Element; isText: (node: Node) =&gt; node is Text; isComment: (node: Node) =&gt; node is Comment;&#125; modulesattributes根据 (vnode | oldVnode).data.attrs 设置或更新节点的 attributes 属性。实现上借助 elm.setAttribute, elm.setAttributeNS, elm.removeAttribute 方法。当 attrs 属性以 xml: 或 xlink: 起始时，使用 elm.setAttributeNS 方法设置属性的命名空间为 ‘http://www.w3.org/XML/1998/namespace&#39; 或 ‘http://www.w3.org/1999/xlink&#39;。该模块透出 create, update 钩子。 class根据 (vnode | oldVnode).data.class 设置或更新节点的 class。实现上借助 elm.classList.add, elm.classList.remove 方法。该模块透出 create, update 钩子。 dataset根据 (vnode | oldVnode).data.dataset 设置或更新节点的 data- 属性。实现上首先尝试将 dataset 数据挂载到 elm.dataset 对象上，其次尝试通过 elm.setAttribute, elm.removeAttribute 方法设置或移除元素的 data- 属性（连字符形式）。该模块透出 create, update 钩子。 props根据 (vnode | oldVnode).data.props 设置或更新节点的属性。实现上将 props 数据挂载到 elm 对象上。该模块透出 create, update 钩子。 eventlisteners根据 (vnode | oldVnode).data.on 设置或更新节点的绑定函数。绑定函数经集成为 node.listener 方法，对所有事件都一样。该模块透出 create, update, destory 钩子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** 从 vnode.data.on 中取出执行函数，在元素的绑定事件层面构建集成封装的处理函数 node.listener **/function invokeHandler(handler: any, vnode?: VNode, event?: Event): void &#123; if (typeof handler === \"function\") &#123; handler.call(vnode, event, vnode); &#125; else if (typeof handler === \"object\") &#123; if (typeof handler[0] === \"function\") &#123; if (handler.length === 2) &#123; handler[0].call(vnode, handler[1], event, vnode); &#125; else &#123; var args = handler.slice(1); args.push(event); args.push(vnode); handler[0].apply(vnode, args); &#125; &#125; else &#123; for (var i = 0; i &lt; handler.length; i++) &#123; invokeHandler(handler[i], vnode, event); &#125; &#125; &#125;&#125;function handleEvent(event: Event, vnode: VNode) &#123; var name = event.type, on = (vnode.data as VNodeData).on; if (on &amp;&amp; on[name]) &#123; invokeHandler(on[name], vnode, event); &#125;&#125;function createListener() &#123; return function handler(event: Event) &#123; handleEvent(event, (handler as any).vnode); &#125;&#125;/** --- **/function updateEventListeners(oldVnode: VNode, vnode?: VNode): void &#123; var oldOn = (oldVnode.data as VNodeData).on, oldListener = (oldVnode as any).listener, oldElm: Element = oldVnode.elm as Element, on = vnode &amp;&amp; (vnode.data as VNodeData).on, elm: Element = (vnode &amp;&amp; vnode.elm) as Element, name: string; if (oldOn === on) &#123; return; &#125; if (oldOn &amp;&amp; oldListener) &#123; if (!on) &#123; for (name in oldOn) &#123; oldElm.removeEventListener(name, oldListener, false); &#125; &#125; else &#123; for (name in oldOn) &#123; if (!on[name]) &#123; oldElm.removeEventListener(name, oldListener, false); &#125; &#125; &#125; &#125; if (on) &#123; var listener = (vnode as any).listener = (oldVnode as any).listener || createListener(); listener.vnode = vnode; if (!oldOn) &#123; for (name in on) &#123; elm.addEventListener(name, listener, false); &#125; &#125; else &#123; for (name in on) &#123; if (!oldOn[name]) &#123;// name 事件未作绑定 elm.addEventListener(name, listener, false); &#125; &#125; &#125; &#125;&#125;export const eventListenersModule = &#123; create: updateEventListeners, update: updateEventListeners, destroy: updateEventListeners&#125; as Module; style根据 (vnode | oldVnode).data.style 设置或更新节点的样式。实现上针对 – 起始的样式属性，使用 elm.style.setProperty, elm.style.removeProperty 设置样式；对于其他样式属性，直接对 elm.style 进行赋值。特别的，对于 style.delayed 样式集合，使用 setNextFrame 在下一帧进行绘制。该模块透出 pre, create, update, destroy, remove 钩子。destory 钩子会为 elm 元素设置 style.destory 样式。remove 钩子在元素移除时触发，其会为元素设置 style.remove 样式，并且再 css-transition 动效执行完成后，将调用 rm 回调。该模块透出 pre, create, update, destory, remove 钩子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var reflowForced = false;function updateStyle(oldVnode: VNode, vnode: VNode): void &#123; var cur: any, name: string, elm = vnode.elm, oldStyle = (oldVnode.data as VNodeData).style, style = (vnode.data as VNodeData).style; if (!oldStyle &amp;&amp; !style) return; if (oldStyle === style) return; oldStyle = oldStyle || &#123;&#125; as VNodeStyle; style = style || &#123;&#125; as VNodeStyle; var oldHasDel = 'delayed' in oldStyle; for (name in oldStyle) &#123; if (!style[name]) &#123; if (name[0] === '-' &amp;&amp; name[1] === '-') &#123; (elm as any).style.removeProperty(name); &#125; else &#123; (elm as any).style[name] = ''; &#125; &#125; &#125; for (name in style) &#123; cur = style[name]; if (name === 'delayed' &amp;&amp; style.delayed) &#123; for (let name2 in style.delayed) &#123; cur = style.delayed[name2]; if (!oldHasDel || cur !== (oldStyle.delayed as any)[name2]) &#123; // setNextFrame 调用 requestAnimationFrame 或 setTimeout 设置 elm.style[key] = value setNextFrame((elm as any).style, name2, cur); &#125; &#125; &#125; else if (name !== 'remove' &amp;&amp; cur !== oldStyle[name]) &#123; if (name[0] === '-' &amp;&amp; name[1] === '-') &#123; (elm as any).style.setProperty(name, cur); &#125; else &#123; (elm as any).style[name] = cur; &#125; &#125; &#125;&#125;function applyDestroyStyle(vnode: VNode): void &#123; var style: any, name: string, elm = vnode.elm, s = (vnode.data as VNodeData).style; if (!s || !(style = s.destroy)) return; for (name in style) &#123; (elm as any).style[name] = style[name]; &#125;&#125;function applyRemoveStyle(vnode: VNode, rm: () =&gt; void): void &#123; var s = (vnode.data as VNodeData).style; if (!s || !s.remove) &#123; rm(); return; &#125; if(!reflowForced) &#123; getComputedStyle(document.body).transform; reflowForced = true; &#125; var name: string, elm = vnode.elm, i = 0, compStyle: CSSStyleDeclaration, style = s.remove, amount = 0, applied: Array&lt;string&gt; = []; for (name in style) &#123; applied.push(name); (elm as any).style[name] = style[name]; &#125; compStyle = getComputedStyle(elm as Element); var props = (compStyle as any)['transition-property'].split(', '); for (; i &lt; props.length; ++i) &#123; if(applied.indexOf(props[i]) !== -1) amount++; &#125; (elm as Element).addEventListener('transitionend', function (ev: TransitionEvent) &#123; if (ev.target === elm) --amount; if (amount === 0) rm(); &#125;);&#125;function forceReflow() &#123; reflowForced = false;&#125;export const styleModule = &#123; pre: forceReflow, create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle&#125; as Module; hero根据 vnode.data.hero.id 设置 css-transition 动效（包含元素大小和偏移量）。动效特征从 oldVnode 过渡到 vnode，在动效执行期间保留 oldVnode，等到动效执行完成，再行移除；vnode 在动效执行期间置为透明，同步调整大小，在下一帧置为非透明。该模块透出 pre, create, destory, post 钩子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145function getTextNodeRect(textNode: Text): ClientRect | undefined &#123; var rect: ClientRect | undefined; if (document.createRange) &#123; var range = document.createRange(); range.selectNodeContents(textNode); if (range.getBoundingClientRect) &#123; rect = range.getBoundingClientRect(); &#125; &#125; return rect;&#125;// 获取中心点function calcTransformOrigin(isTextNode: boolean, textRect: ClientRect | undefined, boundingRect: ClientRect): string &#123; if (isTextNode) &#123; if (textRect) &#123; var relativeCenterX = textRect.left + textRect.width/2 - boundingRect.left; var relativeCenterY = textRect.top + textRect.height/2 - boundingRect.top; return relativeCenterX + 'px ' + relativeCenterY + 'px'; &#125; &#125; return '0 0';&#125;// 计算偏移量function getTextDx(oldTextRect: ClientRect | undefined, newTextRect: ClientRect | undefined): number &#123; if (oldTextRect &amp;&amp; newTextRect) &#123; return ((oldTextRect.left + oldTextRect.width/2) - (newTextRect.left + newTextRect.width/2)); &#125; return 0;&#125;function getTextDy(oldTextRect: ClientRect | undefined, newTextRect: ClientRect | undefined): number &#123; if (oldTextRect &amp;&amp; newTextRect) &#123; return ((oldTextRect.top + oldTextRect.height/2) - (newTextRect.top + newTextRect.height/2)); &#125; return 0;&#125;var removed: any, created: any;function pre() &#123; removed = &#123;&#125;; created = [];&#125;function create(oldVnode: VNode, vnode: VNode): void &#123; var hero = (vnode.data as VNodeData).hero; if (hero &amp;&amp; hero.id) &#123; created.push(hero.id);// 记录vnode相关的id，用于查找对应的oldVnode created.push(vnode); &#125;&#125;function destroy(vnode: VNode): void &#123; var hero = (vnode.data as VNodeData).hero; if (hero &amp;&amp; hero.id) &#123; var elm = vnode.elm; (vnode as any).isTextNode = isTextElement(elm as Element | Text); //保存是否文本节点 (vnode as any).boundingRect = (elm as Element).getBoundingClientRect(); //保存元素大小 (vnode as any).textRect = (vnode as any).isTextNode ? getTextNodeRect((elm as Element).childNodes[0] as Text) : null; //保存元素内文本节点大小 var computedStyle = window.getComputedStyle(elm as Element, void 0); (vnode as any).savedStyle = JSON.parse(JSON.stringify(computedStyle)); //保存样式拷贝 removed[hero.id] = vnode; &#125;&#125;function post() &#123; var i: number, id: any, newElm: Element, oldVnode: VNode, oldElm: Element, hRatio: number, wRatio: number, oldRect: ClientRect, newRect: ClientRect, dx: number, dy: number, origTransform: string | null, origTransition: string | null, newStyle: CSSStyleDeclaration, oldStyle: CSSStyleDeclaration, newComputedStyle: CSSStyleDeclaration, isTextNode: boolean, newTextRect: ClientRect | undefined, oldTextRect: ClientRect | undefined; for (i = 0; i &lt; created.length; i += 2) &#123; id = created[i]; newElm = created[i+1].elm; oldVnode = removed[id]; if (oldVnode) &#123; isTextNode = (oldVnode as any).isTextNode &amp;&amp; isTextElement(newElm); //Are old &amp; new both text? newStyle = (newElm as HTMLElement).style; newComputedStyle = window.getComputedStyle(newElm, void 0); oldElm = oldVnode.elm as Element; oldStyle = (oldElm as HTMLElement).style; newRect = newElm.getBoundingClientRect(); oldRect = (oldVnode as any).boundingRect; if (isTextNode) &#123; newTextRect = getTextNodeRect(newElm.childNodes[0] as Text); oldTextRect = (oldVnode as any).textRect; dx = getTextDx(oldTextRect, newTextRect); dy = getTextDy(oldTextRect, newTextRect); &#125; else &#123; dx = oldRect.left - newRect.left; dy = oldRect.top - newRect.top; &#125; hRatio = newRect.height / (Math.max(oldRect.height, 1)); wRatio = isTextNode ? hRatio : newRect.width / (Math.max(oldRect.width, 1)); //缩放率 origTransform = newStyle.transform; origTransition = newStyle.transition; if (newComputedStyle.display === 'inline') //inline elements cannot be transformed newStyle.display = 'inline-block'; newStyle.transition = origTransition + 'transform 0s'; newStyle.transformOrigin = calcTransformOrigin(isTextNode, newTextRect, newRect); newStyle.opacity = '0'; newStyle.transform = origTransform + 'translate('+dx+'px, '+dy+'px) ' + 'scale('+1/wRatio+', '+1/hRatio+')'; // setNextFrame 调用 requestAnimationFrame 或 setTimeout 设置 elm.style[key] = value setNextFrame(newStyle, 'transition', origTransition); setNextFrame(newStyle, 'transform', origTransform); setNextFrame(newStyle, 'opacity', '1'); for (var key in (oldVnode as any).savedStyle) &#123; //re-apply saved inherited properties if (parseInt(key) != key as any as number) &#123; var ms = key.substring(0,2) === 'ms'; var moz = key.substring(0,3) === 'moz'; var webkit = key.substring(0,6) === 'webkit'; if (!ms &amp;&amp; !moz &amp;&amp; !webkit) //ignore prefixed style properties (oldStyle as any)[key] = (oldVnode as any).savedStyle[key]; &#125; &#125; oldStyle.position = 'absolute'; oldStyle.top = oldRect.top + 'px'; oldStyle.left = oldRect.left + 'px'; oldStyle.width = oldRect.width + 'px'; //可能需要将相对大小调整为绝对大小 oldStyle.height = oldRect.height + 'px'; oldStyle.margin = '0'; oldStyle.transformOrigin = calcTransformOrigin(isTextNode, oldTextRect, oldRect); oldStyle.transform = ''; oldStyle.opacity = '1'; document.body.appendChild(oldElm); setNextFrame(oldStyle, 'transform', 'translate('+ -dx +'px, '+ -dy +'px) scale('+wRatio+', '+hRatio+')'); setNextFrame(oldStyle, 'opacity', '0'); oldElm.addEventListener('transitionend', function (ev: TransitionEvent) &#123; if (ev.propertyName === 'transform') document.body.removeChild(ev.target as Node); &#125;); &#125; &#125; removed = created = undefined;&#125;export const heroModule = &#123;pre, create, destroy, post&#125; as Module; VNode-Hooksvnode 钩子。 1234567891011121314151617181920212223export type PreHook = () =&gt; any;export type InitHook = (vNode: VNode) =&gt; any;export type CreateHook = (emptyVNode: VNode, vNode: VNode) =&gt; any;export type InsertHook = (vNode: VNode) =&gt; any;export type PrePatchHook = (oldVNode: VNode, vNode: VNode) =&gt; any;export type UpdateHook = (oldVNode: VNode, vNode: VNode) =&gt; any;export type PostPatchHook = (oldVNode: VNode, vNode: VNode) =&gt; any;export type DestroyHook = (vNode: VNode) =&gt; any;export type RemoveHook = (vNode: VNode, removeCallback: () =&gt; void) =&gt; any;export type PostHook = () =&gt; any;export interface Hooks &#123; pre?: PreHook; init?: InitHook; create?: CreateHook; insert?: InsertHook; prepatch?: PrePatchHook; update?: UpdateHook; postpatch?: PostPatchHook; destroy?: DestroyHook; remove?: RemoveHook; post?: PostHook;&#125;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"vue","slug":"frontend/vue","permalink":"http://xzfyu.com/categories/frontend/vue/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"虚拟 dom","slug":"虚拟-dom","permalink":"http://xzfyu.com/tags/虚拟-dom/"}]},{"title":"Vue 虚拟 dom","slug":"frontend/vue/虚拟dom","date":"2019-06-08T16:00:00.000Z","updated":"2020-03-08T10:53:40.196Z","comments":true,"path":"2019/06/09/frontend/vue/虚拟dom/","link":"","permalink":"http://xzfyu.com/2019/06/09/frontend/vue/虚拟dom/","excerpt":"","text":"虚拟 dom 桥接着 view-model 模型和实际的 dom 节点树。首先 view-model 通常不只包含一个节点，而是一颗节点树，和实际的 dom 节点有一对多的关联。因此借助于虚拟 dom 节点，我们就可以与实际的 dom 节点产生一对一的关联。同时，view-model 保存着全量的数据，通过它不能直接对实际的 dom 节点树进行增量更新。有了同样是树结构的虚拟 dom 作为 view-model 和实际 dom 节点树的中继者，一方面我们就能将 view-model 中的数据、模板很好地反映到实际的 dom 节点树上；另一方面 view-model 增量数据更新可表现为虚拟 dom 节点树的前后差异，从而局部重绘实际的 dom 节点树。 整体流程虚拟 dom 的核心操作分为三个步骤：对虚拟 dom 进行建模，并创建虚拟 dom；比较虚拟 dom 树的前后差异；将差异渲染到页面上。在 Vue 中，第二步和第三步在 patch 过程中合为一体。广义的虚拟 dom 还包含从模板解析出虚拟 dom 树的过程，本文针对的是 Vue 中虚拟 dom 的实现，这里仅指明由模板生成的渲染函数。至于解析模板的具体逻辑，笔者将在后续的文章加以分析。下面是 Vue 通过模板解析出的渲染函数。 1234567891011121314151617// 由 src/compiler/codegen/index.js 中 generate 函数输出// _s 函数：toString 方法// _v 函数：创建文本节点// _c 函数：创建标签节点&#123; render: `with (this) &#123; return _c( 'div', &#123; attrs: &#123; \"id\": \"app\" &#125; &#125;, [ _c( 'h1', &#123; staticStyle: &#123; \"color\": \"red\" &#125;, attrs: &#123; \"data-id\": \"1\" &#125; &#125;, [_v(_s(message))] ) ] ) &#125;`&#125; 在上述代码中，有必要指明的是，_c 即 Vue 生命周期 - 创建实例 中的 vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) 以及 vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)。参数 a 为 tag 节点的标签名，b 为 data 节点的数据，c 为 children 子节点，d 为 normalizationType；而 createElement 函数则用于创建 VNode。实际上，上述代码中的 render 渲染函数会被包裹成 vm.$options.render 高阶函数，最终在 vm._render 方法中以 vm.$options.render.call(vm._renderProxy, vm.$createElement) 的调用形式创建 VNode，即通过高阶函数传入 _c, _s, _v 等工具函数。 当通过 vm._render 获得 vnode （该 vnode 将包含从模板中解析到的父 vnode 节点信息）以后，Vue 会调用 vm._update 方法将 vnode 填入文档或进行重绘。vm._update 方法实际基于 vm.patch 方法完成组件的挂载或重绘，参考 Vue 生命周期 - 组件挂载及更新。下图是单个 Vue 组件在父模板中作为模板节点的解析过程。 对于用户手动 new 出的 Vue 实例，完成挂载需要手动调用 $mount 方法，然后将该 Vue 实例关联的模板解析为渲染函数并完成渲染。这时 template 和 _render 方法一样都是 Vue 实例的一部分。当该组件模板 template 包含其他组件节点或原生节点等时，在渲染函数执行期间，注入的 vm._c 方法将会创建与该组件节点或原生节点相对应的 vnode。对于组件节点，在 patch 过程中通过 init 钩子创建关联的 Vue 实例。处理过程参见下文的 patch 一小节。 vnode 模型 vnode 大致可以分为以下几类： EmptyVNode：注释节点，对应原生的注释节点，text 属性有值 且 isComment 属性为真值。 TextVNode：文本节点，对应原生的文本节点，text 属性有值。 ElementVNode：元素节点，对应原生的元素节点，elm 属性在渲染或重绘后有值。 ComponentVNode：组件节点，elm 属性在渲染或重绘后有值，包含类组件、函数式组件、异步组件等。 CloneVNode：拷贝节点，isCloned 属性为真值，以便于复用。 创建 vnode 由上文可以看出，在创建 vnode 的过程中，将调用 createElement 函数生成 vnode 的一般属性，包含 tag, data, children, text, ns, context, key。创建 vnode 有三种方式：对于内置的 html 节点，直接创建 VNode 实例；对于 Vue 组件构成的模板节点，通过 createComponent 创建 VNode 实例；对于 tag 不可识别或为对象的其他节点，同样通过 createComponent 创建 VNode 实例。 createElement在 Vue 中，createElement 函数的功能主要由 _createElement 实现。createElement 的特殊意义是对参数进行处理，余下的过程都由 _createElement 完成。createElement 通过 vm._c 注入到模板渲染函数中；当渲染函数执行过程中，可用于创建 vnode 节点树。createElement 本身的实现也较为简单：针对模板中的原生节点，直接使用 new VNode 创建 vnode 实例；针对模板中的组件节点或其他，调用 createComponent 创建 vnode 实例。以下是 _createElement 函数的扼要实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// createElement 函数处理参数，并调用 _createElement 创建 vnodefunction _createElement ( context: Component,// 模板对应的 vm 实例 tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; // v-bind:is 或 is 属性的存在，意为动态组件 if (isDef(data) &amp;&amp; isDef(data.is)) &#123; tag = data.is &#125; // 插槽支持单个函数作为子组件 if (Array.isArray(children) &amp;&amp; typeof children[0] === 'function' ) &#123; data = data || &#123;&#125; data.scopedSlots = &#123; default: children[0] &#125; children.length = 0 &#125; if (normalizationType === ALWAYS_NORMALIZE) &#123; // normalizeChildren 函数意义为： // 如果 children 是原始类型，字符串、数值、symbol或布尔值，使用 createTextVNode 创建文本节点 // 如果 children 是数组，递归处理，文本节点聚合，参考 normalizeArrayChildren 函数 children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; // simpleNormalizeChildren 如遇到数组，不作递归处理，只是简单地拼接 children = simpleNormalizeChildren(children) &#125; let vnode, ns if (typeof tag === 'string') &#123; let Ctor // config 根据不同环境有不同实现 ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) // 针对环境支持的 html 节点标签 if (config.isReservedTag(tag)) &#123; vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) // resolveAsset 从 context.$options.components 获取指定的组件构造器 &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, 'components', tag))) &#123; vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; &#125; else &#123; vnode = createComponent(tag, data, context, children) &#125; if (Array.isArray(vnode)) &#123; return vnode &#125; else if (isDef(vnode)) &#123; if (isDef(ns)) applyNS(vnode, ns)// 将 ns 写入 vnode // registerDeepBindings 使用 observer 包提供的 traverse 函数递归地调用响应式数据 data 的 getter，绑定依赖 if (isDef(data)) registerDeepBindings(data) return vnode &#125; else &#123; return createEmptyVNode() &#125;&#125; createComponentcreateComponent 函数意义在于创建不同类型的组件：异步组件、函数式组件、类组件等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; const baseCtor = context.$options._base// Vue 构造函数 if (isObject(Ctor)) &#123;// 当 Ctor 为对象，构造 Vue 的子类 Ctor = baseCtor.extend(Ctor) &#125; // 处理异步组件 let asyncFactory if (isUndef(Ctor.cid)) &#123;// Ctor 异步组件形式 asyncFactory = Ctor // 异步组件加载过程中，Ctor 为 undefined；加载完成，Ctor 为待渲染的组件 Ctor = resolveAsyncComponent(asyncFactory, baseCtor) // 异步组件加载过程中，创建异步占位符 if (Ctor === undefined) &#123; return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125; &#125; data = data || &#123;&#125; // 更新类所携带的选项 resolveConstructorOptions(Ctor) // 根据 Ctor.options.model 更新 data 中的指定数据以及绑定事件 // model 选项的意义就在于双向绑定，可包含的属性有 prop, event, callback // prop 指定模板和响应式数据交互的 key；event, callback 指定事件和绑定函数 if (isDef(data.model)) &#123; transformModel(Ctor.options, data) &#125; // 根据 Ctor.options.props 解析出 data.attrs, data.props（父组件传入的 props） // options.props 指定子组件接受数据的 key 键 const propsData = extractPropsFromVNodeData(data, Ctor, tag) // 处理函数式组件 if (isTrue(Ctor.options.functional)) &#123; return createFunctionalComponent(Ctor, propsData, data, context, children) &#125; const listeners = data.on// dom 事件 data.on = data.nativeOn // 抽象组件，data 中仅保留 slot if (isTrue(Ctor.options.abstract)) &#123; const slot = data.slot data = &#123;&#125; if (slot) &#123; data.slot = slot &#125; &#125; // 将 componentVNodeHooks 钩子灌入到 data.hook 中 installComponentHooks(data) const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : ''&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;,// 作为 componentOptions asyncFactory ) return vnode&#125; 函数式组件函数式组件 对应 React 中的无状态组件。不同于类组件以 vm 实例作为上下文，函数式组件在生成过程中将构建新的上下文对象，因此没有对应的 vm 实例，也就没有响应的生命周期和响应式数据。 函数式组件所对应的 vnode 实例包含特殊属性如 fnContext, fnOptions, fnScopeId。fnContext 即模板所对应的 vm 实例；fnOptions 即 vm 构造函数所划定的选项；fnScopeId 即选项中包含的作用域 id。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// 创建函数式-无状态组件function createFunctionalComponent ( Ctor: Class&lt;Component&gt;, propsData: ?Object, data: VNodeData, contextVm: Component, children: ?Array&lt;VNode&gt;): VNode | Array&lt;VNode&gt; | void &#123; const options = Ctor.options const props = &#123;&#125; const propOptions = options.props if (isDef(propOptions)) &#123; for (const key in propOptions) &#123; props[key] = validateProp(key, propOptions, propsData || emptyObject) &#125; &#125; else &#123; if (isDef(data.attrs)) mergeProps(props, data.attrs) if (isDef(data.props)) mergeProps(props, data.props) &#125; // 构建新的上下文对象，对应类组件的 vm 实例 const renderContext = new FunctionalRenderContext( data, props, children, contextVm, Ctor ) // 没有使用 vm 实例作为上下文，因此没有生命周期和响应式数据 // renderContext._c 即上文中的 createElement const vnode = options.render.call(null, renderContext._c, renderContext) if (vnode instanceof VNode) &#123; return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext) &#125; else if (Array.isArray(vnode)) &#123; const vnodes = normalizeChildren(vnode) || [] const res = new Array(vnodes.length) for (let i = 0; i &lt; vnodes.length; i++) &#123; res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext) &#125; return res &#125;&#125;function FunctionalRenderContext ( data: VNodeData, props: Object, children: ?Array&lt;VNode&gt;, parent: Component, Ctor: Class&lt;Component&gt;) &#123; const options = Ctor.options let contextVm if (hasOwn(parent, '_uid')) &#123; contextVm = Object.create(parent) contextVm._original = parent &#125; else &#123; contextVm = parent parent = parent._original &#125; const isCompiled = isTrue(options._compiled) const needNormalization = !isCompiled this.data = data this.props = props this.children = children this.parent = parent this.listeners = data.on || emptyObject this.injections = resolveInject(options.inject, parent) this.slots = () =&gt; &#123; if (!this.$slots) &#123; normalizeScopedSlots( data.scopedSlots, this.$slots = resolveSlots(children, parent) ) &#125; return this.$slots &#125; Object.defineProperty(this, 'scopedSlots', (&#123; enumerable: true, get () &#123; return normalizeScopedSlots(data.scopedSlots, this.slots()) &#125; &#125;: any)) if (isCompiled) &#123; this.$options = options this.$slots = this.slots() this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots) &#125; if (options._scopeId) &#123; this._c = (a, b, c, d) =&gt; &#123; const vnode = createElement(contextVm, a, b, c, d, needNormalization) if (vnode &amp;&amp; !Array.isArray(vnode)) &#123; vnode.fnScopeId = options._scopeId vnode.fnContext = parent &#125; return vnode &#125; &#125; else &#123; this._c = (a, b, c, d) =&gt; createElement(contextVm, a, b, c, d, needNormalization) &#125;&#125;installRenderHelpers(FunctionalRenderContext.prototype)// 拷贝 vnode，以便于根据 isCloned 属性判断是否拷贝节点，如是，可复用function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) &#123; const clone = cloneVNode(vnode) clone.fnContext = contextVm clone.fnOptions = options if (process.env.NODE_ENV !== 'production') &#123; (clone.devtoolsMeta = clone.devtoolsMeta || &#123;&#125;).renderContext = renderContext &#125; if (data.slot) &#123; (clone.data || (clone.data = &#123;&#125;)).slot = data.slot &#125; return clone&#125; 异步组件异步组件 通常是 asyncFactory = (resolve, reject) =&gt; {} 或 () =&gt; ({ component }) 函数注册的组件。异步组件主要由 resolveAsyncComponent 函数处理其加载逻辑。当异步组件在加载过程中，Vue 会使用 createAsyncPlaceholder 创建占位节点。当异步组件加载完成后，Vue 会通过强制重绘父组件的方式，启动该异步组件的渲染过程。实际上，在加载完成后，Vue 会将该异步组件填充到 asyncFactory.resolved 属性中。因此，若有其他组件需要渲染该异步组件时，直接取出 asyncFactory.resolved 作为 vm 实例的构造器并完成渲染即可。 回溯上文的 vnode 模型，其中的 asyncFactory, asyncMeta 属性实际只存在于占位节点中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// 异步组件的渲染机制// 初次加载异步组件，二次以后直接消费已加载的异步组件function resolveAsyncComponent ( factory: Function, baseCtor: Class&lt;Component&gt;): Class&lt;Component&gt; | void &#123; // 当异步组件加载完成再次被使用时，factory.errorComp, factory.resolved 等属性可能填满了值 if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123; return factory.errorComp &#125; if (isDef(factory.resolved)) &#123; return factory.resolved &#125; const owner = currentRenderingInstance// 当前渲染的组件实例，作为异步组件的父组件 // factory.owners 记录异步组件的所有父组件，通过强制更新父组件渲染异步组件 if (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -1) &#123; factory.owners.push(owner) &#125; if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) &#123; return factory.loadingComp &#125; if (owner &amp;&amp; !isDef(factory.owners)) &#123; const owners = factory.owners = [owner] let sync = true let timerLoading = null let timerTimeout = null ;(owner: any).$on('hook:destroyed', () =&gt; remove(owners, owner)) // 通过强制重绘父组件完成异步组件的渲染 const forceRender = (renderCompleted: boolean) =&gt; &#123; for (let i = 0, l = owners.length; i &lt; l; i++) &#123; (owners[i]: any).$forceUpdate() &#125; if (renderCompleted) &#123; owners.length = 0 if (timerLoading !== null) &#123; clearTimeout(timerLoading) timerLoading = null &#125; if (timerTimeout !== null) &#123; clearTimeout(timerTimeout) timerTimeout = null &#125; &#125; &#125; const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // factory.resolved 即 import 加载的组件，或者通过后端返回数据构建的 Vue 子类 factory.resolved = ensureCtor(res, baseCtor) if (!sync) &#123; forceRender(true) &#125; else &#123; owners.length = 0 &#125; &#125;) const reject = once(reason =&gt; &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed to resolve async component: $&#123;String(factory)&#125;` + (reason ? `\\nReason: $&#123;reason&#125;` : '') ) if (isDef(factory.errorComp)) &#123; factory.error = true// 置为真值，以便在重绘时渲染 factory.errorComp forceRender(true) &#125; &#125;) const res = factory(resolve, reject)// 加载异步组件 if (isObject(res)) &#123; if (isPromise(res)) &#123; if (isUndef(factory.resolved)) &#123; res.then(resolve, reject) &#125; &#125; else if (isPromise(res.component)) &#123; res.component.then(resolve, reject) if (isDef(res.error)) &#123; // 构建 factory.errorComp，以便二次渲染 factory.errorComp = ensureCtor(res.error, baseCtor) &#125; if (isDef(res.loading)) &#123; factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) &#123; factory.loading = true &#125; else &#123; timerLoading = setTimeout(() =&gt; &#123; timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123; factory.loading = true forceRender(false) &#125; &#125;, res.delay || 200) &#125; &#125; if (isDef(res.timeout)) &#123; timerTimeout = setTimeout(() =&gt; &#123; timerTimeout = null if (isUndef(factory.resolved)) &#123; reject( process.env.NODE_ENV !== 'production' ? `timeout ($&#123;res.timeout&#125;ms)` : null ) &#125; &#125;, res.timeout) &#125; &#125; &#125; sync = false // 异步组件已加载完成，返回待渲染的组件 return factory.loading ? factory.loadingComp : factory.resolved &#125;&#125;// 创建占位节点createAsyncPlaceholder ( factory: Function, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag: ?string): VNode &#123; const node = createEmptyVNode() node.asyncFactory = factory node.asyncMeta = &#123; data, context, children, tag &#125; return node&#125; 渲染 vnode依据上文，vnode 需要通过 vm.__patch__ 方法完成渲染或重绘出真实 dom。vm.__patch__ 方法的创建过程是基于高阶函数 createPatchFunction，首先将不同平台的 dom 操作作为参数传入 createPatchFunction，然后生成实际针对不同平台的 patch 函数。在 createPatchFunction(backend) 函数中，backend 即不同平台中以钩子形式提供的 dom 操作函数集。 12345678910111213141516171819202122const hooks = ['create', 'activate', 'update', 'remove', 'destroy']// 将平台钩子注入到 createPatchFunction 函数中，以便调用export function createPatchFunction (backend) &#123; const cbs = &#123;&#125; const &#123; modules, nodeOps &#125; = backend// 不同环境的节点、样式、事件等操作 // 从 modules 中读取平台钩子（可能是浏览器钩子），以钩子形式更新节点的属性、事件 // modules 即包含 class, style, attrs, events, domProps, transition for (i = 0; i &lt; hooks.length; ++i) &#123; cbs[hooks[i]] = [] for (j = 0; j &lt; modules.length; ++j) &#123; if (isDef(modules[j][hooks[i]])) &#123; cbs[hooks[i]].push(modules[j][hooks[i]]) &#125; &#125; &#125; return function patch (oldVnode, vnode, hydrating, removeOnly) &#123; // ... &#125;&#125; 因此，下面以浏览器钩子展开说明。 浏览器钩子在浏览器环境中，钩子函数集合包含 class 样式类、style 样式、attrs 节点属性、events 事件、domProps 节点内容等、transition 动效六类操作。 class.js: 提供 create, update 钩子，使用 el.setAttribute(‘class’, cls) 方法设置或更新 vnode.elm 元素的样式类。 style.js: 提供 create, update 钩子，使用 el.style.setProperty(name, val) 或 el.style[name] = val 形式设置或更新 vnode.elm 元素的样式。 attrs.js: 提供 create, update 钩子，使用 el.setAttribute(key, value) 或 el.removeAttribute(key) 方法设置或更新 vnode.elm 元素的 html 属性。 events.js: 提供 create, update 钩子，使用 el.addEventListener, el.removeEventListener 方法设置或更新 vnode.elm 元素的绑定函数。 domProps.js: 提供 create, update 钩子，包含：当 vnode.data.domProps 属性包含 textContent, innerHTML 时，使用 el.removeChild 移除子节点，并将值写入 el 属性中等。 transition.js: 提供 create, activate, remove 钩子，用于实现 css transition，这里不作解读。 钩子的种类以及执行时机为： create: 创建真实 dom 节点时。 activate: transition 过程中动效执行时。 update: 更新真实 dom 节点时。 remove: transition 过程中移除节点时。 destroy: 移除真实 dom 节点时，即组件卸载或 keep-alive 子组件置为非激活状态时。 vnode 钩子除了平台钩子以外，patch 执行过程中还包含 vnode 钩子。通过上文也可以发现，Vue 在执行 createComponent 函数时，会通过调用 installComponentHooks 函数将 vnode 钩子注入到 vnode.data.hook 中。 init 钩子: 如果 vnode 对应未销毁状态的 keep-alive 组件，更新该 keep-alive 组件；如果 vnode 对应组件节点，实例化该组件，使用该组件的内置模板完成渲染，生成 vnode.elm。执行时机为更新组件时。 prepatch 钩子: 更新组件。执行时机为更新组件时。 insert 钩子: 将完成挂载或更新的 vnode 节点插入到父节点中，且调用组件的 mounted 生命周期。执行时机为组件所对应的节点树都渲染到文档中时。 destroy 钩子: 卸载组件，或者将 keep-alive 子组件置为非激活状态。执行时机为 vnode 节点移除时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const componentVNodeHooks = &#123; // 更新 keep-alive 组件，或实例化模板中的子节点组件并完成挂载 init (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123; // keep-alive 组件，复用 vnode，并对其追加补丁 if ( vnode.componentInstance &amp;&amp; !vnode.componentInstance._isDestroyed &amp;&amp; vnode.data.keepAlive ) &#123; const mountedNode: any = vnode componentVNodeHooks.prepatch(mountedNode, mountedNode) // 如模板节点为组件节点，实例化该组件，并予以挂载 &#125; else &#123; const child = vnode.componentInstance = createComponentInstanceForVnode( vnode, activeInstance ) // vm.$mount 方法通过 vm._update 挂载组件 child.$mount(hydrating ? vnode.elm : undefined, hydrating) &#125; &#125;, // 更新组件 prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) &#123; const options = vnode.componentOptions const child = vnode.componentInstance = oldVnode.componentInstance // 更新组件 vm 实例的属性，并酌情重绘 updateChildComponent( child, options.propsData, // updated props options.listeners, // updated listeners vnode, // new parent vnode options.children // new children ) &#125;, // 当组件所对应的 vnode 树都渲染到文档中时，调用 mounted 生命周期 insert (vnode: MountedComponentVNode) &#123; const &#123; context, componentInstance &#125; = vnode // 调用组件的 mounted 生命周期 if (!componentInstance._isMounted) &#123; componentInstance._isMounted = true callHook(componentInstance, 'mounted') &#125; if (vnode.data.keepAlive) &#123; if (context._isMounted) &#123; // 缓存 vm 实例，直到 patch 过程结束才予以激活 queueActivatedComponent(componentInstance) &#125; else &#123; // 直接激活 vm 实例 activateChildComponent(componentInstance, true /* direct */) &#125; &#125; &#125;, // 启动卸载、或将 keep-alive 组件置为未激活状态 destroy (vnode: MountedComponentVNode) &#123; const &#123; componentInstance &#125; = vnode if (!componentInstance._isDestroyed) &#123; if (!vnode.data.keepAlive) &#123; componentInstance.$destroy() &#125; else &#123; deactivateChildComponent(componentInstance, true /* direct */) &#125; &#125; &#125;&#125; 钩子触发器Vue 封装了如下的钩子触发器： 1234567891011121314151617181920212223242526272829303132333435363738// 触发 create 平台钩子以及 vnode 钩子function invokeCreateHooks (vnode, insertedVnodeQueue) &#123; for (let i = 0; i &lt; cbs.create.length; ++i) &#123; cbs.create[i](emptyNode, vnode) &#125; i = vnode.data.hook // Reuse variable if (isDef(i)) &#123; if (isDef(i.create)) i.create(emptyNode, vnode) if (isDef(i.insert)) insertedVnodeQueue.push(vnode) &#125;&#125;// vnode 树中的子节点须等待组件内容都渲染到文档中时，才执行 insert 钩子function invokeInsertHook (vnode, queue, initial) &#123; // 根组件中的子节点须等待跟组件实际渲染到文档中 if (isTrue(initial) &amp;&amp; isDef(vnode.parent)) &#123; vnode.parent.data.pendingInsert = queue &#125; else &#123; for (let i = 0; i &lt; queue.length; ++i) &#123; queue[i].data.hook.insert(queue[i]) &#125; &#125;&#125;// 递归销毁组件、移除 vnode 节点属性function invokeDestroyHook (vnode) &#123; let i, j const data = vnode.data if (isDef(data)) &#123; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.destroy)) i(vnode) for (i = 0; i &lt; cbs.destroy.length; ++i) cbs.destroy[i](vnode) &#125; if (isDef(i = vnode.children)) &#123; for (j = 0; j &lt; vnode.children.length; ++j) &#123; invokeDestroyHook(vnode.children[j]) &#125; &#125;&#125; patchvnode 的 patch 过程就是完成挂载、重绘或卸载。patch 过程中渲染的直接表现是生成 vnode.elm 或 vnode.text。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110function patch (oldVnode, vnode, hydrating, removeOnly) &#123; // 组件卸载 if (isUndef(vnode)) &#123; // 深度优先遍历 oldVnode 树中子节点，执行 cbs.destory 以及 vnode.data.hook.destory 钩子 if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] // 组件挂载 if (isUndef(oldVnode)) &#123; isInitialPatch = true // createElm 函数将 vnode 及 children 解析成节点树 vnode.elm createElm(vnode, insertedVnodeQueue) // 组件更新 &#125; else &#123; const isRealElement = isDef(oldVnode.nodeType)// 原生节点 // 组件节点的数据发生变更，更新组件 if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patchVnode 函数更新组件节点或原生节点 patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; else &#123; if (isRealElement) &#123; // 服务端渲染的是元素节点，采用 hydrate 函数进行渲染，oldVnode 即真实的 dom 元素 if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123; oldVnode.removeAttribute(SSR_ATTR) hydrating = true &#125; if (isTrue(hydrating)) &#123; // hydrate 函数将 oldVnode 作为 vnode 的 elm 属性，并递归处理子节点等 // 当为 component 模板节点或原生节点、文本节点、注释节点时返回真值，否则返回否值 if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123; // invokeInsertHook 函数对于根节点，将 insertedVnodeQueue 存入 vnode.parent.data.pendingInsert 中，等待调用 initComponent 时执行 // 其他，触发 insertedVnodeQueue 数组项中的 data.hook.insert 钩子 invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode// 真实的 dom 节点 &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn( 'The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing ' + 'full client-side render.' ) &#125; &#125; // emptyNodeAt 函数构建一个 VNode 实例，该实例使用 oldVnode 作为 elm 属性 oldVnode = emptyNodeAt(oldVnode) &#125; const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm,// 在执行 leave 动效时不将 vnode 插入到 parentElm 中 nodeOps.nextSibling(oldElm)// 使用兄弟节点锁定插入 parentElm 时的位置 ) // vnode.parent 查找模板节点 if (isDef(vnode.parent)) &#123; let ancestor = vnode.parent // isPatchable 函数向上寻找非 keep-alive 组件，且须判断该组件对应的 vnode.tag 为已定义 // patchable 意味着 keep-alive 组件下复用已缓存的某子组件 const patchable = isPatchable(vnode) while (ancestor) &#123; for (let i = 0; i &lt; cbs.destroy.length; ++i) &#123; cbs.destroy[i](ancestor) &#125; ancestor.elm = vnode.elm // 渲染已缓存的某子组件 if (patchable) &#123; for (let i = 0; i &lt; cbs.create.length; ++i) &#123; cbs.create[i](emptyNode, ancestor) &#125; const insert = ancestor.data.hook.insert if (insert.merged) &#123; for (let i = 1; i &lt; insert.fns.length; i++) &#123;// i 从 1 起始，避免执行组件的 mounted 钩子 insert.fns[i]() &#125; &#125; &#125; else &#123; // registerRef 函数为外层组件实例 ancestor.context 设置 ref 引用 registerRef(ancestor) &#125; ancestor = ancestor.parent &#125; &#125; if (isDef(parentElm)) &#123; // 移除原始节点 removeVnodes(parentElm, [oldVnode], 0, 0) &#125; else if (isDef(oldVnode.tag)) &#123; // 执行 destroy 平台钩子以及 vnode 钩子 invokeDestroyHook(oldVnode) &#125; &#125; &#125; // 只针对 createElm, hybrate 收集到插入情形 invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm&#125; 参考Vue原理解析之Virtual Dompatch","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"vue","slug":"frontend/vue","permalink":"http://xzfyu.com/categories/frontend/vue/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"vue","slug":"vue","permalink":"http://xzfyu.com/tags/vue/"}]},{"title":"Vue 生命周期 - 组件挂载及更新","slug":"frontend/vue/生命周期-组件挂载及更新","date":"2019-05-28T16:00:00.000Z","updated":"2020-03-08T10:53:38.009Z","comments":true,"path":"2019/05/29/frontend/vue/生命周期-组件挂载及更新/","link":"","permalink":"http://xzfyu.com/2019/05/29/frontend/vue/生命周期-组件挂载及更新/","excerpt":"","text":"挂载组件在 生命周期-创建实例 一文中，我们了解到，vm.$mount 方法可用于挂载组件。vm.$mount 有两种使用场景：当开发者显式调用 new Vue(options) 语句构建 vm 实例时，vm.$mount 方法将在实例化过程的尾部得到调用；当从父模板解析并渲染出子组件时，vm.$mount 方法将在 createComponent 函数阶段由 Vue 框架内部调用。 vm.$mount 方法的实现按环境的不同有所差异，比如浏览器环境和 weex 环境。这里只描述浏览器环境中的组件挂载、卸载机制，至于 weex 环境下的组件挂载、卸载机制，笔者将在后续的文章加以展开。 1234567Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; mountComponentmountComponent 函数往前承接 vm.$mount 方法；在其实现中会构建 updateComponent 函数，用以约定 Watcher 实例将以何种方式监听 vm 实例的数据变化。初始化渲染阶段，直接使用 vm.patch 方法将 vnode 挂载到 vm.$el 父元素下，并构建新的 vm.$el；更新阶段，使用 vm.patch 方法追加补丁。vm.patch 方法取决于环境。整体过程如下： vm.$mount 根据客户端环境挂载组件。 mountComponent 构建 updateComponent 函数，初始化渲染和更新节点均通过 vm._update 将 vnode 装载到 vm.$el 文档父元素或模板父元素上。 绑定 vm.$el 和 vm 实例的相关关联。 在这个过程中，Vue 会调用组件的 beforeMount, mounted, beforeCreate 生命周期钩子。 关于 vm.patch 方法的实现原理，笔者将在后续的文章加以介绍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108function lifecycleMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm)// 记录当前实例 vm._vnode = vnode if (!prevVnode) &#123; // 初始化渲染，挂载到父元素 vm.$el 下，父元素相应改变 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // 更新节点，追加补丁 vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance()// 恢复前一个实例，即父实例 if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // HOC 组件通过子组件渲染内容，父组件渲染内容和子组件相等 if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; &#125;&#125;function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el// 父节点元素 // 渲染根节点或模板节点时，如 render 方法未解析到，报错处理 if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') &#123; if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') || vm.$options.el || el) &#123; warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) &#125; else &#123; warn( 'Failed to mount component: template or render function not defined.', vm ) &#125; &#125; &#125; callHook(vm, 'beforeMount') // 构架 updateComponent 函数，用于实际调用 vm._render 渲染函数 let updateComponent if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) // vm._render 在 [生命周期-创建实例](http://xzfyu.com/2019/05/26/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/) 一文中有所描述 // 主要用于解析插槽，调用 vm.$options.render 渲染出 vnode const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) // 通过 vm._update 完成初始化渲染和更新 vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // 第一个参数表示 Watcher 实例关联的 vm 实例 // 第二个参数 updateComponent 表示通过何种方式监听数据变动 // 第三个参数 cb 作为回调，这里是空函数 // 第四个参数 options 在 Watcher 实例执行前调用 options.before 方法 // 第五个参数 isRenderWatcher 将 Watcher 实例赋值给 vm._watcher new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false // 针对手动创建的 Vue 实例，在父模板中占位节点 vm.$vnode 为空 // 对于由父模板创建的实例，mounted 生命周期钩子在 insert 阶段调用，参考 create-component.js if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm&#125; 更新组件vm 数据变更mountComponent 一小节已表明，当 vm 实例数据发生改变时，通过 Watcher 会驱动 updateComponent 方法执行，以追加补丁的方式更新 vm.$el 挂载节点。 除此之外，Vue 像 React 那样提供了 vm.$forceUpdate 方法，该方法仍借助 Watcher 实例实现。 123456Vue.prototype.$forceUpdate = function () &#123; const vm: Component = this if (vm._watcher) &#123; vm._watcher.update() &#125;&#125; 父组件注入数据变更上一小节中的 vm 实例数据变更并不包含父组件注入子组件的数据发生变更。那么，当父组件注入子组件的数据发生变更时，Vue 会怎样处理呢？为此，Vue 提供了 updateChildComponent 函数用于刷新 vm 实例。这一 vm 实例刷新操作包含插槽数据发生变更、props 注入数据变更、或绑定事件发生变更等。至于更新 vm 实例后发生的事情，笔者也将在后续的文章中加以分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function updateChildComponent ( vm: Component, propsData: ?Object, listeners: ?Object, parentVnode: MountedComponentVNode, renderChildren: ?Array&lt;VNode&gt;) &#123; if (process.env.NODE_ENV !== 'production') &#123; isUpdatingChildComponent = true &#125; // 插槽的名称动态改变，采用强制重绘 const newScopedSlots = parentVnode.data.scopedSlots const oldScopedSlots = vm.$scopedSlots const hasDynamicScopedSlot = !!( (newScopedSlots &amp;&amp; !newScopedSlots.$stable) || (oldScopedSlots !== emptyObject &amp;&amp; !oldScopedSlots.$stable) || (newScopedSlots &amp;&amp; vm.$scopedSlots.$key !== newScopedSlots.$key) ) const needsForceUpdate = !!( renderChildren || // has new static slots vm.$options._renderChildren || // has old static slots hasDynamicScopedSlot ) vm.$options._parentVnode = parentVnode vm.$vnode = parentVnode // update vm's placeholder node without re-render if (vm._vnode) &#123; // update child tree's parent vm._vnode.parent = parentVnode &#125; vm.$options._renderChildren = renderChildren vm.$attrs = parentVnode.data.attrs || emptyObject vm.$listeners = listeners || emptyObject // 更新 props if (propsData &amp;&amp; vm.$options.props) &#123; toggleObserving(false) const props = vm._props const propKeys = vm.$options._propKeys || [] for (let i = 0; i &lt; propKeys.length; i++) &#123; const key = propKeys[i] const propOptions: any = vm.$options.props // wtf flow? props[key] = validateProp(key, propOptions, propsData, vm) &#125; toggleObserving(true) vm.$options.propsData = propsData &#125; // 更新绑定事件 listeners = listeners || emptyObject const oldListeners = vm.$options._parentListeners vm.$options._parentListeners = listeners updateComponentListeners(vm, listeners, oldListeners) if (needsForceUpdate) &#123; vm.$slots = resolveSlots(renderChildren, parentVnode.context) vm.$forceUpdate() &#125; if (process.env.NODE_ENV !== 'production') &#123; isUpdatingChildComponent = false &#125;&#125; 卸载组件vm.$destroy 方法主要用于重置状态数据、清除数据、解绑事件，以及将渲染内容从父节点中移除等。至于 vm.$destroy 方法由哪一方发起调用，笔者也将在后续的文章中加以分析。 12345678910111213141516171819202122232425262728293031323334353637Vue.prototype.$destroy = function () &#123; const vm: Component = this if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, 'beforeDestroy') vm._isBeingDestroyed = true const parent = vm.$parent if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm) &#125; if (vm._watcher) &#123; vm._watcher.teardown() &#125; let i = vm._watchers.length while (i--) &#123; vm._watchers[i].teardown() &#125; if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount-- &#125; vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) callHook(vm, 'destroyed') vm.$off() if (vm.$el) &#123; vm.$el.__vue__ = null &#125; if (vm.$vnode) &#123; vm.$vnode.parent = null &#125; &#125;&#125;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"vue","slug":"frontend/vue","permalink":"http://xzfyu.com/categories/frontend/vue/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"vue","slug":"vue","permalink":"http://xzfyu.com/tags/vue/"}]},{"title":"Vue 生命周期 - 创建实例","slug":"frontend/vue/生命周期-创建实例","date":"2019-05-25T16:00:00.000Z","updated":"2020-03-08T10:53:35.162Z","comments":true,"path":"2019/05/26/frontend/vue/生命周期-创建实例/","link":"","permalink":"http://xzfyu.com/2019/05/26/frontend/vue/生命周期-创建实例/","excerpt":"","text":"对应上图前半部分，当执行 new Vue(options) 语句创建 vm 实例（即 Vue 实例）时，在 Vue 框架内到底发生了什么呢？为此，我们简要地把执行过程小结为如下步骤： 解析 options 配置项。 通过 initProxy 函数构建 vm 代理，其将作为模板渲染函数的参数，而不是 vm 实例。 通过 initLifecycle 函数初始化设置生命周期相关实例属性。 通过 initEvents 绑定父组件传入的事件。 通过 initRender 解析插槽，父组件传入的数据，创建 createElement 方法等。 执行 beforeCreate 生命周期方法。 通过 initInjections 解析 inject。 通过 initState 初始化 props, methods, data, computed, watch。 通过 initProvide 解析 provide。 执行 created 生命周期方法。 在 1-10 步骤执行过程中，使用 performance 接口记录耗时。 若 options.el 为真值，通过 vm.$mount 方法挂载组件。 下面，我们将以上步骤拆解了看。 解析选项创建 vm 实例有两种方式：显式调用 new Vue(options) 语句或者解析模板中组件形式的自定义元素。解析选项按这两种方式分为两种可能。我们将这两种方式分为如下两个小节：显式构建组件、解析模板组件。 123456789101112// 解析模板组件if (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options)// 显式构建组件&#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm )&#125; 如 mergeOptions 函数所展示的那样，options 包含 props, methods, inject, computed, data, provider, watch, el, propsData，以及 beforeCreate 等生命周期钩子函数，以及 components 组件, directives 指令, filters 过滤器。props 声明父子组件通信的 key 键；methods 组件中所使用的方法；inject 用于组件跨级通信接值；computed 为计算属性。data 响应式数据；provider 用于组件跨级通信传值，响应式；watch 以键作为观察的数据 key，监听数据变化；el 与 propsData 等同，等价于父组件传入子组件的 prop 值。beforeCreate 等生命周期钩子函数可以使用数组形式或构造函数预先声明的方式声明多个。 显式构建组件 new Vue(options) 语句处理 options 选项的大致逻辑如上图：即把 Vue 或自定义构造函数的 options 静态属性混入实例的显式 options 配置中，以此获得实例最终的 options 属性。有两个过程需要加以说明：Vue 或自定义构造函数的 options 因何而来？实例最终的 options 属性怎样产生？ 对于第一个过程，Vue 会通过 initAssetRegisters 函数生成 Vue.component, Vue.directive, Vue.filter 方法，这些方法可用于注册全局组件、指令和过滤器。而全局组件、指令或过滤器正是通过 Vue.options.components 等属性存储的。这样就可以把这些全局组件、指令和过滤器作为某个特定组件的依赖项。 123456789101112131415161718192021222324252627282930313233const ASSET_TYPES = [ 'component', 'directive', 'filter']// 生成 Vue.component, Vue.directive, Vue.filter 注册方法initAssetRegisters (Vue: GlobalAPI) &#123; ASSET_TYPES.forEach(type =&gt; &#123; Vue[type] = function ( id: string, definition: Function | Object ): Function | Object | void &#123; if (!definition) &#123; return this.options[type + 's'][id] &#125; else &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') &#123; validateComponentName(id) &#125; if (type === 'component' &amp;&amp; isPlainObject(definition)) &#123; definition.name = definition.name || id definition = this.options._base.extend(definition) &#125; if (type === 'directive' &amp;&amp; typeof definition === 'function') &#123; definition = &#123; bind: definition, update: definition &#125; &#125; this.options[type + 's'][id] = definition return definition &#125; &#125; &#125;)&#125; 除此而外，Vue.mixin 方法用于扩展 Vue.options 属性，这样就便于一次性注册全局组件、指令或过滤器。Vue.extend(extendOptions) 方法用于构造子类，该子类犹如工厂，可以批量生产含有特定 options 的组件；extendOptions 可包含 prop 和计算属性等。特别的，当 extendOptions 为对象变量时，Vue 会将子类工厂缓存到该对象变量的 _Ctor 属性中，方便下次直接获取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 扩展 Vue.optionsfunction initMixin (Vue: GlobalAPI) &#123; Vue.mixin = function (mixin: Object) &#123; this.options = mergeOptions(this.options, mixin) return this &#125;&#125;function initExtend (Vue: GlobalAPI) &#123; Vue.cid = 0 let cid = 1 Vue.extend = function (extendOptions: Object): Function &#123; extendOptions = extendOptions || &#123;&#125; const Super = this const SuperId = Super.cid const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;) if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] &#125; const name = extendOptions.name || Super.options.name if (process.env.NODE_ENV !== 'production' &amp;&amp; name) &#123; validateComponentName(name) &#125; const Sub = function VueComponent (options) &#123; this._init(options) &#125; Sub.prototype = Object.create(Super.prototype) Sub.prototype.constructor = Sub Sub.cid = cid++ Sub.options = mergeOptions( Super.options, extendOptions ) Sub['super'] = Super // 初始化 props、计算属性 if (Sub.options.props) &#123; initProps(Sub) &#125; if (Sub.options.computed) &#123; initComputed(Sub) &#125; Sub.extend = Super.extend Sub.mixin = Super.mixin Sub.use = Super.use // 生成 Sub.component, Sub.directive, Sub.filter 注册方法 ASSET_TYPES.forEach(function (type) &#123; Sub[type] = Super[type] &#125;) if (name) &#123; Sub.options.components[name] = Sub &#125; Sub.superOptions = Super.options// 父类 options Sub.extendOptions = extendOptions// 自定义 options Sub.sealedOptions = extend(&#123;&#125;, Sub.options)// 综合 options 备份 cachedCtors[SuperId] = Sub return Sub &#125;&#125;function initProps (Comp) &#123; const props = Comp.options.props for (const key in props) &#123; proxy(Comp.prototype, `_props`, key) &#125;&#125;function initComputed (Comp) &#123; const computed = Comp.options.computed for (const key in computed) &#123; defineComputed(Comp.prototype, key, computed[key]) &#125;&#125; 对于第二个过程，Vue 提供 resolveConstructorOptions 函数，用于向上递归获取构造函数携带的 options 属性，并将其与构造实例时获得的 options 选项混合，最终生成 vm 实例的 options 属性。 12345678910111213141516171819202122232425262728293031323334353637export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) &#123; let options = Ctor.options if (Ctor.super) &#123; // 递归获取父级构造函数的 options，这里考虑了父级构造函数的 options 变更的情况 const superOptions = resolveConstructorOptions(Ctor.super) const cachedSuperOptions = Ctor.superOptions if (superOptions !== cachedSuperOptions) &#123; Ctor.superOptions = superOptions // https://github.com/vuejs/vue/issues/4976 // 避免延迟注入构造函数的 options 引发 bug？？？ const modifiedOptions = resolveModifiedOptions(Ctor) if (modifiedOptions) &#123; extend(Ctor.extendOptions, modifiedOptions) &#125; options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions) if (options.name) &#123; options.components[options.name] = Ctor &#125; &#125; &#125; return options&#125;function resolveModifiedOptions (Ctor: Class&lt;Component&gt;): ?Object &#123; let modified const latest = Ctor.options const sealed = Ctor.sealedOptions for (const key in latest) &#123; if (latest[key] !== sealed[key]) &#123; if (!modified) modified = &#123;&#125; modified[key] = latest[key] &#125; &#125; return modified&#125; 解析模板组件在 Vue 中，父组件模板会被解析成虚拟 dom（即 vNode）。该 vNode 包含当前组件的构造函数、以及通过模板注入的数据和绑定函数等信息。在此基础上，Vue 就可以对子组件进行实例化了。这一过程可以称为 Vue 组建的内部实例化过程。区别于显式实例化，Vue 会把 options._isComponent 置为真值，以此标明这是内部实例化过程。同时，在内部实例化的过程中，Vue 会把从模板中解析到的配置信息传入 vm.$options 终极选项中，如 options._parentVnode 当前组件在父组件中的占位节点、options.parent 父组件实例、options.render 渲染函数、options._parentListeners 子组件绑定的事件信息、options._renderChildren 子组件包含的下级节点。有了这些从父组件模板中透传过来的信息以后，Vue 就可以在实例化过程中消费这些数据，笔者将在下文予以展开。 以下是内部实例化过程中生成最终选项 vm.$options 的源码： 123456789101112131415161718function initInternalComponent (vm: Component, options: InternalComponentOptions) &#123; const opts = vm.$options = Object.create(vm.constructor.options)// 构造函数中携带的选项 const parentVnode = options._parentVnode// 组件在父组件模板的占位节点 opts.parent = options.parent// 父组件实例 opts._parentVnode = parentVnode const vnodeComponentOptions = parentVnode.componentOptions opts.propsData = vnodeComponentOptions.propsData// 父组件传入的 props 数据 opts._parentListeners = vnodeComponentOptions.listeners// 父组件传入的绑定事件 opts._renderChildren = vnodeComponentOptions.children// 父组件传入的 children opts._componentTag = vnodeComponentOptions.tag// 组件的 tag // 渲染函数 if (options.render) &#123; opts.render = options.render opts.staticRenderFns = options.staticRenderFns &#125;&#125; initProxy有了上一小节的 vm.$options.render 方法（从父组件模板中解析到子组件渲染函数），Vue 仍需要将 vm 实例作为执行上下文灌入到 render 方法中，以使 render 方法执行期间可以访问到 vm 实例的属性或方法。为什么要构建 vm 实例的代理呢？当 render 方法访问 vm 实例不存在的属性时，通过 vm 代理就可以予以提示。详情参阅源码。 initLifecycleinitLifecycle 主要用于创建生命周期相关属性。源码见下： 12345678910111213141516171819202122232425function initLifecycle (vm: Component) &#123; const options = vm.$options // 获取非抽象父组件 let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm)// 作为子组件 &#125; vm.$parent = parent// 父组件 vm.$root = parent ? parent.$root : vm// 根组件 vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false// 是否挂载 vm._isDestroyed = false// 是否销毁 vm._isBeingDestroyed = false// 是否开始销毁&#125; initEvents首先 Vue 通过 eventsMixin 自建事件系统 vm.$on, vm.$.once, vm.$off, vm.$emit。事件的绑定函数以对象数组的形式存储在 vm._events 属性中。结合解析模板组件一节由父组件模板配置的 options._parentListeners 信息，Vue 中的 initEvents 方法可用于更新 vm 实例上挂载的事件处理函数。 123456789function initEvents (vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false const listeners = vm.$options._parentListeners if (listeners) &#123; // 更新绑定函数 updateComponentListeners(vm, listeners) &#125;&#125; initRenderinitRender 用于解析插槽 vm.$slots（与 React 中 props.chidren 同等功用，但能传多个），创建 vm._c, vm.$createElement 方法用于为子组件构建 vnode，同时将从父模板中注入的节点属性或事件存储为响应式数据 vm.$attrs, vm.$listeners。有了 vm.$createElement 方法后，原型方法 vm._render 就能实际调用 vm.$options.render.call(vm._renderProxy, vm.$createElement) 方法了，进而实现将模板真正解析为 vnode。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function initRender (vm: Component) &#123; vm._vnode = null // 当前组件的节点树根元素 vm._staticTrees = null // 当前组件的节点树 const options = vm.$options const parentVnode = vm.$vnode = options._parentVnode // 当前组件在父模板中的占位节点 const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext)// 解析插槽 vm.$scopedSlots = emptyObject // 创建 vnode 的内部方法，解析父模板后由 Vue 自动调用 // 参数依次为 vm 实例、tag 节点标签、data 父模板传入数据、children 父模板传入的子节点、 // normalizationType 序列化子节点的方式，alwaysNormalize 是否需要序列化子节点 vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // 创建 vnode 的公共方法，当开发者显式执行 new Vue 语句时调用 vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // 通过父模板绑定的属性值 const parentData = parentVnode &amp;&amp; parentVnode.data if (process.env.NODE_ENV !== 'production') &#123; defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$attrs is readonly.`, vm) &#125;, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$listeners is readonly.`, vm) &#125;, true) &#125; else &#123; defineReactive(vm, '$attrs', parentData &amp;&amp; parentData.attrs || emptyObject, null, true) defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true) &#125;&#125;// 解析插槽，将父模板中灌入子组件的 children 解析为 slots 对象或 slots.default 数组function resolveSlots ( children: ?Array&lt;VNode&gt;, context: ?Component): &#123; [key: string]: Array&lt;VNode&gt; &#125; &#123; if (!children || !children.length) &#123; return &#123;&#125; &#125; const slots = &#123;&#125; for (let i = 0, l = children.length; i &lt; l; i++) &#123; const child = children[i] const data = child.data if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123; delete data.attrs.slot &#125; if ((child.context === context || child.fnContext === context) &amp;&amp; data &amp;&amp; data.slot != null ) &#123; const name = data.slot const slot = (slots[name] || (slots[name] = [])) if (child.tag === 'template') &#123; slot.push.apply(slot, child.children || []) &#125; else &#123; slot.push(child) &#125; &#125; else &#123; (slots.default || (slots.default = [])).push(child) &#125; &#125; for (const name in slots) &#123; if (slots[name].every(isWhitespace)) &#123; delete slots[name] &#125; &#125; return slots&#125;function isWhitespace (node: VNode): boolean &#123; return (node.isComment &amp;&amp; !node.asyncFactory) || node.text === ' '&#125; initInjections、initProvidevm.$options.provide，vm.$options.inject 辅助于组件之间跨级传递数据。provide 约定祖先组件传给子孙组件的数据，inject 约定子孙组件接受祖先组件的哪些数据。initProvide 函数用于将 vm.$options.provide 以实际数据的形式写入 vm._provided；initInjections 函数先解析到当前组件实际需要从祖先组件获得的数据或默认数据，然后将这部分数据以响应式数据形式写入 vm 实例属性中，以在数据变更时可引起重绘。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function initProvide (vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === 'function' ? provide.call(vm) : provide &#125;&#125;function initInjections (vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) if (result) &#123; toggleObserving(false) Object.keys(result).forEach(key =&gt; &#123; /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; defineReactive(vm, key, result[key], () =&gt; &#123; warn( `Avoid mutating an injected value directly since the changes will be ` + `overwritten whenever the provided component re-renders. ` + `injection being mutated: \"$&#123;key&#125;\"`, vm ) &#125;) &#125; else &#123; defineReactive(vm, key, result[key]) &#125; &#125;) toggleObserving(true) &#125;&#125;// 获得从祖先组件传入的数据或者取默认值function resolveInject (inject: any, vm: Component): ?Object &#123; if (inject) &#123; const result = Object.create(null) const keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject) for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] // #6574 in case the inject object is observed... if (key === '__ob__') continue const provideKey = inject[key].from let source = vm while (source) &#123; if (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) &#123; result[key] = source._provided[provideKey] break &#125; source = source.$parent &#125; if (!source) &#123; if ('default' in inject[key]) &#123; const provideDefault = inject[key].default result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn(`Injection \"$&#123;key&#125;\" not found`, vm) &#125; &#125; &#125; return result &#125;&#125; initStateinitState 函数用于依次初始化 vm 实例的 props, methods, data, computed, watch 相关信息。其中，在 key 键不冲突的理想状况下，props, methods, data, computed 中的子属性都可以通过 vm 实例进行访问。关于这部分内容，笔者将在后续的文章中加以分析。 vm.$mount当 vm.$options.el 为真值时，创建 vm 实例的过程中将会显式调用 vm.$mount 挂载组件。对于从模板中解析渲染的 vm 实例，将由 Vue 框架调用 vm.$mount 方法挂载组件。参考 Vue 生命周期 - 组件挂载及更新。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"vue","slug":"frontend/vue","permalink":"http://xzfyu.com/categories/frontend/vue/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"vue","slug":"vue","permalink":"http://xzfyu.com/tags/vue/"}]},{"title":"集合","slug":"backend/java/集合","date":"2019-05-12T16:00:00.000Z","updated":"2020-03-08T11:13:25.942Z","comments":true,"path":"2019/05/13/backend/java/集合/","link":"","permalink":"http://xzfyu.com/2019/05/13/backend/java/集合/","excerpt":"","text":"同大多数数据结构类库相同，Java 集合类库在设计上采用接口（interface）和实现（implementation）分离的模式。在强类型语言中，接口和实现的分离有利于在声明实例时切换实现类。Java 核心技术卷以先进先出队列 Queue 接口为例，既可以用循环数组 CircuralArrayQueue 形式实现，又可以用链表 LinkedListQueue 形式实现。循环数组比链表更高效，但是长度受限。在声明实例时，我们可以按条件使用循环数组 Queue expressLane = new CircuralArrayQueue&lt;&gt;() 或者使用 Queue expressLane = new LinkedListQueue&lt;&gt;()。同时设计者会制作 AbstractQueue 抽象类，以方便类库制作者快速实现自己的队列类，因为扩展 AbstractQueue 抽象类会比实现 Queue 接口轻松得多。 Java 集合类库的实现结构为： Java 集合框架有两个基本接口：集合 Collection 和映射 Map。集合使用 add, remove 添加或移除元素，通过迭代器读取元素；映射使用 put 添加元素，get 读取元素。在 Collection, Map 之外，List 有序集合接口允许以索引形式访问元素；Set 接口不能有重复的元素，对于元素相同的两个 Set 需要保证 hashCode 方法会返回相同的散列码；SortedSet, SortedMap 均提供了用于排序的比较器对象；NavigableSet, NavigableMap 均提供了用于搜索和遍历的方法。 具体的集合类大致如下： ArrayList 可动态增长和缩减的索引序列 LinkedList 可在任何位置高效插人和删除元素的有序序列 HashSet 没有重复元素的无序集合 TreeSet 有序集合 EnumSet 包含枚举类型值的集合 LinkedHashSet 可记住元素插入次序的集合 HashMap 存储键值对的映射表 TreeMap 键值有序排列的映射表 EnumMap 键值属于枚举类型的映射表 LinkedHashMap 可记住键值对添加次序的映射表 WeakHashMap 其值无用武之地后可被垃圾回收的映射表 IdentityHashMap 用 = 而不是用 equals 比较键值的映射表 PriorityQueue 允许高效删除最小元素的集合 ArrayDeque 用循环数组实现的双端队列 基础支撑Iterator迭代器可用于遍历元素。元素被访问的顺序取决于集合的实现类，如 ArrayList 支持从索引 0 位置的有序访问；HashSet 支持无序访问。在 Java 中，查找操作与位置变更紧密关联，只能调用 next 方法逐个访问元素；C++ 中，迭代器根据数组索引建模，通过变更索引就可以访问特定的元素。 hasNext 判断集合中是否还有剩余的元素 next 逐个访问元素 remove 删除上次调用 next 方法访问的元素 forEachRemaining 使用 lambda 表达式逐个处理元素 但凡实现了 Iterable 接口的类都支持使用 for each 语句循环，因此标准集合类库都允许使用 for each 语句循环。在实现了 Iterable 接口的类中，iterator 方法用于迭代器；forEach 方法可以使用 lambda 表达式逐个处理元素；spliterator 方法用于创建一个可分割迭代器，以支持并行遍历。 123456789101112public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; ListIterator首先需要说明的是，Java 以双向链表的形式实现 List。因为双向链表比起数组具有如下优点：在指定位置插入元素时，数组需要移动该位置后的元素，双向链表不需要；删除元素时也相同。因为是双向链表，ListIterator 支持反向遍历元素。 hasNext 判断集合中是否还有剩余的元素 next 逐个访问元素 hasPrevious 判断集合中是否还有打头的元素 previous 反向逐个访问元素 remove 基于遍历的方向删除元素 set(e) 修改当前访问的元素 add(e) 基于当前访问的元素位置插入元素 SpliteratorSpliterator 分割迭代器用于分割遍历数据，可分割的数据包含数组、集合、IO 通道、生成器函数。Spliterator.OfPrimitive, Spliterator.OfInt, Spliterator.OfLong, Spliterator.OfDouble 是半指定或全指定类型的分割迭代器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface Spliterator&lt;T&gt; &#123; // 使用 lambda 表达式逐个处理元素 boolean tryAdvance(Consumer&lt;? super T&gt; action); default void forEachRemaining(Consumer&lt;? super T&gt; action) &#123; do &#123; &#125; while (tryAdvance(action)); &#125; // 估算剩余元素 long estimateSize(); // 将 Spliterator 分割成小的 Spliterator，原始 Spliterator 的大小相应改变，分割的方式取决于实现类 Spliterator&lt;T&gt; trySplit(); // 当迭代器拥有 SIZED 特征时，返回剩余元素个数；否则返回-1 default long getExactSizeIfKnown() &#123; return (characteristics() &amp; SIZED) == 0 ? -1L : estimateSize(); &#125; // 包含哪些特征 int characteristics(); // 是否具有某特征 default boolean hasCharacteristics(int characteristics) &#123; return (characteristics() &amp; characteristics) == characteristics; &#125; // 特征 // 元素是否有序，可以用索引访问元素，如 List public static final int ORDERED = 0x00000010; // 元素是否唯一，如 Set public static final int DISTINCT = 0x00000001; // 元素是否有序排列，如 SortedSet public static final int SORTED = 0x00000004; // 是否有大小，大多数集合都可以计算大小，HashSet 不能？ public static final int SIZED = 0x00000040 // 元素不能为 null public static final int NONNULL = 0x00000100; // 元素是否可修改 public static final int IMMUTABLE = 0x00000400; // 可否并行处理。可并行处理不具备线程安全，其大小在另一个线程中可能被修改，因此也不具备 SIZED 特征 public static final int CONCURRENT = 0x00001000; // 使用 trySplit 分割出来的子迭代器都具有 SIZED, SUBSIZED 特征 public static final int SUBSIZED = 0x00004000; // 返回 Comparator 排序方式；自然排序返回 null；不支持排序报错 default Comparator&lt;? super T&gt; getComparator() &#123; throw new IllegalStateException(); &#125;&#125; SerializableCloneableCollectionCollection 和 Iterator 都是泛型接口，内含操作任意集合的实用方法。为了实现 Collection 接口的方便，java.util 提供了 AbstractCollection 抽象类，以抽象常见的处理逻辑。 AbstractCollection 抽象类实现了 finishToArray, hugeCapacity 方法可用于辅助扩容。 ListList 接口最大的特征是可以借助索引插入、获取和删除元素，即元素是有序的。 ArrayListArrayList 是一种支持长度弹性收缩的有序列表。在实现上，ArrayList 使用 elementData 属性以数组形式存储元素，这样就简便地支持了索引读写；ArrayList 提供 ensureCapacity 方法在插值时动态改变 elementData 属性的大小；ArrayList 可使用 writeObject 方法将数据序列化写入输出流中，readObject 方法从输入流中反序列化读取出数据，以赋值到 elementData 属性中。 ArrayList 不是线程安全的；Vector 是线程安全的（Vector 包含了许多不属于集合框架的传统方法），但需要耗费大量的精力实现同步操作。 以下是 ArrayList 中数组扩容的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; private static final int DEFAULT_CAPACITY = 10; transient Object[] elementData; // 外部扩容 public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? 0 : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; // 内部扩容 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;&#125; LinkedListLinkedList 采用双向链表实现。在 LinkedList 中，每个元素 Node 均包含 prev, next 属性引用相邻元素；若无相邻元素，prev, next 属性均置为自身，使首尾相连。LinkedList 保有 first, last 属性引用双向链表中的首个以及最后一个元素。 LinkedList 支持索引访问，然而双向链表实际会基于遍历找到指定位置的元素，并不高效。LinkedList 同样支持读取输入流、写入输出流。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; transient Node&lt;E&gt; first; transient Node&lt;E&gt; last; // 头部插入 private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; &#125; // 尾部插入 void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125;&#125; MapMap 映射是符号表的一种，用于存储和操纵键值对。 关于 Map 接口的实现类如 HashMap, WeakHashMap, TreeMap，以及相关的 Hashtable 类，可参考 透过散列表看HashMap、HashMap中的红黑树。 IdentityHashMap 完全通过数组存储键值对，而不是数组链表。首先通过基于哈希函数计算数组的索引（该哈希函数通过 System.identityHashCode 计算内存地址的散列码，因此允许 key 键重复），然后将键值对先后存入数组的相邻索引位中。当哈希函数算得的索引相同时，IdentityHashMap 首先会比较 key 键，如果 key 键的内存地址相同，就替换为新值；如果不同，在其后插入键值对。因此，在查找键值对时，极限情况下 IdentityHashMap 会遍历整个数组。 LinkedHashMap 会额外使用双向链表保存每个插入的节点，且新修改的节点始终在链表的尾部。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123; transient LinkedHashMap.Entry&lt;K,V&gt; head;// 链表中的首节点 transient LinkedHashMap.Entry&lt;K,V&gt; tail;// 链表中的尾节点 // 在 hashMap.removeNode 方法中执行，用于移除双向链表中的节点 void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b; &#125; void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; // 订制的 removeEldestEntry 可在链表超过指定长度，移除顶部的节点 if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125; &#125; // 在 hashMap.putVal 等方法中执行，将新插入或新修改的节点插入到双向链表的尾部 void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125; &#125;&#125; Set HashSet 使用 HashMap 存储元素，且以元素作为 key 键，因此其所存储的元素是无序的、不重复的。 12345678910111213public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125;&#125; TreeSet 使用 TreeMap 存储元素，同样以元素作为 key 键，因此其所存储的元素是有序的、不重复的。借助于 TreeMap，TreeSet 可对元素进行分组提取。 关于 EnumSet，可参考 枚举。 Queue PriorityQueue 优先级队列，表现上以数组形式存储元素，实际数组项按索引构成一棵二叉树（即将索引展开为二叉树）。在这棵二叉树中，从根节点起，元素从小到大分层排列。PriorityQueue 同样实现了扩容方法。特别的，在添加元素的过程中，PriorityQueue 提供 siftUp 方法保证二叉树中父子节点的优先级按从小到大排列。在移除元素的过程中，PriorityQueue 提供 siftDown 方法取队尾元素填补被删除元素留下的空位，并酌情重新调整二叉树中父子节点的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable &#123; transient Object[] queue; private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125; @SuppressWarnings(\"unchecked\") private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; // 中值作为二叉树的父节点，若插入元素小于父节点，顺势插入 // 若插入元素大于父节点，将父节点下移，并向上比较 int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key; &#125; @SuppressWarnings(\"unchecked\") private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = x; &#125; // x 为队尾元素 private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); &#125; @SuppressWarnings(\"unchecked\") private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; // 若左子节点的优先级大于右子节点，取右子节点，即在左右子节点中最小优先级的节点 if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &lt;= 0) break; // 如果父节点的优先级大于最小优先级的子节点，交换位置 queue[k] = c; k = child; &#125; queue[k] = key; &#125; @SuppressWarnings(\"unchecked\") private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x; &#125;&#125; 数据转换参考Lambda表达式图解LinkedHashMap原理java队列——queue详细分析PriorityQueue 源码分析","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"java","slug":"backend/java","permalink":"http://xzfyu.com/categories/backend/java/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"}]},{"title":"枚举","slug":"backend/java/枚举","date":"2019-05-11T16:00:00.000Z","updated":"2020-03-08T11:19:06.549Z","comments":true,"path":"2019/05/12/backend/java/枚举/","link":"","permalink":"http://xzfyu.com/2019/05/12/backend/java/枚举/","excerpt":"","text":"Enum实现原理枚举使用 enum 关键字声明。枚举不能使用 abstract, final 修饰。除非枚举至少包含一个以类构造的枚举常量，否则枚举都是隐式 final 的。嵌套的枚举类型是隐式 static 的，这就使得枚举类型不能在类中使用 static 声明。典型的枚举声明如下（即包含类修饰符，enum 关键字，枚举标识符，由枚举常量或类语句构成的枚举体）： 123public enum EnumTest &#123; MON, TUE, WED, THU, FRI, SAT, SUN;&#125; 在编译阶段，这个声明会被转换成类。它会有七个实例，且不能构造新的实例（即不能通过 clone 方法创建枚举实例；不能通过反射实例化；不能通过反序列化构建实例）。EnumTest 经反编译的结果为（可以看出，EnumTest.MON 静态属性会指向 EnumTest 实例）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 所有枚举类型都是 Enum 的子类public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; // 枚举常量名 private final String name; public final String name() &#123; return name; &#125; // 枚举常量的序号 private final int ordinal; public final int ordinal() &#123; return ordinal; &#125; protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal; &#125; // 返回用户友好的枚举常量名 public String toString() &#123; return name; &#125; public final boolean equals(Object other) &#123; return this==other; &#125; public final int hashCode() &#123; return super.hashCode(); &#125; protected final Object clone() throws CloneNotSupportedException &#123; throw new CloneNotSupportedException(); &#125; public final int compareTo(E o) &#123; Enum&lt;?&gt; other = (Enum&lt;?&gt;)o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; &#125; public final Class&lt;E&gt; getDeclaringClass() &#123; Class&lt;?&gt; clazz = getClass(); Class&lt;?&gt; zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? (Class&lt;E&gt;)clazz : (Class&lt;E&gt;)zuper; &#125; // 获取指定的枚举常量 public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123; T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(\"Name is null\"); throw new IllegalArgumentException( \"No enum constant \" + enumType.getCanonicalName() + \".\" + name); &#125; protected final void finalize() &#123; &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; throw new InvalidObjectException(\"can't deserialize enum\"); &#125; private void readObjectNoData() throws ObjectStreamException &#123; throw new InvalidObjectException(\"can't deserialize enum\"); &#125;&#125;public class com.hmw.test.EnumTest extends java.lang.Enum&#123; public static final com.hmw.test.EnumTest MON; public static final com.hmw.test.EnumTest TUE; public static final com.hmw.test.EnumTest WED; public static final com.hmw.test.EnumTest THU; public static final com.hmw.test.EnumTest FRI; public static final com.hmw.test.EnumTest SAT; public static final com.hmw.test.EnumTest SUN; static &#123;&#125;; public int getValue(); public boolean isRest(); public static com.hmw.test.EnumTest[] values(); public static com.hmw.test.EnumTest valueOf(java.lang.String); com.hmw.test.EnumTest(java.lang.String, int, int, com.hmw.test.EnumTest);&#125; 枚举常量可以基于类构造，即允许在枚举体内添加构造器、方法和域。这些构造器不能使用 public, protected 修饰，也不允许有父类。其实，在没有构造器的枚举声明中，枚举将使用默认的构造器；编译器可能通过在默认构造函数中声明 String 和 Int 参数来镜像枚举类型。基于构造器的枚举典型如下： 12345678910111213public enum Size &#123; SMALL, MEDUIM, LARGE, EXTRA_LARGE &#125;;public enum Size &#123; SMALL(\"S\"), MEDUIM(\"M\"), LARGE(\"L\"), EXTRA_LARGE(\"XL\"); private String abbreviation; private Size(String abbreviation)&#123; this.abbreviation = abbreviation; &#125;; public String getAbbreviation()&#123; return abbreviation; &#125;;&#125;; 枚举成员包含：在枚举体中声明的成员；继承自 Enum 的成员；values 方法获取所有枚举常量；valueOf(name) 获取指定的枚举常量；以枚举常量名构成的静态属性（即 EnumTest.MON 等）。 使用场景作为常量基于枚举，我们无需使用 public static fianl 语句定义常量，倒可以使用枚举分组定义常量。 switch枚举可以打破 switch 语句只能针对 int, char, enum 类型的藩篱。 12345678910111213141516171819202122232425262728293031323334enum Coin &#123; PENNY(1), NICKEL(5), DIME(10), QUARTER(25); Coin(int value) &#123; this.value = value; &#125;; private final int value; public int value() &#123; return value; &#125;&#125;class Test &#123; enum CoinColor &#123; COPPER, NICKEL, SILVER &#125; static CoinColor color(Coin c) &#123; switch (c) &#123; case PENNY: return CoinColor.COPPER; case NICKEL: return CoinColor.NICKEL; case DIME: case QUARTER: return CoinColor.SILVER; default: throw new AssertionError(\"Unknown coin: \" + c); &#125; &#125; public static void main(String[] args) &#123; for (Coin c : Coin.values()) System.out.println(c + \"\\t\\t\" + c.value() + \"\\t\" + color(c)); &#125;&#125; 枚举方法因为枚举已经继承了 Enum，而 Java 又不支持多重继承，所以只能通过接口约定枚举包含的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142public interface Behaviour &#123; void print(); String getInfo(); &#125;public enum Color implements Behaviour &#123; RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); private String name; private int index; private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; public static String getName(int index) &#123; for (Color c : Color.values()) &#123; if (c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125; @Override public String getInfo() &#123; return this.name; &#125; @Override public void print() &#123; System.out.println(this.index+\":\"+this.name); &#125; &#125; 类语法常量12345678910111213141516171819202122232425enum Operation &#123; PLUS &#123; double eval(double x, double y) &#123; return x + y; &#125; &#125;, MINUS &#123; double eval(double x, double y) &#123; return x - y; &#125; &#125;, TIMES &#123; double eval(double x, double y) &#123; return x * y; &#125; &#125;, DIVIDED_BY &#123; double eval(double x, double y) &#123; return x / y; &#125; &#125;; // Each constant supports an arithmetic operation abstract double eval(double x, double y); public static void main(String args[]) &#123; double x = Double.parseDouble(args[0]); double y = Double.parseDouble(args[1]); for (Operation op : Operation.values()) System.out.println(x + \" \" + op + \" \" + y + \" = \" + op.eval(x, y)); &#125;&#125; 多重枚举12345678910111213141516171819202122232425262728293031323334353637383940414243class Card implements Comparable&lt;Card&gt;, java.io.Serializable &#123; public enum Rank &#123; DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,JACK, QUEEN, KING, ACE &#125; public enum Suit &#123; CLUBS, DIAMONDS, HEARTS, SPADES &#125; private final Rank rank; private final Suit suit; public Rank rank() &#123; return rank; &#125; public Suit suit() &#123; return suit; &#125; private Card(Rank rank, Suit suit) &#123; if (rank == null || suit == null) throw new NullPointerException(rank + \", \" + suit); this.rank = rank; this.suit = suit; &#125; public String toString() &#123; return rank + \" of \" + suit; &#125; // Primary sort on suit, secondary sort on rank public int compareTo(Card c) &#123; int suitCompare = suit.compareTo(c.suit); return (suitCompare != 0 ? suitCompare : rank.compareTo(c.rank)); &#125; private static final List&lt;Card&gt; prototypeDeck = new ArrayList&lt;Card&gt;(52); static &#123; for (Suit suit : Suit.values()) for (Rank rank : Rank.values()) prototypeDeck.add(new Card(rank, suit)); &#125; // Returns a new deck public static List&lt;Card&gt; newDeck() &#123; return new ArrayList&lt;Card&gt;(prototypeDeck); &#125;&#125; EnumSetEnumSet 作为了抽象类，它继承了 AbstractSet 抽象类，并保证了枚举实例的有序性。EnumSet 的子类均通过 elementType 属性存储枚举类；universe 属性存储着指定枚举类下的所有枚举实例。在 EnumSet 子类中，elements 属性标记了 EnumSet 实例可以访问哪些枚举实例。EnumSet 有两个私有实现类 RegularEnumSet, JumboEnumSet，两者均只能通过 EnumSet 提供的方法创建，如 EnumSet.noneOf 方法等。在 RegularEnumSet 中，elements 属性以二进制形式标记着哪些枚举实例是可以访问的；在 JumboEnumSet 中，elements 属性以二进制数组的形式标记着哪些枚举实例是可以访问的。关于 elements 属性，详见下文。 EnumSet 抽象了如下方法： noneOf(Class elementType)：通过指定的枚举类创建空的枚举集合。 allOf(Class elementType)：创建一个包含所有枚举实例的集合。 copyOf(EnumSet s)：拷贝枚举集合。 copyOf(Collection c)：拷贝集合，包含枚举集合。 complementOf(EnumSet s)：基于相同的枚举类创建集合，该集合内包含 s 所未曾有的枚举实例（补集）。 of(E e), of(E e1, E e2), of(E e1, E e2, E e3), of(E e1, E e2, E e3, E e4), of(E e1, E e2, E e3, E e4, E e5), of(E first, E… rest)：创建包含指定枚举实例的集合（该方法作用于 elements 标记，以指定 EnumSet 实例可以访问哪些枚举实例，下同）。 range(E from, E to)：从指定区间中抽出枚举实例创建集合。 clone()：拷贝集合。 addAll()：将指定枚举类下的枚举实例加入集合中。 addRange(E from, E to)：将指定区间的枚举实例加入集合中。 complement()：以指定枚举类下的枚举实例求差集。 getUniverse(Class elementType)：获取指定枚举类下的枚举实例，数组形式。 1234567891011121314151617181920212223242526272829public abstract class EnumSet&lt;E extends Enum&lt;E&gt;&gt; extends AbstractSet&lt;E&gt; implements Cloneable, java.io.Serializable &#123; final Class&lt;E&gt; elementType;// 枚举类 final Enum&lt;?&gt;[] universe;// 全量枚举实例 EnumSet(Class&lt;E&gt;elementType, Enum&lt;?&gt;[] universe) &#123; this.elementType = elementType; this.universe = universe; &#125; // 容量大于 64 时，创建 JumboEnumSet 实例；否则创建 RegularEnumSet 实例 public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123; Enum&lt;?&gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + \" not an enum\"); if (universe.length &lt;= 64) return new RegularEnumSet&lt;&gt;(elementType, universe); else return new JumboEnumSet&lt;&gt;(elementType, universe); &#125; // 获取所有枚举实例 // 通过 SharedSecrets.getJavaLangAccess().getEnumConstantsShared 找出 JVM 栈帧中的所有类实例 private static &lt;E extends Enum&lt;E&gt;&gt; E[] getUniverse(Class&lt;E&gt; elementType) &#123; return SharedSecrets.getJavaLangAccess() .getEnumConstantsShared(elementType); &#125;&#125; RegularEnumSetRegularEnumSet 实例的 elements 属性以长整型 —— 二进制形式存储 RegularEnumSet 实例可以访问哪些元素，如 …0100 表示 RegularEnumSet 实例可以访问第三个枚举元素。elements 属性的更新通过位运算实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class RegularEnumSet&lt;E extends Enum&lt;E&gt;&gt; extends EnumSet&lt;E&gt; &#123; // 位向量 private long elements = 0L; // 获取枚举实例的个数 public int size() &#123; return Long.bitCount(elements); &#125; // 辅助添加枚举实例 public boolean add(E e) &#123; typeCheck(e); long oldElements = elements; elements |= (1L &lt;&lt; ((Enum&lt;?&gt;)e).ordinal()); return elements != oldElements; &#125; public Iterator&lt;E&gt; iterator() &#123; return new EnumSetIterator&lt;&gt;(); &#125; private class EnumSetIterator&lt;E extends Enum&lt;E&gt;&gt; implements Iterator&lt;E&gt; &#123; long unseen; long lastReturned = 0; EnumSetIterator() &#123; unseen = elements; &#125; public boolean hasNext() &#123; return unseen != 0; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; if (unseen == 0) throw new NoSuchElementException(); lastReturned = unseen &amp; -unseen;// 计算 unseen 的二进制最低位 unseen -= lastReturned;// 计算 lastReturned 从最低位开始，第一位为 1 的下标值 return (E) universe[Long.numberOfTrailingZeros(lastReturned)]; &#125; public void remove() &#123; if (lastReturned == 0) throw new IllegalStateException(); elements &amp;= ~lastReturned; lastReturned = 0; &#125; &#125;&#125; JumboEnumSet与 RegularEnumSet 不同的是，JumboEnumSet 实例的 elements 属性是数组结构，每个数组项又跟 RegularEnumSet 实例的 elements 属性相同，以二进制 —— 长整型形式标识着哪些枚举实例是可以访问的。 1234567891011121314151617181920212223class JumboEnumSet&lt;E extends Enum&lt;E&gt;&gt; extends EnumSet&lt;E&gt; &#123; private long elements[]; JumboEnumSet(Class&lt;E&gt;elementType, Enum&lt;?&gt;[] universe) &#123; super(elementType, universe); elements = new long[(universe.length + 63) &gt;&gt;&gt; 6]; &#125; public boolean add(E e) &#123; typeCheck(e); int eOrdinal = e.ordinal(); int eWordNum = eOrdinal &gt;&gt;&gt; 6; long oldElements = elements[eWordNum]; // 每个数组项的特征与 RegularEnumSet 实例的 elements 属性相同 elements[eWordNum] |= (1L &lt;&lt; eOrdinal); boolean result = (elements[eWordNum] != oldElements); if (result) size++; return result; &#125;&#125; EnumMapEnumMap 使用枚举实例作为键，值自定义。与 EnumSet 相类，EnumMap 同样使用 JavaLangAccess, SharedSecrets 获取枚举类下的所有枚举实例，并存入 keyUniverse 数组中。大致实现原理见下： 123456789101112131415161718192021222324252627282930313233343536373839public class EnumMap&lt;K extends Enum&lt;K&gt;, V&gt; extends AbstractMap&lt;K, V&gt; implements java.io.Serializable, Cloneable&#123; private final Class&lt;K&gt; keyType;// 枚举类 private transient K[] keyUniverse;// 全量枚举实例，枚举实例作为键 private transient Object[] vals;// 全量值 private Object maskNull(Object value) &#123; return (value == null ? NULL : value); &#125; @SuppressWarnings(\"unchecked\") private V unmaskNull(Object value) &#123; return (V)(value == NULL ? null : value); &#125; public EnumMap(Class&lt;K&gt; keyType) &#123; this.keyType = keyType; keyUniverse = getKeyUniverse(keyType); vals = new Object[keyUniverse.length]; &#125; public V put(K key, V value) &#123; typeCheck(key); int index = key.ordinal(); Object oldValue = vals[index]; vals[index] = maskNull(value); if (oldValue == null) size++; return unmaskNull(oldValue); &#125; // 获取全量枚举实例 private static &lt;K extends Enum&lt;K&gt;&gt; K[] getKeyUniverse(Class&lt;K&gt; keyType) &#123; return SharedSecrets.getJavaLangAccess() .getEnumConstantsShared(keyType); &#125;&#125; 参考Java SE 规范Java 枚举(enum) 详解7种常见的用法java enum(枚举)使用详解 + 总结使用JavaLangAccess和SharedSecrets来获取JVM中的实例Java1.8-RegularEnumSet和JumboEnumSet源码解析Java位运算学习","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"java","slug":"backend/java","permalink":"http://xzfyu.com/categories/backend/java/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"}]},{"title":"符号表与二叉查找树","slug":"计算机科学/算法/符号表与二叉查找树","date":"2019-04-20T16:00:00.000Z","updated":"2020-03-08T11:05:45.742Z","comments":true,"path":"2019/04/21/计算机科学/算法/符号表与二叉查找树/","link":"","permalink":"http://xzfyu.com/2019/04/21/计算机科学/算法/符号表与二叉查找树/","excerpt":"","text":"符号表符号表用于存储键值对。通常符号表按功能提供了如下 API（由 API 可逐步深入到设计决策、测试用例、实现等）： get: 获取指定 key 键的值。 put: 将键值对存入符号表中。 delete: 删除指定的键值对。 contains: 判断符号表中是否包含指定的键。 isEmpty: 判断符号表是否为空。 size: 获取符号表中键值对的数量。 keys: 获取符号表中所有 key 键的集合。 符号表分为无序符号表和有序符号表两种。 无序符号表以下是基于单向链表实现的无序符号表： 1234567891011121314151617181920212223242526272829303132333435public class SequentialSearchST&lt;Key, Value&gt;&#123; private Node&lt;Key, Value&gt; first; private int N;// 键值对数量 // 链表节点模型 private static class Node&lt;Key, Value&gt; &#123; public Key key; public Value val; public Node&lt;Key, Value&gt; next; public Node(Key key, Value val, Node&lt;Key, Value&gt; next) &#123; this.key = k; this.val = val; this.next = next; &#125; &#125; public Value get(Key key) &#123; for (Node&lt;Key, Value&gt; x = first ; x != null; x = x.next) &#123; if (x.key.equals(key)) return x.val; &#125; return null; &#125; public void put(Key key, Value val) &#123; for (Node&lt;Key, Value&gt; x = first; x != null; x = x.next) &#123; if (x.key.equals(key)) &#123; x.val = val; return; &#125; &#125; first = new Node&lt;Key, Value&gt;(key, val, first); N++; &#125;&#125; 有序符号表有序符号表需要额外实现如下接口： min, max: 获取最小键、最大键。 floor, ceiling: 向下取整、向上取整。 select: 获取指定排名的键。该操作可应用于搜索引擎的排名等。 rank: 获取小于指定 key 键的节点数量。该操作可应用于搜索引擎的排名等。 deleteMin: 删除最小键。 deleteMax: 删除最大键。 基于有序数组实现的有序符号表，可借助两分查找法快速插入和获取键值对，其核心方法为 rank。相比于链表，基于有序数组实现的符号表能保证查找的高效，但是在插入节点需要对后续节点执行额外的移位动作。以下为其实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;, Value&gt;&#123; private Key[] keys; private Value[] vals; private int N;// 键值对数量 public BinarySearchST(int capacity)&#123; keys = (Key[]) new Comparable[capacity]; vals = (Value[]) new Object[capacity]; &#125; // 基于两分查找法，获取小于指定 key 键的节点数量 public int rank(Key key)&#123; int lo = 0, hi = N - 1; while(lo &lt;= hi)&#123; int mid = lo + (hi - lo) / 2; int cmp = key.compareTo(keys[mid]); if (cmp &lt; 0) hi = mid - 1; else if (cmp &gt; 0) lo = mid + 1; else return mid; &#125; return lo; &#125; public Value get(Key key)&#123; if (isEmpty()) return null; int i = rank(key); if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) return vals[i]; else return null; &#125; public void put(Key key, Value val)&#123; int i = rank(key); if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0)&#123;// 有则替换 vals[i] = val; return; &#125; // 后续键值对移位 for (int j = N; j &gt; i; j--)&#123; keys[j] = keys[j - 1]; vals[j] = vals[j - 1]; &#125; keys[i] = key; vals[i] = val; N++; &#125;&#125; 二叉查找树二叉查找树 Binary Search Tree(BST) 是有序符号表的一种。在二叉树中，每个父节点下的左右子节点按 key 键有序排列，这样在查找和插入节点时就能保证如快速排序的高效。二叉树的设计原则包含：私有方法提供抽象，公共方法提供接口；二叉树基于节点建模，节点保有子节点和子树的信息，私有方法须实现可递归性。二叉查找树的 API 如有序符号表，包含基本的查找、插入、删除操作： size: 获取节点数量。 get: 向下递归查找节点。 put: 插入节点。基于向下递归插入节点，向上递归更新节点数量。 min, max: 获取最小键、最大键。 floor, ceiling: 向下取整、向上取整。 select: 获取指定排名的键。 rank: 获取小于指定 key 键的节点数量。 delete: 删除节点。当被删除节点为父节点时，使用前驱或后继节点与该节点换位的方式删除。 deleteMin: 删除最小键，该方法可用于后继节点替换模式的删除操作。 deleteMax: 删除最大键，该方法可用于前驱节点替换模式的删除操作。 keys: 借助于中序遍历，获取二叉树中或指定范围内所有键的集合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt;&#123; private Node root; private class Node &#123; private Key key; private Value val; private Node left, right; private int N;// 子树中的节点总数 public Node(Key key, Value val, int N)&#123; this.key = key; this.val = val; this.N = N; &#125; &#125; public int size()&#123; return size(root); &#125; private int size(Node x)&#123; if (x == null) return 0; else return x.N; &#125; public Value get(Key key)&#123; return get(root, key); &#125; private Value get(Node x, Key key)&#123; if (x == null) return null; int cmp = key.compateTo(x.key); if (cmp &lt; 0) return get(x.left, key); else if (cmp &gt; 0) return get(x.right, key); else return x.val; &#125; public void put(Key key, Value val)&#123; root = put(root, key, val); &#125; private Node put(Node x, Key key, Value val)&#123; if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = put(x.left, key, val); else if (cmp &gt; 0) x.right = put(x.right, key, val); else x.val = val; x.N = size(x.left) + size(x.right) + 1; return x; &#125; // 获取最小键；max 方法与之相类 public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if (x.left == null) return x; return min(x.left); &#125; // 向下取整；ceiling 向上取整与之相类 public Key floor(Key key)&#123; Node x = floor(root, key); if (x == null) return null; return x.key; &#125; private Node floor(Node x, Key key)&#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp &lt; 0) return floor(x.left, key);// 保证输出左子树中的节点 Node t = floor(x.right, key);// 向上递归获取左子树中的节点 if (t != null) return t; else return x;// 返回左子树中的节点，以便向上递归 &#125; // 获取排名为 k 的键 public Key select(int k)&#123; return select(root, k).key; &#125; private Node select(Node x, int k)&#123; if (x == null) return null; int t = size(x.left); if (t &gt; k) return select(x.left, k); else if (t &lt; k) return select(x.right, k-t-1); else return x; &#125; // 获取小于 key 键的数量，入参 key 键在二叉树中已存在 public int rank(Key key)&#123; return rank(key, root); &#125; private int rank(Key key, Node x)&#123; if (x == null) return 0; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return rank(key, x.left);// 右子树中会包含大于 key 的键 else if (cmp &gt; 0) return 1 + size(x.left) + rank(key, x.right); else return size(x.left);// 父节点与 key 键相同，统计左子树的节点数量 &#125; public void deleteMin()&#123; root = deleteMin(root); &#125; private Node deleteMin(Node x)&#123; if (x.left == null) return x.right; x.left = deleteMin(x.left); x.N = size(x.left) + size(x.right) + 1; return x; &#125; public void delete(Key key)&#123; root = delete(root, key); &#125; private Node delete(Node x, Key key)&#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = delete(x.left, key); else if (cmp &gt; 0) x.right = delete(x.right, key); else &#123; if (x.right == null) return x.left; if (x.left == null) return x.right; Node t = x; x = min(t.right);// 以后继节点代替待删除节点位置 x.right = deleteMin(t.right);// 移除后继节点 x.left = t.left; &#125; x.N = size(x.left) + size(x.right) + 1; return x; &#125; // 获取二叉树中所有键的集合 public Iterable&lt;Key&gt; keys()&#123; return keys(min(), max()); &#125; // 获取指定范围内所有键的集合 public Iterable&lt;Key&gt; keys(Key lo, Key hi)&#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root, queue, lo, hi); return queue; &#125; private void keys(Node x, Queue&lt;key&gt; queue, Key lo, Key hi)&#123; if (x == null) return; int comlo = lo.compareTo(x.key); int comhi = hi.compareTo(x.key); if (comlo &lt; 0) keys(x.left, queue, lo, hi);// 收集左子树中的 key if (comlo &lt;= 0 &amp;&amp; comhi &gt;= 0) queue.enqueue(x.key);// 在指定范围内，收集 key 键 if (comhi &gt; 0) keys(x.right, queue, lo, hi);// 收集右子树中的 key &#125;&#125;","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"算法","slug":"计算机科学/算法","permalink":"http://xzfyu.com/categories/计算机科学/算法/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://xzfyu.com/tags/算法/"}]},{"title":"透过散列表看HashMap","slug":"计算机科学/算法/透过散列表看HashMap","date":"2019-04-19T16:00:00.000Z","updated":"2020-03-08T11:05:38.834Z","comments":true,"path":"2019/04/20/计算机科学/算法/透过散列表看HashMap/","link":"","permalink":"http://xzfyu.com/2019/04/20/计算机科学/算法/透过散列表看HashMap/","excerpt":"","text":"散列表用于存储键值对。先举两个例子：如果使用有序数组存储键值对，那么当存在某个较大的键时，整个数组所占用的内存空间就会很大；如果使用无序数组存储键值对，那么在查找元素时就需要遍历数组项，造成了性能的低效。与这两个例子不同的是，散列表有效地平衡了时间和空间复杂度。创建散列表的流程分为： 通过散列函数将键转化为散列码，以作为数组的索引。 通过碰撞处理解决两个或多个散列码等值的情况。 散列函数制作散列函数时需要面对的问题是：对于任意数据类型的键，都需要将其转化为可接受的数组索引；计算过程应尽可能的简便，计算结果应尽可能地均匀分布。可针对如下情形实现不同的散列策略： 正整数 k：可采用除留余数法，即当数组长度为 M 时，散列码就是 k%M。当 M 是素数时，得到的散列码会均匀分布。 浮点数 k：可采用 k*M 再四舍五入的方式计算码；也可采用将 k 表示为二进制数，然后再使用除留余数法。后一种方式更均匀，因为在使用前一种方式时，浮点数高位起到的作用会更大。 字符串 k：可采用 horner 算法获取散列码，即 其中，s.charAt(i) 将以非负 16 位整数形式获取 char 值。当 R 为较小的素数如 31 时，就可以保证结果的均匀分布。 组合键 k：如果键包含多个整型变量时，可以使用如字符串的形式将其拆解。以 Date 为例，可拆解为 day, month, year 三个整型，这时就可以通过 (((day R + month) % M) R + year) % M 计算散列码。 在 Java 中，每种数据类型都有对应的散列函数。同时每种数据类型的 hashCode 方法须与 equals 方法表现一致，即当 a.equals(b) 返回 true 时，那么 a.hashCode() 结果须与 b.hashCode() 相同；反之则不然，即当 a.hashCode() 与 b.hashCode() 返回值相同时，a.equals(b) 未必返回 true。默认的散列函数会返回对象的内存地址，但只适用于极少数情况。字节型 Byte, 短整型 Short, 整型 Integer, 长整型 Long 的 hashCode 方法都以 32 位 4 字节整数作为散列码；字符型 Character 以 8 位整数为散列码；布尔型 Boolean 以 1231, 1237 作为散列码，true 时为 1231。其他类型的 hashCode 方法或可参见下方代码（特别的，对于自定义的 Java 类，可采用与 String 相类的手法计算散列码，即通过各属性的散列码计算对象的散列码）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 单精度浮点型；双精度浮点型 Double 与此相类public final class Float extends Number implements Comparable&lt;Float&gt; &#123; // native 关键字的函数由操作系统实现（使用如 c 语言），java 只能调用 // 单精度浮点型第 31 位为符号，30-23 位为指数，22-0 为有效数 public static native int floatToRawIntBits(float value); public static int floatToIntBits(float value) &#123; int result = floatToRawIntBits(value); // Check for NaN based on values of bit fields, maximum // exponent and nonzero significand. // EXP_BIT_MASK = 2139095040; SIGNIF_BIT_MASK = 8388607; if ( ((result &amp; FloatConsts.EXP_BIT_MASK) == FloatConsts.EXP_BIT_MASK) &amp;&amp; (result &amp; FloatConsts.SIGNIF_BIT_MASK) != 0) result = 0x7fc00000; return result; &#125; public static int hashCode(float value) &#123; return floatToIntBits(value); &#125; @Override public int hashCode() &#123; return Float.hashCode(value); &#125;&#125;// 字符串public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; // 使用 hash 作为软缓存，避免重复计算，第二次执行 hashCode 都将返回计算好的 hash private int hash; // Default to 0 public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125;&#125; HashMap 中的散列码通过静态方法 hash 计算，即取 key 键的散列码，并与右移 16 位的散列码进行异或。执行 (n - 1) &amp; hash 计算，可以将散列码转化为数组索引。与此不同的是，Hashtable 的散列码通过执行 key.hashCode 直接获取，再执行 (hash &amp; 0x7FFFFFFF) % M 计算出数组索引。散列码计算方式改易的原因不详。 12345678910// HashMap 中的散列码static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;// 常规散列码，也是 Hashtable 中的散列码private int hash(Object key)&#123; return (key.hashCode() &amp; 0x7FFFFFFF) % M;&#125; 碰撞冲突当键的散列码等值时，有两种方式可用于处理这类碰撞冲突的情况：其一是拉链法，即在数组项中以链表的形式存储散列码等值的元素；其一是基于线性探测法等实现开放地址散列表，即存储的元素量不能超过数组长度，使数组足够容纳冲突的键。 拉链法拉链法既可使用原始链表实现，也可使用符号表实现。不同的是，原始链表对链表节点进行建模，符号表基于单向链表对整体进行建模。以下是基于符号表的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 符号表public class SequentialSearchST&lt;Key, Value&gt;&#123; private Node first; private class Node &#123; Key key; Value val; Node next; public Node(Key key, Value val, Node next) &#123; this.key = key; this.val = val; this.next = next; &#125; &#125; public Value get(Key key) &#123; for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) &#123; return x.val; &#125; &#125; return null; &#125; public void put(Key key, Value val) &#123; for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) &#123; x.val = val; return; &#125; &#125; first = new Node(key, val, first); &#125;&#125;// 基于符号表、拉链法的散列表public class SeparateChainingHashST&lt;Key, Value&gt;&#123; private static final int INIT_CAPACITY = 997; private int N;// 键值对总数 private int M;// 散列表大小 private SequentailSearchST&lt;Key, Value&gt;[] st;// 链表数组 public SeparateChainingHashST() &#123; this(INIT_CAPACITY); &#125; public SeparateChainingHashST(int M) &#123; this.M = M; // Java 不支持泛型数组，先需经过类型转换 st = (SequentailSearchST&lt;Key, value&gt;[]) new SequentailSearchST[M]; for (int i = 0; i &lt; m; i++) &#123; st[i] = new SequentailSearchST&lt;&gt;(); &#125; &#125; private int hash(Key key) &#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; private Value get(Key key) &#123; return (Value) st[hash(key)].get(key); &#125; private void put(Key key, Value val) &#123; st[hash(key)].put(key, val); &#125;&#125; 在 java 中，Hashtable 和 HashMap 都是基于拉链法构建的，且每个数组项被称为桶。无论 Hashtable，还是 HashMap，散列表的大小都可基于插入的元素量进行动态调整，这一过程被称为再散列 rehash。 HashtableHashtable 的 rehash 过程为：当元素量超过 hashtable.threshold 阈值（散列表的长度乘以装填因子 loadFactor）时，首先创建长度翻倍的新数组，再将原有元素按新的索引值插入到数组中，最后废弃旧数组。 Hashtable 的公共方法都加上了 synchronized 关键字，因此它是线程安全的，能保证在插值过程中找到正确的索引，而不会引起当另一个线程变更数组长度时导致的索引不定问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; private transient Entry&lt;?,?&gt;[] table;// 以链表数组形式存储元素 private int threshold;// 阈值，超过该值将 rehash，值为当前长度 ✖ 装填因子 private float loadFactor;// 装填因子 // 添加元素 public synchronized V put(K key, V value) &#123; if (value == null) &#123; throw new NullPointerException(); &#125; Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; // 长度变更使得元素索引不定，需要遍历数组查找元素是否已在散列表中 for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null; &#125; // 私有方法，结合 rehash 添加新元素 private void addEntry(int hash, K key, V value, int index) &#123; modCount++; Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) &#123; rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; &#125; // 再散列 protected void rehash() &#123; int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; int newCapacity = (oldCapacity &lt;&lt; 1) + 1;// 长度放大两倍 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; if (oldCapacity == MAX_ARRAY_SIZE) return; newCapacity = MAX_ARRAY_SIZE; &#125; Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; &#125; &#125; &#125; // 链表节点模型 private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Entry&lt;K,V&gt; next;// 构成单向链表 public int hashCode() &#123; return hash ^ Objects.hashCode(value); &#125; &#125;&#125; WeakHashMap一言以蔽之，WeakHashMap 是基于 Map 接口实现的线程不安全的 Hashtable。 HashMap因为 Hashtable 通过遍历链表的方式查找和插入元素并不高效，HashMap 在桶的容量超过指定值时，就会将桶的存储结构转化为红黑树，这样就提升了查找和插入的效率。关于红黑树的更多内容，可参见HashMap中的红黑树。 至于为什么在 Java 中，HashMap 被设计成线程不安全的？因为线程安全的实现方式会增加检查、加锁、解锁的开销。Java 另外提供了线程安全的 ConcurrentHashMap 类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; transient Node&lt;K,V&gt;[] table;// 以链表数组形式存储元素 static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; // 查找元素 public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 桶中的首节点就是查找的元素 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; // 从红黑树查找节点 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 从链表中查找节点 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; // 插入元素 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 保证散列表的长度不为 0 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 桶中首个节点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 链表、红黑二叉树的首节点与插入元素含有相同 key 键 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 将元素插入红黑树中 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 将元素插入链表中；当超过阈值时，转化为红黑树 else &#123; // 遍历链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 将元素插入到链表的尾端；newNode 方法创建链表节点 p.next = newNode(hash, key, value, null); // 超过指定长度 TREEIFY_THRESHOLD = 8，将链表转化成红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; &#125; // 链表中存在相同的 key 键 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 链表或红黑二叉树中存在相同的 key 键 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e);// 触发 LinkedHashMap 的动作 return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict);// 触发 LinkedHashMap 的动作 return null; &#125; // 将链表转化成红黑树 final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; // 散列表红黑树化前的最小长度 MIN_TREEIFY_CAPACITY = 64，未满足，则扩容 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; // replacementTreeNode 将链表节点转化为红黑树节点 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null)// 填充首节点 hd = p; // 修正链表节点的 prev, next 属性 else &#123; p.prev = tl; tl.next = p; &#125; tl = p;// 记录上一个节点 &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) // 将链表转化成红黑树 hd.treeify(tab); &#125; &#125; // 再散列，在保证容量和阈值不为 0 的前提下，把容量翻倍，老数据分拆注入新数组中 final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 散列表容器超过最大值 MAXIMUM_CAPACITY = 1 &lt;&lt; 30，只调整阈值 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 散列表容量翻倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; &#125; else if (oldThr &gt; 0) newCap = oldThr; // 设置初始容量 DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 和阈值 // 装填因子 DEFAULT_LOAD_FACTOR = 0.75f else &#123; newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];// 链表数组 table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 桶中只有节点，将节点直接添加到新的桶中 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 桶的数据结构为红黑树，将红黑树分拆到两个桶中（j, j + oldCap），其数据结构为红黑树或链表 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 桶的数据结构为链表，将链表分拆到两个桶中（j, j + oldCap），其数据结构仍为链表 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e;// 记录上一个节点 loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; // 删除节点 public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; // 先找到待删除的节点 Node&lt;K,V&gt; node = null, e; K k; V v; // 待删除为首节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 从红黑树或链表中找到待删除节点 else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 删除节点 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125;&#125; 概率问题本节所要致力于解决的问题是，当散列表的大小为 M 时，长度为 k 的链表出现的概率是多少？为什么要解决这个问题呢？因为只有在链表长度足够短时，查找和插入节点才会显得高效。 假设散列函数能将所有的元素均匀且独立地分配到数组中，即元素放入某个链表中的概率为 1/M，没有放入该链表的概率为 1-1/M。因此由二项分布可知，该链表长度为 k 的概率为（α = N/M 为期望）： 当 α 足够小时，可以转化为泊松分布的数学表达式： 介于此，对于初始大小为 16 的 HashMap，链表长度等于 8 的可能性为 0.00000006，这时就需要将链表转换成红黑树。 线性探测法因为开放地址散列表的长度大于待插入的元素量，当插入元素的数组索引已被占用时，就可以通过索引自增 1 的方式向下查找并插入。在这个过程中，插入元素可能已经存在在散列表中，因此就需要检测数组元素的键是否和插入元素的键相同，这一过程称为探测。需要说明的是，开放地址散列表中的空位譬如磁盘碎片，不只有一处，而是会散落多处。探测的成本在于需要遍历连续无间断的元素量（即键簇中包含的元素量）。 开放地址散列表的性能也依赖于 N/M 的比值，即数组的使用率。我们需要动态调整数组大小的方式来保证使用率在 1/8 到 1/2 之间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class LinearProbingHashST&lt;Key, Value&gt;&#123; private int N; private int M; private Key[] keys; private Value[] vals; public LinearProbingHashST() &#123; keys = (Key[]) new Object[M]; values = (Value[]) new Object[M]; &#125; public void put(Key key, Value val) &#123; if (N &gt;= M / 2) resize(M * 2); int i; // 采用余数计算索引，在保证索引正确的同时，也能跳回到 0 索引位置 for (i = hash(key); keys[i] != null; i = (i + 1) % M) &#123; if (key.equals(keys[i])) &#123; vals[i] = val; return; &#125; &#125; keys[i] = key; vals[i] = val; N++; &#125; public Value get(Key key) &#123; for (int i = hash(key); keys[i] != null; i = (i + 1) % M) &#123; if (key.equals(keys[i])) &#123; return vals[i]; &#125; &#125; return null; &#125; public void delete(Key key) &#123; if (!contains(key)) &#123; return; &#125; int i = hash(key); // 找到 key 键 while (!key.equals(keys[i])) &#123; i = (i + 1) % M; &#125; keys[i] = null; values[i] = null; i = (i + 1) % M; // 遍历调整后续元素的位置 while (keys[i] != null) &#123; Key keyToRehash = keys[i]; Value valueToRehash = values[i]; keys[i] = null; values[i] = null; N--; put(keyToRehash, valueToRehash); i = (i + 1) % M; &#125; N--; if (N &gt; 0 &amp;&amp; N == M / 8) &#123; resize(M / 2); &#125; &#125;&#125; 参考Java中Native关键字的作用如何通俗理解泊松分布？HashMap桶中链表转红黑树为什么选择数字8？hashMap线程不安全的原因及表现","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"算法","slug":"计算机科学/算法","permalink":"http://xzfyu.com/categories/计算机科学/算法/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://xzfyu.com/tags/算法/"}]},{"title":"HashMap中的红黑树","slug":"计算机科学/算法/HashMap中的红黑树","date":"2019-04-13T16:00:00.000Z","updated":"2020-03-08T11:05:47.872Z","comments":true,"path":"2019/04/14/计算机科学/算法/HashMap中的红黑树/","link":"","permalink":"http://xzfyu.com/2019/04/14/计算机科学/算法/HashMap中的红黑树/","excerpt":"","text":"HashMap 预期以链表数组的形式存储数据，即以 key 键的散列码计算索引，然后将元素插入到作为数组项的链表中（每个数组项称为桶）。为了提升查询的效率，HashMap 中存在一个阈值，当桶中的元素量超过这个阈值时，桶的数据结构就会从链表转变成红黑树。与红宝书中基于 2-3 树实现的红黑树不同，HashMap 中的红黑树基于 2-3-4 树实现。补充说明的是，Java 中的 TreeMap 也是基于 2-3-4 树实现的。 HashMap 中的红黑树节点通过 TreeNode 类构造，并按照按 key 键的散列码由大到小排列，这样就保证了红黑树的有序性。在链表中，相同的散列码只能存储一个元素；在红黑树中却能存储多个元素。当散列码相同时，HashMap 会通过 compareComparables 比较 key 键乃至 tieBreakOrder 实例方法比较内存地址的散列码，以决定元素在红黑树中的位置。因此，HashMap 以静态方法形式实现了两个辅助函数：comparableClassFor 用于判断 key 键的构造器是否实现了 Comparable 接口；compareComparables 静态方法用于比较 key 键。 HashMap 中的红黑树需要解决以下问题：查询节点、插入节点、删除节点、以及红黑树和链表数据结构的相互转换。为了保证红黑树和链表数据结构的高效转换，TreeNode 实例包含 prev, next 属性指向上一个或下一个节点，因此 TreeNode 既携带着红黑树的结构信息，又携带着双向链表的结构信息。 插入节点：HashMap 首先会通过 putTreeVal 方法根据散列码顺序插入节点，然后通过 balanceInsertion 调整红黑树的平衡性。当树中存在相同的 key 键时，putTreeVal 方法会返回已插入的节点。 删除节点：HashMap 首先会通过 removeTreeNode 方法删除节点；特定情况下，删除节点后需要 balanceDeletion 调整红黑树的平衡性。 查询节点：依次通过比较 key 键的散列码、key 键、key 键内存地址的散列码在左右子树中查找节点。 红黑树和链表转换：在转换之前，无论红黑树和链表都保证了 key 键的唯一性。因此，当链表转换成红黑树时，只需根据 key 键的散列码或 key 键内存地址的散列码将链表节点插入到红黑树中的特定位置，然后使用 balanceInsertion 调整树的平衡性。红黑树转换成链表时，只需顺序遍历 treeNode 节点的 next 属性即可。 以下是 TreeNode 的基本模型，同链表一样，红黑树以引用的方式构建整棵树： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 判断对象 x 的类是否实现了 Comparable 接口static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; // getClass 方法用于在运行时获取对象的类 if ((c = x.getClass()) == String.class) // bypass checks return c; // getGenericInterfaces 方法以 Type[] 形式获取类直接实现的接口，包含泛型参数信息 if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null;&#125;// 无法使用 Comparable 接口比较 key 键返回 0，否则返回对比结果@SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) // for cast to Comparablestatic int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x));&#125;static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent;// 父节点 TreeNode&lt;K,V&gt; left;// 左子节点 TreeNode&lt;K,V&gt; right;// 右子节点 TreeNode&lt;K,V&gt; prev;// 上一个节点 boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // 当散列码等值且 key 键比较结果为 0 时，使用内存地址的散列码进行比较 static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) // System.identityHashCode 根据对象在内存中的地址计算出散列码 d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125;&#125; 左旋、右旋左旋、右旋操作的功能点在于： 左旋：将作为右链接的红节点置为左链接。当父节点为左链接红节点、子节点为右链接红节点，通过左旋可以将红节点集中在左侧。 右旋：将作为左链接的红节点置为右链接。当左侧父子节点同时为红节点时，通过右旋可以将其转变成 4- 节点。 左旋红宝书中的左旋操作会返回子树的根节点，以便于向上递归；HashMap 中的左旋操作不会返回子树的根节点，因此在左旋操作仍需要将新添加为子树根节点的 r 节点挂到祖父节点 pp 上（当 pp 为 null 时，则 r 为红黑树的根节点）。右旋操作同此。 1234567891011121314151617181920212223// p 图示中的 E，r 图示中的 Sstatic &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; // 将 3 结点的中间部分挂在左节点 p（原始父节点）下 if ((rl = p.right = r.left) != null) rl.parent = p; // 将红链接中的右节点 r（原始子节点）上移，左节点（原始父节点）下移为右节点的子节点 // 子树（可能是包含根节点的完整二叉树）在父节点 pp 中的位置保持不变 if ((pp = r.parent = p.parent) == null) (root = r).red = false;// 原始父节点即为根节点 else if (pp.left == p) pp.left = r; else pp.right = r; // 父子节点反转 r.left = p; p.parent = r; &#125; return root;&#125; 右旋 1234567891011121314151617181920212223// p 图示中的 S，l 图示中的 Estatic &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; // 将 3 结点的中间部分挂在右节点 p（原始父节点）下 if ((lr = p.left = l.right) != null) lr.parent = p; // 将红链接中的左节点 l（原始子节点）上移，右节点（原始父节点）下移为左节点的子节点 // 子树（可能是包含根节点的完整二叉树）在父节点 pp 中的位置保持不变 if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; // 父子节点反转 l.right = p; p.parent = l; &#125; return root;&#125; 插入节点插入节点包含两个步骤： 通过 putTreeVal 方法根据散列码将节点插入树的底部。 通过 balanceInsertion 方法调整树的平衡性。 通过 moveRootToFront 方法将根节点置于链表的首位。 putTreeValputTreeVal 基于以下逻辑插入节点： 首先比较 key 键的散列码，若不同，就通过比较值将节点插入到左子树或右子树中。 其次比较 key 键与树中节点是否等值，若等值，返回树中已存在的节点。 其次使用 Comparable 接口比较 key 键，根据比较结果将节点插入左子树或右子树中。 其次使用 tieBreakOrder 方法比较内存地址的散列码，再根据比较结果将节点插入左子树或右子树中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// h 插入节点的散列码；k 插入节点的 key；pk 红黑二叉树节点的 keyfinal TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; // 散列码大的放在右侧，小的放在左侧 if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; // 散列码相等，比较 key 键 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; // 新插入的节点置于链表的左侧 if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125;&#125; balanceInsertionbalanceInsertion 方法在向上递归的过程中需要处理的情况有以下几种： 插入根节点，只需将根节点转变成黑链接即可。 黑节点下插入子节点，左右两侧都是红链接，构成 4- 节点。 4- 节点下插入子节点，将 4- 节点转变成 3 个 2- 节点子树。 单侧插入两个红节点，通过左旋、右旋转变成 3 个 2- 节点子树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 1. 首层插入根节点，黑链接// 2. 第二层插入的两个节点通常情况下均为红链接static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; // x 作为根节点 if ((xp = x.parent) == null) &#123; x.red = false; return x; // 父节点为普通节点或者父节点作为根节点 &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; // 以下均基于父子节点同时为红链接，且必然存在祖父节点的情况 if (xp == (xppl = xpp.left)) &#123; // 祖父节点下两侧节点均为红链接，构成 4- 节点，通过颜色转换将左右两侧节点置为黑链接 // 此时将祖父节点置为红链接，以便于向上递归 if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; // 祖父节点下单侧出现两个红链接，通过旋转调整 &#125; else &#123; // 右节点左旋，使红链接集中在左侧，同时反转父子节点 if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; // 将集中在左侧的父子节点右旋成 4- 节点 if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125;&#125; moveRootToFrontmoveRootToFront 方法用于将红黑树的根节点置于链表的顶部。因为通过 balanceInsertion 等方法调整树平衡性时，原本子节点可能成为根节点，这样新的根节点在链表中的位置就需要得到调整。针对这种情况，moveRootToFront 方法先从链表中剔除这个新的根节点，然后将这个根节点置于链表的首位。 1234567891011121314151617181920212223242526static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123; int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) &#123; Node&lt;K,V&gt; rn; tab[index] = root; // 将新根节点 root 从原始链表中剔除，再插入为根节点 TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; // 将链表的原始首节点 first 置于新的根节点 root 后 if (first != null) first.prev = root; root.next = first; root.prev = null; &#125; assert checkInvariants(root); &#125;&#125; 删除节点删除节点包含两个步骤： 通过 removeTreeNode 方法删除当前节点。当待删除节点存在左右子节点时，删除过程中需要使用后继节点替换当前节点。 移位后的待删除节点为 3- 节点的父节点，通过 balanceInsertion 方法调整树的平衡性。 通过 moveRootToFront 方法将根节点置于链表的首位。 removeTreeNoderemoveTreeNode 基于以下逻辑删除当前节点： 通过重置 prev, next 属性调整双向链表的结构信息。 重置根节点；当树中节点过少时，将树转换成链表。 若待删除节点包含左右子节点，交换待删除节点和其后继节点的位置。可想而知的是，在完美平衡树中，这一操作会将待删除节点移到 2-3-4 树的底部。如果待删除节点为红节点，那么就构成了 4- 节点；否则构成了 3- 节点或普通 2- 节点。 若待删除节点在移位后为 3- 节点中的父节点，删除节点，然后通过 balanceDeletion 调整树的平衡性。若待删除节点在移位后为 4- 节点中的子节点，直接删除。若待删除节点在移位后为普通 2- 节点，通过 balanceDeletion 调整树的平衡性，然后删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; // 调整双向链表的结构信息 if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; // 重置根节点 if (root.parent != null) root = root.root(); // 树中节点过少，将树转化成链表 if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; // 查找后继节点 s TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; // 交换待删除节点 p 和后继节点 s 的位置 if (s == pr) &#123; // p was s's direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; // 若 p 下还有子节点 replacement，将 replacement 挂在祖父节点下，并剔除 p if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; // 首先 p 已经移到了 2-3-4 树的底部，与其他节点构成 3- 节点或普通 2- 节点、或 4- 节点 // 当 p 为红节点时，即作为 4- 节点的子节点，无需通过 balanceDeletion 调整树的平衡性 // 当 p 为黑节点，即作为 3- 节点的父节点或普通 2- 节点，调整树的平衡性 // 当构成 3- 节点时，replacement 作为 p 的子节点，必为红节点 // 当构成 2- 节点时，replacement 即为 p TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); // 若 p 下没有子节点（p 的位置可能经过 balanceDeletion 调整），剔除 p if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r);&#125; balanceDeletionremoveTreeNode 方法保证了 balanceDeletion 的执行时机，即 x 在树的底部，且 x 只可能是 3- 节点或普通 2- 节点，不可能是 4- 节点中的子红节点。在完美平衡树的机制下，x 的兄弟节点也只可能包含一级子节点。 balanceDeletion 在向上递归的过程中需要处理的情况有以下几种： 当 x 为根节点或空节点，无需调整树的平衡性。 当 x 为 3- 节点中的子红节点，将其转换成普通 2- 节点，无需调整树的平衡性。向上递归过程也可能导致 x 为红节点，这是也只需转换颜色即可。 当 x 为 2- 节点，这时需要保障兄弟节点树的平衡性。若兄弟节点两侧都不是红节点或都不存在时，这时兄弟节点树的平衡性有所保障，只需将兄弟节点标红即可。若兄弟节点单侧包含红节点时，需要保障从父节点起的树的平衡性，这时可以按条件先将红节点右旋至右侧，再通过左旋将父节点下移、兄弟节点上移、左侄子节点挂在父节点下，以保障树的平衡性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; // x 作为空节点或根节点，无需调整 if (x == null || x == root) return root; else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; // x 作为 3- 节点中的子红节点，将其转换为普通 2- 节点 else if (x.red) &#123; x.red = false; return root; &#125; // x 作为普通 2-节点，且位于左侧 else if ((xpl = xp.left) == x) &#123; // 兄弟节点是红节点，左旋将父节点转换为红节点 if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; root = rotateLeft(root, xp); // 原兄弟节点的左子节点作为新的 xpr 兄弟节点 xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; // 兄弟节点的两个子节点都不是红节点或都不存在时，兄弟节点树的平衡性有所保障，只需将兄弟节点标红 if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; x = xp; &#125; else &#123; // 只兄弟节点的左子节点为红节点，右旋将红节点挂于右侧 if (sr == null || !sr.red) &#123; if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; &#125; // 只兄弟节点的右子节点为红节点，将颜色标黑 if (xpr != null) &#123; xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; &#125; // 左旋将父节点下移，兄弟节点上移 if (xp != null) &#123; xp.red = false; root = rotateLeft(root, xp); &#125; x = root; &#125; &#125; &#125; else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125;&#125; 查询节点查询节点包含如下三个方法： root 获取红黑树的根节点。 find 查找当前子树中的节点。 getTreeNode 查找完整红黑树中的节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 获取根节点final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125;&#125;// 从当前节点起查找节点：h 散列码，k key键final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; // 比较散列码 if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; // 散列码相等，判断 key 是否等值 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; // 使用 compareComparables 比较 key 键 else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; // 节点按 key 键内存地址的散列码决定位置，从左右子树中查找 // 右子树递归调用 find 方法 else if ((q = pr.find(h, k, kc)) != null) return q; // 左子树循环 else p = pl; &#125; while (p != null); return null;&#125;// 从根节点起查找节点final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null);&#125; 桶交互链表 -&gt; 红黑树将链表转换成红黑树就是节点插入的过程，其特殊性是在这个插入过程中，key 键不存在重复值。因此该过程可分为步骤： 插入根节点。 根据散列码将节点插入二叉树的底部。 通过 balanceInsertion 调整树的平衡性。 通过 moveRootToFront 将根节点置于链表的首位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 将链表转化成红黑二叉树，存储结构仍为链表，首节点是红黑二叉树的根节点final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123;// 填充根节点 x.parent = null; x.red = false; root = x; &#125; else &#123; K k = x.key;// 链表节点的 key，待插入红黑二叉树中 int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key;// 红黑二叉树节点的 key // 顺序比较 key 键的散列码、key 键、内存地址的散列码，确定节点的位置 dir if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; // 将 x 插入底部，不设置红链接标识，散列码大的位于左侧 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root);&#125; 红黑树 -&gt; 链表1234567891011121314// 将红黑二叉树转化成链表final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; // 通过 replacementNode 方法将 TreeNode 转化成 Node Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p;// hd 即链表中的首节点 else tl.next = p; tl = p;// 记录上一个节点，以绑定上一个节点和当前节点的关联 &#125; return hd;&#125; 扩容当需要扩容时，调用 split 方法可以将红黑树中的元素分拆到两个桶中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // 将红黑树拆分为两个链表 TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e;// 记录上一个节点 ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; // 根据元素量转换为红黑树或链表，并分配到不同的桶中 if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125;&#125; 后记文章草草整理完，回头想想，我仍感觉自己没法把握红黑树为什么会采用这种方式实现，就好像困惑于红黑树这个主意到底是谁在什么契机下想出来的那般。种种奥妙，尚未窥破，仍需努力。 参考balanceInsertion 红黑树平衡插入图解红黑树-算法导论-java实现基于HashMap1.8","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"算法","slug":"计算机科学/算法","permalink":"http://xzfyu.com/categories/计算机科学/算法/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://xzfyu.com/tags/算法/"}]},{"title":"红黑树","slug":"计算机科学/算法/红黑树","date":"2019-04-06T16:00:00.000Z","updated":"2020-03-08T11:05:42.975Z","comments":true,"path":"2019/04/07/计算机科学/算法/红黑树/","link":"","permalink":"http://xzfyu.com/2019/04/07/计算机科学/算法/红黑树/","excerpt":"","text":"与数组相比，链表提升了插入元素的效率。因为数组在插入元素时，需要移动后续元素的位置；而链表只需要改变后继元素的 prev 属性。然而在查询元素时，链表需要遍历所有元素，并不高效。借助于红黑树，既能提升查询的效率，又能保证插入的效率。 为什么说红黑树有助于提升查询和插入的效率呢？因为红黑树本质上是一棵完美平衡的二叉查找树，可以通过节点的有序性保证查找和插入操作的便捷，其作时间复杂度就是树的高度 O(lgN)，自然比链表的 O(N) 高效很多。红黑树有如下两个特征：有序性、平衡性。我们讲一棵红黑树是有序的，通常指的是树中的节点会遵照 key 键自小到大或自大到小的顺序。有序性是实现二叉树完美平衡的先决条件。完美平衡指的是树从根节点到每个底部节点的高度大致相当，这样才能保证查询操作的时间复杂度为 O(lgN)。设想当二叉树出现了单边有值的极端情况时，其查询效率就和链表一样同为 O(N)。因此，实际上是完美平衡的二叉树便于查询节点，而红黑树是完美平衡二叉树的一种实现方式。 犹如红黑树是完美平衡树的一种实现方式，红黑树自身也有多种实现方式。本文所介绍的红黑树（即算法红宝书中的红黑树）是基于 2-3 树实现的。在插入元素方面，2-3 树所具有的优点为：当向 2- 节点插入新节点时，通过将 2- 节点转变成 3- 节点，可以迅速接纳新的节点；当向 3- 节点插入新节点时，通过将 3- 节点转变成 4- 节点，再将 4- 节点转变成 3 个 2- 节点构成的子树，也可以迅速接纳新的节点。在实现上，若使用不同的数据类型表示 2- 节点或 3- 节点及其附属信息，接着实现不同类型节点的转换，这样势必会使程序相当复杂，且容易遇上性能问题。红黑树就应运而生了。 红宝书中的红黑树有如下性质： 红链接均为左链接 没有任何一个节点同时和两条红链接相连 该树是完美黑色平衡的，即任意空链接到根节点的路径上的黑链接数量相同 第一条性质指的是红黑树中构成 3- 节点的方式总是唯一的。当红链接为右链接时，需要通过左旋操作将其转变为标准的左链接 3- 节点。第二条性质包含以下两种情况：父子节点不能同时为红链接（无论子节点是左链接还是右链接）；父节点下的两个子节点不能同时为红链接。当父子节点同时为红链接时，可通过旋转操作将其转变为 3 个 2- 节点的子树，这样就能同时消除父子节点的红链接。当父节点下的两个子节点同时为红链接时，可通过颜色转换操作将两个子节点变为黑链接。从 2-3 树的角度直观地看第二条性质，也是指红黑树中的每一个节点不能同时从属于两个 3- 节点。因此，第二条性质和第三条性质一样，表明红黑树是和 2-3 树一一对应的。 需要说明的是：2- 节点是包含 2 个子节点的节点，在红黑树中就是普通节点；3- 节点由两个节点构成，其下包含 3 个子节点，在红黑树中就是左子节点为红链接；4- 节点由三个节点构成，其下包含 4 个子节点，在红黑树中就是左右两侧子节点均为红链接。当分析红黑树的直观视图时，我们只需要考虑 2- 节点和 3- 节点。在插入和删除元素时，我们才需要考虑 4- 节点。红黑树的直观视图就是二叉树。特别的，当将 3- 节点拉平后，红黑树的直观视图就会变成 2-3 树。 12345678910111213141516171819202122private static final boolean RED = true;private static final boolean BLACK = false;private class Node &#123; Key key; Value value; Node left, right;// 左右子树 int N;// 节点总数 boolean color;// 标识红链接或黑链接 Node(Key key, Value value, int N, boolean color)&#123; this.key = key; this.value = value; this.N = N; this.color = color; &#125;&#125;private boolean isRed(Node x)&#123; if (x == null) return false; return x.color == RED;&#125; 在分析红黑树时，我们需要致力于解决如下这样一个命题：怎样在插入和删除节点时保证树的平衡性？ 左旋、右旋、颜色转换红黑树抽象了三种抽象操作：左旋转、右旋转和颜色转换。这三种抽象操作都是局部变换。简单地说，左旋转用于将红链接从右链接转变成左链接，即红链接均为左链接的标准红黑树；右旋转用于将父节点和左子节点均为红链接的子树转变成 3 个 2- 节点的子树；颜色转换将两个子节点同时为红链接的子树转变成 3 个 2- 节点的子树，同时子树的根节点转变为红链接，颜色转换操作可以向上递归，以实现整颗红黑树中不能有两个子节点同时为红链接。 左旋 12345678910Node rotateLeft(Node h)&#123; Node x = h.right;// 取出原红链接节点 x h.right = x.left;// 将中间部分 x.left 置于左节点 h 下 x.left = h;// 因 x 将作为子树的根节点，将左节点 h 置为红链接节点 x 的左子节点 x.color = h.color;// 不改变子树根节点的颜色 h.color = RED;// 将子树中的红链接节点置为 h，即左移 x.N = h.N;// 调整节点数目 h.N = 1 + size(h.left) + size(h.right); return x;// 返回子树的根节点&#125; 上文已指出，左旋的目的就是将作为右链接的红链接转变为标准的左链接。 右旋 12345678910Node rotateRight(Node h)&#123; Node x = h.left;// 取出原红链接节点 x h.left = x.right;// 将中间部分 x.left 置于右节点 h 下 x.right = h;// 因 x 将作为子树的根节点，右节点 h 置为红链接节点 x 的右子节点 x.color = h.color;// 不改变子树根节点的颜色 h.color = RED;// 将子树中的红链接节点置为 h，即右移 x.N = h.N;// 调整节点数目 h.N = 1 + size(h.left) + size(h.right); return x;// 返回子树的根节点&#125; 右旋的目的需要结合使用场景，即当在父节点和左子节点同时为红链接时，通过右旋和颜色转换可以将子树转变为包含 3 个 2- 节点的子树。试想一下，当父节点和左侧子节点都为红链接时，即上图中 less than E 子树的根节点也是红链接，右旋操作就可以使旋转后的根节点 E 与其两侧子节点构成 4- 节点（即两侧子节点同时为红链接）。这时再通过颜色转换就可以把这两个子节点均置为黑链接，以避免单个节点同时和两条红链接相连。图示参见节点插入部分。 颜色转换 12345void flipColors(Node h)&#123; h.color = RED;// 根节点置为红链接 h.left.color = BLACK;// 左右子节点置为黑链接 h.right.color = BLACK;&#125; 上文已经指出，在父节点和左侧子节点同时为红链接的情形下，通过右旋操作可以使祖父节点拥有两个红链接子节点，再通过颜色转换可以将这两个节点都转换成黑链接。因为左旋、右旋和颜色转换都基于红链接，将子树的根节点置为红链接有助于向上递归调整树的平衡性（即使得左旋、右旋、颜色转换操作能作用于自根节点始的整棵树）。 节点插入节点插入需要针对以下情况： 当插入对象为 2- 节点时，向左插入就是在根节点左侧直接添加一个红链接，使父子节点构成一个 3- 节点；向右插入就是在根节点右侧先添加一个红链接，然后通过左旋反转父子节点的位置。 当插入对象为 3- 节点时，向左插入就使得父子节点同时为红链接，因此就需要通过右旋和颜色转换将其转变为包含 3 个 2- 节点的子树；中间插入就使得父子节点既同时是红链接，子节点又是非法的右链接，因此先需通过左旋将子树变更为向左插入一样的形态，然后再沿用向左插入的调整策略；向右插入可以通过颜色转换将两个子节点变为黑链接。完成以上操作后，向上递归调整自根节点始的整棵树。 插入算法的实现如下： 12345678910111213141516171819202122232425262728293031private Node root;public void put(Key key, Value val)&#123; root = put(root, key, val); root.color = BLACK;// 根节点始终为黑链接&#125;private Node put(Node h, Key key, Value val)&#123; if (h == null) return new Node(key, val, 1, RED);// 创建根节点或底部节点 // 向下递归插入节点 int cmp = key.CompareTo(h.key); if (cmp &lt; 0) h.left = put(h.left, key, val); else if (cmp &gt; 0) h.right = put(h.right, key, val); else h.val = val; // 向上递归调整树的平衡性 // [左旋]，[右旋，颜色转换]是连贯一体的操作，可能有，也可能没有 // 红链接为右链接，左旋，针对 2- 节点或 3-节点中插入情况 // 可能会引起向上递归执行左旋操作 if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h); // 父子节点均为红链接，右旋 if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); // 两侧子节点均为红链接，颜色转换 if (isRed(h.left) &amp;&amp; isRed(h.right)) h = flipColors(h); // 调整节点数目 h.Number = Size(h.left) + Size(h.right) + 1; return h;// 返回根节点，便于向上递归&#125; 节点删除可想而知，当待删除的节点在 3- 节点中，如果 3- 节点在底部，那么这个节点就可以直接删除；如果 3- 节点不在底部，就可以用该节点的前驱或后继节点替换这个节点，然后再删除这个节点。当删除的节点在 2- 节点中，删除操作将破坏树的平衡性，这时就需要从父节点或兄弟节点中借一个节点构成 3- 节点或 4- 节点，然后再执行删除操作。在删除节点的过程中，程序会自顶向下构建 3- 节点或 4- 节点；删除结点后，再自底向上拆解 4- 节点。 需要指出的是，上文中左旋、右旋操作所具有的一般性为：即便子节点不是红链接，左旋、右旋在反转父子节点时，还能创建红链接。因此，构建 3- 节点需要借助于左旋、右旋操作；构建 4- 节点借助于反向颜色转换操作。 反向颜色转换反向颜色转换是上文 flipColors 方法的反向操作，即将左右子节点均置为红链接，这会使得单侧父子节点构成一个 3- 节点（可视为将父节点借给子节点），同时父节点和两侧子节点又会构成一个 4- 节点。 12345void moveFlipColors(Node h)&#123; h.color = Black; h.left.color = Red; h.right.color = Red;&#125; 左移左移操作适用于子树中的最小键，即左侧节点。对比上文，左移操作包含如下两个步骤： 通过反向颜色转换 moveFlipColors 操作构建 4- 节点。 若右侧为 3- 节点，将 3- 节点中的最小键左移到左节点下，使左节点变为 3- 节点。这时需要通过颜色转换 flipColors 拿掉 4- 节点。 123456789private Node moveRedLeft(Node h)&#123; moveFlipColors(h);// 从父节点中借一个 if (isRed(h.right.left))&#123;// 兄弟节点不是 2- 节点，从兄弟节点中借一个 h.right = rotateRight(h.right); h = rotateLeft(h); flipColors(h);// 从兄弟节点借了一个后，把从父节点中借来的还回去 &#125; return h;&#125; 右移右移操作适用于子树中的最大键，即右侧节点。同样包含两个步骤： 通过反向颜色转换 moveFlipColors 操作构建 4- 节点。 若左侧为 2- 节点，将该 2- 节点的父节点右移，使右节点变为 3- 节点。这时需要通过颜色转换 flipColors 拿掉 4- 节点。 12345678private Node moveRedRight(Node h)&#123; moveFlipColors(h);// 从父节点中借一个 if (!isRed(h.left.left))&#123;// 兄弟节点是 2- 节点，从兄弟节点中借一个 h = rotateRight(h); flipColors(h);// 从兄弟节点借了一个后，把从父节点中借来的还回去 &#125; return h;&#125; 再平衡无论在删除左侧节点还是在删除右侧节点时，都可能会在右侧创建新的红链接，所以我们需要通过左旋操作移除该红链接。且删除操作会破坏红黑树的性质，使红黑树下拥有不合法的作为右链接的红链接，或者父节点和左子节点同时为红链接，或者两侧子节点同时为红链接，这时就需要借助节点插入时的左旋、右旋、颜色转换操作逐级向上调整了。 1234567891011121314private Node balance(Node h)&#123; // 删除左节点可能会创建 4- 节点，右链接为红链接 // 删除右节点可能会使用左旋创建居于右侧的红链接 // 两种情况均通过 rotateLeft 还原 if (isRed(h.right)) h = rotateLeft(h); // 和节点插入时相同，通过[左旋]、[右旋，颜色转换]调整树的平衡性 if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.N = size(h.left) + size(h.right) + 1; return h;&#125; 删除最小键 1234567891011121314151617181920212223public void deleteMin()&#123; // 当 flipColors, moveFlipColors 由同一个函数实现时，需要将根节点置红，以便进行反向颜色转换 if(!isRed(root.left) &amp;&amp; !isRed(root.right))&#123; root.color = Red; &#125; root = deleteMin(root); if ( !isEmpty() ) root.color = Black;// 根节点颜色复原&#125;private Node deleteMin(Node h)&#123; // h 就是为最小键，置为 null 移除 if(h.left == null) return null; // 向下递归构建 3- 节点和 4- 节点，并删除节点 // 左子节点为 2- 节点，通过左移操作向右子节点或父节点中借一个 if(!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); h.left = deleteMin(h.left); // 向上递归移除临时的 4- 节点，调整树的平衡性 return balance(h);&#125; 删除最大键 123456789101112131415161718192021222324252627282930public void deleteMax()&#123; if(!isRed(root.left) &amp;&amp; isRed(root.right))&#123; root.color = Red; &#125; root = deleteMax(root); if ( !isEmpty() ) root.color = Black;&#125;private Node deleteMax(Node h)&#123; // 左子节点为红链接时，通过右旋将其给到右侧，以构建 3- 节点 if(isRed(h.left))&#123; h = rotateRight(h); &#125; // h 就是为最大键，置为 null 移除 if(h.right == null)&#123; return null; &#125; // 向下递归构建 3- 节点和 4- 节点，并删除节点 // 右子节点为 2- 节点，通过右移操作向左子节点或父节点中借一个 if(!isRed(h.right) &amp;&amp; !isRed(h.right.left))&#123; h = moveRedRight(h); &#125; h.right = deleteMax(h.right); // 向上递归移除临时的 4- 节点，调整树的平衡性 return balance(h);&#125; 删除节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void delete(Key key)&#123; if(!isRed(root.left)&amp;&amp; !isRed(root.right))&#123; root.color = Red; &#125; root = delete(root, key); if ( !isEmpty() ) root.color = Black;&#125;private Node delete(Node h, Key key)&#123; if (key.compareTo(h.key) &lt; 0)&#123; // 向下递归构建 3- 节点和 4- 节点，并删除节点 // 左子节点为 2- 节点，通过左移操作向右子节点或父节点中借一个 if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); // 递归删除 h.left = delete(h.left, key); &#125; else &#123; // 左子节点为红链接时，通过右旋将其给到右侧，以构建 3- 节点 if (isRed(h.left)) h = rotateRight(h); // 无后继节点，意味待删除节点为底部节点，置为 null 删除 // 怎么保证 h 是 3- 节点？ if (key.compareTo(h.key) == 0 &amp;&amp; (h.right == null)) return null; // 向下递归构建 3- 节点和 4- 节点，并删除节点 // 右子节点为 2- 节点，通过右移操作向左子节点或父节点中借一个 if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h); // 使用后继节点替换 if (key.compareTo(h.key) == 0)&#123; h.val = get(h.right, min(h.right).key); h.key = min(h.right).key; h.right = deleteMin(h.right); &#125; // 递归删除 else h.right = delete(h.right, key); &#125; return balance(h);&#125; 小记这篇文章是我在理解 HashMap 过程中的一阵整理。回头想想，仍觉得自己对红黑树的理解不是很透彻。留在网上暂作为一种记录，以便于渐进式修改。 参考浅谈算法和数据结构: 九 平衡查找树之红黑树一篇文章搞懂红黑树的原理及实现","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"算法","slug":"计算机科学/算法","permalink":"http://xzfyu.com/categories/计算机科学/算法/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://xzfyu.com/tags/算法/"}]},{"title":"Servlet","slug":"backend/web 服务/Servlet","date":"2019-03-22T16:00:00.000Z","updated":"2020-03-08T11:28:14.987Z","comments":true,"path":"2019/03/23/backend/web 服务/Servlet/","link":"","permalink":"http://xzfyu.com/2019/03/23/backend/web 服务/Servlet/","excerpt":"","text":"我们先来看一下，作为 Servlet 容器（也称为 web 容器）的 Tomcat 的一般工作机制： 客户端首次发送请求，Tomcat 将实例化特定的 Servlet 类并执行 init 方法。 Tomcat 将请求解析成 request，并将其转发给 servlet。 servlet调用 service 方法处理请求，获得 reponse 并发送回客户端。 当客户端再次发送请求，重复 2, 3 步。 当 Servlet 销毁时（卸载应用程序或关闭 Servlet 容器），调用 destory 方法。 Servlet 是运行在 web 服务器上用于接受和处理请求、获得响应的程序。javax.servlet 包提供了一组接口和类，用于定义和描述 Servlet 类和 Servlet 容器（提供 servlet的运行时环境）的契约。 The javax.servlet package contains a number of classes and interfaces that describe and define the contracts between a servlet class and the runtime environment provided for an instance of such a class by a conforming servlet container. 和一般的容器技术相同，Servlet 容器会协调 servlet 的生命周期，并为 servlet 提供全局上下文 ServletContext，以便于使用通用的工具函数、全局配置或缓存、访问全量的 servlet、动态注册 Servlet 等。因此，对于单机环境部署的 web 应用，针对不同的路由会有多个 servlet，servletContext 却只有一个；这也使得在单机环境中 servletContext 可用于缓存全局数据。当然在分布式环境下，每台虚拟机都会有一个 servletContext，不宜再使用 servletContext 缓存数据。 聊回容器技术，抽象类 ServletContext 是由容器实现的，就是说容器在应用启动阶段就会实例化全局上下文，并将 Servlet 类加载到内存中。在 ServletContext 抽象类中，我们可以看见 setInitParameter 方法用于对接全局的初始参数，addServlet 方法用于注册 Servlet（实现类完全可以用实例属性缓存全量的 Servlet）。在 javax.servlet 的设计中，Servlet 的初始参数和路由规则等配置项同 Servlet 呈轻耦合关系，addServlet 方法实际注册的是 servletRegistration，这样就使得 servlet 不能变更路由规则了。 由 servletContext 向上封装构成 servletConfig，该实例既作为 servlet.init 方法的参数，又可以通过 servlet.getServletConfig 方法间接访问。每个 servlet 对应一个 servletConfig。通过这个 servletConfig，既可以获取全局上下文（全局的初始参数可通过上下文进行获取），又在于获取 servlet 自有的初始参数。因此，容器会维护 servletContext, servletConfig 实例，并协调 servlet 生命周期方法的调用。Servlet 包含如下三个生命周期方法： init(ServletConfig config) 初始化方法。通常当 Servlet 容器初次接受请求时，就会尝试实例化 Servlet 并调用其 init 方法。如果将 Servlet 配置为 loadOnStartup，那么 init 方法就会在容器启动时调用。 service(ServletRequest req, ServletResponse res) 处理请求以获取响应。需要注意的是，Servlet 容器会以多进程的方式运行，共享的资源、缓存需要及时作同步。 destroy() 当 Servlet 移出 Servlet 容器时被调用，如杀死进程等。实现 destory 方法一般用于销毁状态、及时同步资源或缓存。 javax.servlet 开具了 Filter 过滤器的机制，该机制可用于作公共层面的权限校验、日志打印、数据转换等。它同样通过 servletContext 注册和维护，由容器提供 filterConfig 以获取全局上下文及配置。它也具有三个生命周期方法： init(FilterConfig filterConfig) 初始化方法。 doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 过滤逻辑，调用 chain.doFilter 执行下一个过滤器或将请求转交给 servlet。 destroy() 销毁。 filter 有其适用范围，默认为 DispatcherType.REQUEST 过滤常规请求。当将 Filter 的初始参数 dispatcherTypes 配置为 DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ERROR, DispatcherType.ASYNC 时，将分别对 requestDispatcher.forward(req, res) 重定向、 requestDispatcher.include(req, res) 资源包含、404 响应、异步请求作过滤。 ServletContextServletContext 的功能如下： 获取资源或查看其媒体类型。 注册 servlet 并作管理。 注册 filter 并作管理。 缓存全局数据，在数据变更时触发 listener。 设置 session 超时时间等… servletContext 及其 attribute 属性均会经由 java.util.EventObject 包装，并由实现类组织事件的触发时机。因此对于 servletContext 的初始化及其 attribute 属性的变动，都可以订制监听器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// Servlet 容器初始化时调用public interface ServletContainerInitializer &#123; void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException;&#125;public interface ServletContext &#123; // 全局初始参数 public String getInitParameter(String name); public Enumeration&lt;String&gt; getInitParameterNames(); public boolean setInitParameter(String name, String value); // 获取资源或资源的媒体类型 public String getMimeType(String file); public Set&lt;String&gt; getResourcePaths(String path); public URL getResource(String path) throws MalformedURLException; public InputStream getResourceAsStream(String path); // 获取 requestDispatcher，以重定向或作资源包含 public RequestDispatcher getRequestDispatcher(String path); public RequestDispatcher getNamedDispatcher(String name); // 打印日志，日志的名称和类型由容器决定 public void log(String msg); public void log(String message, Throwable throwable); // 缓存或获取全局状态，其值变更时将会通知 listener public Object getAttribute(String name); public Enumeration&lt;String&gt; getAttributeNames(); public void setAttribute(String name, Object object); public void removeAttribute(String name); // 注册或获取 Servlet public ServletRegistration.Dynamic addServlet(String servletName, String className); public ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet); public ServletRegistration.Dynamic addServlet(String servletName, Class&lt;? extends Servlet&gt; servletClass); public ServletRegistration.Dynamic addJspFile(String jspName, String jspFile); public &lt;T extends Servlet&gt; T createServlet(Class&lt;T&gt; c) throws ServletException; public ServletRegistration getServletRegistration(String servletName); public Map&lt;String, ? extends ServletRegistration&gt; getServletRegistrations(); // 注册或获取过滤器 public FilterRegistration.Dynamic addFilter(String filterName, String className); public FilterRegistration.Dynamic addFilter(String filterName, Filter filter); public FilterRegistration.Dynamic addFilter(String filterName, Class&lt;? extends Filter&gt; filterClass); public &lt;T extends Filter&gt; T createFilter(Class&lt;T&gt; c) throws ServletException; public FilterRegistration getFilterRegistration(String filterName); public Map&lt;String, ? extends FilterRegistration&gt; getFilterRegistrations(); public SessionCookieConfig getSessionCookieConfig(); public void setSessionTrackingModes( Set&lt;SessionTrackingMode&gt; sessionTrackingModes); public Set&lt;SessionTrackingMode&gt; getDefaultSessionTrackingModes(); public Set&lt;SessionTrackingMode&gt; getEffectiveSessionTrackingModes(); // 添加 listener public void addListener(String className); public &lt;T extends EventListener&gt; void addListener(T t); public void addListener(Class&lt;? extends EventListener&gt; listenerClass); public &lt;T extends EventListener&gt; T createListener(Class&lt;T&gt; c) throws ServletException; // 获取、设置 session 超时时间 public int getSessionTimeout(); public void setSessionTimeout(int sessionTimeout); // 获取、设置请求体 request body 编码 public String getRequestCharacterEncoding(); public void setRequestCharacterEncoding(String encoding); // 获取、设置响应体 reponse body 编码 public String getResponseCharacterEncoding(); public void setResponseCharacterEncoding(String encoding); public JspConfigDescriptor getJspConfigDescriptor(); public ClassLoader getClassLoader();&#125; Servlet关于 Servlet 的讲解见于上文，我们知道，开发者可以实现特定的 init, service, destory 方法。在讲解 HttpServlet 前，我们先来了解一下 ServletRequest, ServletResponse。 req &amp;&amp; res顾名思义，当接受到请求时，Servlet 容器会将其封装为 servletRequest，便于读取请求内容。容器既实现了 ServletRequest 接口，又实现了 ServletInputStream 抽象类，通过 servletInputStream.read 方法可读取请求内容。ServletRequest 接口包含如下功能： 访问全局上下文。 getInputStream 返回 ServletInputStream 实例，便于以二进制形式读取请求体。 getReader 返回 BufferedReader 实例，便于以字符串形式读取请求体。 getParameter 获取查询参数。 getPart, getParts 返回 Part 实例或集合，便于获取 multipart/form-data 媒体类型上传的文件， setAttribute 设置缓存数据。 获取其他请求相关信息。 获取服务器或客户端 ip 地址信息等… 用于处理 http 请求的 HttpServletRequest 接口增加了如下功能： getQueryString 获取查询参数。 getMethod 获取请求方式。 getRequestURI 获取请求地址。 getCookies 获取 cookie，返回值为 Cookie 实例构成的数组（Cookie 类用于便捷处理 cookie）。 getRequestedSessionId 获取 sessionId。 getSession 获取 session，返回值为 HttpSession 实例（HttpSession 类用于便捷处理 session）。 getHeader 获取请求头。 newPushBuilder 通过 PushBuilder 伪造请求等。 servletResponse 用于生成响应。同样，容器既实现了 ServletResponse 接口，又实现了 ServletOutputStream 抽象类，通过 servletOutputStream.write 方法可读取请求内容。servletResponse.getOutputStream 方法返回 ServletOutputStream 实例，便于以二进制形式发送数据；servletResponse.getWriter 方法返回 PrintWriter 实例，便于以字符串形式发送数据。因为 http 会在发送响应前先发送响应头，所以响应头需要提前创建。 继承 ServletResponse 的 HttpServletResponse 接口增加了如下功能： 加密 url。 添加 cookie。 设置响应头。 设置状态码。 sendError 发送错误响应。 sendRedirect 重定向。 额外的，javax.servlet.http 提供了 HttpServletRequestWrapper, HttpServletResponseWrapper 允许开发者以子类的形式制作适配器，便于快速处理请求和响应。 HttpServletjavax.servlet 中的 GenericServlet 抽象类同时实现了 Servlet, ServletConfig 接口，因此 GenericServlet 子类既可以实现 init, service, destory 生命周期方法，又可以获取初始参数、servletConfig。 抽象类 HttpServlet 就是 GenericServlet 的子类，在其保护方法 service 中，将根据请求方式的不同分别调用 doGet 等方法处理请求。HttpServlet 子类可实现的方法包含： doGet 处理 get 请求。 doHead 处理 head 请求，只返回响应头。 doPost 处理 post 请求。 doPut 处理 put 请求，用于发送文件等。 doDelete 处理 delete 请求，用于删除服务端的文件等。 doOptions 处理 options 请求，通过 ALLOW 响应头获得服务端对请求路由支持的请求方式，比如通过实现 doGet 方式判断是否支持 get 请求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public abstract class HttpServlet extends GenericServlet &#123; private static final String HEADER_IFMODSINCE = \"If-Modified-Since\"; protected long getLastModified(HttpServletRequest req) &#123; return -1; &#125; private void maybeSetLastModified(HttpServletResponse resp, long lastModified) &#123; if (resp.containsHeader(HEADER_LASTMOD)) return; if (lastModified &gt;= 0) resp.setDateHeader(HEADER_LASTMOD, lastModified); &#125; protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; doGet(req, resp); &#125; else &#123; long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); &#125; catch (IllegalArgumentException iae) &#123; ifModifiedSince = -1; &#125; // 资源更新 if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; String errMsg = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; request = (HttpServletRequest) req; response = (HttpServletResponse) res; &#125; catch (ClassCastException e) &#123; throw new ServletException(lStrings.getString(\"http.non_http\")); &#125; service(request, response); &#125;&#125; annotationjavax.servlet.annotation 提供了一些常用注解： WebServlet 声明 Servlet，设置初始化参数、路由规则等。 WebFilter 声明 Filter。 MultipartConfig 声明 Servlet 将用于处理文件上传操作，期望请求头的媒体类型为 multipart/form-data。 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MultipartConfig &#123; // 容器暂存文件的临时目录 String location() default \"\"; long maxFileSize() default -1L; long maxRequestSize() default -1L; // 文件多大时写入临时目录，小于此值的作内存缓存 int fileSizeThreshold() default 0;&#125; 并发Servlet 容器包含可复用线程组成的线程池，避免创建、销毁线程带来的性能消耗。当容器接收到请求时，它将在线程池中取出可用的线程处理请求。当没有可用的线程时，请求将被放入到一个先进先出队列中等待处理。多线程所带来的问题是，Servlet 中的静态属性和实例属性可以被多个线程同时访问，这样就可能会引起一致性问题：在某个线程中已修改的实例属性不能被并行处理的另一个线程感知到。在多线程的情况中，方法创建的对象和变量在发放执行过程中都是安全的，其他线程没法访问到它们。因此，我们需要避免使用静态属性或实例属性缓存可变内容；非到万不得已，可使用 synchronized 同步代码块处理，保证其他线程无法同时执行代码。 小结可借鉴的点： 协调组件生命周期的容器，在前端层面可以构建管理 page 的容器。 使用抽象类和接口设立规范。 参考Package javax.servletJavaWeb——Servlet（全网最详细教程包括Servlet源码分析）ServletContext理解学习servlet 3.0笔记之servlet的动态注册Servlet3.0的异步Java Web基础知识之Filtertomcat 与 nginx，apache的区别及优缺点Java中synchronized的用法","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"web 服务","slug":"backend/web-服务","permalink":"http://xzfyu.com/categories/backend/web-服务/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"}]},{"title":"Spring Boot试水","slug":"backend/spring/spring boot试水","date":"2019-03-16T16:00:00.000Z","updated":"2020-03-08T11:15:16.371Z","comments":true,"path":"2019/03/17/backend/spring/spring boot试水/","link":"","permalink":"http://xzfyu.com/2019/03/17/backend/spring/spring boot试水/","excerpt":"","text":"Spring Boot 使用了约定大于配置的理念，极大地简化了 Spring 项目的配置环节。 搭建项目 安装 Java, Maven, IntelliJ IDEA。为 Java, Maven 配置环境变量。 通过 IDEA 创建项目：create project - spring initializr - 设置 name（项目名）, GroupId（项目所属组织的唯一标识符）, ArtifactId（项目在组中的唯一标识符） 等 - 初始化选择 dependencies，暂且只选择 web - 设置 project name。IDEA 会自动创建 pom.xml 文件和启动类等。 删除 .mvn, mvnw, mvnw.cmd。 Maven 面板点击 Reimport All Maven Projects，以加载依赖及插件。 项目的启动类右键选择 Run/Debug。这会自动生成本地调试模式的 Configuration 配置文件。启动成功后，就可以在 localhost:8080 访问页面了。 编写 controller，访问 localhost:8080/hello 测试内容。 12345678910111213141516// src/main/java 目录下的启动类，右键选择 Run/Debug 启动@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;// controller 目录 HelloController.java@RestControllerpublic class HelloController &#123; @RequestMapping(value = \"/hello\", method = RequestMethod.GET) public String index()&#123; return \"Hello World!\"; &#125;&#125; 备注： GroupId 同 ArtifactId 一起构成 Maven 项目的唯一性。 初始化选择 web 将在 pom.xml 文件中添加 spring-boot-starter-web 依赖。作为 starter pom，spring-boot-starter-web 实际整合了 spring-boot-starter, spring-boot-starter-tomcat, spring-web, spring-webmvc, hibernate-validator 等包（参考 https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web/2.1.3.RELEASE），以简化 Maven 配置。在项目中执行 mvn dependency:tree 命令，既可以下载依赖，又可以查看依赖的结构。同时，内嵌 Tomcat 的方式，也使 Spring Boot 项目无须以 war 包形式部署。Spring Boot 还支持 Jetty, Undertow 等 Servlet 容器。 Java 1.5 版本过时报错问题：检查 Project Structure - Project | Modules 指定的当前项目 jdk 版本、Setting - Java Compiler 指定的 Java 版本是否正确。 Maven 配置阿里云中央仓库。在 IDEA 中，pom.xml 点击 Alt + Insert 可以快速添加依赖；在添加过程中，可以到阿里 maven查看依赖的版本。IDEA 支持自动导入包。 @SpringBootApplication 实际是个组合注解，包含 @Configuration, @EnableAutoConfiguration, @ComponentScan。@EnableAutoConfiguration 作用是从 classpath 中搜索所有 META-INF/spring.factories 配置文件，然后将其中 org.springframework.boot.autoconfigure.EnableAutoConfiguration 置为 true 的配置项加载到 spring 容器中，并启用自动配置。@ComponentScan 使 Spring Boot 自动扫描启动类同级目录及其下集目录，以自动加载 Bean。@Configuration用于定义配置类，可以被 AnnotationConfigApplicationContext 或 AnnotationConfigWebApplicationContext 类扫描到，用于构建配置类内部的 Bean，以初始化 Spring 容器。 jetty如果想用禁用 Tomcat，使用其他 servlet 容器如 Jetty，pom.xml 文件可以作如下修改： 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 参考IDEA快捷键Maven的构建生命周期理解starter pom详解@EnableAutoConfiguration注解原理@Configuration详解idea创建springboot多模块项目 配置文件Spring Boot 支持使用 application.properties 或 application.yml 作为全局配置文件，通常会配置在 src/main/resources 目录下。Spring Boot 项目的启动类会搜索并加载配置文件来获取配置项。搜索的文件目录包含当前目录的 config 子目录、当前目录、classpath 中的 config 包、classpath。通过 spring.config.location 添加额外的配置文件搜索路径。 配置文件中的配置项可以通过 @Value 注入到 Bean 中，如 @Value(“${alfred.test}”)。配置文件中的配置项也可以通过 @ConfigurationProperties 注解构建 POJO 读取，如 @ConfigurationProperties(prefix = “alfred”) 读取。 1234567// application.ymlserver: port: 9090// application-dev.ymlalfred: test: '测试' 123456789101112131415@RestController@RequestMapping(value = \"/alfred\")public class AlfredController &#123; private static String test; @Value(\"$&#123;alfred.test&#125;\") public void setTest(String test) &#123; AlfredController.test = test; &#125; @RequestMapping(value = \"/test\", method = RequestMethod.GET) public String getTest()&#123; return this.test; &#125;&#125; 针对不同的环境，Spring 支持创建 application-dev.yml, application-test.yml, application-prod.yml 文件，并在 application.yml 指定当前所采用的配置文件，这被称为 Profile 配置。 1234// application.ymlspring: profiles: active: dev 参考@Value详解spring boot 使用@ConfigurationProperties Controller 那些事首先来看一下 Spring MVC 提供的一些注解： @Controller：组合了 @Component，声明一个控制器。 @RestController：组合注解，组合了 @Controller 和 @ResponseBody，将返回值放在 response 体内，以传递 json 数据。 @ResponseBody：将 controller 返回值放在 response 体内。 @RequestMapping：用于映射 Web 请求（访问路径和参数）、处理类和方法等。@RequestMapping 支持 Servlet 的 request 和 response 作为参数，也支持对 request 和 response 的媒体类型进行配置。典型形式如如 @RequestMapping(‘/users’) 或 @RequestMapping(value = ‘/users’, method = RequestMethod.GET) 或 @RequestMapping(path = “/users”, method = RequestMethod.PUT, consumes = “application/json”) 或 @RequestMapping(path = “/users”, method = RequestMethod.POST, produces = “application/json;charset=UTF-8”) 或 @RequestMapping(path = “/users”, method = RequestMethod.GET, params = “myParam=myValue”) 或 @RequestMapping(path = “/pets”, method = RequestMethod.GET, headers = “myHeader=myValue”)。method 请求方法可以是 RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE。 @GetMapping，@PostMapping, @PutMapping, @DeleteMapping, @PatchMapping：简便形式映射 get, post 等请求。 @PathVariable：用来接收路径参数，如 users/{id} 路径中的 id。 @RequestParam：用来接收 get, post 请求中查询路径中的参数，可处理 Content-Type: application/x-www-form-urlencoded 编码格式的数据，形式如 @RequestParam(value=”id”) int id。 @RequestBody：用来接收 json 格式的数据，可将其转换成对应的数据类型，一般用于处理非 Content-Type: application/x-www-form-urlencoded 编码格式的数据，不能处理 get 请求。 @ModelAttribute：将参数绑定到 Model 对象上。 @RequestHeader：获取消息头中的内容。 @CookieValue：用来接收 cookie 的值。 @SessionAttributes：用来将指定实体类的数据存储到 session，一般用在类级别。 @SessionAttribute：用来接收已经存储的 session，一般用在方法级别。 @RequestAttribute：用来接收请求参数，一般用在过滤器或拦截器上。 HttpServletRequest：获取请求内容。 针对请求头 ContentType 指定的编码格式，有如下三种情况： application/x-www-form-urlencoded：@RequestParam, @ModelAttribute, @RequestBody 均可以处理。 multipart/form-data：不能使用 @RequestBody 处理（form表单中有文件时，必须指定 enctype 属性为 multipart/form-data，意为以二进制流的形式传输文件）。 application/json、application/xml等：必须使用 @RequestBody 处理。 针对 ajax 请求，首先制作 ResultUtil 统一处理返回值；然后使用注解编写 controller，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// 使用 ResultUtil 统一处理返回值public class Result&lt;T&gt; &#123; private Integer code; private String msg; private Boolean success; private T data; public Integer getCode()&#123; return code; &#125; public void setCode(Integer code)&#123; this.code = code; &#125; public String getMsg()&#123; return msg; &#125; public void setMsg(String msg)&#123; this.msg = msg; &#125; public Integer getSuccess()&#123; return success; &#125; public void setSuccess(Boolean success)&#123; this.success = success; &#125; public T getData()&#123; return data; &#125; public void setData(T data)&#123; this.data = data; &#125;&#125;public class ResultUtil &#123; public static Result success(Object object)&#123; Result result = new Result(); result.setCode(200); result.setMsg(\"success\"); result.setSuccess(true); result.setData(object); return result; &#125; public static Result success()&#123; return success(null); &#125; public static Result error(Integer code, String msg)&#123; Result result = new Result(); result.setCode(code); result.setMsg(msg); result.setSuccess(false); result.setData(null); return result; &#125;&#125;// controller@RequestMapping(\"/request\")@RestControllerpublic class RequestController &#123; @RequestMapping(value = \"/pathVariableTest/&#123;id&#125;\") public Result pathVariableTest(@PathVariable int id)&#123; return ResultUtil.success(); &#125; @RequestMapping(value = \"/requestParamTest\") public Result requestParamTest(@RequestParam(value = \"id\") int id)&#123; return ResultUtil.success(); &#125; @RequestMapping(value = \"/requestBodyTest\", method = RequestMethod.POST) public Result requestBodyTest(@RequestBody User user)&#123; return ResultUtil.success(user); &#125; @RequestMapping(value = \"/modelAttributeTest\", method = RequestMethod.POST) public Result modelAttributeTest(@ModelAttribute User user)&#123; return ResultUtil.success(user); &#125; @RequestMapping(value = \"httpServletRequestTest\", method = RequestMethod.POST) public Result httpServletRequestTest(HttpServletRequest request)&#123; return ResultUtil.success(request); &#125;&#125; 针对页面，Spring Boot 支持使用 FreeMarker, Groovy, Thymeleaf, Velocity, Mustache 作为模板引擎，推荐使用 Thymeleaf，因为其提供了完美的 Spring MVC 的支持。编写方法为：pom.xml 文件添加 thymeleaf 依赖，制作 controller 直接返回页面模板在 resources/templates 中的位置，添加 html 页面。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 1234567@Controllerpublic class ThymeleafController &#123; @RequestMapping(\"/\") public String index()&#123; return \"index\"; &#125;&#125; 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; just a demo&lt;/body&gt;&lt;/html&gt; 参考@RequestParam、@RequestBody和@ModelAttribute区别@SessionAttributes与@SessionAttribute会话数据控制HttpServletRequest对象利用 Spring Boot 设计风格良好的Restful API及错误响应springboot使用hibernate validator校验 AOP面向切面编程能把横切关注点和业务逻辑相互分离开，以便于为横切关注点单独制作模块。通常，横切关注点包括日志、安全和事务管理等通用内容。以比方论，面向切面编程就是在一个处理过程中定位一个切点，然后在这个切点前后添加一个或多个动作；其实现依赖于 Java 编程的同步性。因此，面向切面编程需要包含切点定位、动作定义、动作相对于切点的执行位置等。在一个处理过程中添加动作本可以借助显式调用函数的方式实现，但这样处理过程就会与一个或多个特定的动作高度耦合，且当另一个处理过程需要添加这一个或多个特定的动作时，仍需要显式调用。如果在处理过程中插入一个空跑的函数声明这是个切点，然后再使用代理封装该函数，就可以在切点前后以松耦合的方式执行特定动作了。特定动作和待封装的函数可能是一对多的关系。spring AOP 以切面（Aspect）为视角，首先以切点（PointCut）声明待封装的函数在哪个位置，其次使用 @After, @Before, @Around 注解声明在切点前后需要执行哪些动作。使用 @PointCut 定义切点是不必要的，它只是一种语法糖；因为在 @After 注解后可直接使用 execution 表达式锁定待封装函数的位置，同时 execution 表达式也能定位到多个待封装函数。特别的，当 execution 表达式定位 controller 时，就可以对特定或所有的 controller 进行拦截，而无需插入在 controller 插入定义为连接点（JoinPoint）的动作，controller 就作为连接点。想要实现这一过程，spring 容器在创建 controller 等定义了连接点的实例时，就必须知道哪些是 Aspect，且这些 Aspect 都需要注明为 Bean 以实例化，然后再使用这些实例去封装定义了连接点的实例。基于上述，AOP 有三种使用方式： execution 表达式直接定位 controller, service 的方法。 execution 表达式定位辅助类，再通过辅助类将 controller, service 的方法声明为连接点。 execution 表达式定位辅助类，在 controller, service 中显式调用辅助类中作为连接点的方法。 编码过程如下： 使用 @Aspect, @Bean 注解声明一个切面。 在切面中使用 @After, @AfterReturning, @AfterThrowing, @Before, @Around 注解定义一个建言（advice）。或者以 execution 表达式定位连接点的位置；或者在切面中 @PointCut 定义切点，并在 @After, @AfterReturning, @AfterThrowing, @Before, @Around 注解中使用该切点作为参数。 controller, service 的方法作为连接点，无需额外编程；辅助类的方法作为连接点，或者在 controller, service 的方法上添加注解，或者在 controller, service 的方法中显示调用辅助类的方法。 本节以 AOP 统一日志处理为例，说明其使用过程： （1）pom.xml 添加 aop, log4j 依赖。123456789101112131415161718192021&lt;!-- 禁用默认日志模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;&lt;/dependency&gt; （2）resources 目录中添加 log4j.properties 配置文件。12345678910111213141516171819202122log4j.rootLogger=INFO, CONSOLE, ROLLING_FILE, DAILY_ROLLING_FILElog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=&lt;%d&gt;[%5p] %m - %c%nlog4j.appender.ROLLING_FILE=org.apache.log4j.RollingFileAppenderlog4j.appender.ROLLING_FILE.File=./logs/client.loglog4j.appender.ROLLING_FILE.Append=truelog4j.appender.ROLLING_FILE.MaxFileSize=20000KBlog4j.appender.ROLLING_FILE.MaxBackupIndex=100log4j.appender.ROLLING_FILE.layout=org.apache.log4j.PatternLayout#log4j.appender.ROLLING_FILE.layout.ConversionPattern=&lt;%d&gt;[%5p] %c - %m%nlog4j.appender.ROLLING_FILE.layout.ConversionPattern=%d %c [%t] (%F:%L) %-5p --&gt; %m%nlog4j.appender.DAILY_ROLLING_FILE=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.DAILY_ROLLING_FILE.File=./logs/clientlog4j.appender.DAILY_ROLLING_FILE.DatePattern='.'yyyy-MM-dd'.log'log4j.appender.DAILY_ROLLING_FILE.Append=truelog4j.appender.DAILY_ROLLING_FILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.DAILY_ROLLING_FILE.layout.ConversionPattern=%d %c [%t] (%F:%L) %-5p --&gt; %m%n （3）制作 Aspect 类。12345678910111213141516171819202122232425262728293031323334@Aspect@Component@Order(1)public class LogAspect &#123; private Logger log = Logger.getLogger(LogAspect.class); //申明一个切点 里面是 execution表达式 @Pointcut(\"@annotation(com.example.demo.aop.Log)\") private void controllerAspect()&#123;&#125; //请求method前打印内容 @Before(\"execution(public * com.example.demo.controller..*.*(..))\") public void methodBefore(JoinPoint joinPoint)&#123; ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = requestAttributes.getRequest(); //打印请求内容 log.info(\"===============请求内容===============\"); log.info(\"请求地址:\"+request.getRequestURL().toString()); log.info(\"请求方式:\"+request.getMethod()); log.info(\"请求类方法:\"+joinPoint.getSignature()); log.info(\"请求类方法参数:\"+ Arrays.toString(joinPoint.getArgs())); log.info(\"===============请求内容===============\"); &#125; //在方法执行完结后打印返回内容 @AfterReturning(returning = \"o\",pointcut = \"controllerAspect()\") public void methodAfterReturing(Object o)&#123; log.info(\"--------------返回内容----------------\"); log.info(\"Response内容:\" + JSON.toJSONString(o)); log.info(\"--------------返回内容----------------\"); &#125;&#125; （4）声明辅助类。123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Log &#123; String log();&#125; （5）被拦截的处理过程。123456789@RestController@RequestMapping(value = \"/aop\")public class AopController &#123; @Log(log = \"注解式拦截的方法\") @RequestMapping(value = \"/test\", method = RequestMethod.GET) public Result getTest()&#123; return ResultUtil.success(); &#125;&#125; 参考Spring Boot项目中使用log4jannotation(@Retention@Target)详解 mybaitsSpring Boot 中整合 mybaits 有两种方式：基于注解或者基于 xml 配置。 （1）pom.xml 添加 mysql, mybatis 依赖。123456789101112&lt;!-- mysql 连接依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; （2）修改配置文件。1234567891011spring: datasource: url: jdbc:mysql://localhost:3306/demo username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver# 基于 xml 配置添加mybatis: mapper-locations: classpath:mapping/*Mapper.xml type-aliases-package: com.example.demo （3）制作 mapper 文件或 *Mapper.xml 文件，以及实体类。（3.1）实体类：1234567891011121314151617181920public class User &#123; private Integer id; private String nickName; public Integer getId()&#123; return id; &#125; public void setId(Integer id)&#123; this.id = id; &#125; public String getNickName()&#123; return nickName; &#125; public void setNickName(String nickName)&#123; this.nickName = nickName; &#125;&#125; （3.2）基于注解的方式：123456789101112131415// dao/mapper 层制作 mapper 文件@Mapperpublic interface MybatisUserAnnotationMapper &#123; @Select(\"SELECT id,nickname FROM demo.user WHERE id = #&#123;id&#125;\") User getUser(@Param(\"id\") Integer id); @Insert(\"INSERT INTO demo.user(nickname)\") void createUser(Map&lt;String, Object&gt; reqMap); @Update(\"UPDATE demo.user SET nickname = #&#123;nickName&#125; WHERE id = #&#123;id&#125;\") void updateUser(@Param(\"id\") Integer id, @Param(\"nickName\") String nickName); @Delete(\"DELETE FROM demo.user WHERE id = #&#123;id&#125;\") void delete(@Param(\"id\") Integer id);&#125; （3.2）基于 xml 配置：1234567891011// dao/mapper 层制作 mapper 文件@Mapperpublic interface MybatisUserAnnotationMapper &#123; User getUser(@Param(\"id\") Integer id); void createUser(Map&lt;String, Object&gt; reqMap); void updateUser(@Param(\"id\") Integer id, @Param(\"nickName\") String nickName); void delete(@Param(\"id\") Integer id);&#125; 123456789101112131415161718192021&lt;!-- resources/mapper 中添加 mapper.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.example.demo.dao.mapper.MybatisUserAnnotationMapper\"&gt; &lt;select id=\"getUser\" resultType=\"com.example.demo.dao.entity.User\"&gt; SELECT id,nickname FROM demo.user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=\"createUser\" parameterType=\"java.util.Map\"&gt; INSERT INTO demo.user(nickname) VALUES (#&#123;nickname&#125;) &lt;/insert&gt; &lt;update id=\"updateUser\"&gt; UPDATE demo.user SET nickname = #&#123;nickName&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=\"delete\"&gt; DELETE FROM demo.user WHERE id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; druiddruid 是阿里推出的数据库监控驱动。 （1）添加 druid 依赖。 123456&lt;!-- druid 数据库监控驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt; （2）修改配置文件。 12345678910111213141516171819202122spring: datasource: url: jdbc:mysql://localhost:3306/demo username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 filters: stat,wall,log4j connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 useGlobalDataSourceStat: true （3）添加 DruidConfig 文件。 1234567891011121314151617181920212223242526272829@Configurationpublic class DruidConfig &#123; private Logger log = Logger.getLogger(LogAspect.class); @Bean @ConfigurationProperties(\"spring.datasource\") public DataSource druidDataSource() &#123; return new DruidDataSource(); &#125; @Bean public ServletRegistrationBean druidStatViewServlet() &#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); registrationBean.addInitParameter(\"allow\", \"127.0.0.1\");// IP白名单 (没有配置或者为空，则允许所有访问) registrationBean.addInitParameter(\"deny\", \"\");// IP黑名单 (存在共同时，deny优先于allow) registrationBean.addInitParameter(\"loginUsername\", \"admin\"); registrationBean.addInitParameter(\"loginPassword\", \"123456\"); registrationBean.addInitParameter(\"resetEnable\", \"false\"); return registrationBean; &#125; @Bean public FilterRegistrationBean druidWebStatViewFilter() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(new WebStatFilter()); registrationBean.addInitParameter(\"urlPatterns\", \"/*\"); registrationBean.addInitParameter(\"exclusions\", \"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\"); return registrationBean; &#125;&#125; （4）localhost:9090/druid/index.html 登录访问监控数据。 参考Homebrew介绍和使用Homebrew安装Mysql步骤及注意事项（配合Navicat使用）mysql 报错Authentication method ‘caching_sha2_password’ is not supportedspringboot中使用Druid redis（1）pom.xml 添加 redis, jedis 依赖。123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; （2）添加 config/RedisConfig 文件。123456789101112131415161718192021222324@Configurationpublic class RedisConfig &#123; @Value(\"$&#123;spring.redis.host&#125;\") private String host; @Value(\"$&#123;spring.redis.port&#125;\") private Integer port; @Value(\"$&#123;spring.redis.password&#125;\") private String password; @Bean public ShardedJedisPool shardedJedisPool()&#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMinIdle(100); jedisPoolConfig.setMaxIdle(1000); jedisPoolConfig.setMaxTotal(10000); ArrayList&lt;JedisShardInfo&gt; arrayList = new ArrayList&lt;&gt;(); JedisShardInfo redisShardInfo = new JedisShardInfo(host, port); redisShardInfo.setPassword(password); arrayList.add(redisShardInfo); return new ShardedJedisPool(jedisPoolConfig, arrayList); &#125;&#125; （3）制作 RedisUtils 模块。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// redis/RedisUtilspublic interface RedisUtils &#123; /** * set存数据 * @param key * @param value * @return */ String set(String key, String value); /** * get获取数据 * @param key * @return */ String get(String key); /** * 设置有效天数 * @param key * @param expire * @return */ Long expire(String key, Integer expire); /** * 移除数据 * @param key * @return */ Long del(String key);&#125;// redis/RedisUtilsImpl@Componentpublic class RedisUtilsImpl implements RedisUtils &#123; @Autowired(required = false) private ShardedJedisPool shardedJedisPool; private &lt;T&gt; T excute(Function&lt;ShardedJedis, T&gt; func)&#123; ShardedJedis shardedJedis = shardedJedisPool.getResource(); return func.apply(shardedJedis); &#125; @Override public String set(final String key, final String value) &#123; return excute(e -&gt; e.set(key, value)); &#125; @Override public String get(final String key) &#123; return excute(e -&gt; e.get(key)); &#125; @Override public Long expire(final String key, Integer expire) &#123; return excute(e -&gt; e.expire(key, expire)); &#125; @Override public Long del(final String key) &#123; return excute(e -&gt; e.del(key)); &#125;&#125; （4）使用。12345678910111213141516@RestController@RequestMapping(\"/redis\")public class RedisController &#123; @Resource RedisUtils redisUtils; @RequestMapping(value = \"/set/&#123;str&#125;\", method = RequestMethod.GET) public String set(@PathVariable(\"str\") String str)&#123; return redisUtils.set(\"test\", str); &#125; @RequestMapping(value = \"/get\", method = RequestMethod.GET) public String get()&#123; return redisUtils.get(\"test\"); &#125;&#125; 参考MAC使用homeBrew安装Redis 定时任务（1）启动类中添加 @EnableScheduling 注解开启定时任务。12345678@ComponentScan(basePackages = \"com.example.demo.*\")@SpringBootApplication@EnableSchedulingpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; （2）实现定时任务 service。12345678@Componentpublic class QuartzService &#123; // 每分钟执行 @Scheduled(cron = \"0 0/1 * * * ?\") public void timerToNow()&#123; System.out.println(\"now time:\" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); &#125;&#125; 参考cron表达式 参考Spring Boot文档Spring MVC文档","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"spring","slug":"backend/spring","permalink":"http://xzfyu.com/categories/backend/spring/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"java","slug":"java","permalink":"http://xzfyu.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://xzfyu.com/tags/spring/"}]},{"title":"浏览器渲染机制及性能优化","slug":"frontend/architecture/浏览器渲染机制及性能优化","date":"2019-03-02T16:00:00.000Z","updated":"2020-03-08T10:42:40.983Z","comments":true,"path":"2019/03/03/frontend/architecture/浏览器渲染机制及性能优化/","link":"","permalink":"http://xzfyu.com/2019/03/03/frontend/architecture/浏览器渲染机制及性能优化/","excerpt":"","text":"网页渲染机制网页渲染过程包含页面加载和页面渲染两个过程。页面加载过程指的是从服务器请求资源并构建 DOM 树的过程。网页渲染过程指的是通过 DOM 树渲染出视图内容。这两个过程有重合内容，因为异步加载的 js 脚本可能会修改 DOM 结构。 在 webkit 中，针对不同类型的资源，会有多个加载类进行处理。其大体策略为：先从本地缓存池中查找资源；如果找不到，再从网络上获取以 url 为标识的资源。缓存分为两种：其一是内存缓存，其二是磁盘缓存。页面资源通常是同步加载；以同步模式加载 js 资源时会打断 DOM 树的构建。 浏览器首先加载网页内容，使用 html 解释器将网页转变成一系列的 token，再根据 token 构建 DOM 树。当一个可见的 DOM 节点（不包含 head 元素和 display 置为 none 的节点）插入到 DOM 树时，浏览器就会构建一个 RenderObject 节点并将其插入到 Render 树中（Render 树即 RenderObject 节点构成的树）。Render 树包含节点的样式信息，可以简单地理解为由 DOM + CSS 构成（css 样式会经由 css 解释器计算出各元素的样式，然后再将挂到 RenderObject 节点上）。Render 树将交由排版引擎处理，计算出每一个 RenderObject 节点的大小和位置等信息；然后再交由渲染引擎完成页面内容的绘制。 在 Render 树之外，为方便处理 Positioning（定位），Clipping（裁剪），Overflow-scroll（页內滚动），CSS Transform/Opacity/Animation/Filter，Mask or Reflection，Z-indexing（Z排序）等，浏览器还会生成 Layer 树。比如根节点从属于一个 RenderLayer 节点，绝对定位的节点从属于另一个 RenderLayer 节点，这样就能有效地处理视图元素的层次结构。如果某 DOM 节点没有对应的 RenderLayer，就从属于父节点的 RenderLayer。 Layer 树会交由浏览器渲染引擎处理。渲染引擎首先以一个布局信息不够明确的矩形绘制 RenderLayer 节点；再向下遍历子 RenderLayer 节点，并完成相关的 RenderObject 节点的绘制；然后向上递归并调整 RenderLayer 节点的布局（即回流）。可以理解的是，Render 树决定了网页的内容，Layer 树决定了网页的层次结构。RenderLayer 布局由 CPU 处理，并将位图作为纹理上传给 GPU，由 GPU 绘制内容并缓存（缓存的意义在于避免重绘）。完整过程如下： 对于网页中的 js 脚本，浏览器首先会使用 js 引擎解释脚本，然后再通过 DOM 接口和 CSSOM 接口修改网页内容和样式，最终也以影响 Render 树的方式干预绘制过程。 在 chrome 浏览器中，F12 开发者工具 - more tools - Layers、rendering 插件可用于查看网页层级及渲染性能。 Navigation TimingNavigation Timing 说明了当用户在键入 url 后，浏览器中所发生的行为过程，主要包含：unload（卸载前一份文档），redirect（重定向），App Cache（重用缓存资源），DNS（DNS 查询） ，TCP（建立 TCP 连接），Request（请求网络资源），Processing（DOM 构建），onload（资源加载完成）。见下图： Performance API 可用于分析网页的渲染性能，如： 1234567891011121314151617181920212223242526const performanceTest = () =&gt; &#123; const &#123; timing &#125; = performance; const readyStart = timing.fetchStart - timing.navigationStart; const redirectTime = timing.redirectEnd - timing.redirectStart; const appcacheTime = timing.domainLookupStart - timing.fetchStart; const unloadEventTime = timing.unloadEventEnd - timing.unloadEventStart; const lookupDomainTime = timing.domainLookupEnd - timing.domainLookupStart; const connectTime = timing.connectEnd - timing.connectStart; const requestTime = timing.reponseEnd - timing.requestStart; const initDomTreeTime = timing.domInteractive - timing.reponseEnd; const domReadyTime = timing.domComplete - timing.domInteractive; const loadEventTime = timing.loadEventEnd - timing.loadEventStart; const loadTime = timing.loadEventEnd - timing.navigationStart; console.log(`准备新页面时间耗时：$&#123;readyStart&#125;`); console.log(`redirect 重定向耗时：$&#123;redirectTime&#125;`); console.log(`Appcache 耗时：$&#123;appcacheTime&#125;`); console.log(`unload 前文档耗时：$&#123;unloadEventTime&#125;`); console.log(`DNS 查询耗时：$&#123;lookupDomainTime&#125;`); console.log(`TCP 连接耗时：$&#123;connectTime&#125;`); console.log(`request 请求耗时：$&#123;requestTime&#125;`); console.log(`请求完毕至 DOM 加载：$&#123;initDomTreeTime&#125;`); console.log(`解析 DOM 树耗时：$&#123;domReadyTime&#125;`); console.log(`load 事件耗时：$&#123;domReadyTime&#125;`); console.log(`加载时间耗时：$&#123;loadTime&#125;`);&#125; 单资源加载过程点开浏览器\b Network 面板，鼠标悬浮在某资源的 waterfall 区域，可以查看某一资源的加载过程。如下图： Queuing：请求排队中。在 HTTP 1 上，浏览器仅允许每个源拥有六个 TCP 连接；若请求的资源为低优先级资源，将让位给高优先级的样式或脚本资源 Stalled：请求等待发送所用的时间，包含代理协商所用的任何时间 DNS Lookup：执行 DNS 查询所用的时间。页面上的每一个新域都需要完整的往返才能执行 DNS 查询 Initial Connection：建立连接所用的时间，包括 TCP 握手/重试和协商 SSL 的时间 SSL：完成 SSL 握手所用的时间 Request Sent：发出网络请求所用的时间 Waiting(TTFB)：等待初始响应所用的时间，也称为至第一字节的响应时间 Content Download：接收响应数据所用的时间 performance.getEntries() 可用于获取页面所有资源的 performance timing 情况。 回流、重绘回流（重排）指的是，当元素的布局或显示等信息改变时，引起 Render 树部分或整体的重新构建，即网页布局的调整。重绘指的是，Render 树中节点属性的更新。因此，回流必然会引起重绘，重绘不一定引起回流。与布局无关的元素属性操作将只引起重绘，否则将同时引起回流和重绘。可能引起回流、重绘的行为如下： 添加、删除元素（回流+重绘） 隐藏元素：display:none（回流+重绘）；visibility:hidden（只重绘，不回流） 移动元素：改变 top,left（不一定引起回流）；将元素移动到另一个父元素中（回流+重绘）等 改变 style：布局相关属性如 padding, border-width, font-size（回流+重绘）；布局无关属性（只重绘，不回流）。可查看 https://csstriggers.com/ 以获取更多信息 用户操作：改变浏览器大小，改变浏览器的字体大小等（回流+重绘） 回流的开销比重绘大。如果 body 顶部插入一个节点，将引起整个 body 的回流；如果尾部插入一个节点，将只引起部分内容的回流，因此开销较小。浏览器为提升回流、重绘的性能，会构建队列以执行批量处理。但是，访问节点的 offsetTop, scrollTop, clientTop, width, height 类属性或调用了 getComputedStyle 方法，将迫使浏览器提前执行队列以获得最新的样式。减少回流、重绘的方法如下： className 或 cssText 批量更新样式，避免单属性操作引起的频繁回流或重绘 新创建的元素改完样式后，再插入文档；或者先将节点的 display 属性置为 none，调整样式后再置回显示状态 使用变量缓存元素的样式，避免频繁读取元素的样式，致使浏览器提前执行回流队列（以计算元素的布局信息） 指定图片的宽高，避免新加载的图片调整大小时引起的回流 [慎用]使频繁回流、重绘的元素单独有一个 RenderLayer：借助 video 元素、WebGL、Canvas、CSS3 3D、CSS滤镜、z-index 大于某个相邻节点的元素都会有独立的 RenderLayer，比如通过添加 transform: translateZ(0);backface-visibility: hidden; 样式即可。 回流、重绘可借助 dynaTrace（测试ie）、Speed Tracer（测试Chrome） 测试。 性能分析performancePerformance API 除了可以用于分析网页渲染过程的性能外，也可以用于分析某个方法的执行性能等。 performance.memory：内存占用的具体数据 performance.now()：获取从 navigationStart 到当前时间的时间，可用于计算方法的执行时间 performance.mark(markName)：给相应的视点做标记 performance.measure(name, startMark, endMark)：计算方法的执行时间 performance.getEntriesByName(name)：获取指定 measure performance.clearMarks()：清除标记 performance.clearMeasures()：清除 measure profileconsole.profile() 或 console.profileEnd() 可用于分析 js 脚本的内存、cpu 占用情况。以下代码为使用 performance，profile 监控某方法执行性能的示例（）。 12345678910111213141516171819202122232425262728293031323334353637const analyse = (fn, options) =&gt; &#123; const &#123; measureName &#125; = options; performance.mark(`$&#123;measureName&#125;-start`); console.profile(); fn(); console.profileEnd(); // 标记一个结束点 performance.mark(`$&#123;measureName&#125;-end`); // 标记开始点和结束点之间的时间戳 performance.measure( measureName, `$&#123;measureName&#125;-start`, `$&#123;measureName&#125;-end`, ); // 获取所有名称为mySetTimeout的measures const measures = performance.getEntriesByName(measureName); const measure = measures[0]; console.log(`$&#123;measureName&#125; milliseconds: $&#123;measure.duration&#125;`); // 清除标记 performance.clearMarks(); performance.clearMeasures();&#125;;analyse(() =&gt; &#123; for (let i = 0; i &lt; 1000; i++)&#123; console.log(i + 1); &#125;;&#125;, &#123; measureName: 'cycle'&#125;); 分析工具 chrome 浏览器的 Page Speed 扩展工具能帮助我们查看网页加载性能，并给出有效的建议。 性能优化YSlow 性能优化原则主要包含网络加载类、页面渲染类、css 优化类、js 执行类、缓存类、图片类、架构协议类等几大类。概要性总结如下： 网络加载类 减少 http 请求次数，可以利用构建工具合并文件、使用雪碧图等。原因是浏览器同域资源的请求数有所限制。 减小 http 请求大小，可以利用构建工具压缩混淆 js 脚本或 css 样式，使用 base64 图片等。 避免使用 style 或 script 标签直接引入代码块，使用外部文件引入（这样做会增加请求数，手机端可以酌情引入样式、代码块）。 避免空的 href 和 src。原因是渲染过程中仍会引起加载动作。 为 html 指定 Cache-Control 或 Expires 以缓存页面。如 12&lt;meta http-equiv=\"Cache-Control\" content=\"max-age=7200\" /&gt;&lt;meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2019 23:00:00 GMT\" /&gt; 为 html 指定 Etag 或 Last-Modified 以缓存页面。对于未修改的文件，浏览器会从本地缓存中读取。如 1&lt;meta http-equiv=\"last-modified\" content=\"Mon, 20 Jul 2019 23:00:00 GMT\" /&gt; 避免重定向，每次重定向会消耗大约 600 毫秒的时间。 使用静态资源粉鱼存放来增加并行下载数。原因还是浏览器同域资源的请求数有所限制。 使用 CDN 内容分发网络。CDN 可以提升静态资源的加载速度。 使用 CDN Combo，即将多个文件请求打包成一个文件，这样可以服用同一个 http 请求，加快资源下载速度。 使用 ajax 缓存：针对 get 请求，消息头添加 Expires，可以缓存响应。 使用 get 请求。原因是 post 请求先发送文件头，再发送 http 正文；get 请求只发送文件头。 减少 cookie 的大小并进行 cookie 隔离（即使用不同域名存放静态资源，这样就隔离了 cookie）；设置合适的域级别和有效期。 减小 favicon.ico 的大小并缓存。 推荐使用异步 js 资源；异步的 js 资源不会阻塞文档解析。 合理拆分 css 及 js 资源，避免阻塞渲染。 避免在 import 方式加载 css 资源。原因是 import 方式需等解析到 @import 时才会加载指定的 css 资源，会大大延后 css 渲染完成的时间。 通过 Content-Encoding: gzip 响应头压缩资源。以下是基于 nginx 压缩文件。1234etag on; # 开启etag验证expires 7d; # 设置缓存过期时间为7天gzip on; # 压缩资源gzip_types text/plain application/javascriptapplication/x-javascripttext/css application/xml text/javascriptapplication/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml; # 压缩资源类型（压缩图片会占用后台资源，效果也不佳） 页面渲染类 把 css 资源放在 html 顶部，保证浏览器尽早完成页面渲染。 把 js 资源放在 html 尾部，避免加载和解析 js 过程中阻塞页面渲染。 避免在 html 中直接缩放图片。原因是缩放图片的动作会引起重排重绘。 减少 dom 节点的数量和深度，以提升 dom 树构建的速度。 避免使用 table, iframe 等慢元素。原因是 table 会等到它的 dom 树全部生成后再一次性插入页面中；iframe 内资源的下载过程会阻塞父页面静态资源的下载及 css, dom 树的解析。 避免运行耗时的 js；采用预加载方式加载资源，即当浏览器空闲候，再预加载资源（包含跳转页面的资源、新版本的资源等）。 避免使用运行较慢的 css 表达式或滤镜。 移动端优化策略网络加载类 首屏数据提前请求，避免 js 文件加载后再请求数据。 首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化。 模块化资源异步并行下载，可借助 webpack 达成 dynamic-import 实现。 inline 首屏必要的 css 和 js，避免页面出现空白。 设置文件资源的 DNS 预解析，让浏览器提前解析获取静态资源的主机 IP，避免等到请求时才发起 DNS 解析请求。如 12&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\" /&gt;&lt;link rel=\"dns-prefetch\" href=\"//cdn.domain.com\" /&gt; 资源预加载。 保证 html 内容在 1KB 以内。TCP 网络传输的最大传输单元（Maximum Transimission Unit，MTU）为 1500B，即一个 RTT（Round-Tip Time，网络请求往返时间）内可以传输的数据量最大为 1500 字节。保证 html 内容在 1KB 以内，可以使 html 在一个 RTT 内加载完成。 缓存类 合理利用浏览器缓存，Cache-Control, Expires, Etag, Last-Modified 以及 localStorage 等，尽可能减少网络请求。 静态资源离线方案？？？ 尝试使用 AMP HTML？？？ 图片类 压缩图片，合理使用 base64 图片。 使用更高压缩比格式的图片，如 webp 等。 图片懒加载。 1&lt;img data-src=\"//cdn.domain.com/path/photo.js\" alt=\"懒加载\" /&gt; 使用 media query 或 srcset 根据不同屏幕加载不同大小的图片。 使用 iconfront 代替图片图标。可使用 阿里矢量图标库 制作图标。 1234567@font-face &#123; font-family: iconfront; src: url(\"./iconfront.eot\"); src: url(\"./iconfront.eot?#iefix\") format(\"eot\"), url(\"./iconfront.woff\") format(\"woff\"), url(\"./iconfront.ttf\") format(\"truetype\");&#125; 限制图片大小：推荐 10KB 以内，不能超过 30KB。 脚本类 尽量使用 id 选择器。原因选择 id 元素时执行速度最快。 尽量缓存 dom 对象，避免每次使用时需要从 dom 树中重新查找。 尽量使用事件代理，避免直接使用事件绑定。这样可以避免不必要的内存泄露及需要动态添加元素的事件绑定问题。 使用 touchstart 代替 click。因为移动端 touchstart 事件和 click 事件之间存在 300 毫秒的延时。 避免 touchmove, scroll 链接事件处理，事件触发频繁容易使页面卡顿，可每隔 16ms （60 帧的真间隔为 16.7ms）再触发事件。 避免使用 eval, with，使用 join 代替连接符 +，推荐使用 es6 的模板字符串。这样更安全。 尽量使用 es6+ 的特性来编程。这样更安全高效。 渲染类 使用 viewport 固定品目渲染，可以加载渲染过程，同时可以避免缩放导致的重排重绘。 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" /&gt; 避免各种形式的重排重绘。 使用 css3 动画，使用 transform: translateZ(0) 开启 GPU 加速，让动画更流畅。 合理使用 canvas 和 requestAnimationFrame 等更高效的动画实现方式，避免 setTimeout, setInterval 等方式直接处理连续动画。 使用 svg 代替图片，因为 svg 内容更小，结构更方便调整。 避免 float 比较耗时的布局方式，推荐使用固定布局或弹性布局。 避免过多的 font-size 声明，这样会增加字体的大小计算。 架构协议类 尝试使用 SPDY 和 http2 协议。SPDY 协议可复用连接，以加快传输过程，缩短资源加载时间。 使用后端数据渲染（数据回填到 html 中），这样可以避免空白页的出现，同时可以解决移动端 SEO 问题。 使用 Native View 代替 DOM，以便将页面内容渲染提升到接近客户端 Native 应用级别。 参考Render树、RenderObject与RenderLayerwebkit渲染机制浅析了解 Resource Timing页面呈现、重绘、回流Performance — 前端性能监控利器首屏时间从12.67s到1.06s，我是如何做到的？雅虎前端优化的35条军规淘宝首页性能优化实践","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"architecture","slug":"frontend/architecture","permalink":"http://xzfyu.com/categories/frontend/architecture/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"性能","slug":"性能","permalink":"http://xzfyu.com/tags/性能/"}]},{"title":"nginx","slug":"backend/部署/nginx","date":"2019-02-25T16:00:00.000Z","updated":"2020-03-08T11:10:50.140Z","comments":true,"path":"2019/02/26/backend/部署/nginx/","link":"","permalink":"http://xzfyu.com/2019/02/26/backend/部署/nginx/","excerpt":"","text":"步骤 nginx主站 下载 nginx cd 到 nginx 目录，start nginx 启动 修改 conf/nginx.conf 全局配置，nginx -s reload 重启 命令start nginx 启动nginx -s stop 强制退出nginx -s quit 平滑退出nginx -s reload 修改配置后，平滑重启 taskkill /F /IM nginx.exe &gt; null 强制杀死 nginx 进程taskkill /fi “imagename nginx.exe” 查看 nginx 进程 配置123456789101112131415161718worker_process 1;events &#123; worker_connection 1024;&#125;http &#123; include mime.types; # 缺失会导致 css 解析无效 default_type application/octet-stream; gzip on; server &#123; listen 80; server_name localhost; root D:/git/test; &#125;&#125; 参考Nginx安装及配置详解nginx常用配置—-作为web服务端nginx for Windows","categories":[{"name":"backend","slug":"backend","permalink":"http://xzfyu.com/categories/backend/"},{"name":"部署","slug":"backend/部署","permalink":"http://xzfyu.com/categories/backend/部署/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"}]},{"title":"换种角度","slug":"随笔/换种角度","date":"2019-02-23T16:00:00.000Z","updated":"2019-02-24T07:30:55.994Z","comments":true,"path":"2019/02/24/随笔/换种角度/","link":"","permalink":"http://xzfyu.com/2019/02/24/随笔/换种角度/","excerpt":"","text":"视图层有两种要素：页面元素和用户行为。作为可见的实体，页面元素根据用户行为施加的影响，变化着形态。假使把页面元素比作我们自学生时代就接触的弹簧，按照实验数据抽象的弹性系数就是页面元素自有的属性，施加的外力就是用户针对该节点的操作，click 或 change 之流。我们可以仿照胡克定律的方式，使用数学函数阐述视图层的变化，如 view = handler(action)。与自然现象那种冥冥中的物理机制不同的是，在人为的视图层机制中，handler 是可控的。我们既可以在 node.onClick 中看见 handler 的影子，又可以在 node.addEventListener(‘onClick’, handler) 看见 handler 的影子。当我们以弹性系数是弹簧固有的物理特征这种方式思忖这两种实现时，我们就能意识到：前一种方式是较为直观的，施加哪种影响，产生哪种变化，比如先作力的合成，再计算力的影响；后一种是可量化的、轻耦合的，不限于物质实体而抽象物理机制，再使用这套物理机制演绎物质实体的表现，比如先作力的分解，再叠加力的影响。这样我们就可以认为，作为平台的浏览器提供了力学定律，前端开发者定义了物质实体的物理特征，用户施加了作用力，继而使物质实体发生了变化。以这种方式理解浏览器的事件机制既是我个人的一种癖好，又可以拉近与浏览器实现的亲近感。在延伸面上，我们还可以把事件委托看成是”隔山打牛“这种武侠招式的浏览器表现，不是很有趣吗？ 有什么在妨碍我们看清浏览器的实现机制就是 view = handler(action) 呢？在浏览器中，页面元素被抽象成了具有样式属性且富有层次结构的节点。在内存中驻留的节点属性就像实时变化的运动量那样，让我们不能直观地感受到输入输出模型，而是更容易只看到等式的右半部分：在 handler(action) 执行过程中，node 节点的形态发生着变化。让我们再聚焦于脚蹬自行车这种”隔山打牛“的情景，我们想必会直观地认为在 handler(action) 执行过程中，脚踏板、链条、轮轴、车轮都在运动，而不能定位到输入输出模型。一个 handler(action) 过程中的多节点变化不正是这样的吗？我们书写的代码不也正是这样的吗？因此而论，就像我们基于力学定律阐释脚蹬自行车这一物理过程一样，view = handler(action) 就是我们的力学定律，节点的种种变化就是我们的物理过程。也因此，在单输入单输出模型下，基于操作节点的前端编码方式就退化成了学生时代的解题，或者我们找到了学生时代解题的意义。以下就是单输入输出模型中常见的任务流处理方式： 123x1 = f1(x0);x2 = f2(x1);// ... 当我们再把眼光投向多输入多输出模型，或者整体构造比自行车复杂得多的现代汽车，面向过程的思考方式势必会让我们遭遇分岔的支路。这时候，面向对象的方式就隆重登场了。在面向对象的思维方式中，实体的状态变更可以归结为实体自有的特征，如前文提到的弹性系数。环绕弹性系数，弹簧拉伸长度和受力的机制都可以内化为实体的状态及方法。如果实体的特征仅止于此，以面向对象的方式对实体进行建模看似是不必要的。我们可以感知到面向过程的方式在这样一种单输入单输出模型上的便利性和清晰性。当然，当实体并不止于单方面的特征，面向对象的方式就会优于面向过程的方式。在这方面，我们以自带搜索表单和编辑弹窗的列表组件加以说明。如果我们以面向对象的方式封装每个组件的状态和行为，每个组件即构成交互网络中的一个节点，其所缺的就是上下游节点的通信方式。作为上游的列表组件，既可以集成弹窗的显示隐藏状态以及操纵弹窗显示隐藏的方法；又可以直接调用弹窗组件的显示隐藏方法。列表组件和搜索表单的交互方式也是一样的。因此，面向对象的方式更像一个节点网络，每个节点都各自组织节点内部的状态和行为，节点之间又通过交互接口完成通信。这和面向过程的方式有着着眼点上的不同：面向过程聚焦于输入输出流的传递和变更，更适合在单任务流串联各实体变化的脉络轨线；面向对象在于对单实体的丰富特征进行抽象，然后在节点网络中组织上下游的通信，更适合机制复杂的系统。 在面向对象的编码方式中，除了 uml 类图之外，通过节点网络阐述各节点的组织关系以及各节点的内在特征也许是可行的。我们知道，以类实现的实体之间可以有依赖、聚合、继承关系，比如列表组件聚合了搜索表单和编辑弹窗，这三个组件可能都依赖了状态管理类、继承自实现生命周期管理方法的基类组件。状态管理类可视为 mobx 等类库在组件状态管理上提供的解决方案；基类组件可视为 react 等框架在视图层提供的抽象。当我们在业务层面在进一步抽象，就可以针对列表组件分别抽象两个类去封装其与搜索表单和编辑弹窗的状态管理和交互逻辑，以避免代码的重复书写。为此，typescript 像 java 那样提供了抽象类、接口、多重继承、私有属性等，为我们以面向对象的方式编写前端代码提供了许多弹药。正如这篇文章旨在于换种角度思考编程、盘活思路，这里不对具体的编码实现作深入，遗留下来的可探讨、可推敲空间仍在于展开问题，或者寻找提升编程技术的切入点。当然，这样会显得虎头蛇尾、泛泛而谈，也是笔者编程造诣不够精深的佐证吧。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://xzfyu.com/categories/随笔/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"css 总汇","slug":"frontend/css/css 总汇","date":"2019-02-07T16:00:00.000Z","updated":"2020-03-08T10:35:38.559Z","comments":true,"path":"2019/02/08/frontend/css/css 总汇/","link":"","permalink":"http://xzfyu.com/2019/02/08/frontend/css/css 总汇/","excerpt":"","text":"选择器基本选择器 选择器 意义 版本 示例 * 通用选择器 2.1 * E 标签选择器 1 p .class 类选择器 1 .nav #id ID选择器 1 #wrapper E[attr] 属性选择器，匹配带 ‘data-url’ 属性的 a 元素 2.1 a[data-url] E[attr=val] 属性选择器，匹配 type 属性为 ‘text’ 的 input 元素 2.1 input[type=’text’] E[attr~=val] 属性选择器，匹配 keywords 属性包含 ‘round’ 的 div 元素 2.1 div[keywords~=’round’] E[attr=val] 属性选择器，匹配 lang 属性以 ‘zh’ 开始的 label 元素 2.1 label[lang=’zh’] E[attr^=val] 属性选择器，匹配 href 属性以 ‘http://‘ 开始的 a 元素 3 a[href^=’http://‘] E[attr$=val] 属性选择器，匹配 src 属性以 ‘.png’ 结尾的 img 元素 3 img[src$=’.png’] E[attr*=val] 属性选择器，匹配 href 属性中包含 ‘baidu.com’ 的 a 元素 3 a[href*=’baidu.com’] E F 后代选择器 1 .blog p E&gt;F 子选择器 2.1 .nav &gt; button E+F 相邻兄弟选择器 2.1 label + input E~F 兄弟选择器 3 header ~ div S1, S2 选择器分组 1 input, select, textarea 伪类选择器 选择器 意义 版本 示例 :link 动态伪类，匹配未访问过的链接 1 a:link :visited 动态伪类，匹配被访问过的链接 1 a:visited :hover 动态伪类，匹配鼠标悬浮的元素 1 div:hover :active 动态伪类，匹配鼠标按下的元素 1 a:active :focus 动态伪类，匹配获得焦点的元素 2.1 input:focus :target 目标伪类，匹配活动的锚 2.1 #tab1:target :lang(val) 语言伪类，匹配指定 lang 属性的元素 2.1 p:lang(zh) :enabled 状态伪类，匹配启用的元素 3 input:enabled :disabled 状态伪类，匹配禁用的元素 3 input:disabled :checked 状态伪类，匹配选中的元素 3 input:checked :root 结构性伪类，文档根元素 3 :root :nth-child(n) 结构性伪类，匹配父元素的第 n 个子元素 3 :nth-child :nth-last-child(n) 结构性伪类，匹配父元素的倒数第 n 个子元素 3 :nth-last-child :nth-of-type(n) 结构性伪类，匹配父元素的第 n 个相同子元素 3 :nth-of-type :nth-last-of-type(n) 结构性伪类，匹配父元素的倒数第 n 个相同子元素 3 :nth-last-of-type :first-child 结构性伪类，匹配父元素的第一个子元素 3 :first-child :last-child 结构性伪类，匹配父元素的最后一个子元素 3 :last-child :first-of-type 结构性伪类，匹配父元素的第一个相同子元素 3 :first-of-type :last-of-type 结构性伪类，匹配父元素的最后一个相同子元素 3 :last-of-type :only-child 结构性伪类，匹配父元素的唯一一个子元素 3 :only-child :only-of-type 结构性伪类，匹配父元素的唯一一个相同子元素 3 :only-of-type :empty 结构性伪类，匹配没有子元素的元素 3 :empty ::first-line 伪元素，匹配元素文本内容的首行 1 p::first-line ::first-letter 伪元素，匹配元素文本内容的首字母 1 p::first-letter ::before 伪元素，匹配元素之前的内容 2.1 div::before ::after 伪元素，匹配元素之后的内容 2.1 div::after 选择器权重选择器分为 4 个优先级，分别是：内联样式；ID 选择器；类、伪类，属性选择器；元素，伪元素。其权重通常是 1000, 100, 10, 1。需要注明的是，11 个类选择器的权重并不会超过 1 个 ID 选择器。除此之外，!important 可将对应规则的权重提升到最高。 响应式开发viewport在介绍响应式开发前，先须理清如下三个概念，各设备的物理像素和设备像素比也见于下表： 物理像素：屏幕实际的像素点。 设备独立像素：逻辑像素，用于定义应用的 UI。 屏幕像素比：物理像素和设备独立像素的比值。 设备名称 物理像素 设备独立像素 屏幕像素比 iPhone 7, 6, 6S 750*1334 373*667 2 iPhone 7 plus, 6S plus, 6 plus 1080*1920 414*736 3 iPhone 5, 5S, 5C, 5E 640*1136 320*568 2 iPhone 4 640*960 320*480 2 iPod Touch 640*1136 320*568 2 Galaxy S7, S7 edge, S6 1440*2560 360*640 4 Galaxy S5, S4 1080*1920 360*640 3 Galaxy S4 mini 540*960 360*640 1.5 Galaxy S3 720*1280 360*640 2 Galaxy Note 4 1440*2560 360*640 4 Galaxy Note 3 1080*1920 360*640 3 Galaxy Note 2 720*1280 360*640 2 Mi 4, 3 1080*1920 360*640 3 HTC One 1080*1920 360*640 3 Sony Xperia 23 1080*1920 360*640 3 Lenovo K900 1080*1920 360*640 3 ZTE Grand S 1080*1920 360*640 3 iPad Pro 2048*2732 1024*1366 2 iPad 3, 4, Air, Air2 1536*2048 768*1024 2 iPad mini 2, 3 1536*2048 768*1024 2 iPad mini 768*1024 768*1024 1 大多数设备的视口宽度都为 980 px，通过设置 可调整视口（viewport）的宽度。关于视口的概念，可参考 移动前端开发之viewport的深入理解。其中，meta 标签包含的属性含义如下： width：设置 viewport 宽度。 initial-scale：设置 viewport 初始缩放值。 minimum-scale：设置 viewport 最小缩放值。 maximum-scale：设置 viewport 最大缩放值。 height：设置 viewport 高度。 user-scalable：是否允许用户缩放。 flex 布局flex 弹性布局示意图： 在 flex 容器内，水平轴称为交叉轴，垂直轴称为主轴；容器内分布 flex 项目。flex 容器包含以下属性： 属性名称 意义 可选值 flex-direction 决定 item 排列方向 row 从左至右；column 从上到下；row-reverse；column-reverse flex-wrap 决定 item 换行方式 nowrap 不换行；wrap；wrap-reverse 第一行在下面 justify-content 决定 item 在主轴上的对齐方式 flex-start；flex-end；center；space-between 两端对齐；space-around 沿轴线均匀分布 align-items 决定 item 在交叉轴上的对齐方式 flex-start；flex-end；center；baseline；stretch 当 item 未设置高度时，item 将与容器等高度 align-content 决定多行 item 的对齐方式 flex-start；flex-end；center；space-between；space-around；stretch flex 项目包含如下属性： 属性名称 意义 可选值 order 决定 item 排列顺序，默认值为 0 - flex-grow 决定 item 放大比例，默认值为 0 - flex-shrink 决定 item 缩小比例，默认值为 1 - flex-basis 决定 item 在主轴上占据的空间，默认值为 auto - align-self 决定 item 在交叉轴上的对齐方式 auto；flex-start；flex-end；center；baseline；stretch 关于 flex 布局，可参考 flex弹性布局学习总结。 媒体查询媒体查询可以定义在 css 中，也可以定义在 link 元素的 media 属性内。后一种方法始终会加载 css 样式，通过 media 属性决定是否应用 css 样式。 媒体查询可使用如下属性，并可加以 min- 或 max- 前缀： width：视口的宽度。 height：视口的高度。 aspect-ratio：视口的宽高比。 orientation：设备横竖屏，值为 portrait 或 landscape。 resolution：设备分辨率，值可以是每英寸 dpi 或每厘米 dpcm。 媒体查询以 @media 起始；以 not 为逻辑非，’,’ 号为逻辑或。@media 后可使用不同的媒体类型或媒体属性。媒体类型包含：all 所有媒体类型；print 打印设备；screen 显示器；speech 辅助设备。 remcss 中的计量单位有 px, pt, em, rem 等。em 相对当前元素的字体大小；rem 相对根元素的字体大小。使用 rem 制作响应式页面，先须根据屏幕大小调整切换根元素的字体大小。关于如何动态调整根元素的字体大小，可参考 lib-flexible。 多列布局在 css3 中，文本可采用多列布局，其中施以影响的样式有： column-count：设定列数。 column-width：设定列宽度。 column-gap：设定列间距。 column-rule：设定列间距的样式规则。 动效transform 转换 translate(x, y)：平移。 translate3d(x, y, z)：平移。 translateX(x)：平移。 translateY(y)：平移。 translateZ(z)：平移。 scale(x, y)：缩放。 scale3d(x, y, z)：缩放。 scaleX(x)：缩放。 scaleY(y)：缩放。 scaleZ(z)：缩放。 rotate(angle)：旋转。 rotate3d(x, y, z, angle)：旋转。 rotateX(angle)：旋转。 rotateY(angle)：旋转。 rotateZ(angle)：旋转。 skew(x-angle, y-angle)：倾斜变形。 skewX(angle)：倾斜变形。 skewY(angle)：倾斜变形。 matrix(n, n, n, n, n, n)：自定义转换。 matrix3d(n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n)：自定义转换。 prespective(n)：透视图。 transition 过渡transition 在指定 css 属性发生变化时，开始执行动效。它的格式以及包含的属性如下： 1transition: transition-property transition-duration transition-timing-function transition-delay; transition-property：指定将发生变化的 css 属性。 transition-duration：指定动效执行的时长。 transition-timing-function：指定动效的速度曲线。可能的值包含：linea 以相同的速度执行动效，等同于贝济埃曲线（0.0, 0.0, 1.0, 1.0）；ease 以逐渐变慢的速度执行动效，等同于贝济埃曲线（0.25, 1.0, 0.25, 1.0）；ease-in 以慢速开始执行动效，等同于贝济埃曲线（0.42, 0.0, 1.0, 1.0）；ease-out 以慢速结束执行动效，等同于贝济埃曲线（0.0, 0.0, 0.58, 1.0）；ease-in-out 以慢速开始并结束执行动效，等同于贝济埃曲线（0.42, 0.0, 0.58, 1.0）；cubic-bezier(n, n, n, n) 自定义时间曲线，即自定义贝济埃曲线。 transition-delay：指定动效的延迟时间。 animation 动画animation 适用于块状和内联元素。它的格式以及包含的属性如下： 1animation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction; animation-name：值可以为 @keyframes 创建的动画名称，默认值为 none，即不会有任何动画效果。 animation-duration：动画播放时长。 animation-timing-function：指定动画的速度曲线，值可以是 linea, ease, ease-in, ease-out, ease-in-out, cubic-bezier(n, n, n, n)。 animation-delay：动画的延迟时间。 animation-iteration-count：动画的播放次数。 animation-direction：动画的播放方向，默认值为 normal。当指定为 alternate 时，偶数次向前播放，奇数次向后播放。 常用特性开放字体格式 WOFF通过 css3 中的 @font-face 可使用开放字体格式（Web Open Font Format，简称 WOFF）。@font-face 规则如下： 1234567891011121314151617@font-face &#123; font-family: &lt;开放字体格式名&gt;; src: &lt;字体路径&gt; [&lt;字体格式&gt;] [,&lt;字体路径&gt; [&lt;字体格式&gt;]] *; [font-weight: &lt;字体粗细&gt;]; [font-style: &lt;字体样式&gt;]; &#125;@font-face &#123; font-family: 'fontello'; src: url('./font/fontello.eot?69798120'); src: url('./font/fontello.eot?69798120#iefix') format('embedded-open-type'), url('./font/fontello.woff?69798120') format('woff'), url('./font/fontello.tff?69798120') format('truetype'), url('./font/fontello.svg?69798120#fontello') format('svg'); font-weight: normal; font-style: normal; &#125; 字体格式包含如下值： .tff：TrueType 格式，是 windows, mac 上常见的字体。 .otf: OpenType 格式，一种原始的字体。 .woff: Web Open Font Format 格式，Web 字体中最佳格式，TrueType/OpenType 格式的压缩版。 .eot：Embedded Open Type 格式，可以从 TrueType 创建此格式的字体，IE 专用格式，支持此字体的浏览器有 IE4+。 .svg：SVG 格式。 @font-face 可用于加载字体图标 IconFont。字体图标可参考 iconfont字体图标的使用方法–超简单!。 背景 background-color：指定背景色。 background-position：指定背景图像的位置。 background-size：指定背景图像的尺寸，值可以指定背景的宽度和高度，也可以是 cover 使背景图像覆盖背景区域，超出部分将会裁剪, contain 使背景图像适应背景区域。 background-repeat：指定是否重复背景图像。 background-origin：指定背景的定位区域，值可以是 padding, padding-box, border, border-box, content, content-box，即从内边距或外边距开始。 background-clip：指定背景的绘制区域，指定区域将被裁剪，值可以是 border-box, padding-box, content-box。 background-attachment：指定背景图像是否固定或者随着页面的其余部分滚动。 background-image：指定背景图像。 颜色颜色取值可以指定颜色名称，如 black；或 HEX 以十六进制表示颜色，如 #000000；或 RGB 记法，如 rgb(0, 0, 0)；或 RGBA 记法，alpha 为透明度，如 rgba(0, 0, 0, 0.5)；或 HSL 记法，如 hsl(360, 50%, 50%)；或 HSLA 记法，如 hsla(360, 50%, 50%, 0.5)；或 transparent 全透明色彩；或 currentcolor 当前标签继承的文字颜色。 颜色也可以设置渐变。linear-gradient 线性渐变，如 linear-gradient(direction, color-stop1, color-stop2, …)；或 radial-gradient 径向渐变，如 radial-gradient(position, shape size, start-color, …, last-color)。 也可以使用 opacity 指定透明度。 文字效果 text-shadow：字体阴影，格式如 text-shadow: h-shadow v-shadow blur color。其中，h-shadow 为水平阴影的位置；v-shadow 为垂直阴影的位置；blur 模糊的距离；color 阴影的颜色。 text-overflow：指定文本溢出的处理方式。值可以是 clip 裁剪；ellipsis 省略号显示；string 指定字符串替代被裁剪的文本。 word-wrap：指定长单词或 url 地址是否自动换行，值可以是 normal, break-word。normal 在允许的断字点换行；break-word 在长单词或 url 地址内部进行换行。 word-break：指定自动换行的处理方式，值可以是 normal, break-all, keep-all。normal 默认的换行方式；break-all 允许在单次内换行；keep-all 只能在半角空格或连字符处换行。 边框 border-width：指定边框的宽度。 border-style：指定边框样式。 border-color：指定边框颜色。 border-radius：指定圆角边框。 border-image：指定边框背景图像。 box-shadow：指定边框阴影。格式如 box-shadow: h-shadow v-shadow blur spread color inset。 其他box-sizing：盒模式。calc：函数计算样式。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"http://xzfyu.com/categories/frontend/css/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"css","slug":"css","permalink":"http://xzfyu.com/tags/css/"}]},{"title":"移动Web高效开发实践","slug":"读书笔记/移动Web高效开发实践","date":"2019-02-02T16:00:00.000Z","updated":"2019-02-11T13:37:59.215Z","comments":true,"path":"2019/02/03/读书笔记/移动Web高效开发实践/","link":"","permalink":"http://xzfyu.com/2019/02/03/读书笔记/移动Web高效开发实践/","excerpt":"","text":"本文档主要用于汇总待整理的问题点，后续将以文章形式逐条剖析。 开发环境或工具 NProxy：web 代理工具，参考 前端调试利器—nproxy。 http-server：搭建 http 服务器，参考 本地搭建http-server服务器。 caniuse：查询浏览器对样式的支持度。 modernizr：嵌入脚本，检测浏览器对样式或特征的支持度。 html5 布局元素：Header, Nav, Article, Section, Aside, Footer。 input[type=?]：search, tel, url, email, date, color, number, range, datetime, month, week。 input[?=]：required, pattern, autofocus, form, placeholder。 新元素：progress 进度条, meter 标尺。 新属性：contenteditable 使元素可编辑。 audio 音频、video 视频：包含 controls 展示默认控件, autoplay, loop 循环播放, preload 预加载, volumn 音量属性，通过 source 元素加载音频、视频；可以用 api 形式操作音频。 navigator.geolocation.getCurrentPosition(success, error, options)：获取当前地理位置。 navigator.mediaDevices.getUserMedia(contraints).then(success).catch(error)：调用摄像头拍照，success 回调的参数 stream 可通过 window.URL.createObjectURL(stream) 赋值给 video 元素的 src 属性。 deviceorientation 事件：可监听设备旋转角度的变化，绕上下坐标旋转称为 alpha 弧度，绕左右坐标称为 beta，绕前后坐标旋转称为 gamma。 devicemotion 事件：可监听设备移动的距离以及旋转角度的变化。 离线存储：以 ‘.mainfest’ 或 ‘.appcache’ 描述文件设定待存储的资源目录，html 指定 mainfest 属性关联该描述文件，这样可以在断网状态下加载本地缓存的资源。结合 LocalStorage，可以缓存本地用户填写的数据。除此之外，service worker 可以用指定的方式加载本地缓存。关于 service worker，可参考 Service Worker API, 构建 Web 应用之 Service Worker 初探, Web离线应用解决方案——ServiceWorker。 LocalStorage, SessionStorage：本地存储。 IndexedDB：浏览器本地的结构化数据库，使用 new LocalDB(dbName, tableName) 创建。 Canvas 画布。 SVG 矢量图。 WebGL 三维图像。渲染引擎可参考 pixi.js。 window.postMessage(message, target, [transfer])：跨域传送。 xhr2：添加 ontimeout, onprogress 方法，可传送 FormData 数据。 EventSource：创建 EventSource 对象接受服务端主动推送的消息。 WebSocket 全双工通信。 WebRTC 实时通信。 drag, drop 拖拽。 history api。 web workers 多线程。 performance api 网站性能。 microdata：参考 前端的基礎修養：Microdata。 css参考 css 总汇。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xzfyu.com/categories/读书笔记/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"git","slug":"git","permalink":"http://xzfyu.com/tags/git/"}]},{"title":"react-router","slug":"frontend/library/react-router源码分析","date":"2019-01-30T16:00:00.000Z","updated":"2020-03-08T10:45:48.826Z","comments":true,"path":"2019/01/31/frontend/library/react-router源码分析/","link":"","permalink":"http://xzfyu.com/2019/01/31/frontend/library/react-router源码分析/","excerpt":"","text":"react-router基于 history 创建的 history 对象、以及 create-react-context 为上下游组件传递 context 数据，上游的 Router 组件用于监听地址栏的变更，随后将 history 对象以及当前的 state.location 信息写入 context；下游的 Route 组件通过工具函数 matchPath 判断 location.pathname 是否匹配 props.path，以此渲染出内容。 在这种机制下，存在两个问题：如果 location.pathname 与多个 Route 匹配时，react-router 将会渲染出这几个 Route 的内容；如果嵌套使用的 Route 元素均需要与 location.pathname 当前的地址栏信息加以比较的话，那么这个 Route 元素的 props.path 属性也需要感知父 Route 元素的 props.path 信息。针对第一个问题，react-router 提供了 Switch 组件。借助 Switch 组件，react-router 将只渲染首个匹配的 Route 元素，且为子组件注入 props.computedMatch 属性（以避免 matchPath 的多次调用）。针对第二个问题，react-router 通过 Switch 组件或父 Route 组件向子组件注入 props.match 属性，再通过 match.path 设置子 Route 的 props.path 属性（参见 basic 示例）。 除了改变子组件的 props.match 属性外，Switch 和 Route 组件均能改变子组件的 props.location 属性。react-router 以 Animated Transitions 示例 指出 props.location 属性可应用于动效渲染场景。在示例中，react-router 使用指定 location 属性的 Switch 组件包裹前后两个页面级渲染内容，再经由指定 key 键为 location.key 的 CSSTransition 组件包裹（指定 key 键是为了在 CSSTransition 组件重绘期间，使该组件一前一后、卸载再挂载的机制切合视图上的移入移出动效），而后统一由 TransitionGroup 组件管理 CSSTransition 组件的动效切换过程。这样就可以实现：在地址栏变更过程中，前一个 CSSTransition 组件同步驻留，执行完隐藏动效后再移出；后一个 CSSTransition 组件执行完显示动效后再移入。 顺带指出的是，因为 Route 或 Switch 组件都可以指定动态的 props.location 属性，那就可以设想如下的黑魔法：自定义的、且与历史堆栈无甚关联的动态 location 属性将主导子 Route 的渲染状态。当然，这一黑魔法并不规范，理应避免使用。 在 Router 之外，react-router 还提供 MemoryRouter, StaticRouter 组件。MemoryRouter 组件可根据虚拟的缓存历史堆栈控制子 Route 的渲染状态，适用于测试或 native 环境。StaticRouter 组件适用于服务端渲染：react-router 会根据地址栏渲染出指定的内容，因此可以在 node 端设定 controller 对不同的前端路由统一发送 html 内容（通过 ReactDOMServer.renderToString 获得指定路由的 html 内容）；但是当地址栏与前端路由不匹配时，我们需要跳转到 404 页面，react-router 就会通过 StaticRouter 组件的机制在 ReactDOMServer.renderToString 方法执行期间，使用 content 引用对象收集待 404 页面地址，然后在 node 端进行重定向。引用对象 content 收集数据的方式有两种：第一种在虚拟跳转页面环节（为此，react-router 为 StaticRouter 组件提供了特定的 push, replace 方法实现）；第二种在待渲染页面 render 期间对 content 属性进行赋值。当然，这两种收集方式都在 ReactDOMServer.renderToString 方法执行期间完成。以上机制，可参考官方的 Server Rendering 示例。 上一个段落的 ReactDOMServer.renderToString 方法执行期间，前端代码会虚拟地重定向到 404 页面；node 端再通过 context 感知到这一虚拟重定向过程，然后再发起真实的重定向。在这个过程中，虚拟重定向是由 Redirect 组件完成的。在 react-router4 中，Redirect 组件的机制就是在组件的生命周期中跳转页面、或者在渲染期间改变 context 的属性（服务端渲染时，将待跳转页面上报给 node 服务器），并无其他内容。因此，如果不需要重定向，就需要条件语句控制 Redirect 组件的渲染。参考 Redirects (Auth) 示例。 在 Redirect 组件之外，借助 history 库封装的 block 方法，Prompt 组件用于拦截地址栏的变更，如默认会使用 window.confirm 提醒用户是否要进行跳转。Prompt 组件按两种条件决定是否需要对用户进行提示，其一是 props.when 属性，当其为真值进入条件二（因此可以将 state 状态赋值给 props.when 以设定条件）；其二是 props.message 属性，即 history 库中的 prompt，该值可以为函数，允许开发者根据待变更地址的 location, action 动态加以判断，是否需要提示用户。 我们用下图表示上文中组件的层级关系（虚线表示可有无可）： 以下列表简要概括各组价的输出能力和特点： StaticRouter: 服务器端渲染时，配合收集跳转页面地址并完成服务器端重定向。 MemoryRouter: native 环境使用虚拟历史堆栈实现前端路由。 Router: 将真实或虚拟的路由信息注入到子组件中，以控制 Route 内容的渲染。 Switch: 控制渲染首个匹配路由信息的 Route 内容。 Route: 设定单个路由规则，匹配时渲染内容。渲染内容可以是 children, Component, render 懒加载。其中，children 可以 React 元素，或 render props 形式。 Render: 作为 Route 下的渲染内容。 Redirect: 渲染时即重定向。 Prompt: 拦截地址栏变更。 __RouterContext基于 create-react-context，__RouterContext 用于为上下游组件传递 context。 withRouterwithRouter 装饰器将构造 HOC 组件，用于将 context 内容注入到子组件的 props 中。并且，HOC 组件基于 hoist-non-react-statics，拷贝了原始组件的非 react 类静态属性或方法。 工具函数 Lifecycle: 生命周期方法管理组件。 generatePath(path, params): 基于 path-to-regexp，将路径规则 path 和路由参数 params 解析为实际的路径。实现上，根据路径规则的解析函数会以对象形式缓存在内存中。 matchPath(pathname, { path, exact, strict, sensitive }): 基于 path-to-regexp，将实际路径 pathname 解析为 { path, url, isExact, params } 形式。其中，path 为路径规则；url 为匹配的路径内容；isExact 指实际路径 path 和路径规则 pathname 是否相等；params 为路由参数。 react-router-configreact-router-config 输出如下两个工具函数： matchRoutes(routes, pathname): 从类树形结构的路由中获取当前匹配的路由节点分叉。主要针对 react-router4 没有在全局层面缓存全量的路由配置信息，路由配置散落在 Route 组件中。 renderRoutes(routes, extraProps, switchProps): 使用 Switch, Route 组件渲染单层结构的数组路由 routes。 react-router-dom基于 react-router 包，react-router-dom 针对浏览器环境提供了如下组件： BrowserRouter: 使用 history 库输出的 createBrowserHistory，构建前端路由。 HashRouter: 使用 history 库输出的 createBrowserHistory, 构建 hash 路由。 Link: 基于 __RouterContext，绘制 a 标签跳转链接。在配置 props.onClick 方法的情景中，可以采用采用浏览器机制跳转。 NavLink: 根据路由匹配情况，为 Link 元素设置特殊的样式。 react-router-native基于 react-router 包，react-router-dom 针对 native 环境提供了如下组件： NativeRouter: 基于 MemoryRouter 组件，构建前端路由。默认的 props.getUserConfirmation 方法通过 react-native 输出的 Alert 实现。 BackButton: 基于 react-native 输出的 BackHandler 绑定 hardwareBackPress 事件，实现点击 back 按钮回退页面的功能。 Link: 通过为 props.Component 组件绑定 onPress 事件并渲染，实现页面跳转。 DeepLinking: 基于 react-native 输出的 Linking 绑定 url 事件，以使 Linking.openURL 调用过程中移除参数 url 中 ‘://‘ 及其前的内容。关于深度链接，可参看 浅析移动应用深度链接 (Deeplinking)， Linking。 总结本文的写作基于反向演绎，缺少遇到问题时正向推理的顺畅感，又介于笔者水平有限，文中难免谬误，仍望海涵。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"history","slug":"frontend/library/history源码","date":"2019-01-26T16:00:00.000Z","updated":"2020-03-08T10:45:48.826Z","comments":true,"path":"2019/01/27/frontend/library/history源码/","link":"","permalink":"http://xzfyu.com/2019/01/27/frontend/library/history源码/","excerpt":"","text":"history 库基于 html5 的 history 接口，用于操控和观察浏览器地址栏的变更。本文分为两部分：介绍 html5 的 history 接口；再介绍 history 库的实现。 history 接口为实现浏览器地址栏变更，又不至使页面刷新，html 提供了 history.pushState(state, title, url) 方法。该方法结合 ajax 请求一起使用，就可以实现地址栏变更时的局部刷新。实现详情可参阅 MANIPULATING HISTORY FOR FUN &amp; PROFIT 这篇文章。同时，这篇文章也指出，若想保证回退按钮也实现局部刷新，须监听 popstate 事件。以下整理的是 mozilla 开列的 history 文档。 history.length: 存储在回话历史堆栈中的元素数量。 history.state: 获取栈顶——历史堆栈入口的状态值。 history.back(): 前往上一页，浏览器的回退按钮可以模拟此方法。 history.forward(): 前往下一页，浏览器的前进按钮可以模拟此方法。 history.go(num): 前往历史堆栈中的指定页面。 history.pushState(state, title, url): 将数据压入历史堆栈中。state 数据量须小于 640kb，firefox 会将其保存到本地磁盘中。firefox 也会忽略 title 参数。这一过程将触发 popstate 事件，但不会触发 hashchange 事件。 history.replaceState(state, title, url): 替换历史堆栈入口的数据。 popstate: 当历史堆栈入口数据变更时，均会触发 popstate 事件，包含调用 history.back, history.forward, history.go 方法，以及点击前进、回退按钮。history.pushState, history.replaceState 方法不会触发 popstate 事件。 window.onpopstate = (event) =&gt; {}; window.addEventListener(‘popstate’, (event) =&gt; {}): 监听 popstate 事件。 hashchange: hash 路径变更，将会触发 hashchange 事件。 window.onhashchange = (event) =&gt; {}; window.addEventListener(‘hashchange’, (event) =&gt; {}): 监听 hashchange 事件。 history 库history 库创建了一个虚拟的 history 对象，以操纵浏览器地址栏的变更（createBrowserHistory）、或者操纵 hash 路径的变更（createHashHistory）、或者管理内存中的虚拟历史堆栈（createMemoryHistory）。各 history 对象均含有如下属性或方法： push(path, state): 往历史堆栈中压入数据。 replace(path, state): 变更历史堆栈入口数据。 go, goBack, goForward: 根据历史堆栈信息进行跳页。 block(prompt): 根据条件 prompt 阻断地址栏变更。 listen((location, action) =&gt; {}): 监听地址栏变更。 length: 历史堆栈中的数据量。 action: history 前次执行的方法名，值包含 ‘POP’, ‘PUSH’, ‘REPLACE’。 location: 历史堆栈入口的数据内容，数据结构为 { pathname, search, hash, key, state }，通过 LocationUtils.createLocation 创建。 监听函数 listener 会在地址栏变更后予以执行。实现上，history 先收集历史堆栈入口的变更数据，并写入虚拟的 history 对象中，然后再执行 listener。这一过程表现为 createBrowserHistory, createHashHistory, createMemoryHistory 模块中的 setState 函数。因此，通过 pushState, replaceState, go 方法，或者通过对 location 对象赋值变更地址栏后，就可以调用 setState 执行监听函数了。 12345function setState(nextState) &#123; Object.assign(history, nextState); history.length = globalHistory.length; transitionManager.notifyListeners(history.location, history.action);&#125; history 有两种阻断地址栏变更的方法：在变更前拦截；在变更后回滚。相对于变更地址栏的三种方式：对 location 对象直接赋值，或者调用 pushState, replaceState 方法，或者调用 go 方法。前两种方法，我们都知道地址栏将要变更为何值，因此 history 选择在变更前拦截；后一种方法，我们不知道地址栏将会变更为何值，因此 history 选择在变更后回滚。实现上，history 使用 transitionManager.confirmTransitionTo 包裹前两种方法的调用过程；通过监听 popstate, hashchange 事件获得变更后的 location 数据，同样使用 transitionManager.confirmTransitionTo 判断是否需要回滚，还是维持现状。回滚机制的典型实现如 createBrowserHistory, createHashHistory 模块中的 handlePop 函数等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 回滚到前几页时，跳过回滚机制let forceNextPop = false;function handlePop(location) &#123; if (forceNextPop) &#123; forceNextPop = false; setState(); &#125; else &#123; const action = 'POP'; // 通过 prompt 判断是否需要回滚 transitionManager.confirmTransitionTo( location, action, getUserConfirmation, ok =&gt; &#123; if (ok) &#123; // 维持现状 setState(&#123; action, location &#125;); &#125; else &#123; // 回滚 revertPop(location); &#125; &#125; ); &#125;&#125;function revertPop(fromLocation) &#123; const toLocation = history.location; // TODO: We could probably make this more reliable by // keeping a list of keys we've seen in sessionStorage. // Instead, we just default to 0 for keys we don't know. // allKeys 缓存历史堆栈中的数据标识 let toIndex = allKeys.indexOf(toLocation.key); if (toIndex === -1) toIndex = 0; let fromIndex = allKeys.indexOf(fromLocation.key); if (fromIndex === -1) fromIndex = 0; const delta = toIndex - fromIndex; if (delta) &#123; forceNextPop = true; go(delta); &#125;&#125; transitionManager 由 createTransitionManager 模块创建，提供了如下四种方法： appendListener(fn)：添加 fn 监听函数，返回函数可用于移除添加的监听函数。 notifyListeners(…args)：执行所有已添加的监听函数。 setPrompt(nextPrompt)：字符串时为提示；函数形式 (location, action) =&gt; {} 既可用于判断变更条件是否达成，或者输出提示文案；布尔值作为变更条件判断的结果。 confirmTransitionTo(location, action, getUserConfirmation, callback)：变更地址栏时，通过 prompt 判断变更条件是否达成或者获取提示文案；若取得提示文案，由 getUserConfirmation = (prompt, callback) =&gt; {} 设定 callback 的调用机制，否则以变更条件达成与否的状态值作为 callback 的参数，并执行 callback 回调。 1234567891011121314151617181920212223242526272829303132function confirmTransitionTo( location, action, getUserConfirmation, callback) &#123; // TODO: If another transition starts while we're still confirming // the previous one, we may end up in a weird state. Figure out the // best way to handle this. if (prompt != null) &#123; const result = typeof prompt === 'function' ? prompt(location, action) : prompt; if (typeof result === 'string') &#123; if (typeof getUserConfirmation === 'function') &#123; getUserConfirmation(result, callback); &#125; else &#123; warning( false, 'A history needs a getUserConfirmation function in order to use a prompt message' ); callback(true); &#125; &#125; else &#123; // Return false from a transition hook to cancel the transition. callback(result !== false); &#125; &#125; else &#123; callback(true); &#125;&#125; 基于以上触发监听函数、阻断地址栏变更的机制，下面我们一一揭开 createBrowserHistory, createHashHistory, createMemoryHistory 模块的面纱。 createBrowserHistorycreateBrowserHistory 基于 html5 中的 pushState, replaceState 变更地址栏。地址栏变更内容不限于 hash 路径。当浏览器不支持 html5 的 history 接口时，createBrowserHistory 将直接变更 location.href 或者调用 location.replace 方法实现地址栏变更。 首先，createBrowserHistory 接受 props 参数。其中，props.forceRefresh 设定以刷新页面的形式变更地址栏；getUserConfirmation 配合 browserHistory.block 方法，可根据地址栏变更信息决定是否允许本次变更；props.keyLength 决定每条历史数据标识符 key 键的长度；props.basename 设置地址栏变更的基本路径。 其次，实现 push, replace 方法，用于变更历史入口。在支持 html5 history 接口的浏览器中，createBrowserHistory 将调用 setState 方法监听函数的执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100function push(path, state) &#123; warning( !( typeof path === 'object' &amp;&amp; path.state !== undefined &amp;&amp; state !== undefined ), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored' ); const action = 'PUSH'; const location = createLocation(path, state, createKey(), history.location); transitionManager.confirmTransitionTo( location, action, getUserConfirmation, ok =&gt; &#123; if (!ok) return; const href = createHref(location); const &#123; key, state &#125; = location; if (canUseHistory) &#123; globalHistory.pushState(&#123; key, state &#125;, null, href); if (forceRefresh) &#123; window.location.href = href; &#125; else &#123; const prevIndex = allKeys.indexOf(history.location.key); const nextKeys = allKeys.slice( 0, prevIndex === -1 ? 0 : prevIndex + 1 ); nextKeys.push(location.key); allKeys = nextKeys; setState(&#123; action, location &#125;); &#125; &#125; else &#123; warning( state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history' ); window.location.href = href; &#125; &#125; );&#125;function replace(path, state) &#123; warning( !( typeof path === 'object' &amp;&amp; path.state !== undefined &amp;&amp; state !== undefined ), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored' ); const action = 'REPLACE'; const location = createLocation(path, state, createKey(), history.location); transitionManager.confirmTransitionTo( location, action, getUserConfirmation, ok =&gt; &#123; if (!ok) return; const href = createHref(location); const &#123; key, state &#125; = location; if (canUseHistory) &#123; globalHistory.replaceState(&#123; key, state &#125;, null, href); if (forceRefresh) &#123; window.location.replace(href); &#125; else &#123; const prevIndex = allKeys.indexOf(history.location.key); if (prevIndex !== -1) allKeys[prevIndex] = location.key; setState(&#123; action, location &#125;); &#125; &#125; else &#123; warning( state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history' ); window.location.replace(href); &#125; &#125; );&#125; 其次，基于原生的 history 对象实现 go, goBack, goForward 方法。此种变更地址栏的方式可以触发 popstate 或 hashchange 事件。 最后，实现 block 方法阻断地址栏变更；listen 方法监听地址栏变更。两者都会绑定 popstate 或 hashchange 事件的回调函数。通过这两个事件判断本次变更是否需要回滚、以及触发 listener 监听函数的执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 作为事件的绑定函数function handlePopState(event) &#123; // Ignore extraneous popstate events in WebKit. if (isExtraneousPopstateEvent(event)) return; handlePop(getDOMLocation(event.state));&#125;function handleHashChange() &#123; handlePop(getDOMLocation(getHistoryState()));&#125;// 绑定或清理事件的处理函数let listenerCount = 0;function checkDOMListeners(delta) &#123; listenerCount += delta; if (listenerCount === 1 &amp;&amp; delta === 1) &#123; window.addEventListener(PopStateEvent, handlePopState); if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange); &#125; else if (listenerCount === 0) &#123; window.removeEventListener(PopStateEvent, handlePopState); if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange); &#125;&#125;// 阻断地址栏变更let isBlocked = false;function block(prompt = false) &#123; const unblock = transitionManager.setPrompt(prompt); if (!isBlocked) &#123; checkDOMListeners(1); isBlocked = true; &#125; return () =&gt; &#123; if (isBlocked) &#123; isBlocked = false; checkDOMListeners(-1); &#125; return unblock(); &#125;;&#125;// 监听地址栏变更function listen(listener) &#123; const unlisten = transitionManager.appendListener(listener); checkDOMListeners(1); return () =&gt; &#123; checkDOMListeners(-1); unlisten(); &#125;;&#125; createHashHistorycreateHashHistory 的处理逻辑与 createBrowserHistory 相同，只不过 createHashHistory 着眼于 hash 路径的变更。 createHashHistory 的参数 props 仅接受 basename, getUserConfirmation, hashType 三个属性。createHashHistory 专有的 hashType 用于设置 hash 路径的编码解码策略，默认为 ‘slash’。 12345678910111213141516// hash 路径的编码解码策略集合const HashPathCoders = &#123; hashbang: &#123; encodePath: path =&gt; path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path), decodePath: path =&gt; (path.charAt(0) === '!' ? path.substr(1) : path) &#125;, noslash: &#123; encodePath: stripLeadingSlash, decodePath: addLeadingSlash &#125;, slash: &#123; encodePath: addLeadingSlash, decodePath: addLeadingSlash &#125;&#125;; 在 createHashHistory 模块中，变更 hash 路径基于 location.hash 赋值和 location.replace 方法。同时，createHashHistory 借助 hashchange 事件实现回滚，而上述两者变更 hash 路径的方式均会触发 hashchange 事件。因此，在 push, replace 方法的实现中，待变更的地址将会写入 ignorePath 缓存中，以在 handleHashChange 绑定函数对此变更不作回滚操作。 1234567891011121314151617181920function handleHashChange() &#123; const path = getHashPath(); const encodedPath = encodePath(path); if (path !== encodedPath) &#123; // Ensure we always have a properly-encoded hash. replaceHashPath(encodedPath); &#125; else &#123; const location = getDOMLocation(); const prevLocation = history.location; if (!forceNextPop &amp;&amp; locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change. if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace. ignorePath = null; handlePop(location); &#125;&#125; createMemoryHistorycreateMemoryHistory 用于在内存中创建完全虚拟的历史堆栈，只缓存历史记录，但与真实的地址栏无关（不会引起地址栏变更，不会和原生的 history 对象保持同步），也与 popstate, hashchange 事件无关。 createMemoryHistory 的参数 props 接受 getUserConfirmation, initialEntries, initialIndex, keyLength 属性。其中，props.initialEntries 指定最初的历史堆栈内容 history.entries；props.initialIndex 指定最初的索引值 history.index。push, replace 方法均将改变 history.entries 历史堆栈内容；go, goBack, goForward \b均基于 history.entries 历史堆栈内容，以改变 history.index 及 history.location。实现参见源码。 工具函数PathUtils路径相关操作。 addLeadingSlash(path)：酌情为 path 路径添加前缀 ‘/‘。 stripLeadingSlash(path)：酌情为 path 路径剔除前缀 ‘/‘。 hasBasename(path, prefix)：判断路径 path 是否包含前缀 prefix。 stripBasename(path, prefix)：酌情为 path 路径剔除前缀 prefix。 stripTrailingSlash(path)：酌情为 path 路径剔除后缀 ‘/‘。 parsePath(path)：将字符串路径 path 转换为 { pathname, search, hash } 对象。 createPath(location)：将 { pathname, search, hash } 对象转换为字符串路径 path。 LocationUtilslocation 对象相关操作，基于 resolve-pathname, value-equal。 createLocation(path, state, key, currentLocation) 构建 location = { pathname, search, hash, key, state } 对象，pathname 将根据 currentLocation 参数进行调整。 locationsAreEqual(a, b) 判断两个 location 对象是否相等。 DOMUtilsDOM 环境判断。 canUseDOM 是否可以操作节点。 getConfirmation(message, callback) 使用 window.confirm 弹出确认框，callback 的参数可用于判断用户是否点击确认按键。 supportsHistory 判断浏览器平台是否支持 HTML5 history API。 supportsPopStateOnHashChange 判断浏览器平台是否会在 hash 路径变更时触发 popstate 事件。 supportsGoWithoutReloadUsingHash 使用 go(n) 变更 hash 路径时是否不会页面刷新。 isExtraneousPopstateEvent 判断 popstate 事件是否由无关的操作引起。iOS 平台 chrome 浏览器点击回退按钮会触发 state 为 undefined 的 popstate 事件。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"scheduler 源码分析","slug":"frontend/react16/scheduler","date":"2019-01-14T16:00:00.000Z","updated":"2020-03-08T10:46:35.757Z","comments":true,"path":"2019/01/15/frontend/react16/scheduler/","link":"","permalink":"http://xzfyu.com/2019/01/15/frontend/react16/scheduler/","excerpt":"","text":"scheduler 模块用于管理重绘完成后回调的执行逻辑。在 scheduler 中，requestHostCallback 函数用于实现在重绘完成后、视线程的空闲程度以及任务预设的超时时间，以在特定的时机执行任务。在 requestHostCallback 的基础上，scheduler 使用双向链表构建含有优先级的原子任务节点，再输出添加并执行任务节点、打断任务节点执行的 api。 requestHostCallbackscheduler 模块支持三种方式实现 requestHostCallback, cancelHostCallback, shouldYieldToHost, getCurrentTime 函数：一、通过 window._schedMock 或 global._schedMock 数组注入；二、通过 setTimeout 实现（实现上当 requestHostCallback 的首参 —— 任务函数尚在执行过程中，scheduler 将 requestHostCallback 作为 setTimeout 的回调函数，以使在新添加任务函数间接添加到 macrotasks 队列中，可参看源码）；三、基于 MessageChannel, requestAnimationFrame 实现（MessageChannel 用于探知线程是否空闲，requestAnimationFrame 用于与重绘机制契合）。本文着重介绍第三种方式，并用 rAF 指代 requestAnimationFrame。 基于 MessageChannel, requestAnimationFrame 实现的上述四种函数的功能点为： 函数名 意义 requestHostCallback(callback, absoluteTimeout) 在重绘完成后执行任务，并与线程的空闲程度相契合，详情见下文 cancelHostCallback 用于取消任务 shouldYieldToHost 用于判断任务是否超时、需要被打断 getCurrentTime 使用 performance 或 Date 对象获取当前时间 requestHostCallback 执行的流程图为： 上图中所用的缓存值有： 缓存 意义 scheduledHostCallback 待执行的回调，即上图中的任务，会被刷新 timeoutTime 任务允许的超时时间点 isAnimationFrameScheduled rAF 轮询启动状态 isMessageEventScheduled 消息发送中标识 isFlushingHostCallback 任务执行中标识 activeFrameTime 任务允许的超时时间点 timeoutTime 一帧的期望执行时长，预设为 33 ms，在视图刷新过快时会更新，值将变小 previousFrameTime 前一帧执行时长 frameDeadline 下一帧期望完成时间点，用于判断重绘后 js 线程是否空闲，还是长期占用 实现机制上，scheduler 首先实现 requestAnimationFrameWithTimeout 函数。该函数封装 requestAnimationFrame 函数，以使任务在重绘完后才予执行；但如果一些视图操作在后台执行，requestAnimationFrame 的回调将得不到执行，因此 scheduler 使用 setTimeout 兜底。流程图中启动 rAF 轮询就是指调用 requestAnimationFrameWithTimeout； animateTick 作为 requestAnimationFrameWithTimeout 回调。在 animateTick 的实现中，若 scheduledHostCallback 非 null，scheduler 将持续调用 requestAnimationFrameWithTimeout。因此本文将这一过程称为 rAF 轮询。 scheduler 考虑了重绘完成后、线程可能处于紧张的场景，因此所添加的任务并没有直接作为 requestAnimationFrameWithTimeout 的回调。scheduler 使用 MessageChannel 添加 macrotasks 队列作桥接，等待线程空闲，然后再执行任务。在 animateTick 中，scheduler 将计算下一帧期望完成时间点 previousFrameTime，然后通过 port.postMessage 方法发送消息。等到 port1 接受到消息时，schdulear 将 previousFrameTime 与 currentTime 作比较：当 previousFrameTime 小于等于 currentTime 时，scheduler 认为线程不是空闲的，对于超时的任务将立即执行，对于未超时的任务将在下次重绘后予以处理；当 previousFrameTime 大于 currentTime 时，线程就是空闲的，scheduler 将立即执行。这一处理机制在 port1.onMessage 监听函数中实现（作为 macrotasks，port1 接受消息的时机将随着线程的空闲程度起变化）。 有了上述的处理逻辑，scheduler 在外围制作 requestHostCallback(callback, absoluteTimeout) 接口：当前如果有任务正在执行中（意为当前没有重绘任务，重绘线程是空闲的）或者所添加的任务需要立即执行，scheduler 直接调用 port.postMessage 发送消息，跳过 rAF 轮询，以使任务得到即时执行；否则，如果 rAF 轮询未启动，调用 requestAnimationFrameWithTimeout(animationTick) 启动轮询。 在 requestHostCallback 接口之外，cancelHostCallback 通过 scheduledHostCallback 置为 null，以中断任务的执行；shouldYieldToHost 用于比较 frameDeadline 是否小于等于 currentTime（在一帧时间外），以此推断线程是否空闲，好添加并处理新任务。以下是 requestHostCallback 函数实现的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121var requestAnimationFrameWithTimeout = function(callback) &#123; // schedule rAF and also a setTimeout rAFID = localRequestAnimationFrame(function(timestamp) &#123; // cancel the setTimeout localClearTimeout(rAFTimeoutID); callback(timestamp); &#125;); rAFTimeoutID = localSetTimeout(function() &#123; // cancel the requestAnimationFrame localCancelAnimationFrame(rAFID); callback(getCurrentTime()); &#125;, ANIMATION_FRAME_TIMEOUT);&#125;;var channel = new MessageChannel();var port = channel.port2;channel.port1.onmessage = function(event) &#123; isMessageEventScheduled = false; var prevScheduledCallback = scheduledHostCallback; var prevTimeoutTime = timeoutTime; scheduledHostCallback = null; timeoutTime = -1; var currentTime = getCurrentTime(); var didTimeout = false; // 线程不空闲 if (frameDeadline - currentTime &lt;= 0) &#123; // There's no time left in this idle period. Check if the callback has // a timeout and whether it's been exceeded. if (prevTimeoutTime !== -1 &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123; // Exceeded the timeout. Invoke the callback even though there's no // time left. didTimeout = true; &#125; else &#123; // No timeout. if (!isAnimationFrameScheduled) &#123; // Schedule another animation callback so we retry later. isAnimationFrameScheduled = true; requestAnimationFrameWithTimeout(animationTick); &#125; // Exit without invoking the callback. scheduledHostCallback = prevScheduledCallback; timeoutTime = prevTimeoutTime; return; &#125; &#125; if (prevScheduledCallback !== null) &#123; isFlushingHostCallback = true; try &#123; prevScheduledCallback(didTimeout); &#125; finally &#123; isFlushingHostCallback = false; &#125; &#125;&#125;;var animationTick = function(rafTime) &#123; if (scheduledHostCallback !== null) &#123; // Eagerly schedule the next animation callback at the beginning of the // frame. If the scheduler queue is not empty at the end of the frame, it // will continue flushing inside that callback. If the queue *is* empty, // then it will exit immediately. Posting the callback at the start of the // frame ensures it's fired within the earliest possible frame. If we // waited until the end of the frame to post the callback, we risk the // browser skipping a frame and not firing the callback until the frame // after that. requestAnimationFrameWithTimeout(animationTick); &#125; else &#123; // No pending work. Exit. isAnimationFrameScheduled = false; return; &#125; var nextFrameTime = rafTime - frameDeadline + activeFrameTime; if ( nextFrameTime &lt; activeFrameTime &amp;&amp; previousFrameTime &lt; activeFrameTime ) &#123; if (nextFrameTime &lt; 8) &#123; // Defensive coding. We don't support higher frame rates than 120hz. // If the calculated frame time gets lower than 8, it is probably a bug. nextFrameTime = 8; &#125; // If one frame goes long, then the next one can be short to catch up. // If two frames are short in a row, then that's an indication that we // actually have a higher frame rate than what we're currently optimizing. // We adjust our heuristic dynamically accordingly. For example, if we're // running on 120hz display or 90hz VR display. // Take the max of the two in case one of them was an anomaly due to // missed frame deadlines. activeFrameTime = nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime; &#125; else &#123; previousFrameTime = nextFrameTime; &#125; frameDeadline = rafTime + activeFrameTime; if (!isMessageEventScheduled) &#123; isMessageEventScheduled = true; port.postMessage(undefined); &#125;&#125;;requestHostCallback = function(callback, absoluteTimeout) &#123; scheduledHostCallback = callback; timeoutTime = absoluteTimeout; if (isFlushingHostCallback || absoluteTimeout &lt; 0) &#123; // Don't wait for the next frame. Continue working ASAP, in a new event. port.postMessage(undefined); &#125; else if (!isAnimationFrameScheduled) &#123; // If rAF didn't already schedule one, we need to schedule a frame. // TODO: If this rAF doesn't materialize because the browser throttles, we // might want to still have setTimeout trigger rIC as a backup to ensure // that we keep performing work. isAnimationFrameScheduled = true; requestAnimationFrameWithTimeout(animationTick); &#125;&#125;; schedulercallbackNode 及其执行机制scheduler 以首尾相连的双向链表缓存 callbackNode，每个任务节点的 previous 属性指向上一个任务节点（firstCallbackNode 的 previous 属性指向 lastCallbackNode），next 属性指向下一个任务节点（lastCallbackNode 的 next 属性指向 firstCallbackNode）。链表中的 callbackNode 以优先级（以超时时间 expirationTime 属性表示）进行排序。以双向链表构建的数据，只需要缓存 firstCallbackNode 首任务节点。 scheduler 针对 callbackNode 设定五种优先级，分别是 ImmediatePriority, UserBlockingPriority, NormalPriority, LowPriority, IdlePriority。优先级会影响超时时间，以上五个优先级的超时时间分别为 -1, 250, 5000, 10000, 1073741823。因此对于 ImmediatePriority 优先级的任务节点，在使用 requestHostCallback 函数处理的过程中，该任务节点就不需要经过 rAF 回调机制，而是会经由 MessageChannel 直接被处理。 在 callbackNode 任务节点中，callback 属性为待执行的函数，priorityLevel 为执行优先级，expirationTime 为允许的超时时间点（以当前时间 + 超时时间的方式计算）。因为 requestHostCallback 每次调用时都会刷新 scheduledHostCallback 缓存，callbackNode.callback 并不能直接作为 requestHostCallback 的参数，那样会在两次调用过程中，造成前一个任务丢失。scheduler 实际使用 flushWork 函数作为 requestHostCallback 的参数（在 ensureHostCallbackIsScheduled 函数中处理），便于批量执行双向链表中的 callbackNode.callback 函数，也不至使任务丢失。 flushWork 函数基于 flushFirstCallback, flushImmediateWork，以下是这三个函数的实现机制： flushFirstCallback 从双向链表中取出首个任务节点并执行。若首个任务节点的 callback 返回函数，使用该函数构建新的 callbackNode 任务节点，并将该任务节点插入双向链表中：若该任务节点的优先级最高、且不只包含一个任务节点，调用 ensureHostCallbackIsScheduled，在下一次重绘后酌情执行双向链表中的任务节点；否则只将新创建的任务节点添加到双向链表中。 基于 flushFirstCallback，flushImmediateWork 函数用于执行双向链表中所有优先级为 ImmediatePriority 的任务节点。如果双向链表不只包含优先级为 ImmediatePriority 的任务节点，flushImmediateWork 将调用 ensureHostCallbackIsScheduled 等待下次重绘后执行剩余的任务节点。 flushWork 作为 requestHostCallback 函数的参数，获得的首个实参 didTimeout 为是否超时的标识。如果超时，flushWork 通过调用 flushFirstCallback 批量执行所有未超时的任务节点；若果没有超时，flushWork 将在下一帧未完成前（通过 shouldYieldToHost 函数判断）尽可能地执行任务节点。等上述条件逻辑执行完成后，如果双向链表非空，调用 ensureHostCallbackIsScheduled 等待下次重绘后执行剩余的任务节点。特别的，当双向链表中还存在 ImmediatePriority 优先级的任务节点，flushWork 将调用 flushImmediateWork 批量执行这些任务节点。 因为 scheduler 使用首个任务节点的超时时间点作为 requestHostCallback 函数的次参（在 ensureHostCallbackIsScheduled 函数中处理）。因此，如果首个任务节点的优先级为 ImmediatePriority，flushWork 所获得参数 didTimeout 也将是否值，其执行逻辑将是执行所有优先级为 ImmediatePriority 的任务节点，再调用 ensureHostCallbackIsScheduled 等待下一次重绘时执行其余任务节点。如果首个任务节点的优先级为 UserBlockingPriority 等，flushWork 将执行同优先级的任务节点，再调用 ensureHostCallbackIsScheduled 等待下一次重绘时执行其余任务节点。所有对不同优先级的任务节点，scheduler 采用分段执行的策略。 缓存 意义 currentPriorityLevel 执行中任务节点的优先级，默认为 NormalPriority currentExpirationTime 执行中任务节点的超时时间点 enableSchedulerDebugging debug 模式？ isExecutingCallback 任务节点正在批量执行中标识 isHostCallbackScheduled requestHostCallback 已执行并开启 rAF 轮询标识 isSchedulerPaused scheduler 是否被打断，将不会执行任务节点，由接口层更新该值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185function ensureHostCallbackIsScheduled() &#123; if (isExecutingCallback) &#123; // Don't schedule work yet; wait until the next time we yield. return; &#125; // Schedule the host callback using the earliest expiration in the list. var expirationTime = firstCallbackNode.expirationTime; if (!isHostCallbackScheduled) &#123; isHostCallbackScheduled = true; &#125; else &#123; // Cancel the existing host callback. cancelHostCallback(); &#125; requestHostCallback(flushWork, expirationTime);&#125;function flushFirstCallback() &#123; var flushedNode = firstCallbackNode; // Remove the node from the list before calling the callback. That way the // list is in a consistent state even if the callback throws. var next = firstCallbackNode.next; if (firstCallbackNode === next) &#123; // This is the last callback in the list. firstCallbackNode = null; next = null; &#125; else &#123; var lastCallbackNode = firstCallbackNode.previous; firstCallbackNode = lastCallbackNode.next = next; next.previous = lastCallbackNode; &#125; flushedNode.next = flushedNode.previous = null; // Now it's safe to call the callback. var callback = flushedNode.callback; var expirationTime = flushedNode.expirationTime; var priorityLevel = flushedNode.priorityLevel; var previousPriorityLevel = currentPriorityLevel; var previousExpirationTime = currentExpirationTime; currentPriorityLevel = priorityLevel; currentExpirationTime = expirationTime; var continuationCallback; try &#123; continuationCallback = callback(); &#125; finally &#123; currentPriorityLevel = previousPriorityLevel; currentExpirationTime = previousExpirationTime; &#125; // A callback may return a continuation. The continuation should be scheduled // with the same priority and expiration as the just-finished callback. if (typeof continuationCallback === 'function') &#123; var continuationNode: CallbackNode = &#123; callback: continuationCallback, priorityLevel, expirationTime, next: null, previous: null, &#125;; // Insert the new callback into the list, sorted by its expiration. This is // almost the same as the code in `scheduleCallback`, except the callback // is inserted into the list *before* callbacks of equal expiration instead // of after. if (firstCallbackNode === null) &#123; // This is the first callback in the list. firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode; &#125; else &#123; var nextAfterContinuation = null; var node = firstCallbackNode; do &#123; if (node.expirationTime &gt;= expirationTime) &#123; // This callback expires at or after the continuation. We will insert // the continuation *before* this callback. nextAfterContinuation = node; break; &#125; node = node.next; &#125; while (node !== firstCallbackNode); if (nextAfterContinuation === null) &#123; // No equal or lower priority callback was found, which means the new // callback is the lowest priority callback in the list. nextAfterContinuation = firstCallbackNode; &#125; else if (nextAfterContinuation === firstCallbackNode) &#123; // The new callback is the highest priority callback in the list. firstCallbackNode = continuationNode; ensureHostCallbackIsScheduled(); &#125; var previous = nextAfterContinuation.previous; previous.next = nextAfterContinuation.previous = continuationNode; continuationNode.next = nextAfterContinuation; continuationNode.previous = previous; &#125; &#125;&#125;function flushImmediateWork() &#123; if ( // Confirm we've exited the outer most event handler currentEventStartTime === -1 &amp;&amp; firstCallbackNode !== null &amp;&amp; firstCallbackNode.priorityLevel === ImmediatePriority ) &#123; isExecutingCallback = true; try &#123; do &#123; flushFirstCallback(); &#125; while ( // Keep flushing until there are no more immediate callbacks firstCallbackNode !== null &amp;&amp; firstCallbackNode.priorityLevel === ImmediatePriority ); &#125; finally &#123; isExecutingCallback = false; if (firstCallbackNode !== null) &#123; // There's still work remaining. Request another callback. ensureHostCallbackIsScheduled(); &#125; else &#123; isHostCallbackScheduled = false; &#125; &#125; &#125;&#125;function flushWork(didTimeout) &#123; // Exit right away if we're currently paused if (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123; return; &#125; isExecutingCallback = true; const previousDidTimeout = currentDidTimeout; currentDidTimeout = didTimeout; try &#123; if (didTimeout) &#123; // Flush all the expired callbacks without yielding. while ( firstCallbackNode !== null &amp;&amp; !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused) ) &#123; // TODO Wrap i nfeature flag // Read the current time. Flush all the callbacks that expire at or // earlier than that time. Then read the current time again and repeat. // This optimizes for as few performance.now calls as possible. var currentTime = getCurrentTime(); if (firstCallbackNode.expirationTime &lt;= currentTime) &#123; do &#123; flushFirstCallback(); &#125; while ( firstCallbackNode !== null &amp;&amp; firstCallbackNode.expirationTime &lt;= currentTime &amp;&amp; !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused) ); continue; &#125; break; &#125; &#125; else &#123; // Keep flushing callbacks until we run out of time in the frame. if (firstCallbackNode !== null) &#123; do &#123; if (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123; break; &#125; flushFirstCallback(); &#125; while (firstCallbackNode !== null &amp;&amp; !shouldYieldToHost()); &#125; &#125; &#125; finally &#123; isExecutingCallback = false; currentDidTimeout = previousDidTimeout; if (firstCallbackNode !== null) &#123; // There's still work remaining. Request another callback. ensureHostCallbackIsScheduled(); &#125; else &#123; isHostCallbackScheduled = false; &#125; // Before exiting, flush all the immediate work that was scheduled. flushImmediateWork(); &#125;&#125; apisunstable_scheduleCallbackunstable_scheduleCallback(callback, deprecated_options) 基于 currentPriorityLevel 优先级计算超时时间点，将 callback 构建为一个 callbackNode 任务节点，并将该节点插入双向链表，启用 ensureHostCallbackIsScheduled 等待重绘后执行任务节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function unstable_scheduleCallback(callback, deprecated_options) &#123; var startTime = currentEventStartTime !== -1 ? currentEventStartTime : getCurrentTime(); var expirationTime; if ( typeof deprecated_options === 'object' &amp;&amp; deprecated_options !== null &amp;&amp; typeof deprecated_options.timeout === 'number' ) &#123; // FIXME: Remove this branch once we lift expiration times out of React. expirationTime = startTime + deprecated_options.timeout; &#125; else &#123; switch (currentPriorityLevel) &#123; case ImmediatePriority: expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT; break; case UserBlockingPriority: expirationTime = startTime + USER_BLOCKING_PRIORITY; break; case IdlePriority: expirationTime = startTime + IDLE_PRIORITY; break; case LowPriority: expirationTime = startTime + LOW_PRIORITY_TIMEOUT; break; case NormalPriority: default: expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT; &#125; &#125; var newNode = &#123; callback, priorityLevel: currentPriorityLevel, expirationTime, next: null, previous: null, &#125;; // Insert the new callback into the list, ordered first by expiration, then // by insertion. So the new callback is inserted any other callback with // equal expiration. if (firstCallbackNode === null) &#123; // This is the first callback in the list. firstCallbackNode = newNode.next = newNode.previous = newNode; ensureHostCallbackIsScheduled(); &#125; else &#123; var next = null; var node = firstCallbackNode; do &#123; if (node.expirationTime &gt; expirationTime) &#123; // The new callback expires before this one. next = node; break; &#125; node = node.next; &#125; while (node !== firstCallbackNode); if (next === null) &#123; // No callback with a later expiration was found, which means the new // callback has the latest expiration in the list. next = firstCallbackNode; &#125; else if (next === firstCallbackNode) &#123; // The new callback has the earliest expiration in the entire list. firstCallbackNode = newNode; ensureHostCallbackIsScheduled(); &#125; var previous = next.previous; previous.next = next.previous = newNode; newNode.next = next; newNode.previous = previous; &#125; return newNode;&#125; unstable_runWithPriorityunstable_runWithPriority(priorityLevel, eventHandler) 将 currentPriorityLevel 缓存设置为 priorityLevel，随后再执行 eventHandler，最后调用 flushImmediateWork 函数执行所有优先级为 ImmediatePriority 的任务节点，其余任务节点等待下次重绘后再执行。可以设想，当 eventHandler 为 unstable_scheduleCallback 函数时，将影响所添加任务节点的优先级，并立即执行 ImmediatePriority 优先级的任务。 123456789101112131415161718192021222324252627function unstable_runWithPriority(priorityLevel, eventHandler) &#123; switch (priorityLevel) &#123; case ImmediatePriority: case UserBlockingPriority: case NormalPriority: case LowPriority: case IdlePriority: break; default: priorityLevel = NormalPriority; &#125; var previousPriorityLevel = currentPriorityLevel; var previousEventStartTime = currentEventStartTime; currentPriorityLevel = priorityLevel; currentEventStartTime = getCurrentTime(); try &#123; return eventHandler(); &#125; finally &#123; currentPriorityLevel = previousPriorityLevel; currentEventStartTime = previousEventStartTime; // Before exiting, flush all the immediate work that was scheduled. flushImmediateWork(); &#125;&#125; unstable_wrapCallbackunstable_wrapCallback(callback) 记录当前的优先级 currentPriorityLevel，返回函数处理效果如 unstable_runWithPriority，对于 callback 中新添加的任务节点将使用所记录的 currentPriorityLevel 作为优先级。 123456789101112131415161718function unstable_wrapCallback(callback) &#123; var parentPriorityLevel = currentPriorityLevel; return function() &#123; // This is a fork of runWithPriority, inlined for performance. var previousPriorityLevel = currentPriorityLevel; var previousEventStartTime = currentEventStartTime; currentPriorityLevel = parentPriorityLevel; currentEventStartTime = getCurrentTime(); try &#123; return callback.apply(this, arguments); &#125; finally &#123; currentPriorityLevel = previousPriorityLevel; currentEventStartTime = previousEventStartTime; flushImmediateWork(); &#125; &#125;;&#125; 其他 unstable_pauseExecution 通过将 isSchedulerPaused 置为 true，打断 scheduler 处理任务节点。 unstable_continueExecution 取消打断状态，使 scheduler 恢复处理任务节点。 unstable_getFirstCallbackNode 获取双向链表中的首个任务节点。 unstable_cancelCallback(callbackNode) 从双向链表中移除指定任务节点。 unstable_getCurrentPriorityLevel 获取当前优先级 currentPriorityLevel 缓存。 unstable_shouldYield 是否需要被打断。 unstable_now 获取当前时间。 12345678function unstable_shouldYield() &#123; return ( !currentDidTimeout &amp;&amp; ((firstCallbackNode !== null &amp;&amp; firstCallbackNode.expirationTime &lt; currentExpirationTime) || shouldYieldToHost()) );&#125; 总结scheduler 模块代码简短，逻辑复杂，在这篇文章中，难免有理解不当的地方。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"http://xzfyu.com/categories/frontend/react/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"react api 整理","slug":"frontend/react16/React","date":"2019-01-13T16:00:00.000Z","updated":"2020-03-08T10:46:34.003Z","comments":true,"path":"2019/01/14/frontend/react16/React/","link":"","permalink":"http://xzfyu.com/2019/01/14/frontend/react16/React/","excerpt":"","text":"本文档意在整理 react 顶层 api 的内容和实现，可参阅react 官方文档。React 包主要提供 api 接口，功能上的核心逻辑点通常由 react-dom 等包实现。 组件React 组件可将视图内容拆分为独立的、可复用的单元，以便在组件的模块制作过程中独立实现视图逻辑和业务逻辑。在 es6 语法背景下，React 组件可基于 React.Component, React.PureComponent 类加以制作。如果没有使用 es6 语法，可以使用 create-react-class 库。除此以外，也可以编写函数式组件。该函数式组件能用 React.memo 加以包裹。 在源码中，React.Component, React.PureComponent 类由 ReactBaseClasses 模块提供。 ComponentComponent(props, context, updater) 基类在构造函数中初始化 props, context, refs, updater 实例属性，并包含 isReactComponent, setState, forceUpdate 原型方法。其中，updater 属性在实例化阶段将赋值为默认的 ReactNoopUpdateQueue，渲染阶段在注入实际的 updater。setState, forceUpdate 原型方法基于 updater.enqueueSetState, updater.enqueueForceUpdate 构建。 PureComponentPureComponent(props, context, updater) 与 Component 基类拥有相同的实例属性，其原型对象也通过桥接函数赋值的形式重新构造、且混入了 Component 基类的原型方法，除此之外，PureComponent 还具有 isPureReactComponent 原型方法。 生命周期可参考 React 组件生命周期 挂载阶段： constructor(props): 实例化。 static getDeriverdStateFromProps 从 props 中获取 state。 render 渲染。 componentDidMount: 完成挂载。 更新阶段： static getDeriverdStateFromProps 从 props 中获取 state。 shouldComponentUpdate 判断是否需要重绘。 rendere 渲染。 getShapshotBeforeUpdate 获取快照。 componentDidUpdate 渲染完成后回调。 卸载阶段： componentWillUnmount 即将卸载。 错误处理： static getDerivedStateFromError 从错误中获取 state。 componentDidCatch 捕获错误并进行处理。 React.memoReact.memo(funcComponent, compare) 用于创建高阶组件，使函数式组件具有如 PureComponent 的效果。在默认情况下，它会浅比较接受到的 props，当然，在提供 compare(prevProps, nextProps) 参数的场景中，你也可以定制重绘时机。 1234function MyComponent(props)&#123;&#125;;function areEqual(prevProps, nextProps)&#123;&#125;;export default React.memo(MyComponent, areEqual); 实现上，memo 函数会构建类 React 元素数据如 { $$typeof, type, compare }。其中，$$typeof 为来自 shared/ReactSymbols 包下的常量 REACT_MEMO_TYPE；type 为首参函数式组件；compare 即次参对比函数。 元素React 元素可使用 JSX 语法书写，也可以使用 createElement, createFactory 方法构建。react-hyperscript, hyperscript-helpers 这两个类库也提供了创建 React 元素的便捷语法糖。 除了 createElement, createFactory 方法以外，React 还提供 cloneElementAndReplaceKey, cloneElement, isValidElement 用于克隆元素或者校验元素。这些方法均由 ReactElement 模块输出。而 React.children 用于处理对子元素的操作。 ElementReactElement(type, key, ref, self, source, owner, props) 作为创建元素的工厂函数，将构建 element 常量并返回。其中，element 包含可枚举可赋值的 $$typeof, type, key, ref, props, _owner 属性，$$typeof 属性为特定常量 REACT_ELEMENT_TYPE。在开发环境中，element 又包含 _store 存储校验标识（_store.validated），不可枚举不可赋值的 _self, _source 属性；且 element, element.props 均使用 Object.freeze 冻结。 createElement(type, config, children) 使用特定的自定义或内置组件 type 创建元素。参数 config 通过 key, ref, self, source 配置元素的 key, ref, self, source 属性，其余属性将作为元素的 props。children 用于配置元素下割的子元素。在创建元素时，ReactCurrentOwner.current 将作为元素的 _owner 属性。ReactCurrentOwner.current 值为渲染过程中的 Fiber 实例。 createFactory(type) 为特定的组件创建工厂函数。 cloneAndReplaceKey(oldElement, newKey) 使用 oldElement 组件构造器 oldElement.type 以及 ref, props, _owner, _self, _source 属性构建新的元素，该元素的 key 属性指定为 newKey。 cloneElement(element, config, children) 与 cloneAndReplaceKey 不同的是，该方法在克隆元素时可以重新配置 key, ref, props, children 属性。如果重置 ref 属性时，克隆元素的 _owner 属性也将同步更新为渲染过程中的 ReactCurrentOwner.current。 isValidElement(object) 通过校验参数 object 是否为对象且其 $$typeof 属性为 REACT_ELEMENT_TYPE，以判断是否 React 元素。 ChildrenforEach(children, forEachFunc, forEachContext) 遍历子元素，执行 forEachFunc 函数。 map(children, func, context) 遍历子元素，执行 func 函数。功能点同 forEach 方法，但是返回数组。 toArray(children) 将子元素转化为数组。 count(children) 计算子元素的数目。 only((children)) 校验参数 children 是否单一的 React 元素，并返回。 实现上，React 以 traverseAllChildren(children, callback, traverseContext) 函数作为遍历子元素的 api。traverseAllChildren 函数通过递归调用 traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) 遍历子元素，并校验子元素集合不能由 Map, Object 对象构建。对于回调的执行机制，React 会先使用 getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) 将 forEach 方法的参数 forEachFunc, forEachContext 或者 map 方法的参数 func, context 组装成 traverseContext 对象（该对象还包含用于收集子元素的数组 mapResult 和元素 key 键的公共前缀 keyPrefix 属性）。在 traverseContext 对象的基础上，React 对 forEach, map 构建了单独的回调包装函数 forEachSingleChild, mapSingleChildIntoContext，以处理特定的逻辑。具体实现可参阅源码。 多个元素在渲染时可使用 React.Fragment 组件包裹，那样就不必创建额外的 dom 节点。React 输出的 Fragment 组件直接来自于 shared/ReactSymbols 包下的常量 REACT_FRAGMENT_TYPE。 1234&lt;React.Fragment&gt; Some text. &lt;h2&gt;A heading&lt;/h2&gt;&lt;/React.Fragment&gt; RefscreateRefReact.createRef 创建 refObject 对象，该对象可以作为 React 元素的 ref 属性，以此引用指定的 React 元素。React 包下只创建 refObject 对象并使用 Object.seal 加以密封，核心逻辑由其他包提供。 1234567891011121314class MyComponent extends React.Component &#123; constructor(props)&#123; super(props); this.input = React.createRef(); &#125; componentDidMount()&#123; this.input.current.focus(); &#125; render()&#123; return &lt;input type='text' ref=&#123;this.input&#125; /&gt; &#125;&#125; forwardRefReact.forwardRef 通过创建组件的方式将其所接受的 ref 引用配置长传给其子孙组件。forwardRef 有两个应用场景：为函数式组件指定引用；为高阶组件指定引用。 12345678cosnt FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className='FancyButton'&gt; &#123;props.children&#125; &lt;/button&gt;));const ref = React.createRef();&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;; 上述代码可将创建的 refObject 对象通过 forwardRef 的次参传入函数式组件，以便引用原生 dom 组件。虽然这样创建 ref 引用会增加 FancyButton 与其父元素的层级关联，造成一定的复杂度，但是当 FancyButton 组件被多个应用级组件所使用时，且这些应用级组件都要细微地操作 button 节点，通过 forwardRef 长传 ref 引用就必不可少了。 在制作高阶组件时，同样可以使用 React.forwardRef 将 ref 引用转变为特定的 props 属性并传入高阶组件中，那样被包裹的组件就可以使用该 props 属性设置 ref 引用了。代码实现如： 1234567891011121314151617function logProps(Component)&#123; class LogProps extends React.Component &#123; componentDidUpdate(prevProps)&#123; console.log('old props:', prevProps); console.log('new props:', this.props); &#125; render()&#123; const &#123;forwardedRef, ...rest&#125; = this.props; return &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;LogProps &#123;...props&#125; forwaredRef=&#123;ref&#125; /&gt;; &#125;)&#125; 在实现中，forwardRef 将校验参数是否为函数且包含两个参数（通过 length 属性校验）等，最终返回类 React 元素结构如 { $$typeof, render }。其中，$$typeof 为常量 REACT_FORWARD_REF_TYPE，render 即 forwardRef 的参数。 SuspenseReact.Suspense 支持在某事件执行完成后渲染组件。目前只支持一种应用场景：通过 React.lazy 动态加载组件，在组件加载完成后，再行渲染。 12345const LazyComponent = React.lazy(() =&gt; import('./OtherComponent.js'));&lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;&gt; &lt;LazyComponent&gt;&lt;/Suspense&gt; 在 OtherComponent 组件加载过程中，React 将使用 fallback 渲染元素；当 OtherComponent 加载完成后，视图将显示 OtherComponent 组件。Suspense 组件内允许渲染多个懒加载组件。在组件加载失败的场景中，可以构建实现了 getDerivedStateFromError(error) 静态方法以及 componentDidCatch(error, info) 生命周期方法的 ErrorBoundary 组件捕获错误并加以处理。 使用 React.lazy 动态加载的组件，不止可以作为 Suspense 组件的子元素，还可以作为 Route 组件的 component，以在路由层面实现动态加载。 在实现上，React.lazy 方法将构建类 React 元素的数据结构如 { $$typeof, _ctor, _status, _result }。其中，$$typeof 为常量 REACT_LAZY_TYPE，_ctor 为 React.lazy 接受的参数。React 输出的 Suspense 组件直接来自于 shared/ReactSymbols 包下的常量 REACT_SUSPENSE_TYPE。 createContextContext 可视为 React 组件树的全局数据（比如验权后的用户信息、网页的主题风格、显示的语言），用于向子孙组件透传数据，而不必通过 props 属性逐层传递、或者将在顶层组件中将实际消费数据的子组件作为 children 传入中介组件。 Context 使用的方式为： 使用 React.createContext(defaultValue) 创建 Context 对象。当 React 组件订阅了该 Context 对象时，该组件将从就近且匹配的 Provider 中读取 Context 对象。如果没有匹配的 Provider，那就会使用 defaultValue。 Context.Provider 以父组件的形式作为 Context 对象的提供者，当其重绘时，将迫使订阅数据的组件相应重绘。 在自定义组件中添加 contextType 静态属性，当其值为 Context 对象时，就可以通过组件实例的 context.value 访问实际透传的数据。 第 3 步也可以替代为第 4 步，使用 Context.Consumer 作为数据的消费者，其下可以用 value =&gt; ReactNode 的形式编写函数式组件。 123456789101112131415161718192021222324252627282930313233343536373839const ThemeContext = React.createContext('light');const UserContext = React.createContext(&#123; name: 'Guest' &#125;);class App extends React.Component &#123; render()&#123; const &#123; signedInUser, theme &#125; = this.props; return ( &lt;ThemeContext.Provider value=&#123;theme&#125;&gt; &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt; &lt;Layout /&gt; &lt;/UserContext.Provider&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;function Layout()&#123; return ( &lt;div&gt; &lt;Sidebar /&gt; &lt;Context /&gt; &lt;/div&gt; )&#125;function Context()&#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;UserContext.Consumer&gt; &#123;user =&gt; ( &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt; )&#125; &lt;/UserContext.Consumer&gt; )&#125; &lt;/ThemeContext.Consumer&gt; )&#125; 实现上，createContext(defaultValue, calculateChangeBits) 方法会创建类 React 元素数据如 { $$typeof, _calculateChangedBits, _currentValue, _currentValue2, _threadCount, Provider, Consumer }。其中，$$typeof 为常量 REACT_CONTEXT_TYPE。Context.Provider 创建类 React 元素数据如 { $$typeof, _context }。其中，$$typeof 为常量 REACT_PROVIDER_TYPE；_context 即引用 Context 对象。Context.Consumer 在生产环境中就是Context 引用对象，开发环境将校验不能使用嵌套形式编码如 Context.Consumer.Provider, Context.Consumer.Consumer。 ReactHooks借助于 HOC 或者 render props，你可以整合组件内的可重用逻辑。比如当弹窗 Modal 组件内包含多个可切换的表单组件时，可以使用 render props 将表单的渲染函数传入 Modal 中。但是这样处理却会破坏组件的结构，容易造成 wrapper 装饰器层叠套用较深，在层叠组件中维护组件的状态。使用 ReactHooks 后，我们可以提取状态处理逻辑，这样可以对状态处理逻辑进行独立测试和复用，且不会改变组件的层级。在多个组件中，共用钩子也是较为方便的。 在编写组件时，随着项目的逐步发展，组件的逻辑将变得极为复杂，比如 componentDidMount 方法内既会包含数据获取的操作，又会包含事件绑定，同时，相同功能点的处理逻辑（事件绑定和解绑）会散落在多个生命周期中。这样就会包含多个执行逻辑，也使代码不易测试、容易出错。借助状态管理器，我们可以将部分执行逻辑写入 store 中，然而这样会引入过多的抽象，执行逻辑也分散在多个模块中，也使组件不便于重用。使用 ReactHooks 后，我们可以基于功能点将彼此相关的处理逻辑拆分为多个小函数，而不是割裂性地分布在组件的多个生命周期中。 如同 Svelte, Angular, Glimer 所展示的，提前预编译组件在未来拥有极高的潜力。React 最近在尝试使用 Prepack 在编译时预处理组件，并且已经看见了一些眉目。然而类组件会使这些优化进展缓慢，同时，类也不能很好的压缩，并使热加载变得不可靠。使用 ReactHooks 后，我们可以使用更多的 React 特性，且不必借助类组件的形式。 从效果上看，ReactHooks 为函数式组件提供状态管理以及相关生命周期特性。 在 React 包中，除却必要的校验外，ReactHooks 提供的 api 都将间接调用 ReactCurrentOwner.currentDispatcher 的同名方法。 State Hook1234567891011121314import &#123; useState &#125; from 'react';function Example()&#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; )&#125; useState 将声明一个状态变量，作为返回数组的首项，该状态变量受到 React 机制的保护，只能通过第二个数组项 setCount 进行修改（其功能点一如类组件中使用的 setState 方法）。useState 的参数为状态的初始值，不限于对象形式。如果要使用两个状态，可调用 useState 两次达成。如前所述，useState 以数组形式返回一对值，前一个是当前的状态，后一个是用于变更状态的函数。 useState 的首参也可以是函数，初始状态由函数的返回值提供。 Effect HookEffect Hook 用于组织副作用逻辑，包含远程数据获取、事件绑定、节点操作、日志打印等。假设有针对组件状态的处理逻辑，在类组件的编程形式中，我们需要在 componentDidMount, componentDidUpdate 生命周期中两次组织同一个处理逻辑。当使用 Effect Hook 时，我们只需要组织一次这个处理逻辑。 12345678910111213141516171819202122import &#123; useState, useEffect &#125; from 'react';function FriendStatus(props)&#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status)&#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeToFriendStatus(props.friend.id, handleStatusChange); &#125; &#125;) if (isOnline === null)&#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125; 效果上，useEffect(effect, inputs) 等同于告知 React 在组件渲染完成后需要执行 effect 副作用（React 会记录这个副作用函数，并在组件渲染完成后调用）；参数 inputs 以数组形式告知 React 当某些数据变更时，才执行副作用（可以是函数式组件内的任何变量或属性，并在 effect 中有所使用）。在函数式组件中使用 useEffect，其意义在于便捷地通过 useState 访问状态；同时，每次重绘将会构建新的 effect，其效果等同于每次渲染都会调度不同的副作用，属于一次性消费。与 componentDidMount, componentDidUpdate 不同的是，useEffect 副作用不会阻塞视图更新。useLayoutEffect 方法与 useEffect 类似，可用于测算布局。 当所需执行的副作用为事件订阅类时，在组件卸载时，我们需要解绑事件，以防内存溢出。当 effect 返回函数（比如用于解绑事件）时，React 会在组件即将更新时执行这个函数。以下是 基于 useEffect，我们可以将相同功能点的处理逻辑写在一个 effect 中，组件内使用多个 effect 涵盖不同的功能点，而不是像类组件那样使相同功能点的处理逻辑散落在不同生命周期中。同时，我们也不需要在 componentDidUpdate 编写一套 props 变更的处理逻辑，因为 useEffect 在组件重置后均会得到调用。 Custom Hook自定义 hook 允许在不同组件重用状态处理逻辑 12345678910111213141516171819202122232425262728293031323334353637import &#123; useState, useEffect &#125; from 'react';function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125;function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125;function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? 'green' : 'black' &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 自定义 hook 名需要使用 ‘use’ 起始，这样才能满足 eslint-plugin-react-hooks，React 也能侦测出这是一个 hook。其次，在不同组件中使用的自定义 hook，会构建不同的 state。 useReducer当组件的状态管理略显复杂时，React 提供 useReducer 钩子以 Redux 风格管理状态。 useReducer 方法的首参为 reducer，次参为 initialState，尾参为 initialAction 如 {type: ‘reset’, payload: initialCount}。 123456789101112131415161718192021222324252627282930313233function todosReducer(state, action) &#123; switch (action.type) &#123; case 'add': return [...state, &#123; text: action.text, completed: false &#125;]; // ... other actions ... default: return state; &#125;&#125;function useReducer(reducer, initialState) &#123; const [state, setState] = useState(initialState); function dispatch(action) &#123; const nextState = reducer(state, action); setState(nextState); &#125; return [state, dispatch];&#125;function Todos() &#123; const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) &#123; dispatch(&#123; type: 'add', text &#125;); &#125; // ...&#125; 其他 useContext(context): 使用 React.createContext 创建的 context 对象作为参数，从就近的 Provider 中获取 context 对象。当 context 对象在 Provider 中更新时，组件将重绘。 useCallback(() =&gt; { doSomething(realInputs) }, inputs): 当 inputs 数组数据变更时，执行 doSomething 回调。useCallback(fn, inputs) 等价于 useMemo(() =&gt; fn, inputs)。 useMemo(() =&gt; { computeExpensiveValue(realInputs) }, inputs): 当 inputs 数组数据变更时，执行 computeExpensiveValue 函数，重新计算新值。 useRef(initialValue): 将使用接受的首参构建引用，通过 current 属性访问。该 ref 引用将在组件的生命周期中得到维持。 useImperativeMethods(ref, createInstance, [inputs]): 用于对外导出操纵子元素的 ref 引用方法，只能配合 forwardRef 方法使用。 1234567891011121314151617181920212223242526// useReffunction TextInputWithFocusButton() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; // `current` points to the mounted text input element inputEl.current.focus(); &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125;// useImperativeMethodsfunction FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeMethods(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;FancyInput = forwardRef(FancyInput);","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"react","slug":"frontend/react","permalink":"http://xzfyu.com/categories/frontend/react/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"Menu","slug":"frontend/antd/Menu","date":"2018-12-09T16:00:00.000Z","updated":"2020-03-08T10:28:26.017Z","comments":true,"path":"2018/12/10/frontend/antd/Menu/","link":"","permalink":"http://xzfyu.com/2018/12/10/frontend/antd/Menu/","excerpt":"","text":"antd 中的 Menu 组件用于绘制菜单栏，其实现基于 rc-menu。本文第一部分介绍菜单栏实现的整体结构；第二部分介绍 rc-menu；第三部分介绍 Menu 组件。 需要声明的是，本文使用 RcMenu 指代 rc-menu 输出的 Menu 组件或其实例，使用 Menu 指代 antd 输出的 Menu 组件或其实例、或抽象意义的菜单栏组件，余同。 整体结构在视图上，菜单栏分为水平布局和垂直布局两种，又支持层叠嵌套（如主菜单 Menu 嵌套子菜单 SubMenu）；子菜单的展开形式分为内嵌和浮层两种。Menu 组件通过 props.mode 区分所采用的模式：vertical 为垂直模式；horizontal 为水平模式；inline 为内嵌模式。菜单栏的垂直布局和水平布局借助样式实现。在水平布局中，超出菜单栏宽度的菜单项需要合并展示，这部分处理逻辑由 rc-menu 中的 DomWrap 组件实现。 在内容上，主菜单和子菜单相仿，功能上有交集。在 rc-menu 中，主菜单 Menu 和子菜单 SubMenu 均通过 SubPopupMenu 组件绘制内容，SubPopupMenu 又使用 DomWrap 控制水平布局时的元素展示。SubPopupMenu 自有的处理逻辑为：控制菜单栏的激活状态（通过 componentDidUpdate, onKeyDown, onItemHover 方法达成，详见下文）。用过 antd 的同学应该了解，Menu 组件下可使用 SubMenu, MenuItem, MenuItemGroup 绘制子菜单或菜单项，父子元素之间就会有状态管理方面的通信需求。针对这个问题，SubPopupMenu 使用 React.clone 方法将父组件实现的状态管理函数或其 props 属性注入到子组件中，从而串联了主菜单与子菜单、主菜单与菜单项、以及子菜单与菜单项。 菜单栏的状态管理分为三种：菜单项的激活状态、菜单项的选中状态、子菜单的展开折叠状态。rc-menu 借助 mini-store 管理这些状态：activeKey 激活的菜单项，selectedKeys 选中的菜单项，openKeys 展开的子菜单。如上文所说，activeKey 由 SubPopupMenu 处理其更新逻辑。selectedKeys, openKeys 均由 RcMenu 处理其更新逻辑。交互层面，当 props.selectedKeys, props.openKeys 变更时，RcMenu 提供的 updateMiniStore 方法将负责更新 store 中的存储数据；当用户行为发生时，RcMenu 提供的 onSelect, onDeSelect, onOpenChange 方法将负责更新 store 中的存储数据，这些方法又通过 SubPopupMenu 长传到 SubMenu, MenuItem, MenuItemGroup 中。简而言之，RcMenu 既通过 props 接受使用者传入的菜单栏整体配置数据，又集成了 selectedKeys, openKeys 的状态管理函数。 在 RcMenu 提供 onSelect, onDeSelect, onOpenChange 方法和 SubPopupMenu 提供的 onItemHover 方法的基础上，子菜单 RcSubMenu 既将 onSelect, onDeSelect 透传给菜单项，又使用 onOpenChange 控制展开折叠状态，onItemHover 更新激活状态。不同于主菜单，子菜单需要以内嵌或浮层形式表现内容，且需要在展开与折叠过程中显示动效。借助 rc-trigger、rc-animate 库，RcSubMenu 集成了浮层显示功能和动效展示逻辑。即，通过 props.mode 判断菜单栏是否采用 inline 模式，RcSubMenu 将以浮层形式绘制子菜单内容；子菜单展开与折叠过程中所采用的动效，取决于顶层容器 Menu 主菜单接受 props 配置。 菜单项 RcMenuItem 通过 props 接受 RcMenu 提供的 onSelect, onDeSelect 方法和 SubPopupMenu 提供的 onItemHover 方法，以便在点击事件、鼠标移入移出时更新 store 中的状态。在 RcMenuItem 的基础上，RcMenuItemGroup 用于绘制成组的菜单项。 下图是 rc-menu 的整体结构: 在 rc-menu 实现状态管理的基础上，antd 提供的 Menu 组件用于桥接侧边栏和菜单栏的关联性，维护内置的动效显示，以及样式处理。详见下文。 rc-menurc-menu 的类图为： rc-menu 中的状态管理： selectedKeys 选中的菜单项：由 RcMenu 提供 onSelect, onDeselect 方法加以管理。onSelect, onDeselect 方法将长传到 RcMenuItem 组件，以便在 RcMenuItem 的 onKeyDown, onClick 行为中更新状态。同时，在 RcMenu 的 componentDidUpdate 生命周期中，也将 props.selectedKeys 更新状态值。 openKeys 展开的子菜单：由 RcMenu 提供 onOpenChange 方法加以管理。onOpenChange 方法将长传到 RcSubMenu 组件并封装为 RcSubMenu.triggerOpenChange 方法，以便在 RcSubMenu 的 onKeyDown, onTitleClick, onPopupVisibleChange 行为中更新状态。同时，在 RcMenu 的 componentDidUpdate 生命周期中，也将 props.openKeys 更新状态值。 activeKey 激活的菜单项：由辅助函数 updateActiveKey 加以管理。updateActiveKey 函数被 SubPopupMenu 的 componentDidUpdate, onItemHover 方法调用。其中，onItemHover 方法将长传到 RcSubMenu 或 RcMenuItem 组件，以便在 RcSubMenu 的 onTitleMouseEnter, onTitleMouseLeave 行为或 RcMenuItem 的 onMouseEnter, onMouseLeave 行为中更新状态。 defaultActiveFirst 是否激活首个菜单项，辅助计算激活的菜单项：由辅助函数 updateDefaultActiveFirst 加以管理。updateDefaultActiveFirst 函数被 RcSubMenu 的 constructor, onKeyDown, onMouseEnter, onTitleClick 方法调用。其中，constructor 将视 RcSubMenu 接受的 props.defaultActiveFirst 设置状态；onKeyDown 将状态更新为 true；onMouseEnter, onTitleClick 均更新为 false。 rc-menu 中的 key 键用于辅助状态管理。key 键仅对于子菜单或菜单项才有效。在默认情况下，SubPopupMenu 会以 ‘0-menu-‘ 作为前缀，递归创建子菜单或菜单项的 key 键，并设置为该子菜单或菜单项的 props.eventKey。当菜单项作为子菜单的元素时，那么菜单项的 key 键就以子菜单的 props.eventKey 作为前缀。当使用者为子菜单或菜单项设置了 key 键时，rc-menu 将以它作为该子菜单或菜单项的 props.eventKey 键。因此，相同的 key 键是不被允许的。 1234567891011// 当 SubPopupMenu 作为 RcMenu 的直系子元素时，返回 '0-menu-'// 其余情况获取子菜单或菜单项的 props.eventKeyfunction getEventKey(props) &#123; return props.eventKey || '0-menu-';&#125;// 自动创建 key 键并返回，或者返回使用者设置的 key 键function getKeyFromChildrenIndex(child, menuEventKey, index) &#123; const prefix = menuEventKey || ''; return child.key || `$&#123;prefix&#125;item_$&#123;index&#125;`;&#125; 在 store 中，selectedKeys, openKeys 以 key 键作为数组项；activeKey, defaultActiveFirst 以 key 键作为属性名。当用户行为发生时，key 键将被封装到对象中，通过逐级调用 props 方法，冒泡给 RcMenu 实例的 onOpenChange, onSelect, onDeselect 或者 SubPopupMenu 实例的 onItemHover 方法，最终改变 store 的状态。需要说明的是，菜单项的 onClick 也会逐级调用 props 方法，以数组形式拼接子菜单的 key 键，最终冒泡给 RcMenu 接受的 props.onClick 方法。而 RcMenu 接受的 props.onDestory 方法，则是逐级向下传递，最终在每个菜单项的 componentWillUnmount 生命周期中，均执行 onDestory 方法，参数即菜单项的 key 键。特别的，RcMenu 实现的 onKeyDown 实例方法将逐级往下调用 SubPopupMenu, RcSubMenu, RcMenuItem 中的 onKeyDown 方法。在这个过程中，SubPopupMenu 构建的 onKeyDown 实例方法也将在 DomWrap 组件被绑定为视图元素 onKeyDown 事件发生时的执行函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Menu extends React.Component &#123; // 以引用形式调用，可依次改变选中的菜单项 // 当遇到子菜单时，先展开子菜单，再选中子菜单项 onKeyDown = (e, callback) =&gt; &#123; // this.innerMenu.getWrappedInstance 用于获得 Menu 下直系子元素 —— SubPopupMenu 实例 this.innerMenu.getWrappedInstance().onKeyDown(e, callback); &#125;&#125;class SubPopupMenu extends React.Component &#123; onKeyDown = (e, callback) =&gt; &#123; const keyCode = e.keyCode; let handled; // 依次选中菜单项或展开子菜单 this.getFlatInstanceArray().forEach((obj) =&gt; &#123; if (obj &amp;&amp; obj.props.active &amp;&amp; obj.onKeyDown) &#123; handled = obj.onKeyDown(e); &#125; &#125;); if (handled) &#123; return 1; &#125; let activeItem = null; if (keyCode === KeyCode.UP || keyCode === KeyCode.DOWN) &#123; activeItem = this.step(keyCode === KeyCode.UP ? -1 : 1); &#125; if (activeItem) &#123; e.preventDefault(); updateActiveKey(this.props.store, getEventKey(this.props), activeItem.props.eventKey); if (typeof callback === 'function') &#123; callback(activeItem); &#125; return 1; &#125; &#125;;&#125;class SubMenu extends React.Component &#123; onKeyDown = (e) =&gt; &#123; const keyCode = e.keyCode; const menu = this.menuInstance; const &#123; isOpen, store &#125; = this.props; // 展开子菜单，更新 defaultActiveFirst 状态 if (keyCode === KeyCode.ENTER) &#123; this.onTitleClick(e); updateDefaultActiveFirst(store, this.props.eventKey, true); return true; &#125; if (keyCode === KeyCode.RIGHT) &#123; // 展开状态，选中子菜单项；menu 为 SubMenu 下直系子元素 —— SubPopupMenu 实例 if (isOpen) &#123; menu.onKeyDown(e); // 未展开状态，展开子菜单并更新 defaultActiveFirst 状态 &#125; else &#123; this.triggerOpenChange(true); updateDefaultActiveFirst(store, this.props.eventKey, true); &#125; return true; &#125; if (keyCode === KeyCode.LEFT) &#123; let handled; if (isOpen) &#123; handled = menu.onKeyDown(e); &#125; else &#123; return undefined; &#125; if (!handled) &#123; this.triggerOpenChange(false); handled = true; &#125; return handled; &#125; if (isOpen &amp;&amp; (keyCode === KeyCode.UP || keyCode === KeyCode.DOWN)) &#123; return menu.onKeyDown(e); &#125; &#125;;&#125;class MenuItem extends React.Component &#123; onKeyDown = (e) =&gt; &#123; const keyCode = e.keyCode; if (keyCode === KeyCode.ENTER) &#123; this.onClick(e);// 更新菜单的选中状态 return true; &#125; &#125;;&#125; 以上介绍了 rc-menu 中的状态管理和事件处理逻辑，下面将扼要地介绍 rc-menu 中的各组件。 SubPopupMenuSubPopupMenu 对激活状态的管理可参见上文，可参见上文及源码。这里只介绍 SubPopupMenu 的层级关系。 SubPopupMenu 可以作为 RcMenu 或 RcSubMenu 的直系子元素，其下可渲染 RcSubMenu 或 RcMenuItem 元素。在其实现中，既将 RcMenu 接受的 props 菜单栏整体配置项注入到子元素；又将 RcMenu 或 SubPopupMenu 提供的状态管理函数（均封装为 SubPopupMenu 的实例方法）注入 RcSubMenu 或 RcMenuItem。上述过程，见于 renderCommonMenuItem 方法，该方法由 renderMenuItem 直接调用。 renderMenuItem 方法的实现与 ref 引用处理一样，两者均让人心生纳闷：前者没有实现的必要；后者在 componentDidMount 生命周期管理实例引用，当菜单内容变化时仍会以缓存持有引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class SubPopupMenu extends React.Component &#123; renderCommonMenuItem = (child, i, extraProps) =&gt; &#123; const state = this.props.store.getState(); const props = this.props; const key = getKeyFromChildrenIndex(child, props.eventKey, i);// 创建或获取 key 键 const childProps = child.props; const isActive = key === state.activeKey; // 混入菜单栏整体配置或状态管理函数、事件绑定函数 const newChildProps = &#123; mode: childProps.mode || props.mode, level: props.level, inlineIndent: props.inlineIndent, renderMenuItem: this.renderMenuItem, rootPrefixCls: props.prefixCls, index: i, parentMenu: props.parentMenu, // customized ref function, need to be invoked manually in child's componentDidMount manualRef: childProps.disabled ? undefined : createChainedFunction(child.ref, saveRef.bind(this)), eventKey: key, active: !childProps.disabled &amp;&amp; isActive, multiple: props.multiple, onClick: (e) =&gt; &#123; (childProps.onClick || noop)(e); this.onClick(e); &#125;, onItemHover: this.onItemHover, openTransitionName: this.getOpenTransitionName(), openAnimation: props.openAnimation, subMenuOpenDelay: props.subMenuOpenDelay, subMenuCloseDelay: props.subMenuCloseDelay, forceSubMenuRender: props.forceSubMenuRender, onOpenChange: this.onOpenChange, onDeselect: this.onDeselect, onSelect: this.onSelect, builtinPlacements: props.builtinPlacements, itemIcon: childProps.itemIcon || this.props.itemIcon, expandIcon: childProps.expandIcon || this.props.expandIcon, ...extraProps, &#125;; if (props.mode === 'inline') &#123; newChildProps.triggerSubMenuAction = 'click'; &#125; return React.cloneElement(child, newChildProps); &#125;; render() &#123; // props 处理及解构 // renderMenuItem 将调用 renderCommonMenuItem 渲染子元素 return ( &lt;DOMWrap &#123;...props&#125; prefixCls=&#123;prefixCls&#125; mode=&#123;mode&#125; tag=\"ul\" level=&#123;level&#125; theme=&#123;theme&#125; hiddenClassName=&#123;`$&#123;prefixCls&#125;-hidden`&#125; visible=&#123;visible&#125; overflowedIndicator=&#123;overflowedIndicator&#125; &#123;...domProps&#125;&gt; &#123; React.Children.map(props.children, (c, i) =&gt; this.renderMenuItem(c, i, eventKey || '0-menu-') ) &#125; &lt;/DOMWrap&gt; ); &#125;&#125; DomWrap对于水平布局的菜单栏，DOMWrap 借助 resize-observer-polyfill，MutationObserver ，当 DOMWrap 实例或其子元素的 dom 内容或尺寸调整时，重新加以渲染。这样，在 DOMWrap 中就可以计算最后一个待显示的菜单项，并将这个菜单项和其余菜单项以 SubMenu 形式合并展示。其处理逻辑有： 在 componentDidMount 生命周期为 DOMWrap 实例及其子元素绑定 dom 变更的监听函数。 当 dom 变更时，由监听函数调用 setChildrenWidthAndResize 实例方法。setChildrenWidthAndResize 先计算菜单项全显示时的总宽度，再将该宽度和菜单栏实际宽度对比，由此更新 state.lastVisibleIndex（最后一个待显示的菜单项的索引）。 在重绘阶段，DomWrap 将在每个已显示的菜单项后插入一个不予显示的 SubMenu 组件（其样式类带有 ‘overflowed-submenu’ 后缀，eventKey 为 ‘overflowed-indicator’ 后缀）；而待合并的菜单项将会用一个显示的 SubMenu 组件包裹，这样在点击时就可以显示浮层。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class DOMWrap extends React.Component &#123; componentDidMount() &#123; this.setChildrenWidthAndResize(); if (this.props.level === 1 &amp;&amp; this.props.mode === 'horizontal') &#123; const menuUl = ReactDOM.findDOMNode(this); if (!menuUl) return; this.resizeObserver = new ResizeObserver(entries =&gt; &#123; entries.forEach(this.setChildrenWidthAndResize); &#125;); // 为 DOMWrap 及其子元素绑定监听函数 [].slice.call(menuUl.children).concat(menuUl).forEach(el =&gt; &#123; this.resizeObserver.observe(el); &#125;); // 当子元素列表改变时，重新为子元素绑定监听函数，避免触发不必要的回调 if (typeof MutationObserver !== 'undefined') &#123; this.mutationObserver = new MutationObserver(() =&gt; &#123; this.resizeObserver.disconnect(); [].slice.call(menuUl.children).concat(menuUl).forEach(el =&gt; &#123; this.resizeObserver.observe(el); &#125;); this.setChildrenWidthAndResize(); &#125;); this.mutationObserver.observe( menuUl, &#123; attributes: false, childList: true, subTree: false &#125; ); &#125; &#125; &#125; getOverflowedSubMenuItem = (keyPrefix, overflowedItems, renderPlaceholder) =&gt; &#123; // this.props.overflowedIndicator 通常是 '...' const &#123; overflowedIndicator, level, mode, prefixCls, theme, style: propStyle &#125; = this.props; if (level !== 1 || mode !== 'horizontal') &#123; return null; &#125; const copy = this.props.children[0]; const &#123; children: throwAway, title, eventKey, ...rest &#125; = copy.props; let style = &#123; ...propStyle &#125;; let key = `$&#123;keyPrefix&#125;-overflowed-indicator`; if (overflowedItems.length === 0 &amp;&amp; renderPlaceholder !== true) &#123; style = &#123; ...style, display: 'none', &#125;; &#125; else if (renderPlaceholder) &#123; style = &#123; ...style, visibility: 'hidden', position: 'absolute', &#125;; key = `$&#123;key&#125;-placeholder`; &#125; const popupClassName = theme ? `$&#123;prefixCls&#125;-$&#123;theme&#125;` : ''; const props = &#123;&#125;; menuAllProps.forEach(k =&gt; &#123; if (rest[k] !== undefined) &#123; props[k] = rest[k]; &#125; &#125;); return ( &lt;SubMenu title=&#123;overflowedIndicator&#125; className=&#123;`$&#123;prefixCls&#125;-overflowed-submenu`&#125; popupClassName=&#123;popupClassName&#125; &#123;...props&#125; key=&#123;key&#125; eventKey=&#123;`$&#123;keyPrefix&#125;-overflowed-indicator`&#125; disabled=&#123;false&#125; style=&#123;style&#125;&gt; &#123;overflowedItems&#125; &lt;/SubMenu&gt; ); &#125; renderChildren(children) &#123; const &#123; lastVisibleIndex &#125; = this.state; return (children || []).reduce((acc, childNode, index) =&gt; &#123; let item = childNode; if (this.props.mode === 'horizontal') &#123; let overflowed = this.getOverflowedSubMenuItem(childNode.props.eventKey, []); if (lastVisibleIndex !== undefined &amp;&amp; this.props.className.indexOf(`$&#123;this.props.prefixCls&#125;-root`) !== -1 ) &#123; if (index &gt; lastVisibleIndex) &#123; // 修改 eventKey 是为了防止隐藏状态下还会触发 openkeys 事件 item = React.cloneElement(childNode, &#123; style: &#123; display: 'none' &#125;, eventKey: `$&#123;childNode.props.eventKey&#125;-hidden`, className: `$&#123;childNode.className&#125; $&#123;MENUITEM_OVERFLOWED_CLASSNAME&#125;` &#125;); &#125; if (index === lastVisibleIndex + 1) &#123; this.overflowedItems = children.slice(lastVisibleIndex + 1).map(c =&gt; &#123; return React.cloneElement(c, &#123; key: c.props.eventKey, mode: 'vertical-left' &#125;); &#125;); overflowed = this.getOverflowedSubMenuItem( childNode.props.eventKey, this.overflowedItems, ); &#125; &#125; const ret = [...acc, overflowed, item]; if (index === children.length - 1) &#123; // 设置占位符，以计算 overflowed indicator 的宽度 ret.push(this.getOverflowedSubMenuItem(childNode.props.eventKey, [], true)); &#125; return ret; &#125; return [...acc, item]; &#125;, []); &#125; render() &#123; // Tag 即 this.props.tag，默认为 ul return ( &lt;Tag &#123;...rest&#125;&gt; &#123;this.renderChildren(this.props.children)&#125; &lt;/Tag&gt; ); &#125;&#125; SubMenu除了上文提到的，SubMenu 的处理逻辑还包含： 通过 store 获取 props.isOpen 子菜单是否展开, props.active 子菜单是否激活, props.selectedKeys 辅助计算子菜单或子菜单项是否被选中。三者均影响样式。 组件层级上，SubMenu 根据菜单栏是否采用 inline 模式，以决定使用 Trigger 组件（rc-trigger 提供）包裹子元素，或者单纯绘制子元素；继而使用 Animate 组件（rc-animate 提供）绘制子元素，子元素均统一由 SubPopupMenu 组件渲染。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Menu extends React.Component &#123; // 获取传入子组件的 props.openTransitionName 属性 getOpenTransitionName = () =&gt; &#123; const props = this.props; let transitionName = props.openTransitionName; const animationName = props.openAnimation; if (!transitionName &amp;&amp; typeof animationName === 'string') &#123; transitionName = `$&#123;props.prefixCls&#125;-open-$&#123;animationName&#125;`; &#125; return transitionName; &#125;&#125;class SubMenu extends React.Component &#123; renderChildren(children) &#123; // 构建 baseProps，按条件只绘制空内容... const animProps = &#123;&#125;; const transitionAppear = haveRendered || !baseProps.visible || !baseProps.mode === 'inline'; if (baseProps.openTransitionName) &#123; animProps.transitionName = baseProps.openTransitionName; &#125; else if (typeof baseProps.openAnimation === 'object') &#123; animProps.animation = &#123; ...baseProps.openAnimation &#125;; if (!transitionAppear) &#123; delete animProps.animation.appear; &#125; &#125; return ( &lt;Animate &#123;...animProps&#125; showProp=\"visible\" component=\"\" transitionAppear=&#123;transitionAppear&#125;&gt; &lt;SubPopupMenu &#123;...baseProps&#125; id=&#123;this._menuId&#125;&gt;&#123;children&#125;&lt;/SubPopupMenu&gt; &lt;/Animate&gt; ); &#125; render() &#123; // props 处理及结构... const isOpen = props.isOpen; const isInlineMode = props.mode === 'inline'; // 展开按钮 let icon = null; if (props.mode !== 'horizontal') &#123; icon = this.props.expandIcon; // ReactNode if (typeof this.props.expandIcon === 'function') icon = React.createElement(this.props.expandIcon, &#123; ...this.props &#125;); &#125; const title = ( &lt;div ref=&#123;this.saveSubMenuTitle&#125; style=&#123;style&#125; className=&#123;`$&#123;prefixCls&#125;-title`&#125; &#123;...titleMouseEvents&#125; &#123;...titleClickEvents&#125; aria-expanded=&#123;isOpen&#125; &#123;...ariaOwns&#125; aria-haspopup=\"true\" title=&#123;typeof props.title === 'string' ? props.title : undefined&#125;&gt; &#123;props.title&#125; &#123;icon || &lt;i className=&#123;`$&#123;prefixCls&#125;-arrow`&#125; /&gt;&#125; &lt;/div&gt; ); const children = this.renderChildren(props.children); return ( &lt;li &#123;...props&#125; &#123;...mouseEvents&#125; className=&#123;className&#125; role=\"menuitem\"&gt; &#123;isInlineMode &amp;&amp; title&#125; &#123;isInlineMode &amp;&amp; children&#125; &#123;!isInlineMode &amp;&amp; ( &lt;Trigger prefixCls=&#123;prefixCls&#125; popupClassName=&#123;`$&#123;prefixCls&#125;-popup $&#123;popupClassName&#125;`&#125; getPopupContainer=&#123;getPopupContainer&#125; builtinPlacements=&#123;Object.assign(&#123;&#125;, placements, builtinPlacements)&#125; popupPlacement=&#123;popupPlacement&#125; popupVisible=&#123;isOpen&#125; popupAlign=&#123;popupAlign&#125; popup=&#123;children&#125; action=&#123;disabled ? [] : [triggerSubMenuAction]&#125; mouseEnterDelay=&#123;subMenuOpenDelay&#125; mouseLeaveDelay=&#123;subMenuCloseDelay&#125; onPopupVisibleChange=&#123;this.onPopupVisibleChange&#125; forceRender=&#123;forceSubMenuRender&#125;&gt; &#123;title&#125; &lt;/Trigger&gt; )&#125; &lt;/li&gt; ); &#125;&#125; 其他Menu 用于绘制主菜单，参见上文或源码。 MenuItem 用于绘制菜单项，将根据 store 中的 activeKey, selectedKeys 渲染样式。除了常规的事件处理函数之外，当菜单项被激活时，MenuItem 将借助 dom-scroll-into-view 使屏幕滚动到指定区域。MenuItem 与 SubMenu 一样，也将使用 props.level 菜单项的层级计算左边距。 MenuItemGroup 用于绘制成组的菜单项，并且带有标题。在 MenuItemGroup 中，实际绘制菜单项所需的 props.renderMenuItem 方法由 SubPopupMenu 提供。 Divider 用于绘制分割线。 MenuMenuMenu 作为菜单的容器，其上桥接 Sider 布局组件传入的 context.siderCollapsed, context.collapsedWidth；其下为子菜单或菜单项注入 context.inlineCollapsed, context.antdMenuTheme。其中，context.siderCollapsed 表示侧边栏是否折叠；context.collapsedWidth 表示侧边栏宽度；context.inlineCollapsed 表示内嵌模式的菜单是否折叠，或者侧边栏是否折叠；context.antdMenuTheme 表示菜单所采用的样式风格。 组件层级上，Menu 使用 RcMenu 绘制内容。当传入 props.openKeys 时，Menu 将表现为受控组件，其内置的 state.openKeys 将根据 props.openKeys 作调整，使用者也可以通过 props.onOpenChange 实时获取到实时展开的菜单项；当没有传入 props.openKeys 时，Menu 将表现为非受控组件，state.openKeys 将根据用户行为更新。 在非内嵌模式下，Menu 为 RcMenu 绑定 onClick = this.handleClick 实例方法，以在当用户点击菜单栏的空白区域或子菜单项时，可隐藏弹出的浮层。 在动效处理上，当菜单栏由 inline 模式切换到其他模式或者在 inline 模式下收起菜单（实际菜单需要垂直布局显示）时，先需显示 inline 模式下子菜单的折叠动效，在动效执行完成后，再转换成其他模式（介于 rc-menu 没有针对动效时延的处理）。Menu 使用 switchingModeFromInline 实例属性记录模式转换及折叠状态切换。在此基础上，getRealMenuMode 用于计算菜单实际采用的显示模式，再由 getMenuOpenAnimation 获得待显示的功效。当动效执行完成时，handleTransitionEnd 实例方法将重置 switchingModeFromInline 缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import cssAnimation from 'css-animation';import raf from 'raf';function animate(node: HTMLElement, show: boolean, done: () =&gt; void) &#123; let height: number; let requestAnimationFrameId: number; return cssAnimation(node, 'ant-motion-collapse', &#123; start() &#123; if (!show) &#123; node.style.height = `$&#123;node.offsetHeight&#125;px`; node.style.opacity = '1'; &#125; else &#123; height = node.offsetHeight; node.style.height = '0px'; node.style.opacity = '0'; &#125; &#125;, active() &#123; if (requestAnimationFrameId) &#123; raf.cancel(requestAnimationFrameId); &#125; requestAnimationFrameId = raf(() =&gt; &#123; node.style.height = `$&#123;show ? height : 0&#125;px`; node.style.opacity = show ? '1' : '0'; &#125;); &#125;, end() &#123; if (requestAnimationFrameId) &#123; raf.cancel(requestAnimationFrameId); &#125; node.style.height = ''; node.style.opacity = ''; done(); &#125;, &#125;);&#125;const animation = &#123; enter(node: HTMLElement, done: () =&gt; void) &#123; return animate(node, true, done); &#125;, leave(node: HTMLElement, done: () =&gt; void) &#123; return animate(node, false, done); &#125;, appear(node: HTMLElement, done: () =&gt; void) &#123; return animate(node, true, done); &#125;,&#125;;class Menu extends React.Component&lt;MenuProps, MenuState&gt; &#123; componentWillReceiveProps(nextProps: MenuProps, nextContext: SiderContext) &#123; if (this.props.mode === 'inline' &amp;&amp; nextProps.mode !== 'inline') &#123; this.switchingModeFromInline = true; &#125; if ('openKeys' in nextProps) &#123; this.setState(&#123; openKeys: nextProps.openKeys! &#125;); return; &#125; if ((nextProps.inlineCollapsed &amp;&amp; !this.props.inlineCollapsed) || (nextContext.siderCollapsed &amp;&amp; !this.context.siderCollapsed)) &#123; this.switchingModeFromInline = true; this.inlineOpenKeys = this.state.openKeys;// 缓存 inline 模式展开的菜单项 this.setState(&#123; openKeys: [] &#125;); &#125; if ((!nextProps.inlineCollapsed &amp;&amp; this.props.inlineCollapsed) || (!nextContext.siderCollapsed &amp;&amp; this.context.siderCollapsed)) &#123; this.setState(&#123; openKeys: this.inlineOpenKeys &#125;); this.inlineOpenKeys = []; &#125; &#125; // Restore vertical mode when menu is collapsed responsively when mounted // https://github.com/ant-design/ant-design/issues/13104 // TODO: not a perfect solution, looking a new way to avoid setting switchingModeFromInline in this situation // 折叠状态刷新页面，因为未执行动效，switchingModeFromInline 仍为真，显示为 inline 模式 handleMouseEnter = (e: MouseEvent) =&gt; &#123; this.restoreModeVerticalFromInline(); const &#123; onMouseEnter &#125; = this.props; if (onMouseEnter) &#123; onMouseEnter(e); &#125; &#125; handleTransitionEnd = (e: TransitionEvent) =&gt; &#123; // when inlineCollapsed menu width animation finished // https://github.com/ant-design/ant-design/issues/12864 const widthCollapsed = e.propertyName === 'width' &amp;&amp; e.target === e.currentTarget; // Fix for &lt;Menu style=&#123;&#123; width: '100%' &#125;&#125; /&gt;, the width transition won't trigger when menu is collapsed // https://github.com/ant-design/ant-design-pro/issues/2783 const iconScaled = e.propertyName === 'font-size' &amp;&amp; (e.target as HTMLElement).className.indexOf('anticon') &gt;= 0; if (widthCollapsed || iconScaled) &#123; this.restoreModeVerticalFromInline(); &#125; &#125; // 重置 switchingModeFromInline，并重绘菜单 restoreModeVerticalFromInline() &#123; if (this.switchingModeFromInline) &#123; this.switchingModeFromInline = false; this.setState(&#123;&#125;); &#125; &#125; // 是否折叠，取决于侧边栏的折叠情况、内嵌模式的折叠情况 getInlineCollapsed() &#123; const &#123; inlineCollapsed &#125; = this.props; if (this.context.siderCollapsed !== undefined) &#123; return this.context.siderCollapsed; &#125; return inlineCollapsed; &#125; // 由 inline 模式转换成其他模式时，首先保持 inline 模式，目的是执行子菜单折叠动效 // 在 inline 模式下，收起菜单也将先保持 inline 模式 getRealMenuMode() &#123; const inlineCollapsed = this.getInlineCollapsed(); if (this.switchingModeFromInline &amp;&amp; inlineCollapsed) &#123; return 'inline'; &#125; const &#123; mode &#125; = this.props; return inlineCollapsed ? 'vertical' : mode; &#125; getMenuOpenAnimation(menuMode: MenuMode) &#123; const &#123; openAnimation, openTransitionName &#125; = this.props; let menuOpenAnimation = openAnimation || openTransitionName; if (openAnimation === undefined &amp;&amp; openTransitionName === undefined) &#123; switch (menuMode) &#123; case 'horizontal': menuOpenAnimation = 'slide-up'; break; case 'vertical': case 'vertical-left': case 'vertical-right': // When mode switch from inline submenu should hide without animation if (this.switchingModeFromInline) &#123; menuOpenAnimation = ''; this.switchingModeFromInline = false; &#125; else &#123; menuOpenAnimation = 'zoom-big'; &#125; break; case 'inline': menuOpenAnimation = animation; break; default: &#125; &#125; return menuOpenAnimation; &#125;&#125; SubMenuSubMenu 使用 RcSubMenu 绘制子菜单。逻辑上，SubMenu 通过 context.antdMenuTheme 设置子菜单的主题样式；又实现 onKeyDown 方法，以桥接 SubPopupMenu 和 RcSubMenu 中的同名方法（参见上文）。 MenuItemMenuItem 使用 RcMenuItem 绘制菜单项。逻辑上，MenuItem 既像 SubMenu 那样实现了 onKeyDown 方法；又使用 Tooltip 绘制气泡框。当 context.inlineCollapsed 为 true 且 props.level 为 1（菜单项层级为1）时，将使用气泡框组件绘制子元素。 样式处理 菜单折叠前后展示样式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.@&#123;menu-prefix-cls&#125; &#123; &amp;-item, &amp;-submenu-title &#123; cursor: pointer; margin: 0; padding: 0 20px; position: relative; display: block; white-space: nowrap; transition: color .3s @ease-in-out, border-color .3s @ease-in-out, background .3s @ease-in-out, padding .15s @ease-in-out; .@&#123;iconfont-css-prefix&#125; &#123; min-width: 14px; margin-right: 10px; font-size: @font-size-base; transition: font-size .15s @ease-out, margin .3s @ease-in-out; + span &#123; transition: opacity .3s @ease-in-out, width .3s @ease-in-out; opacity: 1; &#125; &#125; &#125; &amp;-inline-collapsed &#123; width: @menu-collapsed-width; &gt; .@&#123;menu-prefix-cls&#125;-item, &gt; .@&#123;menu-prefix-cls&#125;-item-group &gt; .@&#123;menu-prefix-cls&#125;-item-group-list &gt; .@&#123;menu-prefix-cls&#125;-item, &gt; .@&#123;menu-prefix-cls&#125;-item-group &gt; .@&#123;menu-prefix-cls&#125;-item-group-list &gt; .@&#123;menu-prefix-cls&#125;-submenu &gt; .@&#123;menu-prefix-cls&#125;-submenu-title, &gt; .@&#123;menu-prefix-cls&#125;-submenu &gt; .@&#123;menu-prefix-cls&#125;-submenu-title &#123; left: 0; text-overflow: clip;// 裁剪超出文本 padding: 0 (@menu-collapsed-width - 16px) / 2 !important; .@&#123;menu-prefix-cls&#125;-submenu-arrow &#123;// 隐藏展开折叠图标 display: none; &#125; .@&#123;iconfont-css-prefix&#125; &#123; font-size: 16px; line-height: @menu-item-height; margin: 0; + span &#123;// 隐藏文本 max-width: 0; display: inline-block; opacity: 0; &#125; &#125; &#125; &#125;&#125; 子菜单浮层： 123456789101112131415161718192021222324.@&#123;menu-prefix-cls&#125; &#123; &amp;-submenu &#123; &amp;-popup &#123; position: absolute; border-radius: @border-radius-base; z-index: @zindex-dropdown; background: @menu-popup-bg; .submenu-title-wrapper &#123; padding-right: 20px; &#125; &amp;:before &#123; position: absolute; top: -7px; left: 0; right: 0; bottom: 0; content: ' '; opacity: .0001; &#125; &#125; &#125;&#125; 折叠按钮旋转动效： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.@&#123;menu-prefix-cls&#125; &#123; &amp;-submenu &#123;&amp;-vertical, &amp;-vertical-left, &amp;-vertical-right, &amp;-inline &#123; &gt; .@&#123;menu-prefix-cls&#125;-submenu-title .@&#123;menu-prefix-cls&#125;-submenu-arrow &#123; transition: transform .3s @ease-in-out; position: absolute; top: 50%; right: 16px; width: 10px; &amp;:before, &amp;:after &#123; content: \"\"; position: absolute; vertical-align: baseline; background: #fff; background-image: linear-gradient(to right, @menu-item-color, @menu-item-color);// 渐变 width: 6px; height: 1.5px; border-radius: 2px; transition: background .3s @ease-in-out, transform .3s @ease-in-out, top .3s @ease-in-out; &#125; &amp;:before &#123; transform: rotate(45deg) translateY(-2px); &#125; &amp;:after &#123; transform: rotate(-45deg) translateY(2px); &#125; &#125; &gt; .@&#123;menu-prefix-cls&#125;-submenu-title:hover .@&#123;menu-prefix-cls&#125;-submenu-arrow &#123; &amp;:after, &amp;:before &#123; background: linear-gradient(to right, @menu-highlight-color, @menu-highlight-color); &#125; &#125; &#125; &amp;-inline &gt; .@&#123;menu-prefix-cls&#125;-submenu-title .@&#123;menu-prefix-cls&#125;-submenu-arrow &#123; &amp;:before &#123; transform: rotate(-45deg) translateX(2px); &#125; &amp;:after &#123; transform: rotate(45deg) translateX(-2px); &#125; &#125; &amp;-open &#123; &amp;.@&#123;menu-prefix-cls&#125;-submenu-inline &gt; .@&#123;menu-prefix-cls&#125;-submenu-title .@&#123;menu-prefix-cls&#125;-submenu-arrow &#123; transform: translateY(-2px); &amp;:after &#123; transform: rotate(-45deg) translateX(-2px); &#125; &amp;:before &#123; transform: rotate(45deg) translateX(2px); &#125; &#125; &#125; &#125;&#125; 清除浮动： 123456789101112131415161718192021222324.clearfix() &#123; zoom: 1; &amp;:before, &amp;:after &#123; content: \"\"; display: table; &#125; &amp;:after &#123; clear: both; &#125;&#125;.@&#123;menu-prefix-cls&#125; &#123; .clearfix; &amp;-horizontal &#123; &amp;:after &#123; content: \"\\20\"; display: block; height: 0; clear: both; &#125; &#125;&#125; 结语本文对子菜单的浮层显示和菜单栏的动效处理仍有不足。关于 rc-animate, rc-trigger，笔者将在后续的文章中加以分析。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"http://xzfyu.com/tags/antd/"}]},{"title":"Radio, Checkbox","slug":"frontend/antd/Radio, Checkbox","date":"2018-11-26T16:00:00.000Z","updated":"2020-03-08T10:28:29.305Z","comments":true,"path":"2018/11/27/frontend/antd/Radio, Checkbox/","link":"","permalink":"http://xzfyu.com/2018/11/27/frontend/antd/Radio, Checkbox/","excerpt":"","text":"antd 中的 Radio, Checkbox 组件均基于 rc-checkbox 实现。本文第一部分将介绍 rc-checkbox，余下两部分再介绍 Radio, Checkbox 组件。 rc-checkboxrc-checkbox 输出 Checkbox 组件。其处理逻辑较为简单，包含样式类转换、多余 props 剔除等。元素层级上，rc-checkbox 使用 span 包裹 input 节点和内层 span 节点（该 span 节点将绘制可见的单选框样式）。样式类转换指 span 元素的样式类包含或可能包含 props.prefixCls, props.className, ${props.prefixCls}-checked, ${props.prefixCls}-disabled；input 节点的样式类为 ${props.prefixCls}-input；内层 span 节点的样式类为 ${props.prefixCls}-inner。多余 props 剔除指 input 元素只接受 name, id, type, readOnly, disabled, tabIndex, checked, onClick, onFocus, onBlur, onChange, autoFocus, value, ‘aria-‘, ‘data-‘, role 属性。其中，checked 由 Checkbox 组件的 state.checked 设定；onChange 设置为 Checkbox 组件的 handleChange 方法。当 input 节点数据变更时，props.onChange 接受到的数据先经由 Checkbox 组件转换。以下是其实现。 123456789101112131415161718192021222324handleChange = (e) =&gt; &#123; const &#123; props &#125; = this; if (props.disabled) &#123; return; &#125; if (!('checked' in props)) &#123; this.setState(&#123; checked: e.target.checked, &#125;); &#125; props.onChange(&#123; target: &#123; ...props, checked: e.target.checked, &#125;, stopPropagation() &#123; e.stopPropagation(); &#125;, preventDefault() &#123; e.preventDefault(); &#125;, nativeEvent: e.nativeEvent, &#125;);&#125;; Radio 组件antd 提供三种单选框组件：单选框 Radio, 单选框组合 RadioGroup, 单选框按钮 RadioButton。 Radio 组件的特殊处理逻辑为：通过 context.radioGroup = { name, onChange, value, disabled } 获得 RadioGroup 组件注入的数据，以与单选框组合完成交互。 Radio 组件的元素层级关系为 label 元素和 RcCheckbox 组件。以下 less 样式中，.@{radio-prefix-cls} 即 RcCheckbox 组件绘制的外层 span 元素；.@{radio-inner-prefix-cls} 即 RcCheckbox 组件绘制的内层 span 元素。Radio 组件呈现在视图上的样式以内层 span 元素及其 span:after 伪类内容绘制，选中时 span:after 设置 opacity: 1 样式。以下是 less 代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445.@&#123;radio-prefix-cls&#125; &#123; &amp;-inner &#123; &amp;:after &#123; @radio-dot-size: @radio-size - 8px; position: absolute; width: @radio-dot-size; height: @radio-dot-size; left: (@radio-size - @radio-dot-size) / 2 - 1px; top: (@radio-size - @radio-dot-size) / 2 - 1px; border-radius: @radio-dot-size; display: table; border-top: 0; border-left: 0; content: ' '; background-color: @radio-dot-color; opacity: 0; transform: scale(0); transition: all @radio-duration @ease-in-out-circ; &#125; position: relative; top: 0; left: 0; display: block; width: @radio-size; height: @radio-size; border-width: 1px; border-style: solid; border-radius: 100px; border-color: @border-color-base; background-color: @radio-button-bg; transition: all @radio-duration; &#125;&#125;.@&#123;radio-prefix-cls&#125;-checked &#123; .@&#123;radio-inner-prefix-cls&#125; &#123; border-color: @radio-dot-color; &amp;:after &#123; transform: scale(.875); opacity: 1; transition: all @radio-duration @ease-in-out-circ; &#125; &#125;&#125; RadioButton 组件的渲染过程无甚特别之处，主要是默认将 props.prefixCls 设定为 ‘ant-radio-button’。 RadioGroup 组件接受 props.options 作为选项配置内容（props.options 数组项内容可以是字符串或对象）；并将 radioGroup 作为 context 内容传入子孙组件中。 Checkboxantd 提供两种复选框组件：复选框 Checkbox, 复选框组合 CheckboxGroup。 Checkbox 组件与 Radio 组件的实现无异，只是其接受的 context 数据内容为 checkboxGroup = { toggleOption, value, disabled } 属性。其中，toggleOption 用于影响 Checkbox 组件的 onChange 绑定函数，即改变 CheckboxGroup 组件的 state.value 状态；value 用于判断当前 Checkbox 组件是否处于选中状态。 CheckboxGroup 组件也与 RadioGroup 组件无异，只是其实现 toggleOption 方法，用于在复选框勾选或取消勾选时，实时更新 state.value 值，并调用 props.onChange 方法；并通过 context 注入到子孙组件中。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"http://xzfyu.com/tags/antd/"}]},{"title":"Grid 栅格","slug":"frontend/antd/Grid","date":"2018-11-24T16:00:00.000Z","updated":"2020-03-08T10:28:17.622Z","comments":true,"path":"2018/11/25/frontend/antd/Grid/","link":"","permalink":"http://xzfyu.com/2018/11/25/frontend/antd/Grid/","excerpt":"","text":"antd 提供的 24 栅格系统由 Row, Col 组件实现。 Row栅格布局组件 Row 用于设定整行 row 内各组 col 的布局风格。当 props.type 为 ‘flex’ 时，意味着整行采用 flex 布局。在 flex 布局的基础上，props.justify 通过 justify-content 样式影响各 col 元素的水平排列方式；props.align 通过 align-items 样式影响各 col 元素的垂直对齐方式。props.gutter 用于设定各 col 元素的间隔，间隔单位可以是 ‘px’ 或 ‘rem’。Row 支持以对象形式配置 props.gutter，如 { xs, sm, md, lg, xl, xxl }。其中，xs 为 576 px 以下屏幕；sm 为 576 - 768 px 尺寸屏幕；md 为 768 - 992 px 尺寸屏幕；lg 为 992 - 1200 px 尺寸屏幕；xl 为 1200 - 1600 px 尺寸屏幕；xxl 为 1600 px 以上屏幕； 在响应式处理上，Row 组件借助 enquire.js 库实现。其场景如以 { md: 8, lg: 16 } 对象配置 props.gutter，那么，当屏幕尺寸小于 768px 时，就需要将各 col 元素的间隔从 16 px 调整为 8px。Row 组件对这一场景的实现机制为，在 componentDidMount 生命周期使用 enquire.js 库绑定监听函数，以使得当屏幕尺寸变更时，state.screen 当前屏幕状态也会相应得到更新；随后在 render 阶段，由 getGutter 方法获得当前屏幕尺寸下的 col 元素间隔 gutter，并借助 create-react-context 库将 gutter 注入到 Col 组件中。以下是该机制实现的源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243componentDidMount() &#123; Object.keys(responsiveMap) .map((screen: Breakpoint) =&gt; enquire.register(responsiveMap[screen], &#123; match: () =&gt; &#123; if (typeof this.props.gutter !== 'object') &#123; return; &#125; this.setState((prevState) =&gt; (&#123; screens: &#123; ...prevState.screens, [screen]: true, &#125;, &#125;)); &#125;, unmatch: () =&gt; &#123; if (typeof this.props.gutter !== 'object') &#123; return; &#125; this.setState((prevState) =&gt; (&#123; screens: &#123; ...prevState.screens, [screen]: false, &#125;, &#125;)); &#125;, // Keep a empty destory to avoid triggering unmatch when unregister destroy() &#123;&#125;, &#125;, ));&#125;getGutter(): number | undefined &#123; const &#123; gutter &#125; = this.props; if (typeof gutter === 'object') &#123; for (let i = 0; i &lt;= responsiveArray.length; i++) &#123; const breakpoint: Breakpoint = responsiveArray[i]; if (this.state.screens[breakpoint] &amp;&amp; gutter[breakpoint] !== undefined) &#123; return gutter[breakpoint]; &#125; &#125; &#125; return gutter as number;&#125; 在样式处理方面，整行 row 采用 border-box 盒模型，相对定位，并嵌套使用 .clearfix 样式规则以清除浮动以及 :before, :after 伪类的内容。其余均较为简单，可参见源码。 ColCol 组件主要通过样式类以设定 col 元素的大小和偏移情况。如当配置了 props.offset 属性为 4 时，将相应添加 ant-col-xs-offset-4, ant-col-sm-offset-4, ant-col-md-offset-4, ant-col-lg-offset-4, ant-col-xl-offset-4, ant-col-xll-offset-4 样式类。因此，Col 组件的逻辑主要是将 props 转化成样式类，其实现的重点仍在于 less 样式文件。 当然，各 col 元素的间隔 gutter 由 Row 组件传入。以下是其源码实现，RowContext 通过 create-react-context 库创建，即通过 context 属性传递数据，但只有 Col 组件能加以访问。 123456789101112131415161718192021222324252627282930// Rowrender() &#123; // ... return ( &lt;RowContext.Provider value=&#123;&#123; gutter &#125;&#125;&gt; &lt;div &#123;...otherProps&#125; className=&#123;classes&#125; style=&#123;rowStyle&#125;&gt; &#123;children&#125; &lt;/div&gt; &lt;/RowContext.Provider&gt; );&#125;// Colrender() &#123; return ( &lt;RowContext.Consumer&gt; &#123;(&#123; gutter &#125;) =&gt; &#123; let style = others.style; if (gutter as number &gt; 0) &#123; style = &#123; paddingLeft: (gutter as number) / 2, paddingRight: (gutter as number) / 2, ...style, &#125;; &#125; return &lt;div &#123;...others&#125; style=&#123;style&#125; className=&#123;classes&#125;&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125; &lt;/RowContext.Consumer&gt; )&#125; 在 less 文件中，antd 使用自调用的混合函数创建从 .ant-col-1 到 .ant-col-24 的样式规则。以下是相关源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// style/theme/default.less@grid-columns: 24;// mixin.less// index 由 1 到 24，构建样式规则.make-grid-columns() &#123; .col(@index) &#123; @item: ~\".@&#123;ant-prefix&#125;-col-@&#123;index&#125;, .@&#123;ant-prefix&#125;-col-xs-@&#123;index&#125;, .@&#123;ant-prefix&#125;-col-sm-@&#123;index&#125;, .@&#123;ant-prefix&#125;-col-md-@&#123;index&#125;, .@&#123;ant-prefix&#125;-col-lg-@&#123;index&#125;\"; .col((@index + 1), @item); &#125; .col(@index, @list) when (@index =&lt; @grid-columns) &#123; @item: ~\".@&#123;ant-prefix&#125;-col-@&#123;index&#125;, .@&#123;ant-prefix&#125;-col-xs-@&#123;index&#125;, .@&#123;ant-prefix&#125;-col-sm-@&#123;index&#125;, .@&#123;ant-prefix&#125;-col-md-@&#123;index&#125;, .@&#123;ant-prefix&#125;-col-lg-@&#123;index&#125;\"; .col((@index + 1), ~\"@&#123;list&#125;, @&#123;item&#125;\"); &#125; .col(@index, @list) when (@index &gt; @grid-columns) &#123; @&#123;list&#125; &#123; position: relative; // Prevent columns from collapsing when empty min-height: 1px; padding-left: (@grid-gutter-width / 2); padding-right: (@grid-gutter-width / 2); &#125; &#125; .col(1);&#125;.float-grid-columns(@class) &#123; .col(@index) &#123; // initial @item: ~\".@&#123;ant-prefix&#125;-col@&#123;class&#125;-@&#123;index&#125;\"; .col((@index + 1), @item); &#125; .col(@index, @list) when (@index =&lt; @grid-columns) &#123; // general @item: ~\".@&#123;ant-prefix&#125;-col@&#123;class&#125;-@&#123;index&#125;\"; .col((@index + 1), ~\"@&#123;list&#125;, @&#123;item&#125;\"); &#125; .col(@index, @list) when (@index &gt; @grid-columns) &#123; // terminal @&#123;list&#125; &#123; float: left; flex: 0 0 auto; &#125; &#125; .col(1); // kickstart it&#125;// index 由 24 到 1，构建样式规则.loop-grid-columns(@index, @class) when (@index &gt; 0) &#123; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-@&#123;index&#125; &#123; display: block; box-sizing: border-box; width: percentage((@index / @grid-columns)); &#125; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-push-@&#123;index&#125; &#123; left: percentage((@index / @grid-columns)); &#125; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-pull-@&#123;index&#125; &#123; right: percentage((@index / @grid-columns)); &#125; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-offset-@&#123;index&#125; &#123; margin-left: percentage((@index / @grid-columns)); &#125; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-order-@&#123;index&#125; &#123; order: @index; &#125; .loop-grid-columns((@index - 1), @class);&#125;.loop-grid-columns(@index, @class) when (@index = 0) &#123; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-@&#123;index&#125; &#123; display: none; &#125; .@&#123;ant-prefix&#125;-col-push-@&#123;index&#125; &#123; left: auto; &#125; .@&#123;ant-prefix&#125;-col-pull-@&#123;index&#125; &#123; right: auto; &#125; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-push-@&#123;index&#125; &#123; left: auto; &#125; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-pull-@&#123;index&#125; &#123; right: auto; &#125; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-offset-@&#123;index&#125; &#123; margin-left: 0; &#125; .@&#123;ant-prefix&#125;-col@&#123;class&#125;-order-@&#123;index&#125; &#123; order: 0; &#125;&#125;.make-grid(@class: ~'') &#123; .float-grid-columns(@class); .loop-grid-columns(@grid-columns, @class);&#125;// index.less.make-grid-columns();.make-grid();.make-grid(-xs);@media (min-width: @screen-sm-min) &#123; .make-grid(-sm);&#125;@media (min-width: @screen-md-min) &#123; .make-grid(-md);&#125;@media (min-width: @screen-lg-min) &#123; .make-grid(-lg);&#125;@media (min-width: @screen-xl-min) &#123; .make-grid(-xl);&#125;@media (min-width: @screen-xxl-min) &#123; .make-grid(-xxl);&#125;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"http://xzfyu.com/tags/antd/"}]},{"title":"Layout 布局","slug":"frontend/antd/Layout","date":"2018-11-24T16:00:00.000Z","updated":"2020-03-08T10:28:23.227Z","comments":true,"path":"2018/11/25/frontend/antd/Layout/","link":"","permalink":"http://xzfyu.com/2018/11/25/frontend/antd/Layout/","excerpt":"","text":"antd 提供 Layout, Header, Sider, Content, Footer 组件用于划定页面布局。实现上，侧边栏 Sider 组件比较特殊，将在第一部分加以介绍；其余组件均将在第一部分加以介绍。 Layout布局容器 Layout, 顶部布局 Header, 内容部分 Content, 底部布局 Footer 在实现上大体相当：都是通过 generator(props) = BasicComponent =&gt; Adapter 创建高阶组件 Adapter，再由该高阶组件将 props.prefixCls 注入到 BasicComponent 中。 作为 Layout 组件的 BasicComponent，BasicLayout 组件以 state.siders 记录侧边栏的 id，并允许在子组件中使用 context.siderHook 添加或移除侧边栏，其意义是触发 BasicLayout 组件重绘并判断是否需要添加 .ant-layout-has-sider 样式类。作为 Header, Content, Footer 组件的 BasicComponent，Basic 组件只用于拼接 props.prefixCls, props.className，以构成新的样式类。 Header, Sider, Content, Footer 组件只能作为 Layout 的子组件这一特征，由 less 文件约定，即如果当上述组件不作为 Layout 的子组件时，其样式将得不到正常展示。 Sider侧边栏 Sider 组件用于设定布局，其内容可由 Menu 组件 绘制。在 componentDidMount, componentWillUnmount 生命周期中，侧边栏组件也将通过 context.siderHook.addSider, context.siderHook.removeSider 方法，以添加或移除 Layout 容器中记录的侧边栏 id。侧边栏组件既可以根据折叠状态切换按钮展开或折叠（通过 props.collapsible 或 props.collapsedWidth = 0 开启）；也可以根据屏幕尺寸响应式展开或折叠（通过 props.breakpoint 属性开启），其实现借助 window.matchMedia 方法。子组件可通过 context.siderCollapsed 获得侧边栏的展开和折叠状态。以下是响应式展开或折叠功能的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// matchMedia polyfill for// https://github.com/WickyNilliams/enquire.js/issues/82if (typeof window !== 'undefined') &#123; const matchMediaPolyfill = (mediaQuery: string) =&gt; &#123; return &#123; media: mediaQuery, matches: false, addListener() &#123; &#125;, removeListener() &#123; &#125;, &#125;; &#125;; window.matchMedia = window.matchMedia || matchMediaPolyfill;&#125;class Sider extends React.Component&lt;SiderProps, SiderState&gt; &#123; constructor(props: SiderProps) &#123; // ... let matchMedia; if (typeof window !== 'undefined') &#123; matchMedia = window.matchMedia; &#125; if (matchMedia &amp;&amp; props.breakpoint &amp;&amp; props.breakpoint in dimensionMap) &#123; this.mql = matchMedia(`(max-width: $&#123;dimensionMap[props.breakpoint]&#125;)`); &#125; &#125; componentDidMount() &#123; if (this.mql) &#123; this.mql.addListener(this.responsiveHandler); this.responsiveHandler(this.mql); &#125; // ... &#125; responsiveHandler = (mql: MediaQueryListEvent | MediaQueryList) =&gt; &#123; this.setState(&#123; below: mql.matches &#125;); const &#123; onBreakpoint &#125; = this.props; if (onBreakpoint) &#123; onBreakpoint(mql.matches); &#125; if (this.state.collapsed !== mql.matches) &#123; this.setCollapsed(mql.matches, 'responsive'); &#125; &#125; setCollapsed = (collapsed: boolean, type: CollapseType) =&gt; &#123; if (!('collapsed' in this.props)) &#123; this.setState(&#123; collapsed, &#125;); &#125; const &#123; onCollapse &#125; = this.props; if (onCollapse) &#123; onCollapse(collapsed, type); &#125; &#125;&#125; 侧边栏组件的断点 props.breakpoint 包含五种可能：xs 为 480px；sm 为 576px；md 为 768px；lg 为 992px；xl 为 1200px；xxl 为 1600px。当设置了 props.breakpoint 时，就能实现响应式展开与折叠功能。 当 props.collapsedWidth 设置为 0，折叠状态切换按钮为 bars 类型。默认的折叠状态切换按钮为 left 或 right 类型。此外，可以使用 props.trigger 设置自定义折叠状态切换按钮。 侧边栏的主题样式通过设置样式类实现，如 ant-layout-sider-light。 侧边栏组件使用 react-lifecycles-compat 封装，以在低版本的 react 中书写 static getDerivedStateFromProps, getSnapshotBeforeUpdate 生命周期方法。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"http://xzfyu.com/tags/antd/"}]},{"title":"less 使用指南","slug":"frontend/css/less 使用指南","date":"2018-11-16T16:00:00.000Z","updated":"2020-03-08T10:35:41.114Z","comments":true,"path":"2018/11/17/frontend/css/less 使用指南/","link":"","permalink":"http://xzfyu.com/2018/11/17/frontend/css/less 使用指南/","excerpt":"","text":"前言这篇文章本不打算发布在知乎平台。但是在汇总笔者所不常用的 less 语法时，笔者又小小费了点脑筋，推想了一下 less 的实现（这样有助于从更高的维度去看待很多功能实现）。因此，笔者就希望能在一个更开阔的平台上得到一些回馈和纠错性意见。之所以要汇总 less 语法，那是因为要推究网页、组件库改变样式主题的实现。 导入12@import \"library\"; // library.less@import \"typo.css\"; 导入关键字导入关键字使用形式如 @import (optional, reference) “foo.less”。 所包含的关键字有： reference: 导入的样式文件将作为参考，其所包含的选择器将不会呈现在输出文件，却可以使用 mixin 混入或 extend 扩展将原选择器的样式添加到新的选择器中。reference 的应用场景如，@import (reference) bootstrap.less 样式，使用混入或扩展关键字只将 .navbar all 相关选择器的样式输出。推想其实现如，以内存形式缓存编译后的样式文件，被引用时才注入到输出文件中。 inline: 全量复制 css 文件，不作处理（less 在某些地方不支持注释；且在不修改 css 的情形下，less 也不支持全部的 css hacks）。 less: 以 less 文件形式处理导入的样式文件，不管文件扩展名。 css: 以 css 文件形式处理导入的样式文件，不管文件扩展名。 once: 样式文件只导入一次，默认。 multiple：样式文件导入多次。 optional: 样式文件不存在时不会报错。 嵌套规则使用嵌套形式书写样式文件时，&amp; 表示父选择器。 less 将使用父选择器名替换 &amp;。特殊的，使用 &amp; 能改变选择器的顺序；当有多个父选择器时，&amp; 依次解析为这几个父选择器。 推想其实现如，以块 {} 为编译单元，以 selectors 缓存 {} 前选择器，以 content 缓存 {} 内容并作解析，将样式写入 output；然后递归调用前述过程，传入父 selectors, content，解析子块时再将父 selector 添加到子 selector 前，将样式写入 output。嵌套规则以树形结构组织，但样式写入 output 时为扁平化结构。单个 &amp; 可以使用父 selector；多个 &amp;，可先构建两维数组，每个数组项为父 selector 的有序列表，然后遍历两维数组进行替换。若 &amp; 在选择器的尾部，编译时无需在子选择器前添加父选择器，而只将 &amp; 替换为父选择器。 多个父选择器 1234567891011121314// inputp, a &#123; &amp; + &amp; &#123; border-top: 0; &#125;&#125;// outputp + p,p + a,a + p,a + a &#123; border-top: 0;&#125; 改变选择器的顺序 12345678910111213// input.header &#123; .menu &#123; .no-borderradius &amp; &#123; background-image: url('images/button-background.png'); &#125; &#125;&#125;// output.no-borderradius .header .menu &#123; background-image: url('images/button-background.png');&#125; 变量less 中变量使用 @variableName: variableValue 形式声明；@variableName 或 @{variableName} 形式使用。变量可用于选择器的名称，样式属性的名称，样式属性的值，url，import 语句等。 less 允许使用变量去定义另一个变量的名称，即 @@variablename2 形式声明变量 variablename1。 less 允许先使用变量，再声明变量。推想其实现如，同 js 一样会将声明提前，并保留在内存中，以精确的值替换掉使用的变量，文件解析完成后，再释放内存。 变量有作用域，就近定义的优先。推想其编译过程，块将解析为函数，当在块中再度遇到相同的变量名，注入函数的实参就会被改变，最终输出也因而改变。其实现可能譬如模板引擎。 变量的一大用途包含，通过变量设置网页样式的主题。 12345678@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125; 变量与混合变量可以存储分离的规则集，其下可包含属性、嵌套规则集、变量声明、混合等。分离的规则集在块 {} 中以函数形式使用，该块内就可以使用分离的规则集内所声明的变量、样式属性和混合。 推想其实现如，将分离规则集解析为函数，在快内使用时再行植入。 123456789101112131415161718// input@detached-ruleset: &#123; .mixin() &#123; font-family: \"Comic Sans MS\"; background-color: #AA86EE; &#125;&#125;;.cont &#123; @detached-ruleset(); .mixin();&#125;// output.cont &#123; font-family: \"Comic Sans MS\"; background-color: #AA86EE;&#125; 操作符算数运算符 +, -, *, / 可作用于变量、颜色、数值，less 将尝试获得单位。推想其实现，首先将变量替换为实际的值，然后匹配到操作符，解析操作符前后数值的单位并获得最终单位，使用最终单位修正数值，数值计算并输出。 123456@conversion-1: 5cm + 10mm; // 输出 6cm@conversion-2: 2 - 3cm - 5mm; // 输出 1.5cm@incompatible-units: 2 + 5px - 3cm; // 输出 4px@base: 5%;@filler: @base * 2; // 输出 10%@other: @base + @filler; // 输出 15% 转义任何 ~”anything” 或 ~’anything’ 语句内，单双引号内容都将被保留，可用于规避 ‘//‘, ‘/ /‘被误认为注释。 123.weird-element &#123; content: ~\"^//* some horrible but needed css hack\";// 输出 content: ^//* some horrible but needed css hack;&#125; 混合混合能将某个类或 id 选择器中的样式添加到另一个选择器中，其书写形式如 css 中为类或 id 选择器添加样式，其下可包含选择器（当子选择器为类或 id 选择器时，该子选择器构成另一个混合，可以直接使用；这样，父选择器也称为命名空间）。 当 guard 应用于命名空间时，当且仅当 guard 条件返回真值，才能使用由命名空间定义的混合。参见 guard。 使用混合时添加 !important 关键字，混合下所有样式都将添加 !important。 特别，当类或 id 选择器以 () 结尾时，选择器将不会在输出文件中有所表现，而只是在使用时会将样式混入到其他选择器中。() 中可以添加参数（以 ‘,’ 或 ‘;’ 分割参数），使函数具有函数特征，且支持多态。混合函数使用时可以借助参数名指定参数的值，这样就无关参数的位置；且使用时，@arguments 将包含所有参数；参数支持解构语法如 … 或 @rest…。混合函数的参数可以是复杂的样式规则。 在混合函数中声明的变量，可以在使用混合的块中访问。但是块中若有同名变量，以块中声明的变量优先。 推想其实现如，编译结束后类或 id 选择器构成的混合将保留在内存中，对于 () 结尾的选择器将以函数形式保存，使用时调用函数，这样就不会有样式输出。且保留在内存中的函数是在解析到 () 时构建的，这样就使得 less 语法上呈现多态，编译出来的函数可以使用控制语句处理函数体内参数的多态特征。 命名空间，不输出混合。 1234567891011121314151617181920212223242526272829// input#bundle() &#123; .button &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125;#header a &#123; color: orange; #bundle &gt; .button;&#125;// output#header a &#123; color: orange; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125;&#125; 使用 !important 1234567891011121314// input.foo (@bg: #f5f5f5, @color: #900) &#123; background: @bg; color: @color;&#125;.important &#123; .foo() !important;&#125;// output.important &#123; background: #f5f5f5 !important; color: #900 !important;&#125; 混合函数支持多态 12345678910111213141516171819202122// input.mixin(dark; @color) &#123; color: darken(@color, 10%);&#125;.mixin(light; @color) &#123; color: lighten(@color, 10%);&#125;.mixin(@_; @color) &#123; display: block;&#125;@switch: light;.class &#123; .mixin(@switch; #888);&#125;// output.class &#123; color: #a2a2a2; display: block;&#125; 混合函数中定义的变量，可以在使用时引用 1234567891011121314151617// input.mixin() &#123; @width: 100%; @height: 200px;&#125;.caller &#123; .mixin(); width: @width; height: @height;&#125;// output.caller &#123; width: 100%; height: 200px;&#125; 扩展扩展 :extend 是 less 提供的伪类，使用形式如 .big-bag:extend(.bag) 将使 .big-bag 拥有 .bag 的样式。 使用 all 关键字如 .replacement:extend(.test all)，将把 .test 替换为 .replacement，再行输出另一份样式规则。 推想其实现如，selector1:extend(selector2) 伪类前后内容解析为映射形式，在将 selector2 的样式规则赋值给 selector1。 all 关键字123456789101112131415161718192021222324// input.a.b.test,.test.c &#123; color: orange;&#125;.test &#123; &amp;:hover &#123; color: green; &#125;&#125;.replacement:extend(.test all) &#123;&#125;// output.a.b.test,.test.c,.a.b.replacement,.replacement.c &#123; color: orange;&#125;.test:hover,.replacement:hover &#123; color: green;&#125; 扩展和指令若 extend 伪类在 @media 指令中定义，那么 less 将在 @media 指令内查找匹配的选择器。若 extend 伪类在顶层定义，less 将能匹配到所有 @media 指令中的选择器。 123456789101112131415// input@media print &#123; .screenClass:extend(.selector) &#123;&#125; // extend inside media .selector &#123; // this will be matched - it is in the same media color: black; &#125;&#125;// output@media print &#123; .selector, .screenClass &#123; /* ruleset inside the same media was extended */ color: black; &#125;&#125; 嵌套指令嵌套指令会冒泡到顶层。对于条件指令如 @Media, @supports, @document 等，条件指令上的父选择器会被植入条件指令内；对于非条件指令如 @font-face, @keyframes 等，条件指令上的父选择器会被忽略。 条件指令 123456789101112131415161718192021// input.screen-color &#123; @media screen &#123; color: green; @media (min-width: 768px) &#123; color: red; &#125; &#125;&#125;// output@media screen &#123; .screen-color &#123; color: green; &#125;&#125;@media screen and (min-width: 768px) &#123; .screen-color &#123; color: red; &#125;&#125; 非条件指令 123456789101112131415// input#a &#123; color: blue; @font-face &#123; src: made-up-url; &#125;&#125;// output#a &#123; color: blue;&#125;@font-face &#123; src: made-up-url;&#125; guardguard 用于指定条件，在满足该条件时，才会有样式输出。使用形式如 when (@var = value)，即当 @var 变量或参数等于 value 时，才满足条件。when 条件内可包含比较运算符如 =, &lt;, &gt;, &lt;=, &gt;=，以及逻辑运算符 and, and not，内置的类型检查函数如 iscolor, isnumber, isstring, iskeyword, isurl, ispixel, ispercentage, isem, isunit。 当使用 guard 递归构建 mixin 时，可以形成循环。 逻辑运算符 1234567891011121314151617181920212223// input.mixin (@a) when (@a &gt; 50%) and (@a &gt; 5px)&#123;font-size: 14px;&#125;.mixin (@a) when not (@a &lt; 50%) and not (@a &lt; 5px)&#123;font-size: 20px;&#125;.mixin (@a) &#123; color: @a;&#125;.class1 &#123; .mixin(#FF0000) &#125;.class2 &#123; .mixin(#555) &#125;// output.class1 &#123; font-size: 20px; color: #FF0000;&#125;.class2 &#123; font-size: 20px; color: #555;&#125; 循环 123456789101112131415// input.cont(@count) when (@count &gt; 0) &#123; .cont((@count - 1)); width: (25px * @count);&#125;div &#123; .cont(3);&#125;// outputdiv &#123; width: 25px; width: 50px; width: 75px;&#125; 合并 使用 ‘,’ 串联多个样式属性 12345678910111213// input.myfunc() &#123; box-shadow+: 5px 5px 5px grey;&#125;.class &#123; .myfunc(); box-shadow+: 0 0 5px #f78181;&#125;// output.class &#123; box-shadow: 5px 5px 5px grey, 0 0 5px #f78181;&#125; 使用空格串联多个样式属性 12345678910111213// input.mixin() &#123; transform+_: scale(1);&#125;.class &#123; .mixin(); transform+_: rotate(2deg);&#125;// output.class &#123; transform: scale(1) rotate(2deg);&#125; 函数推想其实现如，由 less 提供上下文环境，并通过该上下文环境输出内置函数。颜色函数的实现是笔者鞭长莫及的。 12345678@base: #f04615;@width: 0.5;.class &#123; width: percentage(@width); color: saturate(@base, 5%); background-color: spin(lighten(@base, 25%), 8);&#125; 其他函数 color: 颜色转换函数。 image-size: 从文件中获取图像的宽度及高度，可作为 image-size 样式的值。 image-width : 从文件中获取图像的宽度。 image-height: 从文件中获取图像的高度。 convert: 单位转换，如 convert(10cm, mm)。 data-uri: 用于嵌入资源，data-uri(url, mimeType)。 unit: 可用于指定单位，unit(dimension, unit)。 get-unit: 可用于获取单位，如 get-unit(30px)。 svg-gradient: 可用于转换颜色， if: 按条件返回指定的值，if(condition, value1, value2)，当 condition 成立时，返回 value1，否则返回 value2。 1234.style &#123; @style: orange, green 30%, #DAA520; background-image: svg-gradient(ellipse, @style);&#125; 字符串函数 escape: 对特殊字符使用URL编码来对字符串或信息进行编码。 e: 去除字符串的引号。 %: format 函数，用于转化字符串，如 %(string，arguments …)。 replace: 用于替换字符串，如 replace(string, pattern, replacement, flags)。 列表函数 length: 用于获取列表的长度，如 @list: “audi”, “benz”, “toyota”, “honda”; length(@list)。 extract: 用于获取列表中指定位置的值，如 @list: “audi”, “benz”, “toyota”, “honda”; length(@list, 2)。 数学函数 ceil: 向上取整。 floor: 向下取整。 percentage: 将浮点数转换为百分比字符串。 round: 四舍五入。 sqrt: 获取平方根。 abs: 取绝对值，如 abs(30ft) 将获得 30ft。 sin, asin, cos, acos, tan, atan: 计算正弦、反正弦等。 pi: 返回 pi 的值。 pow: 计算幂。 mod: 计算首参相对次参的模。 min: 计算最小值，如 min(70,30,45,20)。 max: 计算最大值。 类型函数类型函数包含 iscolor, isnumber, isstring, iskeyword, isurl, ispixel, ispercentage, isem, isunit, isruleset，返回布尔值。 颜色定义函数颜色定义函数包含 rgb(red, green, blue), rgba(red, green, blue, alpha), argb, hsl, hsla, hsv, hsva，具体可以参看 Less 颜色定义函数。 颜色通道函数 hue: 在 HSL 颜色空间中，提取颜色对象的色调通道。 saturation: 在 HSL 颜色空间中，提取彩色对象的饱和通道。 lightness: 在 HSL 颜色空间中，从颜色对象提取亮度通道。 hsvhue: 在 HSV 色彩空间中，提取色彩对象的色调通道。 hsvsaturation: 在 HSL 颜色空间中，提取彩色对象的饱和通道。 hsvvalue: 在 HSL 颜色空间中，提取颜色对象的值通道。 red: 提取彩色对象的红色通道。 green: 提取彩色对象的绿色通道。 blue: 提取彩色对象的蓝色通道。 alpha: 提取颜色对象的 alpha 通道。 luma: 计算颜色对象的亮度值。 luminance: 在没有伽马校正的情况下计算亮度值。 颜色操作函数 saturate: 改变颜色的强度或饱和度，如 saturate(color, amount)。 desaturate: 降低颜色的强度或饱和度。 lighten: 增加颜色的亮度，如 lighten(color, amount)。 darken: 降低颜色的亮度。 fadein: 增加颜色的不透明度，如 fadein(color, amount)。 fadeout: 降低颜色的不透明度。 fade: 设置颜色的不透明度，如 fade(color, amount)。 spin: 旋转颜色的角度，如 spin(color, angle)。 mix: 混合两种颜色以及不透明度，如 mix(color1, color2, weight)，参数 weight 为权重。 tint: 混合颜色和白色，如 tint(color, weight)。 shade: 混合颜色和黑色。 greyscale: 丢弃颜色的饱和度，如 greyscale(color)。 contrast: 设置颜色的对比度，如 contrast(color, dark, light, amount)。 颜色混合函数 multiply: 两种RGB通道颜色相乘，然后除以 255 以得到较暗的颜色作为结果。 screen: 获取两种颜色中更明亮的颜色。 overlay: 结合 multiply, screen 的效果生成结果，使光通道更轻，暗通道更暗。 softlight: 工作方式类似于 overlay 函数，但它仅使用颜色的一部分，其中柔和地突出显示其他颜色。 hardlight: 与 overlay 函数类似，但颜色的作用相反。 它使用第二个参数执行 overlay()函数，以确定是否应该执行乘法或屏幕操作。 difference: 从首参颜色中减去次参颜色，负值将反转。 exclusion: 类似于 difference 函数，但具有较低的对比度。 average: 计算两种颜色的均值。 negation: 与 difference 函数相反，从次参颜色减去首参颜色。 参考less 语言特性less 教程","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"css","slug":"frontend/css","permalink":"http://xzfyu.com/categories/frontend/css/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"css","slug":"css","permalink":"http://xzfyu.com/tags/css/"}]},{"title":"antd-Input 组件","slug":"frontend/antd/Input","date":"2018-11-10T16:00:00.000Z","updated":"2020-03-08T10:28:20.275Z","comments":true,"path":"2018/11/11/frontend/antd/Input/","link":"","permalink":"http://xzfyu.com/2018/11/11/frontend/antd/Input/","excerpt":"","text":"Input 组件Input 组件只关乎布局，其余均为常规处理。props.addonBefore 为前置标签，props.addonAfter 为后置标签，props.prefix 前缀图标，props.suffix 后缀图标。参看官方图例： Input 组件在 render 方法执行阶段将绘制出 input 原生组件。鉴于 react 的实现机制，对于 input 原生组件的处理，有受控组件和非手空组件的区别。受控组件即根据组件的 state 变化渲染 input 节点的值，非受控组件只允许组件渲染出 input 节点的默认值，而其实时值将根据用户的操作行为加以改变。ant design 中的 Input 组件对于受控组件和非受控组件的处理，即是当开发者同时传入 props.value 和 props.defaultValue，props.value 的优先级高于 props.defaultValue，且当 props.value 为 undefined 或 null，均会以空字符串渲染 input 节点的值。 在事件的绑定函数方面，常规的绑定函数均会透传到 input 原生组件上，而 props.onPressEnter, props.onKeyDown 两个绑定函数均会以 inputInstance.handleKeyDown 方法的形式挂载为 input 原生组件的 onKeyDown 绑定函数（inputInstance 为 Input 组件的实例）。 此外，inputInstance 实例内置 focus, blur, select 方法，其功用如 inputInstance.focus 可以在校验表单时使校验失败的输入框组件获得焦点。inputInstance.input 属性用于访问 input 原生节点。 在样式处理方面，笔者将作专文加以阐述。 TextArea 组件TextArea 组件用于绘制 textarea 原生节点。不同于使用前后标签、前后图标影响渲染输入框组件的布局，TextArea 组件只包含 textarea 节点，没有其他布局元素。 TextArea 组件的特殊处理逻辑是，textarea 节点的高度随用户输入内容而改变，受控于 props.autosize = { minRows?, maxRows? } 属性。其实现原理为： 使用插入文档的隐藏文本框节点计算单行文本的高度，再由 minRows, maxRows 计算文本框的最大最小高度，并计算文本框的高度。计算获得的文本框即 textareaStyles 变量。 调用组件实例的 setState 方法，更新 state.textareaStyles，最终构成组件实例的 resizeTextarea 方法。对于受控组件，将在componentWillReceiveProps 生命周期中判断组件获得的 props.value 是否更新，再使用 window.requestAnimationFrame 方式调用 resizeTextarea 方法，以调整文本框的高度。对于非受控组件，在 onChange 事件发生时调用 resizeTextarea 方法。 calculateNodeHeight 函数计算文本框高度源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147const HIDDEN_TEXTAREA_STYLE = ` min-height:0 !important; max-height:none !important; height:0 !important; visibility:hidden !important; overflow:hidden !important; position:absolute !important; z-index:-1000 !important; top:0 !important; right:0 !important`;const SIZING_STYLE = [ 'letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing',];let computedStyleCache: &#123;[key: string]: NodeType&#125; = &#123;&#125;;let hiddenTextarea: HTMLTextAreaElement;function calculateNodeStyling(node: HTMLElement, useCache = false) &#123; const nodeRef = ( node.getAttribute('id') || node.getAttribute('data-reactid') || node.getAttribute('name') ) as string; if (useCache &amp;&amp; computedStyleCache[nodeRef]) &#123; return computedStyleCache[nodeRef]; &#125; const style = window.getComputedStyle(node); const boxSizing = ( style.getPropertyValue('box-sizing') || style.getPropertyValue('-moz-box-sizing') || style.getPropertyValue('-webkit-box-sizing') ); const paddingSize = ( parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top')) ); const borderSize = ( parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width')) ); const sizingStyle = SIZING_STYLE .map(name =&gt; `$&#123;name&#125;:$&#123;style.getPropertyValue(name)&#125;`) .join(';'); const nodeInfo: NodeType = &#123; sizingStyle, paddingSize, borderSize, boxSizing, &#125;; if (useCache &amp;&amp; nodeRef) &#123; computedStyleCache[nodeRef] = nodeInfo; &#125; return nodeInfo;&#125;export default function calculateNodeHeight( uiTextNode: HTMLTextAreaElement, useCache = false, minRows: number | null = null, maxRows: number | null = null,) &#123; if (!hiddenTextarea) &#123; hiddenTextarea = document.createElement('textarea'); document.body.appendChild(hiddenTextarea); &#125; // Fix wrap=\"off\" issue // https://github.com/ant-design/ant-design/issues/6577 if (uiTextNode.getAttribute('wrap')) &#123; hiddenTextarea.setAttribute('wrap', uiTextNode.getAttribute('wrap') as string); &#125; else &#123; hiddenTextarea.removeAttribute('wrap'); &#125; // 将影响文本框节点高度的样式属性拷贝给隐藏节点 // overflow 样式属性置为 hidden，以此将滚动条排除在外 let &#123; paddingSize, borderSize, boxSizing, sizingStyle, &#125; = calculateNodeStyling(uiTextNode, useCache); hiddenTextarea.setAttribute('style', `$&#123;sizingStyle&#125;;$&#123;HIDDEN_TEXTAREA_STYLE&#125;`); hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || ''; let minHeight = Number.MIN_SAFE_INTEGER; let maxHeight = Number.MAX_SAFE_INTEGER; let height = hiddenTextarea.scrollHeight;// 以隐藏节点计算文本框高度 let overflowY: any; // 根据盒模式调整高度 if (boxSizing === 'border-box') &#123; height = height + borderSize; &#125; else if (boxSizing === 'content-box') &#123; height = height - paddingSize; &#125; if (minRows !== null || maxRows !== null) &#123; // 计算文本框单行高度 hiddenTextarea.value = ' '; let singleRowHeight = hiddenTextarea.scrollHeight - paddingSize; if (minRows !== null) &#123; minHeight = singleRowHeight * minRows; if (boxSizing === 'border-box') &#123; minHeight = minHeight + paddingSize + borderSize; &#125; height = Math.max(minHeight, height); &#125; if (maxRows !== null) &#123; maxHeight = singleRowHeight * maxRows; if (boxSizing === 'border-box') &#123; maxHeight = maxHeight + paddingSize + borderSize; &#125; overflowY = height &gt; maxHeight ? '' : 'hidden'; height = Math.min(maxHeight, height); &#125; &#125; if (!maxRows) &#123; overflowY = 'hidden'; &#125; return &#123; height, minHeight, maxHeight, overflowY &#125;;&#125; setState 更新文本框高度源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 不打断本次渲染，在下一次渲染调整文本框的样式function onNextFrame(cb: () =&gt; void) &#123; if (window.requestAnimationFrame) &#123; return window.requestAnimationFrame(cb); &#125; return window.setTimeout(cb, 1);&#125;function clearNextFrameAction(nextFrameId: number) &#123; if (window.cancelAnimationFrame) &#123; window.cancelAnimationFrame(nextFrameId); &#125; else &#123; window.clearTimeout(nextFrameId); &#125;&#125;class TextArea extends React.Component&lt;TextAreaProps, TextAreaState&gt; &#123; static defaultProps = &#123; prefixCls: 'ant-input', &#125;; nextFrameActionId: number; state = &#123; textareaStyles: &#123;&#125;, &#125;; componentDidMount() &#123; this.resizeTextarea(); &#125; componentWillReceiveProps(nextProps: TextAreaProps) &#123; if (this.props.value !== nextProps.value) &#123; if (this.nextFrameActionId) &#123; clearNextFrameAction(this.nextFrameActionId); &#125; this.nextFrameActionId = onNextFrame(this.resizeTextarea); &#125; &#125; resizeTextarea = () =&gt; &#123; const &#123; autosize &#125; = this.props; if (!autosize || !this.textAreaRef) &#123; return; &#125; const minRows = autosize ? (autosize as AutoSizeType).minRows : null; const maxRows = autosize ? (autosize as AutoSizeType).maxRows : null; const textareaStyles = calculateNodeHeight(this.textAreaRef, false, minRows, maxRows); this.setState(&#123; textareaStyles &#125;); &#125; handleTextareaChange = (e: React.ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; &#123; if (!('value' in this.props)) &#123; this.resizeTextarea(); &#125; const &#123; onChange &#125; = this.props; if (onChange) &#123; onChange(e); &#125; &#125; // 余略&#125; SearchSearch 组件基于 Input 组件制作，其特殊处理是在 inputInstance.onPressEnter 方法执行过程中调用 props.onSearch 方法，适用于远程搜索之类的场景；Search 组件还提供 props.enterButton 属性用于配置输入框的后缀图标，默认使用 search 图标，可渲染文本或按钮。实现请参考 ant design 源码。 GroupGroup 组件主要以样式控制多个表单项组件 props.children 的成组渲染。实现请参考 ant design 源码。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"http://xzfyu.com/tags/antd/"}]},{"title":"http-proxy-middleware 源码解读","slug":"frontend/工程化/http-proxy-middleware源码解读","date":"2018-11-10T16:00:00.000Z","updated":"2020-03-08T10:58:05.344Z","comments":true,"path":"2018/11/11/frontend/工程化/http-proxy-middleware源码解读/","link":"","permalink":"http://xzfyu.com/2018/11/11/frontend/工程化/http-proxy-middleware源码解读/","excerpt":"","text":"概述http-proxy-middleware 库借助于 node-http-proxy，用于将 node 服务器接收到的请求转发到目标服务器，实现代理服务器的功能。 实现原理可以推想，使用 node-http-proxy 创建代理服务器 proxyServer 后，通过全局注册的转发规则获取到客户端请求 req 需要发送到的目标地址，再通过调用 proxyServer.web, proxyServer.ws 方法转发请求。 转发规则从原理层面简单的归纳转发规则，就是客户端请求路径到目标服务器地址的映射关系。node-http-proxy 库将转发规则分为两部分加以配置，context 用于匹配需要转发的客户端请求，options.target 用于设定目标服务器的 host；option.router 根据客户端请求重新设定目标服务器的 host（这样，根据不同的请求，可以设定多个目标服务器）；option.pathRewrite 用于辅助将客户端请求路径转化为目标服务器地址。 contextcontext 表示待转发请求的目录名。当客户端请求以 context 起始时，则该请求将被转发。如 context 设置为 ‘/api’，客户端所有以 ‘/api’ 起始的请求都会被转发；默认值为 ‘/‘，意为客户端发送的所有请求都会被转发。node-http-proxy 库使用 createConfig 解析获得 context；matchContext 函数校验客户端请求是否需要转发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 解析获取 context，需要代理的请求 url 前缀 * @param &#123;string|object|function&#125; context 作为 HttpProxyMiddleware 接口传入 createConfig 函数的参数 * @param &#123;undefined|object&#125; opts 作为 HttpProxyMiddleware 接口传入 createConfig 函数的参数 */function createConfig (context, opts) &#123; var config = &#123; context: undefined, options: &#123;&#125; &#125; // context 作为 opts 传入，config.context 使用默认值 if (isContextless(context, opts)) &#123; config.context = '/' config.options = _.assign(config.options, context) // context 以 url 形式配置，可同时配置 context, options.target &#125; else if (isStringShortHand(context)) &#123; var oUrl = url.parse(context) var target = [oUrl.protocol, '//', oUrl.host].join('') config.context = oUrl.pathname || '/' config.options = _.assign(config.options, &#123; target: target &#125;, opts) if (oUrl.protocol === 'ws:' || oUrl.protocol === 'wss:') &#123; config.options.ws = true &#125; &#125; else &#123; config.context = context config.options = _.assign(config.options, opts) &#125; // 配置 Logger 实例 configureLogger(config.options) if (!config.options.target) &#123; throw new Error(ERRORS.ERR_CONFIG_FACTORY_TARGET_MISSING) &#125; return config&#125;/** * 解析获取 context，需要代理的请求 url 前缀 * @param &#123;string|function&#125; context 需要代理的请求 url 前缀 * @param &#123;object&#125; uri 客户端请求的 uri，即 req.originalUrl 或 req.url * @param &#123;object&#125; req 客户端请求 req */function matchContext (context, uri, req) &#123; // context 为字符串路径，校验 url 是否以 context 起始 if (isStringPath(context)) &#123; return matchSingleStringPath(context, uri) &#125; // context 为 glob 模式的字符串路径（通过 is-glob 模块判断），校验 url 是否匹配 context（通过 micromatch 判断） // [glob 介绍](https://blog.csdn.net/Free_Wind22/article/details/78344166) if (isGlobPath(context)) &#123; return matchSingleGlobPath(context, uri) &#125; // 遍历 context，调用 matchSingleStringPath, matchSingleGlobPath 作校验 if (Array.isArray(context)) &#123; if (context.every(isStringPath)) &#123; return matchMultiPath(context, uri) &#125; if (context.every(isGlobPath)) &#123; return matchMultiGlobPath(context, uri) &#125; throw new Error(ERRORS.ERR_CONTEXT_MATCHER_INVALID_ARRAY) &#125; // context 自定义函数，用于校验客户端请求是否需要转发 if (_.isFunction(context)) &#123; var pathname = getUrlPathName(uri) return context(pathname, req) &#125; throw new Error(ERRORS.ERR_CONTEXT_MATCHER_GENERIC)&#125; targettarget 表示目标服务器的 host。在 createConfig 函数的源码中，可以看到，target 即能通过 url 形式的 context 设定，又能通过 options.target 选项设定。当然，这样是作为全局配置设定的；同 node-http-proxy 库，http-proxy-middleware 也可以在具体的请求发生时作特殊处理。这后半分的内容，是通过全局配置 options.router 达成的。在 http-proxy-middleware 处理客户端请求的过程中，getTarget 函数将通过 options.router 获取目标服务器的 host。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 获取目标服务器的 host * @param &#123;object&#125; req 客户端请求 req * @param &#123;object&#125; config 即 HttpProxyMiddleware 接口的 options 参数，获取 options.router */function getTarget (req, config) &#123; var newTarget var router = config.router if (_.isPlainObject(router)) &#123; newTarget = getTargetFromProxyTable(req, router) &#125; else if (_.isFunction(router)) &#123; newTarget = router(req) &#125; return newTarget&#125;function getTargetFromProxyTable (req, table) &#123; var result var host = req.headers.host var path = req.url var hostAndPath = host + path// 客户端请求路径 _.forIn(table, function (value, key) &#123; // containsPath(str) 函数，判断 str 是否包含 '/' if (containsPath(key)) &#123; if (hostAndPath.indexOf(key) &gt; -1) &#123; result = table[key] logger.debug('[HPM] Router table match: \"%s\"', key) return false &#125; &#125; else &#123; if (key === host) &#123; result = table[key] logger.debug('[HPM] Router table match: \"%s\"', host) return false &#125; &#125; &#125;) return result&#125; pathRewrite在 http-proxy-middleware 库中，options.pathRewrite 用于将客户端请求路径转化为目标服务器的路径（pathname 部分），既可以是 map 映射，也可以函数。createPathRewriter 函数将根据 options.pathRewrite 生成路径转化器 pathRewriter 函数；而 pathRewriter 用于将实际的客户端请求地址转化为目标服务器的路径。当 options.pathRewrite 为对象 key-value 时，pathRewriter 将把匹配 key 的客户端请求转化为 value 路径；当 options.pathRewrite 为函数时，将由客户端请求 req.url 获取目标服务器路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 生成 pathRewriter 函数 * @param &#123;object|function&#125; rewriteConfig 即 HttpProxyMiddleware 接口的 options.pathRewrite 配置项 */function createPathRewriter (rewriteConfig) &#123; var rulesCache // isValidRewriteConfig 函数用于校验 options.pathRewrite if (!isValidRewriteConfig(rewriteConfig)) &#123; return &#125; if (_.isFunction(rewriteConfig)) &#123; var customRewriteFn = rewriteConfig return customRewriteFn &#125; else &#123; rulesCache = parsePathRewriteRules(rewriteConfig) return rewritePath &#125; // 参数 path 为 req.url function rewritePath (path) &#123; var result = path _.forEach(rulesCache, function (rule) &#123; if (rule.regex.test(path)) &#123; result = result.replace(rule.regex, rule.value) logger.debug('[HPM] Rewriting path from \"%s\" to \"%s\"', path, result) return false &#125; &#125;) return result &#125;&#125;function parsePathRewriteRules (rewriteConfig) &#123; var rules = [] if (_.isPlainObject(rewriteConfig)) &#123; _.forIn(rewriteConfig, function (value, key) &#123; rules.push(&#123; regex: new RegExp(key), value: rewriteConfig[key] &#125;) logger.info('[HPM] Proxy rewrite rule created: \"%s\" ~&gt; \"%s\"', key, rewriteConfig[key]) &#125;) &#125; return rules&#125; 整体流程这部分将串联转发规则的解析和应用，是为 http-proxy-middleware 库的整体工作流程。 解析 context，options 配置，获得全局注册的 context, options.target；并配置 Logger 实例。 使用 node-http-proxy 库常见代理服务器 proxy。 根据 options.pathRewrite 生成路径转化器 pathRewriter。 为代理服务器绑定事件。 创建转发 http, https, websocket 请求的代理中间件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118function HttpProxyMiddleware (context, opts) &#123; // https://github.com/chimurai/http-proxy-middleware/issues/57 var wsUpgradeDebounced = _.debounce(handleUpgrade) var wsInitialized = false var config = configFactory.createConfig(context, opts) var proxyOptions = config.options var proxy = httpProxy.createProxyServer(&#123;&#125;) logger.info('[HPM] Proxy created:', config.context, ' -&gt; ', proxyOptions.target) var pathRewriter = PathRewriter.create(proxyOptions.pathRewrite) // 为代理服务器绑定事件 handlers.init(proxy, proxyOptions) proxy.on('error', logError) middleware.upgrade = wsUpgradeDebounced return middleware // 实际的代理中间件 function middleware (req, res, next) &#123; if (shouldProxy(config.context, req)) &#123; var activeProxyOptions = prepareProxyRequest(req) proxy.web(req, res, activeProxyOptions) &#125; else &#123; next() &#125; if (proxyOptions.ws === true) &#123; catchUpgradeRequest(req.connection.server) &#125; &#125; function catchUpgradeRequest (server) &#123; if (!wsInitialized) &#123; server.on('upgrade', wsUpgradeDebounced) wsInitialized = true &#125; &#125; // 转发 websocket 请求 function handleUpgrade (req, socket, head) &#123; wsInitialized = true if (shouldProxy(config.context, req)) &#123; var activeProxyOptions = prepareProxyRequest(req) proxy.ws(req, socket, head, activeProxyOptions) logger.info('[HPM] Upgrading to WebSocket') &#125; &#125; // 判断请求是否需要转发 function shouldProxy (context, req) &#123; var path = (req.originalUrl || req.url) return contextMatcher.match(context, path, req) &#125; // 转发请求 function prepareProxyRequest (req) &#123; req.url = (req.originalUrl || req.url) var originalPath = req.url var newProxyOptions = _.assign(&#123;&#125;, proxyOptions) __applyRouter(req, newProxyOptions) __applyPathRewrite(req, pathRewriter) if (proxyOptions.logLevel === 'debug') &#123; // getArrow 返回的标识，用于区分 options.router, options.pathRewrite 的作用与否 // '-&gt;' options.router, options.pathRewrite 均未作用 // '=&gt;' options.router 作用, options.pathRewrite 未作用 // '~&gt;' options.router 未作用, options.pathRewrite 作用 // '≈&gt;' options.router, options.pathRewrite 均作用 var arrow = getArrow(originalPath, req.url, proxyOptions.target, newProxyOptions.target) logger.debug('[HPM] %s %s %s %s', req.method, originalPath, arrow, newProxyOptions.target) &#125; return newProxyOptions &#125; // 根据请求获取目标服务器的 host function __applyRouter (req, options) &#123; var newTarget if (options.router) &#123; newTarget = Router.getTarget(req, options) if (newTarget) &#123; logger.debug('[HPM] Router new target: %s -&gt; \"%s\"', options.target, newTarget) options.target = newTarget &#125; &#125; &#125; // 将目标服务器路径写入 req.url function __applyPathRewrite (req, pathRewriter) &#123; if (pathRewriter) &#123; var path = pathRewriter(req.url, req) if (typeof path === 'string') &#123; req.url = path &#125; else &#123; logger.info('[HPM] pathRewrite: No rewritten path found. (%s)', req.url) &#125; &#125; &#125; function logError (err, req, res) &#123; var hostname = (req.headers &amp;&amp; req.headers.host) || (req.hostname || req.host) var target = proxyOptions.target.host || proxyOptions.target var errorMessage = '[HPM] Error occurred while trying to proxy request %s from %s to %s (%s) (%s)' var errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors' logger.error(errorMessage, req.url, hostname, target, err.code, errReference) &#125;&#125; 其他loggerhttp-proxy-middleware 库使用单例模式创建 Logger 实例，并提供 setProvider 函数切换打印日志的 console 函数；setLevel 方法用于设定日志级别；继而由 Logger 实例提供 log, error, info, warn, debug 方法，这些方法在调用过程都会校验当前执行的方法是否符合当前日志级别，同时会允许首参以 %s 设定占位符，以注入次参等。 因日志模块在 node 服务器中广为应用，这里贴出 http-proxy-middleware 库中的代码实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109var loggerInstancevar defaultProvider = &#123; log: console.log, debug: console.log, info: console.info, warn: console.warn, error: console.error&#125;var LEVELS = &#123; debug: 10, info: 20, warn: 30, error: 50, silent: 80&#125;function Logger () &#123; var logLevel var provider var api = &#123; log: log, debug: debug, info: info, warn: warn, error: error, setLevel: function (v) &#123; if (isValidLevel(v)) &#123;// isValidLevel 校验 v 是否 debug, info, warn, error, slient 中的一个 logLevel = v &#125; &#125;, setProvider: function (fn) &#123; if (fn &amp;&amp; isValidProvider(fn)) &#123;// isValidProvider 校验 fn 是否函数 provider = fn(defaultProvider) &#125; &#125; &#125; init() return api function init () &#123; api.setLevel('info') api.setProvider(function () &#123; return defaultProvider &#125;) &#125; function log () &#123; provider.log(_interpolate.apply(null, arguments)) &#125; function debug () &#123; if (_showLevel('debug')) &#123; provider.debug(_interpolate.apply(null, arguments)) &#125; &#125; function info () &#123; if (_showLevel('info')) &#123; provider.info(_interpolate.apply(null, arguments)) &#125; &#125; function warn () &#123; if (_showLevel('warn')) &#123; provider.warn(_interpolate.apply(null, arguments)) &#125; &#125; function error () &#123; if (_showLevel('error')) &#123; provider.error(_interpolate.apply(null, arguments)) &#125; &#125; // 校验调用的方法是否在当前允许的日志级别下 function _showLevel (showLevel) &#123; var result = false var currentLogLevel = LEVELS[logLevel] if (currentLogLevel &amp;&amp; (currentLogLevel &lt;= LEVELS[showLevel])) &#123; result = true &#125; return result &#125; // 参数转化，允许首参以 %s 形式设置占位符 function _interpolate () &#123; var fn = _.spread(util.format) var result = fn(_.slice(arguments)) return result &#125;&#125;module.exports = &#123; getInstance: function () &#123; if (!loggerInstance) &#123; loggerInstance = new Logger() &#125; return loggerInstance &#125;&#125; 事件绑定解析 options.onError, options.onProxyReq, options.onProxyReqWs, options.onProxyRes, options.onOpen, options.onClose，并绑定为代理服务器的事件。 默认的绑定函数为： 123456789101112131415161718192021222324252627// onError 绑定函数function defaultErrorHandler (err, req, res) &#123; var host = (req.headers &amp;&amp; req.headers.host) var code = err.code if (res.writeHead &amp;&amp; !res.headersSent) &#123; if (/HPE_INVALID/.test(code)) &#123; res.writeHead(502) &#125; else &#123; switch (code) &#123; case 'ECONNRESET': case 'ENOTFOUND': case 'ECONNREFUSED': res.writeHead(504) break default: res.writeHead(500) &#125; &#125; &#125; res.end('Error occured while trying to proxy to: ' + host + req.url)&#125;// onClose 绑定函数function logClose (req, socket, head) &#123; logger.info('[HPM] Client disconnected')&#125; 应用webpack-dev-serverwebpack-dev-server 库会创建 express 服务器，其服务器代理的实现就是解析配置项，并挂载 http-proxy-middleware 中间件。主要逻辑在 features.proxy 方法中实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const features = &#123; // ... proxy: () =&gt; &#123; if (options.proxy) &#123; // 解析配置 if (!Array.isArray(options.proxy)) &#123; options.proxy = Object.keys(options.proxy).map((context) =&gt; &#123; let proxyOptions; const correctedContext = context .replace(/^\\*$/, '**') .replace(/\\/\\*$/, ''); if (typeof options.proxy[context] === 'string') &#123; proxyOptions = &#123; context: correctedContext, target: options.proxy[context] &#125;; &#125; else &#123; proxyOptions = Object.assign(&#123;&#125;, options.proxy[context]); proxyOptions.context = correctedContext; &#125; // 日志级别 proxyOptions.logLevel = proxyOptions.logLevel || 'warn'; return proxyOptions; &#125;); &#125; // 获得 proxy 中间件 const getProxyMiddleware = (proxyConfig) =&gt; &#123; const context = proxyConfig.context || proxyConfig.path; if (proxyConfig.target) &#123; return httpProxyMiddleware(context, proxyConfig); &#125; &#125;; // 以配置项挂载多个中间件 options.proxy.forEach((proxyConfigOrCallback) =&gt; &#123; let proxyConfig; let proxyMiddleware; if (typeof proxyConfigOrCallback === 'function') &#123; proxyConfig = proxyConfigOrCallback(); &#125; else &#123; proxyConfig = proxyConfigOrCallback; &#125; proxyMiddleware = getProxyMiddleware(proxyConfig); if (proxyConfig.ws) &#123; websocketProxies.push(proxyMiddleware); &#125; app.use((req, res, next) =&gt; &#123; if (typeof proxyConfigOrCallback === 'function') &#123; const newProxyConfig = proxyConfigOrCallback(); if (newProxyConfig !== proxyConfig) &#123; proxyConfig = newProxyConfig; proxyMiddleware = getProxyMiddleware(proxyConfig); &#125; &#125; const bypass = typeof proxyConfig.bypass === 'function'; const bypassUrl = (bypass &amp;&amp; proxyConfig.bypass(req, res, proxyConfig)) || false; // 转发到本地服务器 if (bypassUrl) &#123; req.url = bypassUrl; next(); &#125; else if (proxyMiddleware) &#123; return proxyMiddleware(req, res, next); &#125; else &#123; next(); &#125; &#125;); &#125;); &#125; &#125;&#125;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"proxy","slug":"proxy","permalink":"http://xzfyu.com/tags/proxy/"}]},{"title":"适配器模式","slug":"计算机科学/设计模式/适配器模式","date":"2018-11-10T16:00:00.000Z","updated":"2020-03-08T11:07:21.538Z","comments":true,"path":"2018/11/11/计算机科学/设计模式/适配器模式/","link":"","permalink":"http://xzfyu.com/2018/11/11/计算机科学/设计模式/适配器模式/","excerpt":"","text":"","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"设计模式","slug":"计算机科学/设计模式","permalink":"http://xzfyu.com/categories/计算机科学/设计模式/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"}]},{"title":"node-http-proxy 源码解读","slug":"frontend/工程化/node-http-proxy源码解读","date":"2018-11-08T16:00:00.000Z","updated":"2020-03-08T10:57:58.877Z","comments":true,"path":"2018/11/09/frontend/工程化/node-http-proxy源码解读/","link":"","permalink":"http://xzfyu.com/2018/11/09/frontend/工程化/node-http-proxy源码解读/","excerpt":"","text":"概述node-http-proxy 模块用于转发 http 请求，其实现的大致原理为使用 http 或 https 模块搭建 node 代理服务器，将客户端发送的请求数据转发到目标服务器，再将响应输送到客户端。 实现整体流程同 koa 的中间件机制相仿，node-http-proxy 模块内部组装任务队列，在请求转发的过程中，将任务队列中的处理函数逐个执行。处理函数的意义通常是封装消息头，当然，最后一个处理函数用于转发请求、输出响应。 同常见的 ajax 模块，node-http-proxy 模块接受全局配置的 options，同时，在某个具体的请求中，又接受特定的配置项 opts。而客户端发送的请求可能是 http, https 请求，也可能是 websocket 请求，node-http-proxy 模块必须实现对这两类请求的不同处理。 上述三点，实际的代码体现在 createRightProxy 高阶函数中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 参数 type 用于区分请求类型，'web' 为普通 http, https 请求，'ws' 为 websocket 请求function createRightProxy(type) &#123; // 参数 options 为全局配置项 return function(options) &#123; return function(req, res /*, [head], [opts] */) &#123; // passes 任务队列 var passes = (type === 'ws') ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl; // 解析回调函数 if(typeof args[cntr] === 'function') &#123; cbl = args[cntr]; cntr--; &#125; // 混入该请求中特定的配置项 opts var requestOptions = options; if( !(args[cntr] instanceof Buffer) &amp;&amp; args[cntr] !== res ) &#123; requestOptions = extend(&#123;&#125;, options); extend(requestOptions, args[cntr]); cntr--; &#125; // head if(args[cntr] instanceof Buffer) &#123; head = args[cntr]; &#125; // 请求的目标地址 ['target', 'forward'].forEach(function(e) &#123; if (typeof requestOptions[e] === 'string') requestOptions[e] = parse_url(requestOptions[e]); &#125;); if (!requestOptions.target &amp;&amp; !requestOptions.forward) &#123; return this.emit('error', new Error('Must provide a proper URL as target')); &#125; // 挨个执行任务队列，处理消息头，转发请求 for(var i=0; i &lt; passes.length; i++) &#123; if(passes[i](req, res, requestOptions, head, this, cbl)) &#123; break; &#125; &#125; &#125;; &#125;;&#125; 因此，createRightProxy(‘web’)(options), createRightProxy(‘ws’)(options) 就能用于创建实际的请求转发函数。在 node-http-proxy 模块中，这两个函数分别表现为 ProxyServer 实例的 web, ws 方法。其中，proxyServer.web 方法作为 http 或 https 服务器 listen 方法的回调函数，proxyServer.ws 方法作为 ‘upgrade’ 事件的绑定函数，从而能对接上客户端 ajax 请求、websocket 请求的执行时机。 1234567891011121314151617181920212223242526272829303132333435function ProxyServer(options) &#123; // ... // 创建转发 http, https; websocket 请求的处理函数 this.web = this.proxyRequest = createRightProxy('web')(options); this.ws = this.proxyWebsocketRequest = createRightProxy('ws')(options); // 任务队列，用于处理消息头、转发请求 this.webPasses = Object.keys(web).map(function(pass) &#123;// this.web 方法执行过程中调用的任务队列 return web[pass]; &#125;); this.wsPasses = Object.keys(ws).map(function(pass) &#123;// this.ws 方法执行过程中调用的任务队列 return ws[pass]; &#125;); // ...&#125;ProxyServer.prototype.listen = function(port, hostname) &#123; var self = this, closure = function(req, res) &#123; self.web(req, res); &#125;;// 转发 http, https 请求 this._server = this.options.ssl ? https.createServer(this.options.ssl, closure) : http.createServer(closure); // 转发 websocket 请求 if(this.options.ws) &#123; this._server.on('upgrade', function(req, socket, head) &#123; self.ws(req, socket, head); &#125;); &#125; this._server.listen(port, hostname); return this;&#125;; 以上不涉及任务队列的具体实现，却构成了 node-http-proxy 模块整体处理流程。除外而外，ProxyServer 还提供 before(type, passName, callback), after(type, passName, callback) 原型方法，用于在任务队列的某个具体处理函数之前或之后插入一个处理函数 callback。 http, https 请求this.webPasses 任务队列包含如下四种处理函数：deleteLength, timeout, XHeaders, stream。 deleteLength 函数：针对 DELETE 或 OPTIONS，且 headers[‘content-length’] 未设置的情形，将 headers[‘content-length’] 置为 0，并删除 headers[‘transfer-encoding’] 消息头。 timeout 函数：若设置了 options.timeout，调用 req.socket.setTimeout(options.timeout) 设置超时时间。 XHeaders 函数：设置 ‘x-forwarded-for’, ‘x-forwarded-port’, ‘x-forwarded-proto’, ‘x-forwarded-host’ 消息头，包含客户端和代理服务器的地址、端口、协议等内容（以 ‘,’ 拼接 req.headers 同名属性即客户端内容、和代理服务器内容）。其中，’x-forwarded-host’ 消息头只包含 req.headers.host，即代理服务器的主机名。由配置项 options.xfwd 启用 ‘x-forwarded-*’ 消息头的设置。 stream 函数：实际转发请求的处理函数。下文将作详解。 stream 函数的处理流程为： 调用 common.setupOutgoing 方法生成代理请求的配置项。 通过 options.forward, options.target 区分 ‘forward’ 和 ‘target’ 两种模式。在 ‘forward’ 模式下，只通过代理请求转发到目标服务器，输送给客户端的仍是代理服务器的响应。’target’ 模式下，不只可以处理目标服务器的响应，且可监听许多事件对代理请求等作出处理。’forward’ 和 ‘target’ 模式可以并行存在，即同时指定 options.forward, options.target。 首先，common.setupOutgoing 的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 生成代理请求的配置项，将作为 http.request 的参数 * @param &#123;object&#125; outgoing 即 options.ssl 或 &#123;&#125; * @param &#123;object&#125; options 即 options * @param &#123;object&#125; req 即实际的请求 * @param &#123;string|undefined&#125; forward 用于区分 'forward' 和 'target' 模式。值为 'forward' 或 undefined */common.setupOutgoing = function(outgoing, options, req, forward) &#123; outgoing.port = options[forward || 'target'].port || (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80); // http://nodejs.cn/api/http.html#http_http_request_options_callback // host, host: 目标服务器的域名或 IP 地址 // socketPath: Unix 域 Socket（使用 host:port 或 socketPath） // ca: ca 证书 ['host', 'hostname', 'socketPath', 'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach( function(e) &#123; outgoing[e] = options[forward || 'target'][e]; &#125; ); // 请求方法 outgoing.method = options.method || req.method; // 请求头 outgoing.headers = extend(&#123;&#125;, req.headers); if (options.headers)&#123; extend(outgoing.headers, options.headers); &#125; // 基本身份验证，如 'user:password' 用来计算 Authorization 请求头 if (options.auth) &#123; outgoing.auth = options.auth; &#125; if (options.ca) &#123; outgoing.ca = options.ca; &#125; if (isSSL.test(options[forward || 'target'].protocol)) &#123; outgoing.rejectUnauthorized = (typeof options.secure === \"undefined\") ? true : options.secure; &#125; // http://nodejs.cn/api/http.html#http_new_agent_options // 长连接时设置 options.agent = &#123; keepAlive, keepAliveMsecs &#125; outgoing.agent = options.agent || false; outgoing.localAddress = options.localAddress; // 不是长连接，设置 outgoing.headers.connection 请求头 if (!outgoing.agent) &#123; outgoing.headers = outgoing.headers || &#123;&#125;; if (typeof outgoing.headers.connection !== 'string' || !upgradeHeader.test(outgoing.headers.connection) ) &#123; outgoing.headers.connection = 'close'; &#125; &#125; // 最终的请求路径由 options['forward'|'target'], req.url 拼接产生，可根据 options 配置设定某项是否启用 var target = options[forward || 'target']; var targetPath = target &amp;&amp; options.prependPath !== false ? (target.path || '') : ''; var outgoingPath = !options.toProxy ? (url.parse(req.url).path || '') : req.url; outgoingPath = !options.ignorePath ? outgoingPath : ''; outgoing.path = common.urlJoin(targetPath, outgoingPath); if (options.changeOrigin) &#123; outgoing.headers.host = // 通过 requires-port 模块校验在使用某种协议的情况下，是否需要在 url 上拼接端口号 required(outgoing.port, options[forward || 'target'].protocol) &amp;&amp; !hasPort(outgoing.host) ? outgoing.host + ':' + outgoing.port : outgoing.host; &#125; return outgoing;&#125;; 其次，stream 的实现如下： 调用 [http|https].request(outgoing) 创建代理请求。outgoing 由 common.setupOutgoing 函数获得。 调用 (options.buffer || req).pipe(forwardReq) 方法转发代理请求。 target 模式下，调用 web-outgoing 模块中的函数处理代理响应。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990function stream(req, res, options, _, server, clb) &#123; server.emit('start', req, res, options.target || options.forward); // options.followRedirects 是否使用 follow-redirects 重定向 var agents = options.followRedirects ? followRedirects : nativeAgents; var http = agents.http; var https = agents.https; if(options.forward) &#123; // 生成代理请求 var forwardReq = (options.forward.protocol === 'https:' ? https : http).request( common.setupOutgoing(options.ssl || &#123;&#125;, options, req, 'forward') ); var forwardError = createErrorHandler(forwardReq, options.forward); req.on('error', forwardError); forwardReq.on('error', forwardError); // 转发代理请求 (options.buffer || req).pipe(forwardReq); // 非 target 模式，返回响应 if(!options.target) &#123; return res.end(); &#125; &#125; // 生成代理请求 var proxyReq = (options.target.protocol === 'https:' ? https : http).request( common.setupOutgoing(options.ssl || &#123;&#125;, options, req) ); proxyReq.on('socket', function(socket) &#123; if(server) &#123; server.emit('proxyReq', proxyReq, req, res, options); &#125; &#125;); if(options.proxyTimeout) &#123; proxyReq.setTimeout(options.proxyTimeout, function() &#123; proxyReq.abort(); &#125;); &#125; req.on('aborted', function () &#123; proxyReq.abort(); &#125;); var proxyError = createErrorHandler(proxyReq, options.target); req.on('error', proxyError); proxyReq.on('error', proxyError); function createErrorHandler(proxyReq, url) &#123; return function proxyError(err) &#123; if (req.socket.destroyed &amp;&amp; err.code === 'ECONNRESET') &#123; server.emit('econnreset', err, req, res, url); return proxyReq.abort(); &#125; if (clb) &#123; clb(err, req, res, url); &#125; else &#123; server.emit('error', err, req, res, url); &#125; &#125; &#125; // 转发代理请求 (options.buffer || req).pipe(proxyReq); proxyReq.on('response', function(proxyRes) &#123; if(server) &#123; server.emit('proxyRes', proxyRes, req, res); &#125; // 调用 web-outgoing 模块中的函数处理代理响应 if(!res.headersSent &amp;&amp; !options.selfHandleResponse) &#123; for(var i=0; i &lt; web_o.length; i++) &#123; if(web_o[i](req, res, proxyRes, options)) &#123; break; &#125; &#125; &#125; // http://nodejs.cn/api/http.html#http_response_finished if (!res.finished) &#123; // 通过事件处理代理响应 proxyRes.on('end', function () &#123; if (server) server.emit('end', req, res, proxyRes); &#125;); // 由 node-http-proxy 模块处理代理响应的情境下，返回响应 if (!options.selfHandleResponse) proxyRes.pipe(res); &#125; else &#123; if (server) server.emit('end', req, res, proxyRes); &#125; &#125;);&#125; 最后，再来看一下 web-outgoing 模块对代理响应的处理（实现查看源码）： removeChunked 函数：当使用 http/1.0 时（通过 req.httpVersion === ‘1.0’ 判断，客户端决定），移除代理响应的 headers[‘transfer-encoding’]。 setConnection 函数：当使用 http/1.0 时，代理响应的 headers.connection 设为 req.headers.connection || ‘close’；当使用非 http/2.0 时，且 proxyRes.headers.connection 为否，将 代理响应的 headers.connection 设为 req.headers.connection || ‘keep-alive’。 setRedirectHostRewrite 函数：根据 options.hostRewrite 或 options.autoRewrite 或 options.protocolRewrite 重写重定向地址 proxyRes.headers.location。代理相应的状态码须匹配 /^201|30(1|2|7|8)$/ 正则，且 proxyRes.headers.location 须与目标服务器同域名。 writeHeaders 函数：将代理响应的消息头写入实际响应 res 的消息头中。下文将作详解。 writeStatusCode 函数：将代理响应的 statusCode, statusMessage 写入返回给客户端的响应 res 中。 setRedirectHostRewrite 函数的代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function writeHeaders(req, res, proxyRes, options) &#123; var rewriteCookieDomainConfig = options.cookieDomainRewrite, rewriteCookiePathConfig = options.cookiePathRewrite, preserveHeaderKeyCase = options.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key, header) &#123; if (header == undefined) return; if (rewriteCookieDomainConfig &amp;&amp; key.toLowerCase() === 'set-cookie') &#123; header = common.rewriteCookieProperty(header, rewriteCookieDomainConfig, 'domain'); &#125; if (rewriteCookiePathConfig &amp;&amp; key.toLowerCase() === 'set-cookie') &#123; header = common.rewriteCookieProperty(header, rewriteCookiePathConfig, 'path'); &#125; res.setHeader(String(key).trim(), header); &#125;; if (typeof rewriteCookieDomainConfig === 'string') &#123; //also test for '' rewriteCookieDomainConfig = &#123; '*': rewriteCookieDomainConfig &#125;; &#125; if (typeof rewriteCookiePathConfig === 'string') &#123; //also test for '' rewriteCookiePathConfig = &#123; '*': rewriteCookiePathConfig &#125;; &#125; // http://nodejs.cn/api/http.html#http_message_rawheaders if (preserveHeaderKeyCase &amp;&amp; proxyRes.rawHeaders != undefined) &#123; rawHeaderKeyMap = &#123;&#125;; for (var i = 0; i &lt; proxyRes.rawHeaders.length; i += 2) &#123; var key = proxyRes.rawHeaders[i]; rawHeaderKeyMap[key.toLowerCase()] = key; &#125; &#125; Object.keys(proxyRes.headers).forEach(function(key) &#123; var header = proxyRes.headers[key]; if (preserveHeaderKeyCase &amp;&amp; rawHeaderKeyMap) &#123; key = rawHeaderKeyMap[key] || key; &#125; setHeader(key, header); &#125;);&#125;// 根据 options.cookieDomainRewrite, options.cookiePathRewrite 重写 res.headers.cookie 中的 domain, path 属性// cookie.domain 表示 cookie 所在的域// cookie.path 表示 cookie 所在的目录// 参考 [理解cookie的path和domain属性](https://www.cnblogs.com/chris-oil/p/3869803.html)common.rewriteCookieProperty = function rewriteCookieProperty(header, config, property) &#123; if (Array.isArray(header)) &#123; return header.map(function (headerElement) &#123; return rewriteCookieProperty(headerElement, config, property); &#125;); &#125; return header.replace(new RegExp(\"(;\\\\s*\" + property + \"=)([^;]+)\", 'i'), function(match, prefix, previousValue) &#123; var newValue; if (previousValue in config) &#123; newValue = config[previousValue]; &#125; else if ('*' in config) &#123; newValue = config['*']; &#125; else &#123; return match; &#125; if (newValue) &#123; return prefix + newValue; &#125; else &#123; return ''; &#125; &#125;);&#125;; websocket 请求this.wsPasses 任务队列包含如下四种处理函数：checkMethodAndHeader, XHeaders, stream。 checkMethodAndHeader 函数：websocket 请求的请求方式必须是 get，且 headers.upgrade 请求头必须是 ‘websocket’，checkMethodAndHeader 函数用于校验请求方式和 headers.upgrade 请求头。 XHeaders 函数：设置 ‘x-forwarded-for’, ‘x-forwarded-port’, ‘x-forwarded-proto’ 消息头，包含客户端和代理服务器的地址、端口、协议等内容（以 ‘,’ 拼接 req.headers 同名属性即客户端内容、和代理服务器内容）。由配置项 options.xfwd 启用 ‘x-forwarded-*’ 消息头的设置。 stream 函数：实际转发请求的处理函数。下文将作详解。 stream 函数的处理流程为： 调用 common.setupOutgoing 方法生成代理请求的配置项。 调用 [http|https].request(outgoing) 创建代理请求 proxyReq。 调用 proxyReq.end 发送代理请求。 监听 response 事件，修改消息头后将响应发送给客户端。 监听 upgrade 事件，更换协议后，调用 proxySocket.pipe(socket).pipe(proxySocket) 再次发送代理请求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081common.setupSocket = function(socket) &#123; socket.setTimeout(0); socket.setNoDelay(true); socket.setKeepAlive(true, 0); return socket;&#125;;function stream(req, socket, options, head, server, clb) &#123; // 添加请求头内容 var createHttpHeader = function(line, headers) &#123; return Object.keys(headers).reduce(function (head, key) &#123; var value = headers[key]; if (!Array.isArray(value)) &#123; head.push(key + ': ' + value); return head; &#125; for (var i = 0; i &lt; value.length; i++) &#123; head.push(key + ': ' + value[i]); &#125; return head; &#125;, [line]) .join('\\r\\n') + '\\r\\n\\r\\n'; &#125; common.setupSocket(socket); if (head &amp;&amp; head.length) socket.unshift(head); // 创建代理请求 var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request( common.setupOutgoing(options.ssl || &#123;&#125;, options, req) ); if (server) &#123; server.emit('proxyReqWs', proxyReq, req, socket, options, head); &#125; proxyReq.on('error', onOutgoingError); proxyReq.on('response', function (res) &#123; // 属性响应到客户端 if (!res.upgrade) &#123; socket.write(createHttpHeader('HTTP/' + res.httpVersion + ' ' + res.statusCode + ' ' + res.statusMessage, res.headers)); res.pipe(socket); &#125; &#125;); proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) &#123; proxySocket.on('error', onOutgoingError); proxySocket.on('end', function () &#123; server.emit('close', proxyRes, proxySocket, proxyHead); &#125;); socket.on('error', function () &#123; proxySocket.end(); &#125;); common.setupSocket(proxySocket); if (proxyHead &amp;&amp; proxyHead.length) proxySocket.unshift(proxyHead); socket.write(createHttpHeader('HTTP/1.1 101 Switching Protocols', proxyRes.headers)); proxySocket.pipe(socket).pipe(proxySocket);// 再次发送代理请求？ server.emit('open', proxySocket); server.emit('proxySocket', proxySocket); &#125;); return proxyReq.end(); // 发送代理请求 function onOutgoingError(err) &#123; if (clb) &#123; clb(err, req, socket); &#125; else &#123; server.emit('error', err, req, socket); &#125; socket.end(); &#125;&#125; 应用http-proxy-middleware参见 http-proxy-middleware 源码解读。 nokit-filter-proxynokit-filter-proxy 库用于为 nokit 服务器添加代理功能。鉴于前端构建工具 dawn 使用 nokit 搭建本地调试服务器，nokit-filter-proxy 库也用于为 dn-middleware-server 中间件实现代理功能。 同 http-proxy-middleware 库，nokit-filter-proxy 借助 node-http-proxy 实现服务器代理的都是先校验请求路径是否匹配转发策略，拦截并转发请求。nokit-filter-proxy 通过绑定 onRequest 事件函数，实现请求的拦截和转发。详见源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var httpProxy = require(\"http-proxy\");function ProxyFilter(server) &#123; var self = this; var utils = self.utils = server.require(\"$./core/utils\"); // proxy 配置，作为请求路径转发规则 self.configs = server.configs.proxy || &#123;&#125;; // 作为代理服务器的配置项 self.configs.options = self.configs.options || &#123;&#125;; // 代理请求设置 'x-forwarded-for', 'x-forwarded-port', 'x-forwarded-proto', 'x-forwarded-host' 消息头 if (utils.isNull(self.configs.options.xfwd)) &#123; self.configs.options.xfwd = true; &#125; // 代理请求设置 headers.host 消息头 if (utils.isNull(self.configs.options.changeOrigin)) &#123; self.configs.options.changeOrigin = true; &#125; // 请求路径转发规则，key - value 形式，key 为客户端请求路径正则，value 为目标服务器路径 self.configs.rules = self.configs.rules || &#123;&#125;; // 创建代理服务器 self.proxy = httpProxy.createProxyServer(self.configs.options); // 转发代理请求前，使用 headers 配置修改代理请求的消息头 self.onProxyReqHandler = self.onProxyReqHandler.bind(self); self.proxy.on(\"proxyReq\", self.onProxyReqHandler);&#125;;ProxyFilter.prototype.onProxyReqHandler = function(proxyReq, req, res, options) &#123; var self = this; if (!self.configs.headers) return; self.utils.each(self.configs.headers, function(name, value) &#123; proxyReq.setHeader(name, value); &#125;);&#125;;// self.matchRule 根据 rules 配置，解析出请求路径转发规则ProxyFilter.prototype.matchRule = function(url) &#123; var self = this; var rule = null; self.utils.each(self.configs.rules, function(exprText, target) &#123; var expr = new RegExp(exprText); if (expr.test(url)) &#123; var urlParts = expr.exec(url); rule = &#123; url: urlParts.length &gt; 1 ? urlParts[1] : url, target: target &#125;; &#125; &#125;); return rule;&#125;;ProxyFilter.prototype.onRequest = function(context, next) &#123; var self = this; var res = context.res, req = context.req; var rule = self.matchRule(req.url); if (!rule) return next(); req.url = rule.url || \"/\"; // 转发代理请求 self.proxy.web(req, res, &#123; \"target\": rule.target &#125;);&#125;; 后记这两篇文章都是在笔者整理完 proxy 设计模式后整理的。鉴于本人水平有限，文章难免错谬，仍望读者不吝赐教。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"proxy","slug":"proxy","permalink":"http://xzfyu.com/tags/proxy/"}]},{"title":"代理模式","slug":"计算机科学/设计模式/代理模式","date":"2018-11-05T16:00:00.000Z","updated":"2020-03-08T11:28:35.209Z","comments":true,"path":"2018/11/06/计算机科学/设计模式/代理模式/","link":"","permalink":"http://xzfyu.com/2018/11/06/计算机科学/设计模式/代理模式/","excerpt":"","text":"概述代理模式(proxy pattern) 的主要处理逻辑为，构建代理对象以桥接对实际对象的访问。因此，可以在访问过程中构建附加的间接性操作如请求处理、权限校验、内务处理(housekeeping task)等，也可以为多种实际对象提供统一的接口。 《设计模式:可复用面向对象软件的基础》中的说法是： Provide a surrogate or placeholder for another object to control access to it. 维基百科的说法是： A proxy, in its most general form, is a class functioning as an interface to something else. A proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked. 使用代理模式的场景： 远程代理(remote proxy): 为一个远程服务对象提供本地表现，通过本地方法调用远程服务。 虚代理(virtual proxy): 在代理中延迟创建一个开销很大的对象。如在图片代理对象的实现过程中，draw 方法执行前才创建实际所需的图片对象。 保护代理(protection proxy): 访问对象前执行权限校验。 智能指引(smart reference): 访问实际的对象时执行附加操作，如对引用计数，当没被引用时，释放内存；首次引用时，将持久对象装入内存等。 结构 Proxy: 以引用形式持有实体，接口与 Subject 相同，以便于使用代理对象替代实体，并控制对实体的访问。必要时，可以在代理对象中创建或删除实体。 remote proxy 负责对请求及其参数进行编码，并向远程服务器发送请求。 virtual proxy 负责缓存实体的附加信息，以便延迟创建实体。 protection proxy 负责校验请求是否有特定的访问权限。 Subject 定义 RealSubject, Proxy 的公共接口，因此在需要使用 RealSubject 的场景中都可以使用 Proxy 代替。 RealSubject 定义 Proxy 所代表的实体。 经典实现使用代理模式为多种类型的字段提供统一的接口，在 FieldProxy 实例 setValue 方法执行过程中，我们也能添加诸如数据校验等处理函数。这里只展示代理模式实现的一种方式，而不推敲代理模式在字段处理上的意义。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Field &#123; type;// 字段类型 name;// 字段 code title;// 字段名 required;// 字段是否必填 value;// 字段的值 constructor(props)&#123; const &#123; name, title, required &#125; = props; this.name = name; this.title = title; this.required = required; &#125; setValue(value)&#123; this.value = value; &#125;&#125;// inputclass Input extends Field &#123; type = 'input'; placeholder; maxLength; constructor(props)&#123; super(props); const &#123; placeholder, maxLength &#125; = props; this.placeholder = placeholder; this.maxLength = maxLength; &#125;&#125;// textareaclass Textarea extends Field &#123; type = 'textarea'; placeholder; maxLength; constructor(props)&#123; super(props); const &#123; placeholder, maxLength &#125; = props; this.placeholder = placeholder; this.maxLength = maxLength; &#125;&#125;// radioclass Radio extends Field &#123; type = 'radio'; options; constructor(props)&#123; super(props); const &#123; options &#125; = props; this.options = options; &#125;&#125;// checkboxclass Checkbox extends Field &#123; type = 'checkbox'; options; constructor(props)&#123; super(props); const &#123; options &#125; = props; this.options = options; &#125;&#125;// selectclass Select extends Field &#123; type = 'select'; placeholder; options; constructor(props)&#123; super(props); const &#123; options &#125; = props; this.placeholder = placeholder; this.options = options; &#125;&#125;const Fields = &#123; 'input': Input, 'textarea': Textarea, 'radio': Radio, 'checkbox': Checkbox, 'select': Select,&#125;class FieldProxy &#123; field; constructor(props)&#123; const &#123; type, ...others &#125; = props; this.field = new Fields[type](others); &#125; setValue(value)&#123; this.field.setValue(value); &#125;&#125; js中的代理模式图片缓存图片缓存的目的是在远程图片加载的时延过程中，预先以本地图片或占位符代替；在远程图片加载完成之后，再使用 img 节点展示实际的图片。 备注：RealSubject 和 Proxy 使用相同的接口这种情况，在 js 中，可以在自调用匿名函数实现，实例属性可使用闭包缓存。 123456789101112131415161718192021222324252627// 实际加载图片const loadImage = (function()&#123; let imgNode = document.createElement('img'); document.body.appendChild(imgNode); return function(src)&#123; imgNode.src = src; &#125;;&#125;)();const handler = &#123; apply: function(target, thisBinding, args) &#123; const src = args[0]; let img = new Image; img.src = src; img.onLoad = function()&#123; target(src); &#125;; target('local_image.gif'); &#125;&#125;;// 代理加载图片const loadImageProxy = new Proxy(loadImage, handler);loadImageProxy('remote_image.png'); 惰性加载跟代理图片类似，加载 js 脚本也会有一定的时延，这就会造成使用某个类库前，js 脚本还未加载完成，所使用的方法也是 undefined。这时，可使用虚拟代理模拟类库，缓存执行方法，等到 js 脚本加载完成之后，再使用缓存执行实际的方法。 曾探在《Javascript 设计模式与开发实践》一书中，以 minConsole 类库为例，按下 F2 键加载所需的 js 脚本，在此之前，使用代理。 1234567891011121314151617181920212223const miniConsole = (function()&#123; let cache = []; let handler = function(e)&#123; if ( e.keyCode === 113 )&#123; let script = document.createElement('script'); script.onLoad = function()&#123;// 加载完成后，执行缓存的待执行函数 cache.forEach(fn =&gt; fn()); &#125; script.src = 'miniConsole.js'; document.getElementByTagName('head')[0].appendChild(imgNode); document.body.removeEventListener('keydown', handler);// 单次加载 &#125;; &#125;; document.body.addEventListener('keydown', handler, false); // 代理对象，缓存待执行函数 return &#123; log(...args)&#123; cache.push(miniConsole.bind(miniConsole, ...args)); &#125; &#125;&#125;)() 合并http请求搜索组件每次改变值时都会调用远程接口，使用代理模式可延迟调用远程接口，以使交互请求不至频繁。 1234567891011121314151617181920212223function doSearch(content)&#123; get(content);&#125;let cache;let timer = null;const handler = &#123; apply: function(target, thisBinding, args) &#123; const content = args[0]; cache = content; if ( timer ) return; timer = setTimeout(function()&#123; doSearch(cache); cache = null; timer = null; &#125;) &#125;&#125;;const doSearchProxy = new Proxy(doSearch, handler); 缓存代理前端缓存代理包含：对于计算复杂的过程，在入参相同的情况下，可使用缓存的计算结果代替实际的执行计算；对于频繁的 ajax 调用，也可以使用缓存，避免远程调用。 12345678910111213141516let cache;function complexCompute(...args)&#123;&#125;;const handler = &#123; apply: function(target, thisBinding, args) &#123; const cacheKey = args.join(','); if ( cache[cacheKey] ) return cache[cacheKey]; const result = complexCompute(...args); cache[cacheKey] = result; return result; &#125;&#125;;const complexComputeProxy = new Proxy(complexCompute, handler); 参考[设计模式:可复用面向对象软件的基础][Javascript 设计模式和开发实践 - 曾探]java-design-patterns: proxy","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"设计模式","slug":"计算机科学/设计模式","permalink":"http://xzfyu.com/categories/计算机科学/设计模式/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"js设计模式","slug":"js设计模式","permalink":"http://xzfyu.com/tags/js设计模式/"}]},{"title":"antd-Form 组件","slug":"frontend/antd/Form","date":"2018-11-03T16:00:00.000Z","updated":"2020-03-08T10:28:14.672Z","comments":true,"path":"2018/11/04/frontend/antd/Form/","link":"","permalink":"http://xzfyu.com/2018/11/04/frontend/antd/Form/","excerpt":"","text":"ant design 中的 Form 组件基于 rc-form 实现。本文第一部分将介绍 rc-form 库；第二部分再介绍 ant design 中的 Form 组件。 rc-form常规收集表单数据并作校验，只需以 store 实时记录表单数据，校验后重绘表单。这样的思路以业务代码为例，就是，以数据模型 model 集成数据处理操作，再通过 setState 将 model 中的实时数据注入组件中，并驱动组件重绘（除了 setState 方法以外，也可以使用 forceUpdate 方法重绘组件，并在 render 阶段重新访问 model 中的实时数据）。从业务角度对数据及其操作进行建模，必然着眼于实际的业务场景，其类结构也会和数据表有千丝万缕的联系；而表单中的数据更具一般性特征，即能对应多个数据表，对其进行抽象也须从视图层入手。可以推想的是，抽象的表单数据模型必然包含字段名和字段的值构成的映射 valuesMap，字段名和校验结果构成的映射 errorsMap，以及字段名和校验状态构成的映射 validatingMap，这样才能绘制出表单中的字段项。 在 rc-form 中，上述数据模型的具体实现为 FieldsStore 类。如前所述，FieldsStore 实例与视图层的交互逻辑为，在用户行为驱动字段项的数据改变时，即时存储表单数据及校验文案，继而调用表单组件实例的 forceUpdate 方法强制重绘；在绘制过程中，再从 FieldsStore 实例读取实时的表单数据、校验文案及校验状态。建模方面，FieldsStore 实例以 fields 属性存储表单的实时数据，其结构为键值对形式 { [name]: { value, errors, validating, dirty, touched } } 。其中，name 为字段名；value 为字段的值；errors 为校验结果；validating 为校验状态；dirty 为脏值标识（当字段的值已作变更、但未作校验时，那么脏值标识就为 true；已作校验则置为 false）；touched 为更新标识，即用户行为触发时，字段值已作收集标识，收集的值通常是更新后的值 （若 FieldsStore 实例在 onChange 发生时收集数据，touched 标识也意味着数据已作变更。当然，如果此时用户再将数据更新为初始值，touched 标识将依旧为 true，并不能反映表单数据的更新状态。但是在一般情况下，可以根据 touched 标识判断表单数据是否有过更改）。 除了实时更新的数据外，驱动校验需要校验规则 validateRules、触发事件 validateTrigger；字段的初始值 initialValue（当字段的值还没存入 fields 中时，以初始值替代）；从 event 对象获取字段的值，也跟 dom 节点的类型相关，如 input, radio, checkbox 类型，可以借助 getValueFromEvent 函数从 event 对象获取的字段的值；注入字段组件的值需要作特殊的数据转换，其一 radio 原生组件通过 props.checked 接受字段的实时值，其二对于自定义组件，不只接受实时值的 props 属性是特殊的，收集的数据和注入组件中的数据也会存在结果差异，这可以借助 getValueProps 函数作转换操作；在某些场合下，收集的表单数据需要经过特殊转换（使用案例：全选按钮），这可以借助 normalize 函数实现。FieldsStore 实例使用 fieldsMeta 属性存储这些元数据，其结构为 { [name]: { validate, initialValue, getValueFromEvent, valuePropName, getValueProps, normalize } }。其中，validate 包含 validateRules, validateTrigger。 与业务实体不同的是，FieldsStore 实例仅止于存储字段的表单数据和元数据，提供一些便捷的访问器操作，却没有包含数据校验等操作，也没有关联上表单及字段组件。对于用户自定义表单组件，需要提供获取、更新及校验表单数据的方法，以便组织与远程接口密切相关的交互逻辑。对于字段组件，校验规则等与指定字段强关联的配置项适合在使用字段组件时通过 props 注入；同时，在字段组件的值发生变更时，需要收集该字段的值及启动对该字段的校验，因此需要将特定的绑定函数添加到 props 中。这些字段元数据写入 FieldsStore 就适合在绘制字段组件的过程中实现，因此就需要特定的方法用于装饰字段组件或其 props 属性。在 rc-form 中，BaseForm 用于实现这部分功能。 想要为用户自定义组件注入工具函数，可以使用 HOC 高阶组件将工具函数配置为自定义子组件的 props 形式实现。BaseForm 就是这样的高阶组件。在 BaseForm 的 render 阶段，将为用户自定义组件注入 props.form 操纵表单的工具函数集。工具函数集中包含 getFieldValue, getFieldsValue, getFieldError, getFieldsError, isFieldsValidating, isFieldValidating, isFieldTouched, isFieldsTouched 方法用于获取字段的值、校验文案、校验状态、是否更新标识等；setFieldsInitialValue 方法用于设置字段的初始值；setFieldsValue 方法用于设置字段的值；setFields 方法用于设置表单的实时数据，包含字段的值及校验文案等；resetFields 方法用于重置表单；validateFields 方法用于校验表单；getFieldProps 方法用于转换传入字段组件的 props 数据（包含特定的绑定函数），并收集字段组件的元数据；getFieldDecorator 方法基于 getFieldProps 方法，不同于 getFieldProps 方法用于装饰字段组件的 props，getFieldDecorator 用于直接装饰字段组件，这样就可以直接获取并封装传入字段组件实例的 props.onChange 等属性或方法；getFieldInstance 方法用于获取字段实例。 关于校验文案和校验状态的绘制，参见本文的第二部分。 以时序图的方式表达 rc-form 的工作流程为： rc-form 的类图结构为： FieldsStore如上文所述，FieldsStore 基本用作表单字段元数据和实时数据的存储器。此外，rc-form 支持以嵌套结构定义字段名，即使用 ‘.’, ‘[|]’ 作为分割符，如 ‘a.b’ 意味着 a 对象下的 b 属性；’c[0]’ 意味着 c 数组的首项。这一机制借助于 lodash 类库的 set, get 方法和内置的 flattenFields 函数实现的。并且，FieldsStore 提供 isValidNestedFieldName 方法用于校验表单中的字段名不能作为其他字段名的成员。 flattenFields(maybeNestedFields, isLeafNode, errorMessage) 函数用于将嵌套数据扁平化，如将 { a: { b: 1 } } 转化成 { ‘a.b’: 1 }。参数 maybeNestedFields 即嵌套数据；参数 isLeafNode 用于校验扁平化后的数据成员的合理性；参数 errorMessage 校验不合理时的警告文案。其实现如： 1234567891011121314151617181920212223242526272829303132333435363738function treeTraverse(path = '', tree, isLeafNode, errorMessage, callback) &#123; if (isLeafNode(path, tree)) &#123; callback(path, tree); &#125; else if (tree === undefined || tree === null) &#123; // Do nothing &#125; else if (Array.isArray(tree)) &#123; tree.forEach((subTree, index) =&gt; treeTraverse( `$&#123;path&#125;[$&#123;index&#125;]`, subTree, isLeafNode, errorMessage, callback )); &#125; else &#123; // It's object and not a leaf node if (typeof tree !== 'object') &#123; warning(false, errorMessage); return; &#125; Object.keys(tree).forEach(subTreeKey =&gt; &#123; const subTree = tree[subTreeKey]; treeTraverse( `$&#123;path&#125;$&#123;path ? '.' : ''&#125;$&#123;subTreeKey&#125;`, subTree, isLeafNode, errorMessage, callback ); &#125;); &#125;&#125;function flattenFields(maybeNestedFields, isLeafNode, errorMessage) &#123; const fields = &#123;&#125;; treeTraverse(undefined, maybeNestedFields, isLeafNode, errorMessage, (path, node) =&gt; &#123; fields[path] = node; &#125;); return fields;&#125; 元数据以 this.fieldsMeta = { [name]: { validate, hidden, getValueFromEvent, initialValue, valuePropName, getValueProps, normalize } } 形式存储（name 为字段名，下同）。以下是字段元数据中各属性的意义。 validate 校验规则和触发事件，[{ rules, trigger }] 形式。 hidden 设置为 true 时，getFieldsValue, getFieldsError 等方法将无法获取该字段的数据及校验信息等实时数据。本文假设设置了 hidden 为 true 的字段为虚拟隐藏项。 getValueFromEvent(event) 用于从 event 对象中获取字段的值。 initialValue 字段的初始值。 valuePropName 约定字段的值以何种 props 属性注入字段组件中。 getValueProps(value) 用于转化字段的值，输出 props 以注入字段组件中。 normalize(newValue, oldValue, values) 用于转换存入 FieldsStore 实例的字段值。 实时数据以 this.fields = { [name]: { value, errors, validating, dirty, touched } } 形式存储。以下是字段实时数据中各属性的意义。 value 字段的值。 errors 校验文案，数组形式。 validating 校验状态。 dirty 脏值标识。真值时意味着字段数据已作变更，但未作校验。 touched 更新标识。真值时意味着用户行为已促使字段数据发生了变更。 对于元数据，rc-form 实现的访问器机制极为简单，即通过 setFieldMeta(name, meta) 赋值或更新某个字段的元数据，通过 getFieldMeta(name) 获取某个字段的元数据。辅助方法 getAllFieldsName 用于获取 this.feildsMeta 中所有字段名列表。同时，元数据是在字段组件渲染阶段创建的，其存在与否也意味字段组件是否呈现在视图中。实例方法 flattenRegisteredFields(fields) 即基于此实现，既校验与参数 fields 数据的字段组件是否已渲染，又将 fields 数据扁平化。特别的，setFieldsInitialValue(initialValues) 实例方法首先将参数 initialValues 注入为 flattenRegisteredFields 方法的参数以校验相关的字段组件是否以渲染，再将初始值写入 feildsMeta 属性中。因此，针对元数据的操作包含 setFieldMeta, getFieldMeta, setFieldsInitialValue 以及下文的 clearField 四种。 对于实时数据，rc-form 实现的访问器机制较为复杂。其一，未经用户操作字段组件或开发者显示调用 setFields 赋值表单数据，字段的实时数据将不存在 fields 属性中（下文将这些字段称为未收集字段）；其二，既需要支持全量更新表单的实时数据，又需要支持部分更新表单的实时数据；其三，字段中的实时数据成员需要单独获取。以上第一条，使得 FieldsStore 并不存在 getFields 方法，而是先通过 getNotCollectedFields 方法获取未收集字段的初始值，再构建 getNestedAllFields 方法遍历 fields 中的字段以获取到收集到的实时数据；第二条，FieldsStore 提供 updateFields(fields) 方法用于全量更新实时数据，setFields(fields) 用于部分更新实时数据；第三条，使 FieldsStore 在 getField(name) 获取字段的实时数据以外，还提供 getFieldMember(name, member) 用于获取实时数据的成员，并以此构建了 isFieldValidating, isFieldTouched 方法，用于获取字段的校验状态和更新状态。 当然，表单除了更新数据和单字段实时数据获取以外，还有对实时数据如表单数据、校验信息和校验状态的全量获取。为此，FieldsStore 先行提供了辅助函数。其中，getAllFieldsName 基于 fieldsMeta 元数据，获取表单的全量字段名；getValidFieldsName 方法用于获取剔除虚拟隐藏项后的字段名列表；getValidFieldsFullName(maybePartialName) 方法基于 getValidFieldsName，所有以 maybePartialName 起始或等值的字段名列表，但不包含虚拟隐藏项。在此基础上，getNestedField(name, getter) 方法将获取所有以 name 起始或等值的字段名列表，并使用 reduce 方法加以遍历，通过 getter(name) 函数如 getFieldError 等实例方法，以获取字段数据或校验信息。不同于 getNestedField 先使用 getValidFieldsFullName 方法获取匹配的字段名列表，getNestedFields(names, getter) 则直接使用 reduce 遍历参数 names 或剔除虚拟隐藏项后的字段名列表，以获取字段数据或校验信息。 由于字段值的特殊性，即当实时数据尚未存入 fields 时，须以 fieldsMeta 中的初始值代替。因此，FieldsStore 提供了 getValueFromFields(name, fields) 用于从参数 fields 中的实时值或 fieldsMeta 元数据中的初始值。 有了这些辅助函数，FieldsStore 才得以实现： getFieldValue(name) 用于获取匹配字段的值（匹配字段指以 name 起始或与 name 等值的字段，下同）。 getFieldError(name) 用于获取匹配字段的校验信息。 isFieldValidating(name) 用于获取匹配字段的校验状态。 isFieldTouched(name) 用于获取匹配字段的更新标识。 getFieldsValue(names) 用于获取指定字段或表单的全量值数据，但不包含虚拟隐藏项； getFieldsError(names) 用于获取指定字段或表单的全量校验信息，但不包含虚拟隐藏项。 isFieldsValidating(names) 用于获取指定字段或表单的全量校验状态，但不包含虚拟隐藏项。 isFieldsTouched(names) 用于获取指定字段或表单的全量更新标识，但不包含虚拟隐藏项。 除此以外，FieldsStore 中与 BaseForm 交互相关的方法还包含： getFieldValuePropValue(fieldMeta) 基于参数 fieldMeta 获取注入字段组件的 props 属性。该 props 属性为字段的值内容，可经由 fieldMeta.valuePropName, fieldMeta.getValueProps(value) 处理，通过 BaseForm 实例的 getFieldProps 方法注入字段组件。 getAllValues 根据 fieldsMeta 属性获取表单的全量数据，包含虚拟隐藏项。 setFieldsInitialValue 见上文，设置字段的初始值。 updateFields(fields) 见上文，全量更新表单的实时数据。 setFields(fields) 见上文，部分更新表单的实时数据。 resetFields(ns) 方法只输出匹配字段或全部字段的空值（这些字段的实时数据均已收集），本身并不改变 fields 存储的数据。 clearField(name) 用于清除字段的元数据和实时数据。 BaseForm如上文所说，BaseForm 作为自定义组件的外层容器，它用于为字段组件绑定数据收集和校验的方法，以更新 FieldsStore 实例存储的实时数据，同时将操作表单的工具函数集通过 props 注入到用户自定义表单中。其实现为： 首先，通过 createBaseForm(option, mixins) 创建装饰函数。装饰函数可以为用户自定义表单组件包裹上 HOC 容器，即 BaseForm 组件。参数 option 能为 HOC 组件提供 validateMessages, onFieldsChange, onValuesChange, mapProps, mapPropsToFields, fieldNameProp, fieldMetaProp, fieldDataProp, formPropName, name 配置项，参数 mixins 为混入 HOC 组件的实例方法。 validateMessages 用于更改 async-validator 库的配置文案。 onFieldsChange(props, changedFields, oldFields) 当 BaseForm 组件实例的 setFields 方法执行时被调用，包含用户行为促使数据收集或校验时，开发者显式调用 setFields, setFieldsValue, resetFields 时，BaseForm 机制 saveRef 方法执行阶段恢复实时数据时（见下文）。 onValuesChange(props, changedValues, oldValues) 当用户行为触发表单数据收集或校验时（在 onFieldsChange 方法前执行），或开发者显示调用 setFieldsValue 方法时（在 onFieldsChange 方法后执行），都将调用 onValuesChange 函数。 mapProps({ [formPropName] }, restProps) 用于修改注入自定义表单组件的 props。{ [formPropName] } 即 BaseForm 组件实例注入用户自定义组件的表单操作函数集；执行上下文为 BaseForm 组件实例。 mapPropsToFields(props) 将 BaseForm 组件实例获得的 props 转化为 FieldsStore 构造器的参数 fields，通常用于将状态管理器中的 store 数据转换为表单所需的 fields。 fieldNameProp 作为字段组件接受字段名的 props 属性名，其值默认为字段名或表单名加字段名的形式，因此可以通过访问字段组件实例的 props 获取到字段名。 fieldMetaProp 作为字段组件接受元数据的 props 属性名，因此可以通过访问字段组件实例的 props 获取到该字段的元数据。 fieldDataProp 作为字段组件接受实时数据的 props 属性名，因此可以通过访问字段组件实例的 props 获取到该字段的实时数据。 formPropName 作为自定义表单组件接受表单操作函数集的 props 属性名，默认为 ‘form’。 name 表单名。 其次，在 BaseForm 组件实例的 getInitialState 阶段，将调用 option.mapPropsToFields 以获得初始 fields，并创建 FieldsStore 实例（备注：在 BaseForm 组件的 componentWillReceiveProps 生命周期中，也将调用 option.mapPropsToFields 获取 fields，以便使用 FieldsStore 实例的 updateFields 全量更新缓存数据）。除此而外，getInitialState 方法还将创建 instances, cachedBind, clearedFieldMetaCache, renderFields, domFields 缓存，并为 BaseForm 组件注入 getFieldsValue, getFieldValue, setFieldsInitialValue, getFieldsError, getFieldError, isFieldValidating, isFieldsValidating, isFieldsTouched, isFieldTouched 实例方法（意义见上文）。 instances 缓存字段组件实例。 cachedBind 缓存绑定函数（包含收集和校验字段的实例方法 onCollect, onCollectValidate）及 saveRef 引用函数。 clearedFieldMetaCache 缓存待移除字段的实时数据和元数据。getFieldProps 方法执行时清除 clearedFieldMetaCache[name] 缓存数据。saveRef 方法执行时将根据字段组件的渲染状态，尝试使用 clearedFieldMetaCache[name] 恢复 FieldsStore 实例中的实时数据和元数据，在清除 clearedFieldMetaCache[name] 缓存；或者将 FieldsStore 实例中的实时数据和元数据存入 clearedFieldMetaCache[name] 缓存。见下文。 renderFields 缓存 getFieldProps 方法已执行标识。 domFields 缓存字段组件实例仍在视图中展示的标识。 其次，执行 render 方法，将表单操作函数集通过 props 注入用户自定义组件。因此，在用户自定义组件中，开发者可以获取表单的实时数据，或者更新表单数据，或者校验表单，以完成特定渲染。以下是开发者可调用的方法。 setFields(maybeNestedFields, callback) 以参数 maybeNestedFields 部分更新 FieldsStore 实例中的实时数据，并执行 option.onFieldsChange 方法，再调用 forceUpdate 重绘表单并执行回调。 setFieldsValue(changedValues, callback) 基于 setFields 方法，更新表单数据，并执行 option.onValuesChange 方法。若 changedValues 中相关的字段组件未作渲染，予以警告提示。 resetFields(ns) 基于 setFields 方法，重置匹配字段的表单数据或全量表单数据，并清除相关字段的 clearedFieldMetaCache 缓存。 validateFields(ns, opt, cb) 基于 validateFieldsInternal，校验匹配字段的表单数据或全量表单数据。参数 opt 作为 validateFieldsInternal 的参数 options，cb 为校验完成后的回调。 getFieldInstance(name)，获取字段组件实例。 其次，在渲染字段组件的过程中，BaseForm 提供 getFieldProps 实例方法用于装饰注入字段组件的 props，以及 getFieldDecorator 实例方法用于装饰字段组件。 getFieldProps(name, usersFieldOption) 首先将清理 clearedFieldMetaCache 缓存，其次为 FieldsStore 实例收集字段的元数据，如转换校验规则；最终将输出转化后的 props 以用于字段组件的渲染。相关 props 属性包含：指定字段组件的 ref 引用函数为 BaseForm 内置的 saveRef 实例方法；为字段组件绑定 onCollect, onCollectValidate 实例方法，以在用户行为发生时收集或校验表单数据；将元数据 { [fieldMetaProp]: fieldMeta }，实时数据 { [fieldDataProp]: field }，字段名 { [fieldNameProp]: name } 注入字段组件实例。 getFieldDecorator(name, fieldOption) 基于 getFieldProps 方法，直接装饰字段组件，以获得开发者设定在字段组件实例上的 ref 引用函数及 props.onChange 等绑定函数等，并以 fieldMeta.ref, fieldMeta.originalProps 形式存入元数据中。这样就能在 BaseForm 实例的 saveRef 执行过程中，可以调用开发者设定在字段组件实例上的 ref 引用函数；在 BaseForm 实例的 onCollect, onCollectValidate 执行过程中，可以调用开发者设定在字段组件实例上的 onChange 绑定函数。getFieldDecorator 函数也将使用初始值绘制字段项。 为字段组件绑定的 onCollect, onCollectValidate 方法均基于 onCollectCommon(name, action, args) 实例方法。其执行逻辑为：在 action 事件触发时，首先调用开发者配置的绑定函数 fieldMeta[action] 或 fieldMeta.originalProps[action]，其次通过 fieldMeta.getValueFromEvent 从 event 对象获取字段的值或者取值，其次执行挂载于表单上的 option.onValuesChange 绑定函数，最终返回 { name, field, fieldMeta }。下面是 onCollect, onCollectValidate 方法的简要实现逻辑。 onCollect(name_, action, …args) 基于 setFields 方法，在事件触发时，实时更新 FieldsStore 实例存储的实时数据。 onCollectValidate(name_, action, …args) 基于 validateFieldsInternal, setFields 方法，在事件触发时，既实时更新 FieldsStore 实例存储的实时数据，又实时校验字段。 对于字段组件，BaseForm 有一种缓存刷新机制。当字段组件实例从视图中移除时，须得调用 FieldsStore 实例的 clearField 方法以清除缓存的实时数据和元数据。这一过程通常在 ref 引用函数内执行，通过参数 —— 组件实例的真值情况判断字段组件是否已作销毁。而当字段组件更新时，react 16 的机制会在 getFieldProps 方法执行之后，调用两次 ref 引用函数，第一次 ref 引用函数的参数为否值，表示前一个实例需要被销毁；第二次 ref 引用函数的参数为真值，表示创建新的字段组件实例。当执行第一次 ref 引用函数时，FieldsStore 实例的实时数据和元数据都将被销毁。这样，即便字段组件仍旧在视图中有所表现，元数据如校验规则的丢失也将使促使字段组件在值变更时无法得到正常的校验。鉴于此，BaseForm 提供 clearedFieldMetaCache 属性缓存待移除字段的实时数据和元数据，且在第二次执行 ref 引用函数时尝试恢复 FieldsStore 实例中的相应数据。 saveRef(name, _, component) 作为 BaseForm 为字段组件提供的引用函数，其在字段组件挂载、卸载、重绘阶段都会被调用。可根据参数 component 判断组件的渲染状态。当 component 为空值，使用 clearedFieldMetaCache[name] = { field, meta } 收集字段的元数据和表单数据，并清除 FieldsStore 实例中的相关数据，清理 instances[name], cachedBind[name] 等缓存；若 component 为字段组件实例，domFields[name] 缓存标记将置为真值，instances[name] 将缓存字段组件实例，并尝试使用 clearedFieldMetaCache 缓存以恢复 FieldsStore 实例中的相关数据，等恢复完成后，再行清理 clearedFieldMetaCache[name] 缓存。 recoverClearedField(name) 通过 clearedFieldMetaCache[name] 缓存恢复 FieldsStore 实例存储的字段实时数据和元数据，完成后清除 clearedFieldMetaCache[name] 缓存。 字段数据缓存并恢复机制的相关源码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112getFieldProps(name, usersFieldOption = &#123;&#125;) &#123; if (!name) &#123; throw new Error('Must call `getFieldProps` with valid name string!'); &#125; if (process.env.NODE_ENV !== 'production') &#123; warning( this.fieldsStore.isValidNestedFieldName(name), 'One field name cannot be part of another, e.g. `a` and `a.b`.' ); warning( !('exclusive' in usersFieldOption), '`option.exclusive` of `getFieldProps`|`getFieldDecorator` had been remove.' ); &#125; delete this.clearedFieldMetaCache[name]; const fieldOption = &#123; name, trigger: DEFAULT_TRIGGER, valuePropName: 'value', validate: [], ...usersFieldOption, &#125;; const &#123; rules, trigger, validateTrigger = trigger, validate, &#125; = fieldOption; const fieldMeta = this.fieldsStore.getFieldMeta(name); if ('initialValue' in fieldOption) &#123; fieldMeta.initialValue = fieldOption.initialValue; &#125; const inputProps = &#123; ...this.fieldsStore.getFieldValuePropValue(fieldOption), ref: this.getCacheBind(name, `$&#123;name&#125;__ref`, this.saveRef), &#125;; if (fieldNameProp) &#123; inputProps[fieldNameProp] = formName ? `$&#123;formName&#125;_$&#123;name&#125;` : name; &#125; const validateRules = normalizeValidateRules(validate, rules, validateTrigger); const validateTriggers = getValidateTriggers(validateRules); validateTriggers.forEach((action) =&gt; &#123; if (inputProps[action]) return; inputProps[action] = this.getCacheBind(name, action, this.onCollectValidate); &#125;); // make sure that the value will be collect if (trigger &amp;&amp; validateTriggers.indexOf(trigger) === -1) &#123; inputProps[trigger] = this.getCacheBind(name, trigger, this.onCollect); &#125; const meta = &#123; ...fieldMeta, ...fieldOption, validate: validateRules, &#125;; this.fieldsStore.setFieldMeta(name, meta); if (fieldMetaProp) &#123; inputProps[fieldMetaProp] = meta; &#125; if (fieldDataProp) &#123; inputProps[fieldDataProp] = this.fieldsStore.getField(name); &#125; // This field is rende#f81d22, record it this.renderFields[name] = true; return inputProps;&#125;,saveRef(name, _, component) &#123; if (!component) &#123; // after destroy, delete data this.clearedFieldMetaCache[name] = &#123; field: this.fieldsStore.getField(name), meta: this.fieldsStore.getFieldMeta(name), &#125;; this.clearField(name); delete this.domFields[name]; return; &#125; this.domFields[name] = true; this.recoverClearedField(name); const fieldMeta = this.fieldsStore.getFieldMeta(name); if (fieldMeta) &#123; const ref = fieldMeta.ref; if (ref) &#123; if (typeof ref === 'string') &#123; throw new Error(`can not set ref string for $&#123;name&#125;`); &#125; ref(component); &#125; &#125; this.instances[name] = component;&#125;,recoverClearedField(name) &#123; if (this.clearedFieldMetaCache[name]) &#123; this.fieldsStore.setFields(&#123; [name]: this.clearedFieldMetaCache[name].field, &#125;); this.fieldsStore.setFieldMeta(name, this.clearedFieldMetaCache[name].meta); delete this.clearedFieldMetaCache[name]; &#125;&#125; 其次，在 BaseForm 组件的 componentDidMount, componentDidUpdate 生命周期中，将调用 cleanUpUselessFields 实例方法，以根据 renderFields, domFields 缓存判断字段组件渲染状态，如字段组件未作渲染，调用 clearField 实例方法清理 FieldsStore 实例存储的字段实时数据和元数据、以及 instances[name], cachedBind[name] 缓存。 以上功能的实现基于 getCacheBind, getRules, validateFieldsInternal 实例方法。其中，getRules(fieldMeta, action) 用于从 fieldMeta 元数据中获取指定事件的校验规则。下面是 getCacheBind, validateFieldsInternal 方法的简要实现逻辑及相关源码。 getCacheBind(name, action, fn) 以 cachedBind[name][action] = { fn, oriFn } 形式缓存 onCollect, onCollectValidate, saveRef 方法，便于使用 name 进行查找。 validateFieldsInternal(fields, { fieldNames, action, options }, callback) 校验指定字段。可复用之前的校验结果，收集待校验的字段并予以校验，转化校验文案并执行 callback 回调。若异步校验期间字段的值发生改变，将得到校验已过期文案。在校验起始阶段，调用 setFields 记录校验中状态；校验结束阶段，调用 setFields 记录校验结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109getCacheBind(name, action, fn) &#123; if (!this.cachedBind[name]) &#123; this.cachedBind[name] = &#123;&#125;; &#125; const cache = this.cachedBind[name]; if (!cache[action] || cache[action].oriFn !== fn) &#123; cache[action] = &#123; fn: fn.bind(this, name, action), oriFn: fn, &#125;; &#125; return cache[action].fn;&#125;,validateFieldsInternal(fields, &#123; fieldNames, action, options = &#123;&#125;,&#125;, callback) &#123; const allRules = &#123;&#125;; const allValues = &#123;&#125;; const allFields = &#123;&#125;; const alreadyErrors = &#123;&#125;; fields.forEach((field) =&gt; &#123; const name = field.name; if (options.force !== true &amp;&amp; field.dirty === false) &#123; if (field.errors) &#123; set(alreadyErrors, name, &#123; errors: field.errors &#125;); &#125; return; &#125; const fieldMeta = this.fieldsStore.getFieldMeta(name); const newField = &#123; ...field, &#125;; newField.errors = undefined; newField.validating = true; newField.dirty = true; allRules[name] = this.getRules(fieldMeta, action); allValues[name] = newField.value; allFields[name] = newField; &#125;); this.setFields(allFields); // in case normalize Object.keys(allValues).forEach((f) =&gt; &#123; allValues[f] = this.fieldsStore.getFieldValue(f); &#125;); if (callback &amp;&amp; isEmptyObject(allFields)) &#123; callback(isEmptyObject(alreadyErrors) ? null : alreadyErrors, this.fieldsStore.getFieldsValue(fieldNames)); return; &#125; const validator = new AsyncValidator(allRules); if (validateMessages) &#123; validator.messages(validateMessages); &#125; validator.validate(allValues, options, (errors) =&gt; &#123; const errorsGroup = &#123; ...alreadyErrors, &#125;; if (errors &amp;&amp; errors.length) &#123; errors.forEach((e) =&gt; &#123; const fieldName = e.field; const field = get(errorsGroup, fieldName); if (typeof field !== 'object' || Array.isArray(field)) &#123; set(errorsGroup, fieldName, &#123; errors: [] &#125;); &#125; const fieldErrors = get(errorsGroup, fieldName.concat('.errors')); fieldErrors.push(e); &#125;); &#125; const expired = []; const nowAllFields = &#123;&#125;; Object.keys(allRules).forEach((name) =&gt; &#123; const fieldErrors = get(errorsGroup, name); const nowField = this.fieldsStore.getField(name); // avoid concurrency problems if (nowField.value !== allValues[name]) &#123; expired.push(&#123; name, &#125;); &#125; else &#123; nowField.errors = fieldErrors &amp;&amp; fieldErrors.errors; nowField.value = allValues[name]; nowField.validating = false; nowField.dirty = false; nowAllFields[name] = nowField; &#125; &#125;); this.setFields(nowAllFields); if (callback) &#123; if (expired.length) &#123; expired.forEach((&#123; name &#125;) =&gt; &#123; const fieldErrors = [&#123; message: `$&#123;name&#125; need to revalidate`, field: name, &#125;]; set(errorsGroup, name, &#123; expired: true, errors: fieldErrors, &#125;); &#125;); &#125; callback(isEmptyObject(errorsGroup) ? null : errorsGroup, this.fieldsStore.getFieldsValue(fieldNames)); &#125; &#125;);&#125; 其他 createForm(options) 基于 createBaseForm，为 HOC 组件注入默认的 getForm 方法，将 form 表单操作函数工具集通过 props 注入到用户自定义表单组件中。form 中含有的方法，参见上文。 createDOMForm(option) 基于 createBaseForm，在传递给用户自定义表单组件的 props.form 混入 validateFieldsAndScroll 方法，校验失败时滚动到首个错误字段处。该方法引用了 react-dom，只适用于浏览器平台，不适用于手机端。 validateFieldsAndScroll(ns, opt, cb) 基于 dom-scroll-into-view 库实现，首先通过 getBoundingClientRect 获得校验失败字段的 top 值，其次通过 getComputedStyle 或 style 属性获得字段节点首个滚动的父元素，最后调用 dom-scroll-into-view 库提供的 api 滚动页面。 FormScope 以组件形式提供接口。option 配置项通过 props 传入，在 render 阶段调用 createDOMForm，并将 form 传入函数组件 children 中。 createFormField 生成 Field 实例。 antd-Form 组件Form 组件Form 组件本身并不承载逻辑，而是通过 props.className, props.prefixCls, props.layout, props.hideRequiredMark, props.onSubmit 设定注入 form 原生节点的样式类及绑定函数，以影响表单内部节点渲染时的样式。同时，Form 组件将为子组件传入 context.vertical 以区分是水平布局，还是垂直布局。 Form 组件拥有 Item 静态属性指向 FormItem 组件；createFormField 静态方法指向 rc-form 提供的同名方法；createForm 静态方法调用 rc-form 提供的 createBaseForm 方法，用于装饰用户自定义表单组件。 FormItem 组件FormItem 组件用于设定表单项的布局，其可配置的 props 属性包含必填标记 hideRequiredMark, 字段名 label, 校验文案 help, 额外内容 extra。 同受控组件和非受控组件，FormItem 组件提供两种使用方式：其一，当未设定校验信息相关的 props 属性时，FormItem 组件将自动根据内部字段组件实例的状况渲染校验文案及校验状态；其二，当设定校验信息相关的 props 属性时，FormItem 组件将根据开发者传入的 props 渲染校验文案及校验状态。在第一种使用方式下，FormItem 组件只可以包含一个字段组件；在第二种使用方式下，FormItem 组件中可以包含多个字段组件，布局也更为灵活。这里说的相关 props 属性包含：校验文案 help, 校验状态 validateStatus（用于绘制反馈图标）, 必填标识 required, 字段名 id（影响点击 label 时聚焦哪个字段元素）。 那么，FormItem 又是怎样自动收集字段组件的校验数据呢？因为在 BaseForm 组件提供的 getFieldProp 方法，字段的字段名、元数据和实时数据都将作为特殊的 props 属性传入到字段组件中，所以作为字段组件容器的 FormItem，就可以通过这些特殊的 props 属性判断子组件实例是不是一个字段组件实例，当其为字段组件实例时，进一步收集实时的校验信息，从校验规则中获取是否必填标识，以完成渲染。 此外，FormItem 可以使用 props.labelCol, props.wrapperCol 属性栅格化布局标签组件和字段组件，其实现借助于 antd 提供的 Row, Col 组件。当点击标签 label 时，FormItem 提供的绑定函数能为字段组件获得焦点。这里不再多加介绍。 获取字段组件实例的相关源码为：123456789101112131415161718192021222324getControls(children: React.ReactNode, recursively: boolean) &#123; let controls: React.ReactElement&lt;any&gt;[] = []; const childrenArray = React.Children.toArray(children); for (let i = 0; i &lt; childrenArray.length; i++) &#123; if (!recursively &amp;&amp; controls.length &gt; 0) &#123; break; &#125; const child = childrenArray[i] as React.ReactElement&lt;any&gt;; if (child.type &amp;&amp; (child.type as any === FormItem || (child.type as any).displayName === 'FormItem')) &#123; continue; &#125; if (!child.props) &#123; continue; &#125; if (FIELD_META_PROP in child.props) &#123; // And means FIELD_DATA_PROP in child.props, too. controls.push(child); &#125; else if (child.props.children) &#123; controls = controls.concat(this.getControls(child.props.children, recursively)); &#125; &#125; return controls;&#125; 以上即简要分析了 ant-desing 中 Form 组件的实现，文中难免有谬误或思考上的不足处，仍望读者海涵。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"},{"name":"antd","slug":"antd","permalink":"http://xzfyu.com/tags/antd/"}]},{"title":"react-jsonschema-form源码分析","slug":"frontend/library/react-jsonschema-form源码分析","date":"2018-10-09T16:00:00.000Z","updated":"2020-03-08T10:45:48.826Z","comments":true,"path":"2018/10/10/frontend/library/react-jsonschema-form源码分析/","link":"","permalink":"http://xzfyu.com/2018/10/10/frontend/library/react-jsonschema-form源码分析/","excerpt":"","text":"","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"Reflect, Proxy","slug":"frontend/js/Reflect, Proxy","date":"2018-10-08T16:00:00.000Z","updated":"2020-03-08T10:38:48.659Z","comments":true,"path":"2018/10/09/frontend/js/Reflect, Proxy/","link":"","permalink":"http://xzfyu.com/2018/10/09/frontend/js/Reflect, Proxy/","excerpt":"","text":"ReflectES6 提供的 API，集成语言层面的对象操作（操作与 Proxy 一一对应，且为函数形式）。 Reflect.get(target, name, receiver): 获取属性。 Reflect.set(target, name, value, receiver): 对属性赋值。 Reflect.defineProperty(target, name, desc): 修改属性的描述符。 Reflect.deleteProperty(target, name): 删除属性。 Reflect.has(target, name): propKey in proxy 判断。 Reflect.ownKeys(target): 返回对象的自有属性。 Reflect.enumerate(target): 以迭代器形式获取对象的可枚举属性。 Reflect.isExtensible(target): 判断对象是否可扩展。 Reflect.preventExtensions(target): 使对象不可扩展。 Reflect.getOwnPropertyDescriptor(target, name): 获取属性的描述符。 Reflect.getPrototypeOf(target): 获取对象的 proto 属性。 Reflect.setPrototypeOf(target, prototype): 设置对象的原型。 Reflect.apply(target, thisArg, args): 以 thisArg 为上下文执行 target 函数。 Reflect.construct(target, args): 创建 target 实例。 ProxyProxy 在语言层面，拦截针对对象的操作。ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 使用 let proxy = new Proxy(target, handler); 创建 Proxy 实例。参数 target 可以是对象，也可以是函数。handler 为设定拦截操作的集合。操作 proxy，将同时影响 target。 Proxy.revocable 方法返回一个可取消的 Proxy 实例。返回值中，proxy 属性即为 Proxy 实例，revoke 方法用于取消 Proxy 实例。 在 Proxy 代理的情况下，目标对象内的 this 关键字将指向 Proxy 实例。 123456789let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log('GET ' + propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);obj.foo // \"GET foo\" 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked 可拦截的操作包含： get(target, propKey, receiver): 拦截对象属性的读取。参数 reveiver 为操作行为所针对的对象，通常是 proxy 实例。 set(target, propKey, value): 拦截对象属性的设置，返回布尔值。 has(target, propKey): 拦截 propKey in proxy 操作，返回布尔值。 delete(target, propKey): 拦截 delete proxy[propKey] 的操作，返回布尔值。 ownKeys(target): 拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in 循环，返回目标对象自身所有的属性，Object.keys() 返回仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey): 拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc): 拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回布尔值。 preventExtensions(target): 拦截 Object.preventExtensions(proxy)，返回布尔值。 getPrototypeOf(target): 拦截 Object.getPrototypeOf(proxy)，返回对象。 isExtensible(target): 拦截 Object.isExtensible(proxy)，返回布尔值。 setPrototypeOf(target, proto): 拦截 Object.setPrototypeOf(proxy, proto)，返回布尔值。 apply(target, object, args): 拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args): 拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。 harmony-reflect作为垫片，提供 Reflect 全局对象，扩展 Object 及 Proxy。 Reflect扩展或提供平台提供的 Reflect 对象。 Reflect.get(target, name, receiver) 方法实现: 首先，若 target 为 Proxy 实例，获取并调用 handler.get 方法；其次，若 target 不是 Proxy 实例，通过 Object.getOwnPropertyDescriptor 获取属性描述符，若属性描述符为 undefined，尝试通过 Object.getPrototypeOf 方法获取原型的 name 属性；其次，若属性描述符不是 undefined，尝试获取属性描述符中的 value 属性或执行 get 方法。 Reflect.set(target, name, value, receiver) 方法: 首先，若 target 为 Proxy 实例，获取并调用 handler.set 方法；其次，若 target 不是 Proxy 实例，通过 Object.getOwnPropertyDescriptor 获取属性描述符，若属性描述符为 undefined，尝试通过 Object.getPrototypeOf 方法调用原型的 set 方法；其次，若属性描述符不是 undefined，且访问器属性 set 为真值，尝试以 receiver 为上下文调用属性描述符中的 set 方法；其次，通过 Object.getOwnPropertyDescriptor 获取 receiver 对象的属性描述符，若属性描述符为 undefined，调用 Object.defineProperty 重新设置属性描述符，更新 value 值；其次，若 receiver 对象的属性描述符不是 undefined，校验 receiver 是否可扩展，若可扩展，调用 Object.defineProperty 重新设置属性描述符。 Reflect.defineProperty(target, name, desc) 方法: 首先，若 target 为 Proxy 实例，获取并调用 handler.defineProperty 方法；其次，若 target 不是 Proxy 实例，通过 Object.getOwnPropertyDescriptor 获取当前的属性描述符，当属性描述符的 configurable 属性为 false 时，运行原有的 Object.defineProperty 将报错，实现上将引起报错的情形全部以 return false 形式剔除，随后再调用 Object.defineProperty，重新设定属性描述符。 Reflect.deleteProperty(target, name) 方法: 首先，若 target 为 Proxy 实例，获取并调用 handler.deleteProperty 方法；其次，通过 Object.getOwnPropertyDescriptor 获取当前的属性描述符并判断其 configurable 属性，若属性为真，调用 delete target[name] 语句，否则返回 false。 Reflect.has(target, name) 方法: 执行 name in target 语句。 Reflect.ownKeys(target) 方法: 首先，若 target 为 Proxy 实例，获取并调用 handler.ownKeys 方法；其次，调用 Object.getOwnPropertyNames 方法。 Reflect.enumerate(target) 方法: 首先，若 target 为 Proxy 实例，获取并调用 handler.enumerate 方法；其次，通过 for…in 语句获取目标的可枚举属性集合，以迭代器形式输出。 Reflect.isExtensible(target) 方法: 直接调用 Object.isExtensible 方法。 Reflect.preventExtensions(target) 方法: 首先，若 target 为 Proxy 实例，获取并调用 handler.preventExtensions 方法；其次，调用 Object.preventExtensions 方法。 Reflect.getOwnPropertyDescriptor(target, name) 方法: 直接调用 Object.getOwnPropertyDescriptor 方法。 Reflect.getPrototypeOf(target) 方法: 直接调用 Object.getPrototypeOf 方法。 Reflect.setPrototypeOf(target, prototype): 首先，若 target 为 Proxy 实例，获取并调用 handler.setPrototypeOf 方法；其次，判断目标的可扩展性，若其可扩展，以 try-catch 语句执行 Object.setPrototypeOf 方法，以捕获错误。 Reflect.apply(target, thisArg, args): 调用 Function.prototype.apply.call(target, thisArg, args)。 Reflect.construct(target, args, newTarget): 首先，若 target 为 Proxy 实例，获取并调用 handler.construct 方法；其次，在 newTarget 为 undefined 或与 target 等值的基础上，基于 target 并以 null 为上下文生成构造函数；否则，Object.create(newTarget.prototype) 为上文生成构造函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243var Reflect = &#123; // ... enumerate: function(target) &#123; var handler = directProxies.get(target); var result; if (handler !== undefined) &#123; result = handler.enumerate(handler.target); &#125; else &#123; result = []; for (var name in target) &#123; result.push(name); &#125;; &#125; var l = +result.length; var idx = 0; return &#123; next: function() &#123; if (idx === l) return &#123; done: true &#125;; return &#123; done: false, value: result[idx++] &#125;; &#125; &#125;; &#125;, construct: function(target, args, newTarget) &#123; var handler = directProxies.get(target); if (handler !== undefined) &#123; return handler.construct(handler.target, args, newTarget); &#125; if (typeof target !== \"function\") &#123; throw new TypeError(\"target is not a function: \" + target); &#125; if (newTarget === undefined || newTarget === target) &#123; return new (Function.prototype.bind.apply(target, [null].concat(args))); &#125; else &#123; if (typeof newTarget !== \"function\") &#123; throw new TypeError(\"newTarget is not a function: \" + target); &#125; var proto = newTarget.prototype; var instance = (Object(proto) === proto) ? Object.create(proto) : &#123;&#125;; var result = Function.prototype.apply.call(target, instance, args); return Object(result) === result ? result : instance; &#125; &#125;&#125; proxy构建 const vHandler = function Validator(target, handler){} 构造函数，用于对象操作并作校验。当平台提供 Proxy api 时，vHandler 将作为 Proxy.create, Proxy.createFunction 的参数，以改写 global.Proxy(target, handler) 构造函数。生成的 proxy 实例将以 { [proxy]: vHandler } 的形式存入 WeakMap 实例 directProxies 中，用于使 Object 的部分原型方法先作代理处理，再作常规处理。 Validator 实例方法（proxy 为 new Proxy(target, handler) 实例）： proxy.get(receiver, propKey, receiver): 若没有设置 handler.get，调用 Reflect.get 方法；若设置，以 handler 为上下文调用 handler.get，并校验 target[propKey] 的 configurable, writable, get 属性或方法，特定条件下作报错处理。 proxy.set(receiver, propKey, value): 若没有设置 handler.set，调用 Reflect.set 方法；若设置，以 handler 为上下文调用 handler.set，并校验 target[propKey] 的 configurable, writable, get 属性或方法，特定条件下作报错处理。 proxy.has(propKey): 若没有设置 handler.has，调用 Reflect.has 方法；若设置，以 handler 为上下文调用 handler.has，当返回结果为 false 时，并校验 target[propKey] 的 configurable 属性, 及可扩展性，特定条件下作报错处理。 proxy.delete(propKey): 若没有设置 handler.deleteProperty，调用 Reflect.deleteProperty 方法；若设置，以 handler 为上下文调用 handler.deleteProperty，校验 target[propKey] 的可扩展性，特定条件下作报错处理。 proxy.ownKeys(): 若没有设置 handler.ownKeys，调用 Reflect.ownKeys 方法；若设置，以 handler 为上下文调用 handler.ownKeys，并校验 target 各属性的可扩展性，特定条件下作报错处理。 proxy.enumate(), proxy.iterate(): 若没有设置 handler.enumate，调用 Reflect.enumate 方法；若设置，以 handler 为上下文调用 handler.enumate，并校验 target 各属性的可扩展性，特定条件下作报错处理。返回迭代器。 proxy.getPropertyDescriptor(propKey): 若 proxy.has 返回否值，返回 undefined；否则以包装 proxy.set, proxy.get 形式返回属性描述符，且 enumerable, configurable 属性均为真值。 proxy.getOwnPropertyDescriptor(propKey): 若没有设置 handler.getOwnPropertyDescriptor，调用 Reflect.getOwnPropertyDescriptor 方法；若设置，以 handler 为上下文调用 handler.getOwnPropertyDescriptor，校验 target[propKey] 的可扩展性，特定条件下作报错处理。 proxy.defineProperty(propKey, propDesc): 若没有设置 handler.defineProperty，调用 Reflect.defineProperty 方法；若设置，以 handler 为上下文调用 handler.defineProperty，并校验 target[propKey] 的可扩展性，特定条件下作报错处理。 proxy.preventExtensions(): 若没有设置 handler.preventExtensions，调用 Reflect.preventExtensions 方法；若设置，以 handler 为上下文调用 handler.preventExtensions，并校验 target[propKey] 的可扩展性，特定条件下作报错处理。 proxy.getPrototypeOf(): 若没有设置 handler.getPrototypeOf，调用 Reflect.getPrototypeOf 方法；若设置，以 handler 为上下文调用 handler.getPrototypeOf，并校验 target[propKey] 的可扩展性，特定条件下作报错处理。 proxy.isExtensible(): 若没有设置 handler.isExtensible，调用 Reflect.isExtensible 方法；若设置，以 handler 为上下文调用 handler.isExtensible，并校验 target[propKey] 的可扩展性，特定条件下作报错处理。 proxy.setPrototypeOf(proto): 若没有设置 handler.setPrototypeOf，调用 Reflect.setPrototypeOf 方法；若设置，以 handler 为上下文调用 handler.setPrototypeOf，并校验 target[propKey] 的可扩展性，特定条件下作报错处理。 proxy.apply(target, thisBinding, args): 若没有设置 handler.apply，调用 Reflect.apply 方法；若设置，以 handler 为上下文调用 handler.apply。 proxy.construct(target, args, newTarget): 若没有设置 handler.construct，调用 Reflect.construct 方法；若设置，以 handler 为上下文调用 handler.construct。 Object 扩展 Object.preventExtensions(subject): 若 subject 为代理实例，从 directProxies 中获取代理对象的 vHandler，并调用代理对象的 preventExtensions 方法；其次尝试调用 Object.preventExtensions 原始方法。 Object.seal(subject): 密封对象，可改变现有属性，即将所有属性描述符的 configurable 置为否。 Object.freeze(subject): 冻结对象，即将所有属性描述符的 configurable, writable 置为否（访问器属性的状况下仅需处理 configurable 属性）。 Object.isExtensible(subject): 若 subject 为代理实例，从 directProxies 中获取代理对象的 vHandler，并调用代理对象的 isExtensible 方法；其次尝试调用 Object.isExtensible 原始方法。 Object.isSealed(subject): 判断是否密封。 Object.isFrozen(subject): 判断是否冻结。 Object.getOwnPropertyDescriptor(subject, name): 若 subject 为代理实例，从 directProxies 中获取代理对象的 vHandler，并调用代理对象的 getOwnPropertyDescriptor 方法；其次尝试调用 Object.getOwnPropertyDescriptor 原始方法。 Object.defineProperty(subject, name, desc): 若 subject 为代理实例，从 directProxies 中获取代理对象的 vHandler，并调用代理对象的 defineProperty 方法；其次尝试调用 Object.defineProperty 原始方法。 Object.defineProperties(subject, descs): 若 subject 为代理实例，从 directProxies 中获取代理对象的 vHandler，针对属性逐个调用代理对象的 defineProperty 方法；其次尝试调用 Object.defineProperties 原始方法。 Object.keys(subject): 若 subject 为代理实例，从 directProxies 中获取代理对象的 vHandler，并调用代理对象的 ownKeys 方法，剔除其中的不可枚举项；其次尝试调用 Object.keys 原始方法。 Object.getOwnPropertyNames(subject): 若 subject 为代理实例，从 directProxies 中获取代理对象的 vHandler，并调用代理对象的 ownKeys 方法；其次尝试调用 Object.getOwnPropertyNames 原始方法。 Object.getOwnPropertySymbols(subject): 平台提供 Object.getOwnPropertySymbols 原始方法的基础下封装。若 subject 为代理实例，从 directProxies 中获取代理对象的 vHandler，返回空数组；其次尝试调用 Object.getOwnPropertySymbols 原始方法。 Object.assign(target, …source): 平台提供 Object.assign 原始方法的基础下封装。若各参数均为代理对象，直接调用 Object.assign 原始方法；否则，遍历属性以拷贝。 Object.setPrototypeOf(target, proto): 若 target 为代理实例，从 directProxies 中获取代理对象的 vHandler，并调用代理对象的 setPrototypeOf 方法；其次尝试调用 Object.setPrototypeOf 原始方法；其次通过 Object.defineProperty 设置target 的 proto 属性。 Object.prototype.isPrototypeOf(arg): 若 arg 为代理实例，通过 vHandler.getPrototypeOf 方法向上逐层获取 arg 的原型，原型同 this 作等值比较；否则直接调用 Object.prototype.isPrototypeOf 作判断。 Object.prototype.valueOf(): 若 this 为代理实例，从 directProxies 中获取代理对象的 target，以 target 作为上下文执行 Object.prototype.valueOf；否则，直接执行 Object.prototype.valueOf。 Object.prototype.toString(): 若 this 为代理实例，从 directProxies 中获取代理对象的 target，以 target 作为上下文执行 Object.prototype.toString；否则，直接执行 Object.prototype.toString。 Function.prototype.toString(): 若 this 为代理实例，从 directProxies 中获取代理对象的 target，以 target 作为上下文执行 Function.prototype.toString；否则，直接执行 Function.prototype.toString。 Date.prototype.toString(): 若 this 为代理实例，从 directProxies 中获取代理对象的 target，以 target 作为上下文执行 Date.prototype.toString；否则，直接执行 Date.prototype.toString。 Object.prototype.hasOwnProperty(propKey): 若 this 为代理实例，从 directProxies 中获取代理对象的 vHandler，调动 vHandler.getOwnPropertyDescriptor，并判断返回值是否为 undefined；否则，直接执行 Object.prototype.hasOwnProperty。 Array.isArray(subject): 若 subject 为代理实例，从 directProxies 中获取代理对象的 target，并调用 Array.isArray 原始方法判断 target 是否为数组；其次尝试调用 Array.isArray 原始方法。 Array.prototype.concat(…args): 使用 Array.prototype.slice 方法将 args 数组项中的代理实例数组拆解为普通数组，随后使用 Array.prototype.concat 原始方法拼接数组。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"es","slug":"frontend/es","permalink":"http://xzfyu.com/categories/frontend/es/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"js","slug":"js","permalink":"http://xzfyu.com/tags/js/"}]},{"title":"前端构建工具 dawn 不完全解密","slug":"frontend/工程化/前端构建工具dawn","date":"2018-09-10T16:00:00.000Z","updated":"2020-03-08T10:57:36.249Z","comments":true,"path":"2018/09/11/frontend/工程化/前端构建工具dawn/","link":"","permalink":"http://xzfyu.com/2018/09/11/frontend/工程化/前端构建工具dawn/","excerpt":"","text":"实现原理dawn 是一个采用中间件技术实现的轻量的任务流协调器，它和 gulp, grunt 有异曲同工之妙。dawn 本身并不处理任务，转而交由中间件承担这一职能，如同 gulp, grunt 插件。在实现上，dawn 是 webpack 出台后的产物，就不需要像 gulp, grunt 那样关注任务流的始点 —— 文件位置，而更容易聚焦于任务的分解，将编译、压缩作业交给 dn-middleware-webpack 中间件。若说 gulp 中的任务流是鱼跃似的，一个跟着另一个，那么，dawn 通过 ctx 上下文使得两个任务之间可以借助事件或实例属性进行通信。dawn 的中间件实现机制如同 koa，其一使用 next 引用下一个中间件串联任务流，其二以继承事件模型的 ctx 实例作为上下文。其核心代码如下： 12345678910111213141516171819class Context extends EventEmitter &#123; async _execQueue(middlewares, args, onFail) &#123; const middleware = middlewares.shift(); if (!middleware) return; // this.load 安装中间件，并执行中间件的外层函数，获得实际的任务逻辑 handler const handler = await this.load(middleware); const next = (args) =&gt; &#123; // 若返回真值，在 watch 状态下，也只执行一次 if (next.__result) return next.__result; next.__result = this._execQueue(middlewares, args, onFail) .catch(err =&gt; onFail(err)); return next.__result; &#125;; return handler.call(this, next, this, args); &#125;&#125; 因为 dawn 是一个任务流协调器，使得它就像一架航母，其能力仰赖于战斗机群 —— 由丰富的中间件、模板构成的生态系统。第一，这样使得 dawn 更着眼于为开发团队提供服务（两者呈互为因果的关系）。dawn 内建了复合远程配置的功能。不少公司会有私有的 npm 仓库，开发的 dn 中间件、模板先期都会在这些私有仓库中发展成形。借助于 dn config registry http://your_server_url 命令，dawn 安装中间件时会从这些私有仓库中拉取中间件或模板。对于配置文件，借助于 dn config server http://your_server_url 命令，dawn 也会从私有服务器中拉取远程配置，并与本地配置合并。如此，既能保有模板的闭源特征，又能实现配置文件的复用。扯开一个话题，使用 .yml 文件配置选项、将配置文件存于远端，这和我稍有耳闻的 spring boot 项目有些相仿。 第二，为了开发中间件的方便，ctx 必然需要提供大而全的功能。以下简要地展示 ctx 提供的 api 列表： cli: 命令行 Command 实例。 command: 当前执行的命令，如 init, dev, build 等。 pipeline: 当前命令实际所用中间件列表。 cwd: 项目路径。 project: 项目 package.json 文件内容。 middlewareMgr: 中间件管理器，用于查询私有中心的中间件列表，或者安装中间件。 templateMgr: 模板管理器，用于查询私有中心的模板列表，或者文件重命名，或者下载模板。 conf: rc配置管理器，用于获取本地或远程 rc 配置，或者设置 rc 配置，默认获取 .dawnrc 文件。 console: 命令行编辑器 console。 inquirer, utils.inquirer : 命令行交互接口，即 inquirer 类库。 utils.exec(script, opts): 执行 script 命令，返回 promise；utils.exec.withResult(script, opts) 等待并返回执行结果。 utils.writeFile(filename, content): 写文件，返回 promise。 utils.readFile(filename): 读文件，返回 promise。 utils.del: 删除文件，返回 promise。 utils.mkdirp: 创建目录，返回 promise。 download: fetch 响应。 sleep: 延时执行。 prompt: 使用 inquirer.prompt 在命令行编辑器创建引导式交互界面。 utils.mod: 模块管理器，用于执行 npm 命令，或者安装依赖，或者下载模板（缓存在计算机的特定位置），或者获取 npm 包信息。 utils.open: 打开浏览器，即 react-dev-utils/openBrowser 模块。 utils.oneport: 获取一个空闲的端口，即 oneport 类库。 utils.fetch: fetch 响应。 utils.yaml: 通过 js-yaml 类库解析或编译 .yml 文件格式数据。 utils.globby: 通过匹配规则获取文件路径，即 globby 类库。 utils.confman: 配置文件加载器，即 confman 类库 utils.streamToBuffer, utils.stream2buffer: 将可读流转化成 字符串或 buffer，返回 promise。 utils.bufferToStream, utils.buffer2stream: 将字符串或 buffer 转化成可读流，返回 promise。 utils.copydir: 拷贝文件夹，返回 promise。 utils.findCommand(dirname, command): 获取执行脚本文件。 load(opts): 加载中间件，并执行外层函数。 exec(middlewares, initailArgs): 构建任务流，可用于在中间件中构建子任务流。 常用中间件dn-middleware-webpack概述：基于 webpack3 实现的中间件，打包模块。本地开发模式也将打包模块，而不是读取 webpack 缓存数据。 奥妙： dn-middleware-webpack 在回调中执行后续中间件的处理逻辑。 通过 vmodule-webpack-plugin 插件将 config.yml 类配置文件注入为可以 import 引入的虚拟模块。 ctx 中添加 webpack 属性，即 webpack 类库。 选项： 选项 意义 默认值 config 不同环境通过加载配置文件的模块名和文件路径，使用 vmodule-webpack-plugin 创建虚拟模块 { name: ‘$config’, path: ‘./config’ } configFile webpack 配置文件路径，配置文件导出函数有效 ‘./webpack.config.js’ mode 模式 undefined entry 入口文件 [‘./src/*.{js,jsx,ts,tsx}’] inject 注入模板中的公用入口文件 [‘./src/*.{js,jsx,ts,tsx}’] template 模板文件，模板会加载同名的入口文件 [‘./src/assets/*.html’] output 打包文件目录 ‘./build/‘ publicPath 浏览器端访问打包文件的路径 undefined folders 不同文件类型的打包目录 { js: ‘js’, css: ‘css’, img: ‘img’, font: ‘font’, html: ‘’ } chunkFilename 懒加载模块名 ‘chunks/[name]-[chunkhash].js’ umd 值为对象时，混合到 webpackConfig.output 配置中 undefined external 是否使用外部扩展 undefined externals 外部扩展 { ‘jquery’: ‘jQuery’, ‘zepto’: ‘Zepto’, ‘react’: ‘React’, ‘react-dom’: ‘ReactDOM’ } sourceMap 是否生成 source map，开发环境默认生成，false 时不生成；打包时置为 true 才生成 undefined watch 是否使用 webpack 监听文件变更，执行 compiler.watch 或 compiler.run 的差别 undefined watchOpts watch 配置 { aggregateTimeout: 600, ignored: /node_modules/ } babel babel-loader 选项相关，参见下文 rules 配置额外的加载器，默认加载器包含 babel-loader, vue-loader, json-loader, raw-loader, ejs-loader, url-loade, css-loader, less-loader, fast-sass-loader，可加载的文件可想而知 undefined cssModules 是否使用 css modules undefined babel 选项： 选项 意义 默认值 presets 配置额外的 presets，默认包含 ‘babel-preset-env’, ‘babel-preset-react’, ‘babel-preset-stage-0’ undefined plugins 配置额外的 plugins，默认包含 ‘babel-plugin-typecheck’, ‘babel-plugin-transform-decorators-legacy’, ‘babel-plugin-transform-runtime’ undefined targets 作用于 ‘babel-preset-env’，设定编译后脚本的适配环境 undefined browsers 适配的浏览器环境，默认适配 [ ‘last 2 versions’, ‘IE &gt;= 9’ ] undefined uglify targets 中属性，使用 uglify.js 压缩脚本前是否已编译成 es5，默认是，false 为否 undefined include 作用于 ‘babel-preset-env’，设定包含的插件 undefined exclude 作用于 ‘babel-preset-env’，设定移除的插件 undefined loose 作用于 ‘babel-preset-env’，是否允许插件启用 “loose” 转换，默认为否 undefined modules 作用于 ‘babel-preset-env’，将es6模块语法转换为何种模块规范语法，默认为 ‘commonjs’ undefined useBuiltIns 作用于 ‘babel-preset-env’，是否自动引入 ‘babel-ployfill’，默认使用时引入 undefined spec 作用于 ‘babel-preset-env’，是否允许插件启用 “spec” 转换，更符合规范，编译较慢，默认为 false undefined debug 作用于 ‘babel-preset-env’ undefined react 是否使用 ‘babel-preset-react’，默认使用，false 时不使用 undefined transform 作用于 ‘babel-plugin-transform-runtime’ undefined transform.helpers 是否内置 classCallCheck, extends 等，默认内置 undefined transform.polyfill 是否内置 Promise, Set, Map, Symbol 等，默认内置 undefined transform.regenerator 是否内置生成器函数，async 函数，默认内置 undefined transform.moduleName 模块名，import 导入需要，默认为 ‘babel-runtime’ undefined transform.useBuiltIns 默认自动引入 undefined addExports 影响 ‘babel-plugin-add-module-exports’ 插件的使用（该插件可在模块转换成 common.js，无需从default 属性中取出模块导出内容），false 时不使用 ‘babel-plugin-add-module-exports’ undefined strict 影响 ‘babel-plugin-transform-remove-strict-mode’ 插件的使用，true 时不使用 undefined 事件： ‘webpack.opts’，可用于修改 opts 配置项，参数 opts。 ‘webpack.config’，可用于修改注入 webpack 的 config 配置，参数 config, webpack, opts。 ‘webpack.compiler’，操纵 webpack 的编译器，参数 compiler。 ‘webpack.stats’，可用于监控编译状态，参数 stats。 dn-middleware-server概述：基于 nokit，启动本地服务。首次执行时将在项目空间创建 server.yml 配置文件。 奥妙： 在 nokit 服务器中设置拦截器，通过 httpProxy 转发请求。 ctx 中添加 server 属性，即 nokit.Server 实例；以及 httpServer 属性，即 server.httpServer。 选项： 选项 意义 默认值 host 主机，影响自动访问的页面地址 ‘http://localhost&#39; config 配置文件路径，作为 nokit 服务器的配置文件路径，默认读取 server.yml ‘server’ public 浏览器端访问资源文件的路径 ‘./build’ port 端口，默认使用 ctx.oneport 检测空闲的端口 undefined autoOpen 是否自动访问网页，false 时为否 undefined server.yml 中 proxy 支持配置选项： 选项 意义 默认值 rules 转发路径匹配规则，如 ^/api(.*): ‘https://www.aliyun.com/&#39; {} options 作为 Proxy Server 的选项 { xfwd: true, changeOrigin: true } headers 设置代理请求的 header 头，如 Referer: ‘https://www.aliyun.com/&#39; 可携带 cookie undefined 事件： ‘server.init’，服务未启动时事件，参数 server 实例。 ‘server.start’，服务启动成功时事件，参数 server 实例。 dn-middleware-dll概述：独立构建项目依赖，节省打包时间。 奥妙： 借助 ctx.exec 方法执行 webpack 中间件，打包项目的依赖，默认存放在工程目录 .cache 文件夹内。子文件夹名基于项目所使用的依赖通过 md5 生成散列，以便在依赖更新时重新打包。再借助 ctx.exec 方法执行 copy 中间件，将打包文件拷贝到 build/js 文件夹内。 通过 ‘webpack.config’ 事件，在 webpackConfig 插件中注入 webpack.DllReferencePlugin 插件。 选项： 选项 意义 默认值 output 打包文件输出位置 ‘build/js’ libName 打包文件名 ‘lib’ compress 是否压缩打包文件，默认压缩，false 时不压缩 undefined vendors 待打包模块列表，默认为 package.json 中依赖 undefined dn-middleware-faked概述：基于 faked 提供数据模拟服务。 奥妙： 基于 faked 创建 gui server 服务器，配置的模拟数据将输出到工程目录 mock 文件夹中 index.js, gui.data.json。 模拟数据文件最终将作为 webpack 入口文件，以此实现远程请求的拦截，并实现热更新。 执行逻辑被封装为 ctx.faked.apply 方法，在 dn-middleware-webpack 中执行，两个中间件耦合度较高。 选项： 选项 意义 默认值 dir 打包文件输出位置 ‘mock’ port gui server 服务启动的端口号，默认使用 this.utils.oneport 检出 undefined gui 禁用 gui server 服务 ‘build/js’ dn-middleware-i18n概述：将工程目录中 locales 语言包加载为 $locales 模块，通过 $i18n 获取指定模块，实现国际化。 奥妙： 使用 confman.webpackPlugin 方法将工程目录中的语言包输出为 $locales 虚拟模块。 使用 vmodule-webpack-plugin 类库输出 $i18n 虚拟模块，以获取指定文案。 选项： 选项 意义 默认值 dir 语言包所在位置 ‘./locales’ extract 指定将语言包输出为单独的 js 资源的文件夹路径，默认不输出单独的脚本 null 其他 dn-middleware-clean，清理文件或目录，可用 opts.target 加以配置，默认清理 ‘./build/*/.*’。 dn-middleware-copy，复制文件。选项 from 查询源文件的文件夹路径，默认 ‘./from’; to 目标文件夹路径; log 是否打印日志; dot 源文件匹配规则是否支持 ‘.’ 起始; direction 影响映射 key 键指代源文件还是目标文件; files 源文件和目标文件映射，目标文件路径支持占位符 {index} 替换（index 自右而左），或使用源文件路径（映射中，目标文件以 ‘/‘ 结尾）。 dn-middleware-browser-sync 基于 ‘browser-sync’ 监听打包文件变更，借助 ‘connect-browser-sync’ express中间件实现热更新。选项 files 配置监听的文件，默认 [‘./build/*/.*’]；port 为 ‘browser-sync’ 服务启动端口，默认 5001。 dn-middleware-git-sync，git 操作，包含 commit, push 动作（push 又区分日常和预发环境）。 dn-middleware-jcs，在 babel-loader 中添加 ‘jsx-control-statements’ 插件，以使 jsx 可使用结构控制语句，同时 lint 阶段也会作代码检查，参考 通过 JSX Control Statements 编写 JSX。 dn-middleware-lint，使用 eslint 命令作语法检查。 dn-middleware-tslint，对 typescript 进行语法检查。 dn-middleware-typedoc，使用 typedoc 为 typescript 项目生成文档。 dn-middleware-typescript，在 webpackConfig 中添加 awesome-typescript-loader，支持编译 tsx 模块。选项 declaration 是否分离 ts, js 文件，默认分离，false 时不分离。 dn-middleware-pkginfo，更新项目 package.json 中的 name, version, description 信息。 dn-middleware-prepush，在 .git/hooks/pre-push 添加 shell 命令，推送前执行 dn build 命令。 dn-middleware-sensitive-path，在 webpackConfig 中添加 ‘case-sensitive-paths-webpack-plugin’ 插件，使 mac, windows 引入模块时严格区分模块的大小写。 dn-middleware-shell，调用 ctx.utils.exec 执行 shell 命令。选项 script 命令内容；wscript 为 windows 系统下命令内容；async 是否异步执行，默认同步。 dn-middleware-watch，基于 ‘chokidar’ 监听执行文件变更。选项 match 匹配的文件，默认为 ‘./src/*/.*’；event 监听的事件类型；script 事件发生后执行的脚本；onChange 事件发生后执行的动作。 dn-middleware-unit，基于 ‘mocha’ 对 ./test/unit 文件夹中内容作单元测试。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"mobx使用探微","slug":"frontend/library/mobx使用探微","date":"2018-08-21T16:00:00.000Z","updated":"2020-03-08T10:45:48.826Z","comments":true,"path":"2018/08/22/frontend/library/mobx使用探微/","link":"","permalink":"http://xzfyu.com/2018/08/22/frontend/library/mobx使用探微/","excerpt":"","text":"前言写作这篇文章的起因是我有感于实际项目中所遇到的问题。因此，这篇文章只算是摸索的产物，远未臻于完美。在这里，我谨期望阅读这篇文章的同学能够见仁见智，各洒江海。 我所遇到的问题，总结如下： 项目采用分层设计，pages 为视图层，stores 为模型层，services 为服务层。从某种意义上讲，代码是按功能单元进行划分的，而不是业务单元。需要分别从 pages, stores, services 层取出相应的模块，才能构成一个完整的业务单元。分层设计的优点在于代码组织的清晰性，但是降低了可移植性。当需要向第三方应用输出某个业务单元时，就不得不另起炉灶，需要重新为特定的视图组件串联 stores。 无论 stores 层，还是 services 层，代码设计大都以视图为出发点，比如 services 层多次对同一个后台接口实现了调用，比如 stores 混杂着特定页面的视图状态，不利于复用。通过这一点，所能感知的症结是，stores 层中的模块称不上是对数据模型的精要抽象。除此以外，这个病症所体现的另一个特征是，stores 层中的模块常常仅作为视图组件和 ajax 接口的桥接层，即简单地将接口数据灌入到视图中、或者将视图数据提交到远端。这样做的好处是 store 极为轻量，但是，其一，远没有挖掘 mobx 用于组织数据模型的价值（近于使用 redux 处理纯数据），其二，store 没法涵盖数据特征，数据在视图层消费时才能展现其意义。事实上，数据处理中的 value - text 转换也常常会落在视图层。这样，在另一张需要消费同一份数据的视图页面中，就仍需要重做一份数据转换处理。 以上种种，促使我在业余时间着意摸索 mobx 的使用。很显然的，需求是技术提升的动力。离开项目环境，仅凭有限的知识和经验储备，我没办法复现实际项目的业务复杂度。相形之下，我所思忖的案例是较为简单的。因此，由这篇文章引出的种种观点无疑都是可商榷的。不过，有什么是一成不变的呢？譬如武侠小说中提到的，“剑招是死的，人是活的”。我再次期望阅读这篇文章的同学对本文所引出的命题有所意会、有所领悟，而对形式上的糟粕持宽容的态度；若是能以丰富的开发经验对我有所指教，那就再好不过了。 备注：示例代码通过自制的 plutarch 脚手架 实现，托管仓库地址为 mobx-demo 。 案例前情案例将提取商城系统中的产品配置环节，绘制的页面仅包含产品列表页、产品编辑页和产品详情页。介于案例旨在于探讨 mobx 的使用，势必会使业务屈从于所要考量的功能点，一反业务引导开发的常态。我个人的一些看法，在开发已集大成的前提下，由开发引导业务也未尝不是一种选项；系统设计的舵手譬如指挥官，所需的是纵览全局的能力，不扭于认知、经验和职司。假使一位富于远见的开发对多个商城系统的设计和实现已经了然于胸，他又怎不能称为建站工作的主导者呢？只不过这一点对大多数人来说，都过于理想化，很能达成。毕竟职业、天赋和精力的限制，会让我们的成长道路都有所局限。当然，这是题外话。言归正传，本案例涵盖的考察要点包括： 适用于多个页面的 Product 商品模型。 互为关联的 Product, Attribute 商品属性模型。 以上两点，都是以数据模型为导向的，而不是着眼于页面绘制。从职责来看，前端的工作内容是绘制页面，页面逻辑在部分人眼里只是个子内容。但从整体来看，数据才是内容，视图只是表现。mobx 所提供的强大能力不止于像 redux 那样单纯处理数据流，而在于它通过代理提供了数据建模的可能。如果说 redux 是面向过程编程，那么 mobx 就是面向对象编程。附着的那层响应式操作不改变原有类的特征，使我们能更大程度地使用这个类。这是在响应式之外，使用 mobx 编程时尤其需要有所发现的点。下文将作深入探讨。 当前端的开发工作以数据模型为导向时，就更能契合后端的表结构设计、模型层实现，抽象程度也更高，自然能加深对业务的理解。另外，数据处理也不至于散落在视图层。 对于考察要点中的第二项，所需说明的是案例持有的业务特征。当我们访问淘宝，会发现手机从属于“家电 / 数码 / 手机”这一大类，“手机”这一小类；对于“手机”这一小类，还有诸如”机身内存ROM”，“手机类型”，“网络类型”，“附加功能”，“摄像头类型”，“分辨率”等特有属性。可以料想的是，这些特有属性和“手机”这个小类呈联动关系，即 Attribute 有单独的表设计（特征量和特征值双表）。特别说明这一点，既是为了剖析案例所有的业务特征，也是为了表明案例更大程度上植根于猜想，我并没有参与商城开发的十足经验，错谬也在所难免，期望阅读这篇文章的同学海涵。 简易的表结构设计如下（参考淘宝开放平台的商品接口设计）： 图 1，简要表结构 如上图所示，Product 产品表包含 cids 字段指向 Category 分类表，attrs 字段用于聚合 Attribute 属性特征量表和 Attr_Value 属性特征值表。贴图的表结构虽然难免会有差池，但不妨碍本文用于探讨 mobx 的使用。为了简化案列的复杂度，本文也约定 Category, Attribute, Attr_Value 表中的数据不需要另行制作配置页面注入数据。 基于以上，相应接口如下，相关代码参考托管仓库中的 plutarch.mock.js 文件： get api/category 接口用于获取产品类目，传参 level 用于区分检索大类还是小类，cid 用于锁定产品类目。 get api/attributes 接口用于获取与类目相关的属性，传参 cid 用于锁定产品类目。 post api/product 接口用于保存或更新产品。 get api/product 接口用于获取产品。 get api/products 接口用于获取产品列表。 delete api/product 用于删除产品。 案列实现案例仍采用分层架构（如何以业务单元形式组织代码暂留作后续的思考命题）： 图 2，整体架构 requset 模块：基于 aioxs 类库处理 ajax 请求，使用拦截器诊断错误的响应，并使用 antd/message 组件在页面中显示错误内容（该组件能同时展现多个请求错误）。 services 层：使用 class 语法构造，便于继承，同时也继承了 Cache 类，用于缓存比较稳定的接口数据。同时，utils 工具包提供了 mixinStaticProperty 装饰器，用于将 services 层输出类的原型方法注入为 model 类的静态方法，参见 stores/models/Product 类的实现。services 层也可以用于拆分接口，如 services/category 将 getCategory 接口拆分为 getCategoryByCid, getCategoryByLevel 两个接口。这样便于更细微的控制，当然，拆分接口的稳定性另当别论。 stores/models 基本数据模型：数据模型分为两类，一类需要深入数据库或后台模型的数据特征，如 Product 类拥有诸多的可观察属性，便于以方法的形式操作这些属性值的变更，而列表也是由这些类自底而上构成的；另一类则采用数目不多的属性批量更新的机制实现，不需要微操数据的变更，所包含的方法通常也只跟远程请求相关，如 Category, Attribute 类。 stores 层其余衍生数据模型：基于 models 实现，与页面实际交互的模型，如由 Product 类衍生出 ProductInEdit, ProductInDetail, ProductList 三个类，即分别应用于编辑页、详情页和列表页。编辑页和详情页所使用的模型均可拓展 Product 类实现，案列出于职责分离的考虑，将其细分为多个子类。当然，也可以像案列中 Category 类的实现那样，在该类中聚合多种只能，比如全量拉取产品分类数据，以及只拉取针对某个产品的分类数据。同时，为了更好地实现数据处理，Category, Attribute 类均输出实例作为 Product 的实例属性，这样能聚合该产品的分类、属性数据处理操作。 pages 层：当 stores 层通过数据模型承担数据处理操作时，pages 理论上只承担了展示职能。介于 mobx 实现代理数组的特殊性，改变数组项的内部属性只能通过观察该数组项完成，列表操作又需要调用代理数组的方法，才能启动重绘。因此，使用 mobx 注入可观察数据时，首先，组件的颗粒度需要得到细化处理，其次，在删除某个数组项如某个产品时，不禁需要调用 product.delete 方法，也需要调用调用 products.splice 方法，使列表得到重绘。 locales 层：提供国际化文案，使用命名空间拆分成 action, model,text 三大类。action 包含操作类文案，model 包含数据模型相关文案，text 包含标题、消息和普通文本。国际化文案可直接注入视图层，或者经由 model 作转化处理后注入视图层，后者作为 model 的静态属性注入视图层。 以下内容将通过代码展示部分实现。 数据缓存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let caches = &#123;&#125;;class Cache &#123; // 设置数据缓存 setCache(actionName, key, value)&#123; if ( !caches[actionName] ) caches[actionName] = &#123;&#125;; caches[actionName][key] = value; &#125; // 获取数据缓存 getCache(actionName, key)&#123; const cache = caches[actionName]; return cache &amp;&amp; key !== undefined ? cache[key] : cache; &#125; // 清除数据缓存 clearCache(actionName)&#123; caches[actionName] = undefined; &#125;&#125;class CategoryService extends Cache &#123; async getCategory(params)&#123; const &#123; cid, level &#125; = params; if ( level !== undefined ) return this.getCategoryByLevel(level); else if ( cid !== undefined ) return this.getCategoryByCid(cid); &#125; // 在 service 层将 getCategory 拆分成多个针对请求的微处理接口 // 必要时使用缓存数据 async getCategoryByLevel(level)&#123; let res = this.getCache('getCategoryByLevel', level); if ( res ) return res; res = await get('/api/category', &#123; level &#125;); this.setCache('getCategoryByLevel', level, res); return res; &#125; async getCategoryByCid(cid)&#123; let res = this.getCache('getCategoryByCid', cid); if ( res ) return res; res = await get('/api/category', &#123; cid &#125;); this.setCache('getCategoryByCid', cid, res); return res; &#125;&#125; 以上代码通过 Cache 类实现数据缓存功能，CategoryService 类继承后，将根据请求内容、原型方法名缓存 ‘/api/category’ 接口的响应数据。同时，getCategory 接口也视页面中的调用情况拆分为 getCategoryByLevel, getCategoryByCid 两个原型方法，也许这是画蛇添足的一个举动，既会使代码不够简易，在后台接口变动时，又会增加额外的修改量，不过却暗含着一种可能，利弊交由阅读这篇文章的同学自行判断。 以上代码存在的优化点： 缓存 key 键的兼容度，Cache 类实现上仅能处理有请求参数的情形，而有些可以作缓存的接口没有请求参数。 缓存的时效问题，Cache 类的缓存机制在当前访问过程中均有效，在该时间段无法拉取数据库中已作更改的最新值。 数据模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 可采用继承的方式将远程请求方法混入到 Product 类中，此处使用 mixinStaticProperty 装饰器混入静态方法@mixinStaticProperty(ProductService)export default class Product &#123; @observable id;// 商品id @observable name;// 商品名称 @observable cids;// 商品分类 @observable attrValues = &#123;&#125;;// 商品属性 @observable num;// 库存 @observable price;// 价格 @observable desc;// 描述 @observable status;// 状态 constructor(props)&#123; this.setValues(props); &#125; // 后台交互数据全量更新；部分更新可直接使用赋值语句；重置可传空 @action setValues(data = &#123;&#125;)&#123; this.id = data.id; this.name = data.name; this.cids = data.cids; this.attrValues = data.attrValues || &#123;&#125;; this.num = data.num; this.price = data.price; this.desc = data.desc; this.status = data.status; &#125; // 获取后台交互数据 getValues()&#123; return &#123; id: this.id, name: this.name, cids: this.cids, attrValues: this.attrValues, num: this.num, price: this.price, desc: this.desc, status: this.status &#125;; &#125; @action async getProduct(id)&#123; const res = await Product.get(&#123; id &#125;); if ( res ) this.setValues(res); return res || null; &#125; @action async saveProduct()&#123; const params = this.getValues(); const res = params.id ? await Product.update(params) : await Product.save(params); return res; &#125; @action async deleteProduct()&#123; const res = await Product.del(&#123; id: this.id &#125;); return res; &#125;&#125; 以上代码为 Product 基类，可以看出，实现上同后台提供的接口和数据模型均强关联，其一通过 observable 装饰器将后台提供的字段全部转化为可观察属性，并提供 setValues, getValues 批量赋值和取值（通常在提交数据前、获取数据后，需要调用这两个方法）；其二以原型方法实现 ajax 调用，这里既可以继承 services 层中的类，也可以使用 mixinStaticProperty 装饰器注入静态方法。 Product 基类化用了 backbone 模型特征，可以优化的点： 代码自动生成。通过 Product 基类也能发现，该类数据模型拥有很高的类同点，基于后台数据模型及接口实现 mobx 数据模型基类，如果能根据 jar 包和配置文件，自动生成这些基类文件，那就再好不过了。当然，这对我来说，也是短期内没法办到的事。需要走的路还长着呢。 案列中没有考虑两份提交数据，多个接口调用，比如产品状态更新，就需要多一份产品状态提交数据，再调用状态更新的接口。因此，我的一些想法还没经过实践沉淀，合理性和稳定性势必存疑，比如前一条优化建议。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class ProductInDetail extends Product &#123; attribute = new Attribute(); category = new Category(); @observable categories = [];// 商品分类全量信息 @observable attributes = [];// 商品属性全量信息 // 备注，改变单个数组项的属性不会引起视图重绘，必须在数组中改变整个数组项 // 在 product 实例初始化过程中调用 getCategories 方法，不会引起 Table 视图的重绘 @action async getCategories(cids)&#123; this.categories = []; const res = await this.category.getCategoryByCids(cids); if ( res ) this.categories = res; return res; &#125; // 获取商品分类文案 @computed get categoryTexts()&#123; return this.categories.map(item =&gt; item.name).join(', '); &#125; // 获取属性 @action async getAttributes(cid)&#123; this.attributes = []; const res = await this.attribute.getAttributes(&#123; cid &#125;); if ( res ) this.attributes = res; return res; &#125; @computed get attributeTexts()&#123; const &#123; attrValues, attributes &#125; = this; if ( !Object.keys(attrValues).length || !attributes.length ) return []; let result = []; Object.keys(attrValues).map(key =&gt; &#123; const attr = attributes.find(attr =&gt; attr.id == key); const name = attr.name; let value = attrValues[key].map(val =&gt; &#123; return attr.options.find(item =&gt; item.id == val).name; &#125;); result.push(&#123; name, value &#125;); &#125;); return result; &#125; // 获取商品状态文案 @computed get statusText()&#123; let text = StatusList.filter(item =&gt; item.value === this.status)[0].text; return text; &#125;&#125;class ProductInEdit extends Product &#123; attribute = new Attribute(); @observable attributes = [];// 商品属性全量信息 // 获取属性 @action async getAttributes(cid)&#123; this.attributes = []; const res = await this.attribute.getAttributes(&#123; cid &#125;); if ( res ) this.attributes = res; return res; &#125; // 编辑页显示数据 @computed get pageValues()&#123; let attrValues = &#123;&#125;; Object.keys(this.attrValues).map(attrId =&gt; &#123; attrValues[`attrId$&#123;attrId&#125;`] = this.attrValues[attrId]; &#125;); return &#123; name: this.name, cids: this.cids, attrs: attrValues, num: this.num, price: this.price, desc: this.desc &#125;; &#125;&#125; 以上代码基于 Product 类实现详情页、编辑页专用的数据模型，无非获取远程数据，进行 value - name 值转换。在获取远程数据时，可以将另一个数据模型以实例属性的方式注入到当前数据模型中，以便于在当前模型中作数据转换处理，同时增加了模型之间的耦合度。 1234567891011121314class ProductList &#123; @observable products = []; @action async getProducts()&#123; this.products = []; const res = await Product.query(); (res || []).map(item =&gt; &#123; this.products.push(new Product(item));// 此处 Product 为 ProductInDetail &#125;); return res; &#125;&#125;; ProductList 类基于 ProductInDetail 实例构建数组项，以便于在视图层绘制列表时直接绘制 ProductInDetail 实例的计算属性或者调用其远程请求接口。 并行请求并行请求可以在视图层通过 Promise.all 加以组织，也可以在模型层组织同一类并行请求接口，如 Category 模型中通过 getCategoryByCids 方法获取产品的多个类目信息。当然，这部分内容通常由后端同学帮忙完成，这里仅展示前端代码实现上的一种可能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Category extends CategoryService &#123; @observable categories = []; @action insertToCategories = (category = &#123;&#125;) =&gt; &#123; if ( !this.categories.some(item =&gt; item.id == category.id) )&#123; this.categories.push(category); &#125;; &#125; async getCategory(params)&#123; const res = await super.getCategory(params); if ( res )&#123; // 将多次数据变更合成一个事务，减少重绘的次数 transaction(() =&gt; &#123; res.map(item =&gt; &#123; this.insertToCategories(item); &#125;); &#125;); &#125;; return res; &#125; // 处理并行请求 getCategoryByCids(cids)&#123; return new Promise((resolve, reject) =&gt; &#123; this.categories = []; cids.map(async cid =&gt; &#123; const res = await this.getCategory(&#123; cid &#125;); if ( !res ) reject(res); // 最后一个请求，响应通过 insertToCategories 方法收集到 categories 属性中 if ( cids.length == this.categories.length ) resolve(this.categories); &#125;); &#125;); &#125; // 传入 cids，便于并行请求 getCategoryByLevels(cids)&#123; return new Promise((resolve, reject) =&gt; &#123; cids.map(async (cid, index) =&gt; &#123; const res = await this.getCategory(&#123; level: index + 1 &#125;); if ( !res ) reject(res); if ( index + 1 === cids.length ) resolve(this.categories); &#125;); &#125;) &#125; @computed get categoriesTree()&#123; let tree = []; this.categories.toJS().sort((a, b) =&gt; a.level - b.level).filter(item =&gt; &#123; if ( item.level == 1 )&#123; tree.push(&#123; value: item.id, label: item.name, isLeaf: false &#125;); &#125; else if ( item.level == 2 )&#123; let parent = tree.filter(it =&gt; it.value == item.parentId)[0]; if ( !parent.children ) parent.children = []; parent.children.push(&#123; value: item.id, label: item.name &#125;); &#125;; &#125;); return tree; &#125;&#125; 视图组件组件层即如上文所说的，所需注意的是 mobx 中数组的特殊性，单纯赋值数组项的属性不会引起观察数组的组件重绘，而需要将组件的颗粒度锁定为观察数组项，如下方代码的 CategoryText 组件。删除数组项时，也需要调用代理数组的 splice 方法，才能引起列表组件重绘，如 ProductList 组件内 deleteProduct 方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@observerclass CategoryText extends Component&#123; componentDidMount()&#123; const &#123; product, loadCategory &#125; = this.props; if ( loadCategory ) product.getCategories(product.cids); &#125; render()&#123; const &#123; product &#125; = this.props; return product.categoryTexts; &#125;&#125;;@inject('productList')@observerclass ProductList extends Component &#123; columns = [&#123; title: $i18n('model.product.id'), dataIndex: 'id', key: 'id' &#125;, &#123; title: $i18n('model.product.name'), dataIndex: 'name', key: 'name', &#125;, &#123; title: $i18n('model.product.categories'), dataIndex: 'categories', key: 'categories', render: (categories, product) =&gt; &#123; return &lt;CategoryText product=&#123;product&#125; loadCategory=&#123;true&#125; /&gt; &#125; &#125;, &#123; title: $i18n('model.product.price'), dataIndex: 'price', key: 'price' &#125;, &#123; title: $i18n('model.product.num'), dataIndex: 'num', key: 'num' &#125;, &#123; title: $i18n('model.product.status'), dataIndex: 'statusText', key: 'statusText' &#125;, &#123; title: $i18n('model.product.desc'), dataIndex: 'desc', key: 'desc' &#125;, &#123; title: $i18n('action.handle'), key: 'action', render: (text, product, index) =&gt; ( &lt;span&gt; &lt;Link to=&#123;`/detail/$&#123;product.id&#125;`&#125; style=&#123;&#123;marginRight: '10px'&#125;&#125;&gt;&#123;$i18n('text.detail')&#125;&lt;/Link&gt; &lt;Link to=&#123;`/edit/$&#123;product.id&#125;`&#125; style=&#123;&#123;marginRight: '10px'&#125;&#125;&gt;&#123;$i18n('action.edit')&#125;&lt;/Link&gt; &lt;Popconfirm title=&#123;$i18n('text.product.delete_confirm')&#125; onConfirm=&#123;() =&gt; &#123; this.deleteProduct(product, index) &#125;&#125; okText=&#123;$i18n('action.ok')&#125; cancelText=&#123;$i18n('action.cancel')&#125;&gt; &lt;a href=\"javascript:;\"&gt;&#123;$i18n('action.delete')&#125;&lt;/a&gt; &lt;/Popconfirm&gt; &lt;/span&gt; ), &#125;]; componentDidMount()&#123; this.props.productList.getProducts(); &#125; // 删除商品 deleteProduct = async (product, index) =&gt; &#123; const &#123; products &#125; = this.props.productList; const res = await product.deleteProduct(); if ( res )&#123; products.splice(index); message.success($i18n('text.product.delete_success')); &#125;; &#125; render()&#123; const &#123; products &#125; = this.props.productList; return ( &lt;div&gt; &lt;Button style=&#123;&#123;marginBottom: '15px'&#125;&#125; type='primary'&gt; &lt;Link to=&#123;'/create'&#125;&gt;&#123;`$&#123;$i18n('action.create')&#125;$&#123;$i18n('text.product')&#125;`&#125;&lt;/Link&gt; &lt;/Button&gt; &lt;Table size=\"small\" rowKey='id' columns=&#123;this.columns&#125; dataSource=&#123;products.toJS()&#125; /&gt; &lt;/div&gt; ); &#125;&#125;; 更多代码，请参考 mobx-demo，也许阅读这篇文章的同学能有额外的发现呢。 后记《唐李问对》褒扬诸葛亮而贬低曹操，因为曹操的《孟德新书》适合于照章办事的生手，诸葛亮的《兵法二十篇》适合于独立思考的老手。其中的事理，和吴军博士在《数学之美》中论述道与术一样，浮于浅层的形式抵不过深入的理解。这是一篇富有探索气质的文章，更多地旨在于引发思考，而不是妄下定论。何况这篇文章对于 mobx 的使用及其实现内核的化用，也只是迈出了小小的一两步。要走的路还长着呢。 参考淘宝开放平台 - 文档中心淘宝商品数据库设计","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"mobx源码分析（二） 订阅响应式数据","slug":"frontend/library/mobx源码分析2","date":"2018-08-14T16:00:00.000Z","updated":"2020-03-08T10:45:48.826Z","comments":true,"path":"2018/08/15/frontend/library/mobx源码分析2/","link":"","permalink":"http://xzfyu.com/2018/08/15/frontend/library/mobx源码分析2/","excerpt":"","text":"前言处理问题有两种方式，从一般到具体，或者从具体到一般。在写作这两篇文章时，我选择了后者，一是因为我在写作这篇文章的过程中才逐渐摸清 mobx 的设计和实现，二是因为我自身尚不具备足够的积淀，能站在更高的抽象维度对问题的一般面加以思索。上一篇文章对各种数据结构的处理无疑都是具体的，本文将介入如何抽象 observable，即对上一篇文章中的公有特征 reportObserved, reportChanged 方法加以萃取。 本文也将致力于解答上一篇文章遗留的问题，怎样使观察者订阅响应式数据的变更。 总而言之，本文将串联 mobx 的核心运作机制，从执行动作 action 促使响应式数据 observable 变更，到响应式数据变更引起衍生 derivation 执行的一整个过程。 概念首先，我们先来看一下 mobx 设计的几种抽象概念： observable: 响应式数据，最主要的特征是将数据变更信息上报给全局监听器。mobx 使用 IObservable 接口，Atom 类加以抽象。 derivation: 衍生，响应式数据变更后执行的副作用函数，包含计算属性、反应。mobx 使用 IDerivation 接口，ComputedValue 类、Reaction 类加以抽象。 action: 动作，由其促使响应式数据发生变更。上一节已指出，使用 observableValue 实例的 set 方法，就能促使响应式数据发生变更，action 的意义在于，使用 startBatch, endBatch 事务发生执行动作，能整合一组响应式数据变更，在这一组响应式数据变更完成后，再执行 derivation 衍生。在 mobx 中，action 是很轻的一层，因为将响应式数据变更上报到全局环境由 observable 完成，action 中的逻辑处理即是在动作执行期间使用事务加以包裹，并根据配置项判断响应式数据只能在 action 中完成。在这篇文章中将不作赘述。 图 1，observable, derivation 类图 observable对于 observable，所需考虑的是，响应式数据变更会引起指定的观察者执行其处理逻辑；当响应式数据没有指定观察者时，数据变更就不会引起衍生的执行。为此，在 mobx 抽象的 IObservable 接口中，observers 属性为 observable 绑定的观察者队列；lowestObserverState 属性为状态标识，用于标记数据是否被更新，需要执行相应的衍生；diffValue 属性用于实时更新 observable, observer 的依赖关系。 此外，在 IObservable 接口中，mobx 还提供了 onBecameUnobservered, onBecameObservered 钩子，分别在 observable 不被监听或被监听时得到调用；lastAcessedBy（最后消费 observable 的观察者 id）, isBeingObserved 属性用于使 onBecameObservered 钩子不被反复调用；isPendingUnobservation 属性用于使 onBecameUnobservered 钩子不被反复执行。与配置项相当，属性需要通过翻阅源码中的逻辑实现，才能确切感知到该属性存在的价值。介于部分属性与核心流程无关，在这里将只作简要讨论或不作讨论。 Atom 类除了实现 IObservable 接口以外，额外新增了 reportObserved, reportChanged 方法。顾名思义，当 observable 被观察时，需要显示调用 reportObserved 方法；当 observable 数据变更时，需要显示调用 reportChanged 方法。更多内容，参见前文 - mobx 源码分析（一）构造响应式数据。 derivationderivation 可以理解为实际消费 observable 的观察者，因此，本文中的 observer 指代的也就是 derivation。在 mobx 实现中，observable, derivation 相互持有彼此的引用。IDerivation 接口的 observing 属性本次衍生在哪些响应式数据变更时执行；dependenciesState 属性为状态标识，用于标记本次衍生观察的数据是否已经改变，是否运行期处理逻辑；onBecomeStale 方法就是当观察数据变更时，运行的处理逻辑；newObserving 属性用于变更 observable, derivation 的依赖关系（在于观察者可改变观察的数据）；unboundDepsCount 属性用于统计本次衍生所观察的数据量，同 observable.diffValue 一样，目的都在于实时更新 observable, derivation 的依赖关系。 除了上述属性和方法，IDerivation 接口还提供了 runId 属性，由它构成 observable.lastAcessedBy 的值；isTracing 属性标记日志级别，以便在 onBecomeStale 方法执行前打印日志。 IDerivation 接口有两种实现，其一是作为反应的 Reaction 类，其二是作为计算属性的 ComputedValue 类。这两个类都实现了具体的 onBecomeStale 方法。reaction.onBecomeStale 方法的表现是在所有响应式数据变更完成后，再对相关的衍生执行批处理操作，当然，在同一个批处理周期内，不会再对由 reaction 引起的衍生加以处理，这些衍生需要等待下一个批处理周期。ComputedValue 的特别之处是，它既是衍生，观察着数据变更；又是响应式数据，被其他衍生所观察。因此，computedValue.onBecomeStale 方法的处理逻辑是在其他衍生执行 onBecomeStale 过程中，重新获取计算属性的值。 运作机制reportObserved当响应式数据被衍生订阅时，将会执行 obsrvable.reportObserved 方法。在该方法的执行过程中，无他，就是针对当前执行的衍生调用其观察的响应式数据的 onBecameObserved 方法；或者将该 obsrvable 实例添加到 globalState.pendingUnobservations 数组中，等待事务结束时，执行 observable.onBecomeUnobserved 与 computedValue.suspend 方法。这里不再作介绍。 reportChanged图 2，reportChanged 执行流程 结合上图，当响应式数据发生变更时，mobx 的处理机制为： 通过 observable.reportChanged 方法将响应式数据变更的信息上报到全局监听器。 observable.reportChanged 执行过程中，使用 startBatch, endBatch 函数将 propagateChange(observable) 包裹到事务处理流程中。mobx 中的事务通过 globalState.inBatch 计数器标识：在 startBatch 函数执行过程中，globalState.inBatch 加 1；在 endBatch 函数执行过程中，globalState.inBatch 减 1；当 globalState.inBatch 为 0 时，表示单个事务处理结束。因为事务的意义在于将并行的响应式数据变更视为一组，在一组变更完成之后，在执行相应的衍生。 在同一个事务处理流程中，首先通过 propagateChange(observable) 间接将 derivation 加入到 globalState.pendingReactions 队列中。该过程中通过调用 derivation.onBecameStale 方法实现。对于 reaction 反应，在事务执行期间，直接将 reaction 添加到 globalState.pendingReactions 队列；对于 computedValue 计算属性，间接将观察 computedValue 变更的 reaction 添加到 globalState.pendingReactions 队列。 在 endBatch 函数执行期间，通过调用 runReactions 方法遍历 globalState.pendingReactions 队列，执行 reaction.runReaction 方法。每个 reaction.runReaction 方法内部的执行逻辑中，包含 observer 依赖和状态更新，以及执行用户实际注册的监听函数。reaction.runReaction 方法的处理细节将在后文加以分析。 在事务处理的尾端，又将遍历 globalState.pendingUnobservations 数组，调用 observable.onBecomeUnobserved 方法。对于计算属性，额外调用 computedValue.suspend() 方法。这样的目的在于当前没有观察者监听这些 observable 或 computedValue 的变更，无需将数据变更上报到全局环境。 代码段 1，reportChanged 处理流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class Atom implements IAtom &#123; public reportChanged() &#123; startBatch() propagateChanged(this) endBatch() &#125;&#125;function startBatch() &#123; globalState.inBatch++&#125;function endBatch() &#123; if (--globalState.inBatch === 0) &#123; runReactions() const list = globalState.pendingUnobservations for (let i = 0; i &lt; list.length; i++) &#123; const observable = list[i] observable.isPendingUnobservation = false if (observable.observers.size === 0) &#123; if (observable.isBeingObserved) &#123; observable.isBeingObserved = false observable.onBecomeUnobserved() &#125; if (observable instanceof ComputedValue) &#123; observable.suspend() &#125; &#125; &#125; globalState.pendingUnobservations = [] &#125;&#125;function propagateChanged(observable: IObservable) &#123; if (observable.lowestObserverState === IDerivationState.STALE) return observable.lowestObserverState = IDerivationState.STALE observable.observers.forEach(d =&gt; &#123; if (d.dependenciesState === IDerivationState.UP_TO_DATE) &#123; d.onBecomeStale() &#125; d.dependenciesState = IDerivationState.STALE &#125;)&#125;function propagateMaybeChanged(observable: IObservable) &#123; if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return observable.lowestObserverState = IDerivationState.POSSIBLY_STALE observable.observers.forEach(d =&gt; &#123; if (d.dependenciesState === IDerivationState.UP_TO_DATE) &#123; d.dependenciesState = IDerivationState.POSSIBLY_STALE d.onBecomeStale() &#125; &#125;)&#125;class ComputedValue&lt;T&gt; implements IObservable, IComputedValue&lt;T&gt;, IDerivation &#123; onBecomeStale() &#123; propagateMaybeChanged(this) &#125;&#125;class Reaction implements IDerivation, IReactionPublic &#123; onBecomeStale() &#123; this.schedule() &#125; schedule() &#123; if (!this._isScheduled) &#123; this._isScheduled = true globalState.pendingReactions.push(this) runReactions() &#125; &#125;&#125;let reactionScheduler: (fn: () =&gt; void) =&gt; void = f =&gt; f()export function runReactions() &#123; if (globalState.inBatch &gt; 0 || globalState.isRunningReactions) return reactionScheduler(runReactionsHelper)&#125;function runReactionsHelper() &#123; globalState.isRunningReactions = true const allReactions = globalState.pendingReactions let iterations = 0 while (allReactions.length &gt; 0) &#123; let remainingReactions = allReactions.splice(0) for (let i = 0, l = remainingReactions.length; i &lt; l; i++) remainingReactions[i].runReaction() &#125; globalState.isRunningReactions = false&#125; 以上代码不但没有看见计算属性重新取值的实现，而且高度依赖于 observable 和 observer 的依赖关系和各自的状态标识，因此，我们会持有以下两个问题： reaction.runReaction 方法到底是怎样实现的？reaction 和 computedValue 又怎样相互影响？ mobx 怎样更新及维护 observable 和 observer 的依赖关系和状态标识？ runReaction图 3，reaction.runReaction 执行流程 结合上图，reaction.runReaction 针对以下两种情况作出处理： 当响应式数据引起的反应内部没有计算属性时，重新执行反应的处理逻辑。 当响应式数据引起的反应内部有计算属性时，且计算属性观察的数据改变时，通过 computedValue 方法重新获取计算属性的值，事务（在 reaction.runReaction 方法执行过程中，使用 startBatch 函数开启）的意义在于等待计算属性的重新计算。其他情况下使用原有的值。 需要留神的是，在 reaction.runReaction 方法中使用 startBatch 开启事务时，globalState.isRunningReactions 标识仍旧为真值，也就不会造成 globalState.pendingReactions 中未作处理的 reaction 被反复执行。 代码段 2，runReaction 处理流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104class Reaction implements IDerivation, IReactionPublic &#123; runReaction() &#123; if (!this.isDisposed) &#123; startBatch() this._isScheduled = false if (shouldCompute(this)) &#123; // 用户实际注册的监听函数经包装后将以 reaction.onInvalidate 形式呈现 this.onInvalidate() &#125; endBatch() &#125; &#125;&#125;function shouldCompute(derivation: IDerivation): boolean &#123; switch (derivation.dependenciesState) &#123; case IDerivationState.UP_TO_DATE: return false case IDerivationState.NOT_TRACKING: case IDerivationState.STALE: return true case IDerivationState.POSSIBLY_STALE: &#123; const prevUntracked = untrackedStart() const obs = derivation.observing, l = obs.length for (let i = 0; i &lt; l; i++) &#123; const obj = obs[i] if (isComputedValue(obj)) &#123; obj.get() if ((derivation.dependenciesState as any) === IDerivationState.STALE) &#123; untrackedEnd(prevUntracked) return true &#125; &#125; &#125; changeDependenciesStateTo0(derivation) untrackedEnd(prevUntracked) return false &#125; &#125;&#125;class ComputedValue&lt;T&gt; implements IObservable, IComputedValue&lt;T&gt;, IDerivation &#123; public get(): T &#123; if (this.keepAlive &amp;&amp; this.firstGet) &#123; this.firstGet = false autorun(() =&gt; this.get()) &#125; // 初始化获取绑定计算属性的依赖关系，或者在 action 中直接获取计算属性 if (globalState.inBatch === 0 &amp;&amp; this.observers.size === 0) &#123; if (shouldCompute(this)) &#123; this.warnAboutUntrackedRead() startBatch() this.value = this.computeValue(false) endBatch() &#125; // reaction.runReaction 处理逻辑中，将进入第二个条件分支 &#125; else &#123; reportObserved(this) if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this) &#125; const result = this.value! return result &#125; computeValue(track: boolean) &#123; globalState.computationDepth++ let res: T | CaughtException if (track) &#123; res = trackDerivedFunction(this, this.derivation, this.scope) &#125; else &#123; res = this.derivation.call(this.scope) &#125; globalState.computationDepth-- return res &#125; private trackAndCompute(): boolean &#123; const oldValue = this.value const wasSuspended = this.dependenciesState === IDerivationState.NOT_TRACKING const newValue = this.computeValue(true) const changed = wasSuspended || !this.equals(oldValue, newValue) if (changed) this.value = newValue return changed &#125;&#125;export function propagateChangeConfirmed(observable: IObservable) &#123; if (observable.lowestObserverState === IDerivationState.STALE) return observable.lowestObserverState = IDerivationState.STALE observable.observers.forEach(d =&gt; &#123; if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE else if ( d.dependenciesState === IDerivationState.UP_TO_DATE ) observable.lowestObserverState = IDerivationState.UP_TO_DATE &#125;)&#125; 上述代码中，对于 trackDerivedFunction 函数的处理逻辑，我将在下一小节予以分析。 依赖更新我们先来看一下 mobx 为 observable, observer 提供的状态值： IDerivationState.NOT_TRACKING：值为 -1，作为 derivation 的初始状态。当衍生不再订阅响应式数据时，derivation.dependenciesState 值也将被置为 NOT_TRACKING。 IDerivationState.UP_TO_DATE：值为 0，当响应式数据变更且衍生有执行时，derivation.dependenciesState 状态将被置为 UP_TO_DATE。 IDerivationState.POSSIBLY_STALE：值为 1，计算属性变更时，订阅计算属性的衍生状态将置为 POSSIBLY_STALE。若在 shouldCompute 函数执行环节，当确认计算属性的值未作变更时，derivation.dependenciesState 状态将被重置为 UP_TO_DATE；若作变更，状态将置为 STALE。 IDerivationState.STALE：值为 2，当衍生订阅的响应式数据或计算属性变更时，derivation.dependenciesState 状态将被置为 STALE，意味着衍生的逻辑需要重新启动。 图 4，状态标识更新流程 状态标识更新流程为： 当初次添加 derivation 时，状态标识置为 NOT_TRACKING。 当响应式数据更新，监听这个响应式数据的衍生包含 reaction，则将该 reaction 的状态置为 STALE；包含 computedValue，则将该 computedValue 状态置为 STALE，并通过 computedValue.onBecameStale 方法将订阅这个计算属性的反应 reaction 的状态置为 POSSIBLY_STALE。 在事务 endBatch 环节，通过 reaction.runReaction 方法的执行过程刷新该 reaction 和 observable 的绑定关系，并将 reaction 的状态标识置为 NOT_TRACKING（在 reaction 用户端逻辑执行过程中，添加了新的 observable） 或 UP_TO_DATE。若 reaction 还订阅了计算属性，则调用计算属性 computedValue.get 方法，通过这个方法的执行，刷新 computedValue 和 observable 的关系，并将其状态标识置为 NOT_TRACKING 或 UP_TO_DATE。 第 2 步的执行逻辑参见上文给出的 propagateChanged, propagatedMaybeChanged 函数；第 1, 3 两步均通过 trackDerivedFunction 函数实现。 代码段 3，derivation 状态更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function trackDerivedFunction&lt;T&gt;(derivation: IDerivation, f: () =&gt; T, context: any) &#123; changeDependenciesStateTo0(derivation) derivation.newObserving = new Array(derivation.observing.length + 100) derivation.unboundDepsCount = 0 derivation.runId = ++globalState.runId const prevTracking = globalState.trackingDerivation globalState.trackingDerivation = derivation let result if (globalState.disableErrorBoundaries === true) &#123; result = f.call(context) &#125; else &#123; try &#123; result = f.call(context) &#125; catch (e) &#123; result = new CaughtException(e) &#125; &#125; globalState.trackingDerivation = prevTracking bindDependencies(derivation) return result&#125;// 刷新 derivation 和 observable 的依赖关系，并将 derivation 的状态标识置为 UP_TO_DATE 或 NOT_TRACKINGfunction bindDependencies(derivation: IDerivation) &#123; const prevObserving = derivation.observing const observing = (derivation.observing = derivation.newObserving!) let lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE let i0 = 0, l = derivation.unboundDepsCount for (let i = 0; i &lt; l; i++) &#123; const dep = observing[i] if (dep.diffValue === 0) &#123; dep.diffValue = 1 if (i0 !== i) observing[i0] = dep i0++ &#125; if (((dep as any) as IDerivation).dependenciesState &gt; lowestNewObservingDerivationState) &#123; lowestNewObservingDerivationState = ((dep as any) as IDerivation).dependenciesState &#125; &#125; observing.length = i0 derivation.newObserving = null l = prevObserving.length while (l--) &#123; const dep = prevObserving[l] if (dep.diffValue === 0) &#123; removeObserver(dep, derivation) &#125; dep.diffValue = 0 &#125; while (i0--) &#123; const dep = observing[i0] if (dep.diffValue === 1) &#123; dep.diffValue = 0 addObserver(dep, derivation) &#125; &#125; // 对于新添加的观察数据，将 derivation 添加 globalState.pendingReactions 中，在当前事务周期中处理 if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) &#123; derivation.dependenciesState = lowestNewObservingDerivationState derivation.onBecomeStale() &#125;&#125;function changeDependenciesStateTo0(derivation: IDerivation) &#123; if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return derivation.dependenciesState = IDerivationState.UP_TO_DATE const obs = derivation.observing let i = obs.length while (i--) obs[i].lowestObserverState = IDerivationState.UP_TO_DATE&#125; trackDerivedFunction 函数在 mobx 中的实际调用过程： Reaction 构造函数提供了 track 实例方法。该实例方法执行过程中，将 trackDerivedFunction 函数更新 derivation 的状态和依赖关系，同时执行传参 fn 函数。实际在构造 Reaction 过程中，用户端执行逻辑将经由 autorun 函数使用 reaction.track 封装后构成 reaction.onInvalidate 方法，该方法将在 reaction.runReaction 执行过程中得到调用，而用户端执行逻辑也将作为 reaction.track 方法的参数 fn。这样就解释了响应式数据变更时，既会处理用户端执行逻辑，如使视图重绘，又会促使 reaction 的状态值得到更新。 ComputedValue 构造函数提供的 computeValue 实例方法，也会调用 trackDerivedFunction 函数。而 computedValue.get 实例方法将间接调用 computeValue 方法，从而使计算属性的状态得到更新。 代码段 4，trackDerivedFunction 实际调用，只限于 reaction12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Reaction implements IDerivation, IReactionPublic &#123; constructor( public name: string = \"Reaction@\" + getNextId(), private onInvalidate: () =&gt; void, private errorHandler?: (error: any, derivation: IDerivation) =&gt; void ) &#123; &#125; runReaction() &#123; if (!this.isDisposed) &#123; startBatch() this._isScheduled = false if (shouldCompute(this)) &#123; // 用户实际注册的监听函数经包装后将以 reaction.onInvalidate 形式呈现 this.onInvalidate() &#125; endBatch() &#125; &#125; track(fn: () =&gt; void) &#123; startBatch() this._isRunning = true const result = trackDerivedFunction(this, fn, undefined) this._isRunning = false this._isTrackPending = false if (this.isDisposed) &#123; clearObserving(this) &#125; endBatch() &#125;&#125;function autorun( view: (r: IReactionPublic) =&gt; any, opts: IAutorunOptions = EMPTY_OBJECT): IReactionDisposer &#123; const name: string = (opts &amp;&amp; opts.name) || (view as any).name || \"Autorun@\" + getNextId() let reaction: Reaction reaction = new Reaction( name, function (this: Reaction) &#123; this.track(reactionRunner) &#125;, opts.onError ) function reactionRunner() &#123; view(reaction) &#125; // 初始化绑定 reaction 和 observable 的依赖关系，并调用用户端执行逻辑 view reaction.schedule() return reaction.getDisposer()&#125; 接口层接口层的主要目的是将用户端执行逻辑在响应式数据变更后自动得到调用。 autoRunautoRun 函数的处理流程为：构建 Reaction 实例；初始化调用 reaction.schedule 方法，初次调用用户端执行逻辑 ，绑定 observer 和 observable 的依赖关系；使用 reaction.track 包装用户端执行逻辑，在响应式数据变更后，既负责更新 observer 和 observable 的依赖关系，又负责调用用户端执行逻辑。用户端执行逻辑通常表现为视图变更，因此也被标识为 view 函数。 在调用 autoRun 时，可以通过选项 opts.delay 或 opts.scheduler 调度 view 的执行时机。 完整代码如下： 代码段 5，autoRun 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function autorun( view: (r: IReactionPublic) =&gt; any, opts: IAutorunOptions = EMPTY_OBJECT): IReactionDisposer &#123; const name: string = (opts &amp;&amp; opts.name) || (view as any).name || \"Autorun@\" + getNextId() const runSync = !opts.scheduler &amp;&amp; !opts.delay let reaction: Reaction if (runSync) &#123; reaction = new Reaction( name, function (this: Reaction) &#123; this.track(reactionRunner) &#125;, opts.onError ) &#125; else &#123; const scheduler = createSchedulerFromOptions(opts) let isScheduled = false reaction = new Reaction( name, () =&gt; &#123; if (!isScheduled) &#123; isScheduled = true scheduler(() =&gt; &#123; isScheduled = false if (!reaction.isDisposed) reaction.track(reactionRunner) &#125;) &#125; &#125;, opts.onError ) &#125; function reactionRunner() &#123; view(reaction) &#125; reaction.schedule() return reaction.getDisposer()&#125;function createSchedulerFromOptions(opts: IReactionOptions) &#123; return opts.scheduler ? opts.scheduler : opts.delay ? (f: Lambda) =&gt; setTimeout(f, opts.delay!) : run&#125; reactionreaction 函数的处理基本同 autoRun，其主要区别是，用户端执行逻辑表现为当首参计算函数返回的终值发生改变时，执行次参副作用逻辑。 代码段 6，reaction 函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function reaction&lt;T&gt;( expression: (r: IReactionPublic) =&gt; T, effect: (arg: T, r: IReactionPublic) =&gt; void, opts: IReactionOptions = EMPTY_OBJECT): IReactionDisposer &#123; const name = opts.name || \"Reaction@\" + getNextId() const effectAction = action( name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect ) const runSync = !opts.scheduler &amp;&amp; !opts.delay const scheduler = createSchedulerFromOptions(opts) let firstTime = true let isScheduled = false let value: T const equals = (opts as any).compareStructural ? comparer.structural : opts.equals || comparer.default const r = new Reaction( name, () =&gt; &#123; if (firstTime || runSync) &#123; reactionRunner() &#125; else if (!isScheduled) &#123; isScheduled = true scheduler!(reactionRunner) &#125; &#125;, opts.onError ) function reactionRunner() &#123; isScheduled = false if (r.isDisposed) return let changed = false r.track(() =&gt; &#123; const nextValue = expression(r) changed = firstTime || !equals(value, nextValue) value = nextValue &#125;) if (firstTime &amp;&amp; opts.fireImmediately!) effectAction(value, r) if (!firstTime &amp;&amp; (changed as boolean) === true) effectAction(value, r) if (firstTime) firstTime = false &#125; r.schedule() return r.getDisposer()&#125; whenwhen 函数的意义是在满足特定条件下，以动作 action 形式执行副作用函数，其实现内部调用了 autoRun 函数。when 函数分为同步版本和异步版本两个。并且，随着响应式数据的变更满足了特定的条件，在副作用函数执行之前，reactin 实例将被销毁，因此副作用函数将只执行一次。 代码段 7，reaction 函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function when( predicate: () =&gt; boolean, opts?: IWhenOptions): Promise&lt;void&gt; &amp; &#123; cancel(): void &#125;function when( predicate: () =&gt; boolean, effect: Lambda, opts?: IWhenOptions): IReactionDisposerfunction when(predicate: any, arg1?: any, arg2?: any): any &#123; if (arguments.length === 1 || (arg1 &amp;&amp; typeof arg1 === \"object\")) return whenPromise(predicate, arg1) return _when(predicate, arg1, arg2 || &#123;&#125;)&#125;function _when(predicate: () =&gt; boolean, effect: Lambda, opts: IWhenOptions): IReactionDisposer &#123; let timeoutHandle: any if (typeof opts.timeout === \"number\") &#123; timeoutHandle = setTimeout(() =&gt; &#123; if (!disposer[$mobx].isDisposed) &#123; disposer() const error = new Error(\"WHEN_TIMEOUT\") if (opts.onError) opts.onError(error) else throw error &#125; &#125;, opts.timeout) &#125; opts.name = opts.name || \"When@\" + getNextId() const effectAction = createAction(opts.name + \"-effect\", effect as Function) const disposer = autorun(r =&gt; &#123; if (predicate()) &#123; r.dispose() if (timeoutHandle) clearTimeout(timeoutHandle) effectAction() &#125; &#125;, opts) return disposer&#125;function whenPromise( predicate: () =&gt; boolean, opts?: IWhenOptions): Promise&lt;void&gt; &amp; &#123; cancel(): void &#125; &#123; if (process.env.NODE_ENV !== \"production\" &amp;&amp; opts &amp;&amp; opts.onError) return fail(`the options 'onError' and 'promise' cannot be combined`) let cancel const res = new Promise((resolve, reject) =&gt; &#123; let disposer = _when(predicate, resolve, &#123; ...opts, onError: reject &#125;) cancel = () =&gt; &#123; disposer() reject(\"WHEN_CANCELLED\") &#125; &#125;) ; (res as any).cancel = cancel return res as any&#125; 后记mobx 是一个十分严谨的类库，这两篇文章点到的内容最多也不过十之六七。感兴趣的读者可以自行翻阅源码，想必能发现额外的矿藏，比如错误处理、信息追踪等。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"mobx源码分析（一） 构造响应式数据","slug":"frontend/library/mobx源码分析1","date":"2018-08-02T16:00:00.000Z","updated":"2020-03-08T10:45:48.826Z","comments":true,"path":"2018/08/03/frontend/library/mobx源码分析1/","link":"","permalink":"http://xzfyu.com/2018/08/03/frontend/library/mobx源码分析1/","excerpt":"","text":"思想实验在开篇之初，我们先作一番思想实验。借助于形象化思维，通过类比的方式，那样会更容易理解 mobx 的实现。 视线折回到明代，水患侵扰了淳安县境，治理地方水务的官员把这情况上报给知县海瑞，海瑞又上报总督胡宗宪，而胡宗宪呢，他派出快马，向京师呈报奏章，吁请内阁早日筹备赈灾的粮食。与此同时，东厂番子早已把眼线布满全国，不等内阁向嘉靖奏报，嘉靖早已知晓了千里之外的动向。当我们把这环节牵涉到的各级官员设想为收发消息的节点，再把东厂番子设想为全局的监听器，我们就可以据此绘出一张图谱。 图 1，明代行政流程图抽象 即如图谱中所见，node 负责接收消息 message，触发相应的动作 listener，再把消息传递给上层节点的同时，又会把消息传递给全局监听器 monitor，由 monitor 触发 reaction 行为。reaction 行为在现实表现中，往往是命令 node 节点再执行额外的动作，因此，在 node 节点向 monitor 呈报消息的时候，也会携带当前 node 节点的信息。 由此我们类比到 mobx 的实现，绘制出如下图谱： 图 2，mobx 工作流程 上图中，观察对象 observable 身兼一种能力，即在数据变更前，会触发 interceptor 拦截函数的执行；在数据变更后，会触发 listener 监听函数的执行，同时将数据变更的信息上报给全局监听器。在全局监听器中，startBatch, endBatch 用于开启、结束事务。事务执行过程中，将统计哪些观察者 observer 所观察的数据发生了变更、需要重新执行；在事务的尾端（endBatch 过程中），通过 runAction 方法调用这些观察者的实际处理逻辑。 思考以上 mobx 的工作流程，我们需要探索的问题是： 怎样将数据转变成 observable？当数据变更时，observable 又怎样驱动 interceptor, listener 的执行，并上报给全局监听器？ 怎样使 observer 订阅 observable？在数据变更的时候，使得相应的观察者 observer 执行其处理逻辑？ 这篇文章致力于对问题 1 加以解答。对于问题 2，将在下一篇文章加以解答。 响应式数据如果数据赋值这一动作委托给某函数处理，我们可以借助 AOP 编程思想，在该函数的执行过程中，添加一些附加操作，如上报变更信息、启用回调函数、或者触发指定事件等。正因为如此，Vue 才得以通过 Object.defineProperty 方法实现双向数据绑定；React 才得以通过 setState 方法引起组件重绘。mobx 融合了两种处理手法。首先，mobx 基于原始数据构建出 observable 实例，在 observable 实例方法变更数据的过程中，将执行 interceptor, listener, reportChanged 等附加操作，这一机制如同 React 内建的 setState 方法在变更组件状态的同时，还能驱动组件重绘。其次，mobx 通过 Object.defineProperty 方法将原始数据（对象形式）的赋值、取值动作委托给 observable 实例方法加以处理，使得原始数据的赋值动作转变成响应式的、取值动作又能获得原始数据内容，这一过程同 Vue 那样使用了 Object.defineProperty 方法。 mobx 能将如下几种数据类型转变为 observable 实例：ObservableValue 实例作为代理，能将基本数据类型的赋值动作转变成响应式；ObservableObjectAdministration 实例能处理对象；ObservableArrayAdministration 实例能处理数组；ObservableMap 实例能处理 map 数据结构。 图 3，observable 实例基本 与此同时，mobx 使用 enhancer 递归地将层级较深的数据内容转变成上述四种 observable 实例，使得原始数据的子属性及元素（表现为数组、对象或 map）都具备响应式赋值能力。 图 4，enhancer 机制基本 ObservableValue代码段 1，ObservableValue 的部分实例方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public set(newValue: T) &#123; const oldValue = this.value newValue = this.prepareNewValue(newValue) as any if (newValue !== UNCHANGED) &#123; const notifySpy = isSpyEnabled() if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") &#123; spyReportStart(&#123; type: \"update\", name: this.name, newValue, oldValue &#125;) &#125; this.setNewValue(newValue) if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportEnd() &#125;&#125;private prepareNewValue(newValue): T | IUNCHANGED &#123; // 计算属性获取过程不允许变更响应式数据，严格模式下只能通过 action 改变响应式数据（即状态） checkIfStateModificationsAreAllowed(this) if (hasInterceptors(this)) &#123; const change = interceptChange&lt;IValueWillChange&lt;T&gt;&gt;(this, &#123; object: this, type: \"update\", newValue &#125;) if (!change) return UNCHANGED newValue = change.newValue &#125; newValue = this.enhancer(newValue, this.value, this.name) return this.value !== newValue ? newValue : UNCHANGED&#125;setNewValue(newValue: T) &#123; const oldValue = this.value this.value = newValue this.reportChanged() if (hasListeners(this)) &#123; notifyListeners(this, &#123; type: \"update\", object: this, newValue, oldValue &#125;) &#125;&#125;public get(): T &#123; this.reportObserved() return this.dehanceValue(this.value)&#125; 通过以上代码，我们也能看出，ObservableValue 实例的 set 方法具有四种智能职能：开发环境下，在数据变更前后，触发 spyListener 间谍监听器的执行（可用于添加日志）；数据变更前，校验变更的合理性，如计算属性获得过程中不允许作数据变更、严格模式下不允许在 action 外作数据变更；同样在数据变更前，调用 interceptor 拦截器，拦截器可用于打断数据变更的动作；数据变更后，通过 reportChanged 方法将数据变更信息上报到全局监听器，并触发 listener 监听函数的执行。 其中，interceptor, listener 均挂载为 ObservableValue 实例的属性，因此，interceptChange, notifyListeners 以 ObservableValue 实例作为其入参，用于查找待执行的 interceptor, listener。 reportChanged 方法执行过程中，将把当前的 ObservableValue 标识为脏值，并驱动相应的 observer（同样挂载为 ObservableValue 实例的属性）执行其处理逻辑。在 mobx 的实现中，观察者 observer 并不需要感知自己观察的 observable 实例作了哪些变更，而只要知晓 observable 已经作了数据变更，observer 就需要执行其处理逻辑。因此，只要 observer 观察的 observable 实例颗粒度足够细，就能使 observer 基于确凿的数据变更，发起相应的响应式处理流程。这部分内容，散见于下文。 有了上述逻辑实现后，基本数据类型就可以把赋值动作委托给 observableValue.set 方法加以处理，以获得响应式变更数据内容的能力。 enhancer 用于将数据内容转变成 observable 实例，既能用于递归地处理复杂的数据结构，又能适应 js 弱类型语言的特征。比如，当把数据内容从基本数据类型切换成对象时，enhancer 就能使得对象属性的赋值动作也具有响应式效果。enhancer 分为两类，其一作为构造函数的参数，其二作为实例方法。 ObservableObjectAdministration不同于基本数据类型的全量更新，对象单次只更新一个属性。因此，ObservableValue 实例与原始数据的关系较为直接，原始数据的读写动作可直接委托给 observableValue.set, observableValue.get 方法加以处理，呈单一的线条形状；ObservableObjectAdministration 实例和原始数据就显得比较复杂，需要通过属性作桥接，按属性呈多线条形状。无论 ObservableObjectAdministration 实例提供的 read, write, addObservableProp, addComputedProp 都在属性级别。顾名思义，read, write 方法用于针对属性的读写操作，addObservableProp 用于添加可观察属性，addComputedProp 用于添加计算属性。 除此而外，ObservableValue 实例不会改变原始数据 value 的读写过程，而只能通过显式调用 observableValue.set 方法唤起响应式操作。ObservableObjectAdministration 实例可通过 Object.defineProperty 方法影响原始数据的读写。使用了 Object.defineProperty 方法后，读取 target 属性，都将委托给 observableObjectAdministration.read, observableObjectAdministration.write 方法去处理，从而使原始数据的读写过程变成响应式。 在 ObservableObjectAdministration 构造函数的实现内部，仰赖于 ObservableValue, ComputedValue 构造函数，因为其子属性既可能是 ObservableValue 可观察数据，ComputedValue 计算属性，又可能是没有响应式特征的普通数据。 代码段 2，ObservableObjectAdministration 的部分实例方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596read(key: string) &#123; return this.values.get(key)!.get()&#125;write(key: string, newValue) &#123; const instance = this.target const observable = this.values.get(key) // 变更计算属性，予以报错处理， if (observable instanceof ComputedValue) &#123; observable.set(newValue) return &#125; if (hasInterceptors(this)) &#123; const change = interceptChange&lt;IObjectWillChange&gt;(this, &#123; type: \"update\", object: this.proxy || instance, name: key, newValue &#125;) if (!change) return newValue = (change as any).newValue &#125; // 触发 ObservableValue 实例的 interceptor 拦截器, 通过 observableValue.enhance 获取终值 newValue = (observable as any).prepareNewValue(newValue) if (newValue !== UNCHANGED) &#123; const notify = hasListeners(this) const notifySpy = isSpyEnabled() const change = notify || notifySpy ? &#123; type: \"update\", object: this.proxy || instance, oldValue: (observable as any).value, name: key, newValue &#125; : null if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportStart(&#123; ...change, name: this.name, key &#125;) // 触发 ObservableValue 实例的 listener 订阅函数，并调用 observableValue.reportChanged 上报变更 ; (observable as ObservableValue&lt;any&gt;).setNewValue(newValue) if (notify) notifyListeners(this, change) if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportEnd() &#125;&#125;addObservableProp(propName: string, newValue, enhancer: IEnhancer&lt;any&gt; = this.defaultEnhancer) &#123; const &#123; target &#125; = this // 校验 target 对象 propName 是否具有 configurable, writable 可能 assertPropertyConfigurable(target, propName) if (hasInterceptors(this)) &#123; const change = interceptChange&lt;IObjectWillChange&gt;(this, &#123; object: this.proxy || target, name: propName, type: \"add\", newValue &#125;) if (!change) return newValue = (change as any).newValue &#125; const observable = new ObservableValue( newValue, enhancer, `$&#123;this.name&#125;.$&#123;propName&#125;`, false ) this.values.set(propName, observable) newValue = (observable as any).value // observableValue might have changed it Object.defineProperty(target, propName, generateObservablePropConfig(propName)) this.notifyPropertyAddition(propName, newValue)&#125;notifyPropertyAddition(key: string, newValue) &#123; const notify = hasListeners(this) const notifySpy = isSpyEnabled() const change = notify || notifySpy ? &#123; type: \"add\", object: this.proxy || this.target, name: key, newValue &#125; : null if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportStart(&#123; ...change, name: this.name, key &#125;) if (notify) notifyListeners(this, change) if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportEnd() this.keysAtom.reportChanged()&#125; 通过以上代码，可以看出，observableObjectAdministration.write 方法将依次调用挂载在 ObservableValue, ObservableObjectAdministration 实例上的 interceptor 拦截器和 listener 订阅函数，又通过 observableValue.reportChanged 上报给全局监听器，触发相应的观察者 observer 执行其处理逻辑。在这里，作为属性值的 observableValue 实例颗粒度更细，通过 observableValue.reportChanged 上报给全局监听器，将能使观察者 observer 对更细微的数据变动做出响应。为什么 observableObjectAdministration 没有实现 reportChanged 方法呢？因为，基于 enhancer，observableValue 所处理的数据有可能就是一个 observableObjectAdministration 实例，由 observableValue 处理上报动作是可行的。 observableObjectAdministration.addObservableProp 方法用于添加可观察属性。在该方法的内部实现中，既通过创建新的 ObservableValue 实例将属性变更上报给全局监听器，又通过 keysAtom 属性（Atom 实例）上报给全局监听器。前者使观察属性变更的 observer 作出响应，后者用于使观察属性集合的 observer 作出响应。同 Vue，mobx 在取值时设定观察者 observer 和可观察数据 observable 的依赖关系，通过 reportObserved 方法刷新依赖；在赋值时将可观察数据 observable 标识为脏值，观察者 observer 需要执行其处理逻辑。因此，单有 reportChanged 并不触发响应式动作，那时还没有一个观察者需要基于变更的数据作出响应（或者理解为没有观察者订阅变更的数据）；只有 reportObserved, reportChanged，观察者 observer 才会执行其处理逻辑。 图 5，ObservableObjectAdministration 工作流程 ObservableArrayAdministration对于数组，与 Vue 相同，mobx 需要使数组的原型方法也具有响应式操作的能力。不同于 Vue 直接改写数组的实例方法，mobx 使用了 es6 中 Proxy 语法。通过 Proxy 代理器，mobx 将对数组项的读取操作、push 等方法移交给 arrayExtensions 集合处理。因此，ObservableArrayAdministration 构造函数不同于 ObservableObjectAdministration，部分可以在 ObservableArrayAdministration 构造函数中实现的实例方法最终会在 arrayExtensions 对象中实现。 代码段 3，ObservableArrayAdministration 的部分实例方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293spliceWithArray(index: number, deleteCount?: number, newItems?: any[]): any[] &#123; checkIfStateModificationsAreAllowed(this.atom) const length = this.values.length if (index === undefined) index = 0 else if (index &gt; length) index = length else if (index &lt; 0) index = Math.max(0, length + index) if (arguments.length === 1) deleteCount = length - index else if (deleteCount === undefined || deleteCount === null) deleteCount = 0 else deleteCount = Math.max(0, Math.min(deleteCount, length - index)) if (newItems === undefined) newItems = EMPTY_ARRAY if (hasInterceptors(this)) &#123; const change = interceptChange&lt;IArrayWillSplice&lt;any&gt;&gt;(this as any, &#123; object: this.proxy as any, type: \"splice\", index, removedCount: deleteCount, added: newItems &#125;) if (!change) return EMPTY_ARRAY deleteCount = change.removedCount newItems = change.added &#125; newItems = newItems.length === 0 ? newItems : newItems.map(v =&gt; this.enhancer(v, undefined)) if (process.env.NODE_ENV !== \"production\") &#123; const lengthDelta = newItems.length - deleteCount this.updateArrayLength(length, lengthDelta) // checks if internal array wasn't modified &#125; const res = this.spliceItemsIntoValues(index, deleteCount, newItems) if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res) return this.dehanceValues(res)&#125;spliceItemsIntoValues(index, deleteCount, newItems: any[]): any[] &#123; if (newItems.length &lt; MAX_SPLICE_SIZE) &#123; return this.values.splice(index, deleteCount, ...newItems) &#125; else &#123; const res = this.values.slice(index, index + deleteCount) this.values = this.values .slice(0, index) .concat(newItems, this.values.slice(index + deleteCount)) return res &#125;&#125;notifyArraySplice(index: number, added: any[], removed: any[]) &#123; const notifySpy = !this.owned &amp;&amp; isSpyEnabled() const notify = hasListeners(this) const change = notify || notifySpy ? &#123; object: this.proxy, type: \"splice\", index, removed, added, removedCount: removed.length, addedCount: added.length &#125; : null if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportStart(&#123; ...change, name: this.atom.name &#125;) this.atom.reportChanged() if (notify) notifyListeners(this, change) if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportEnd()&#125;notifyArrayChildUpdate(index: number, newValue: any, oldValue: any) &#123; const notifySpy = !this.owned &amp;&amp; isSpyEnabled() const notify = hasListeners(this) const change = notify || notifySpy ? &#123; object: this.proxy, type: \"update\", index, newValue, oldValue &#125; : null if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportStart(&#123; ...change, name: this.atom.name &#125;) this.atom.reportChanged() if (notify) notifyListeners(this, change) if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportEnd()&#125; 通过以上代码，可以看出，ObservableArrayAdministration 构造函数只提供了 spliceWithArray 实例方法，用于一次性变更数组项及数组的长度。在这一过程中，同样会调用挂载在 observableArrayAdministration 实例中的 interceptor, listener，以及通过 reportChanged 方法将变更信息上报给全局监听器。 不同于 observableArrayAdministration 实例中变更数据的子属性由 observableValue 实例构成；observableArrayAdministration 实例中变更的数组项直接通过 enhancer 处理成 observable 实例。因为对于数组，观察者只订阅单个数组项变更的情况较少，不像对象需要监控每个属性的变更，两者监控的颗粒度不一样，前者就使用 enhancer 构造 observable 实例，后者通过 ObservableValue 构造 observable 实例。 代码段4，arrayExtensions 对象含有的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134const arrayExtensions = &#123; clear(): any[] &#123; return this.splice(0) &#125;, replace(newItems: any[]) &#123; const adm: ObservableArrayAdministration = this[$mobx] return adm.spliceWithArray(0, adm.values.length, newItems) &#125;, splice(index: number, deleteCount?: number, ...newItems: any[]): any[] &#123; const adm: ObservableArrayAdministration = this[$mobx] switch (arguments.length) &#123; case 0: return [] case 1: return adm.spliceWithArray(index) case 2: return adm.spliceWithArray(index, deleteCount) &#125; return adm.spliceWithArray(index, deleteCount, newItems) &#125;, spliceWithArray(index: number, deleteCount?: number, newItems?: any[]): any[] &#123; const adm: ObservableArrayAdministration = this[$mobx] return adm.spliceWithArray(index, deleteCount, newItems) &#125;, push(...items: any[]): number &#123; const adm: ObservableArrayAdministration = this[$mobx] adm.spliceWithArray(adm.values.length, 0, items) return adm.values.length &#125;, pop() &#123; return this.splice(Math.max(this[$mobx].values.length - 1, 0), 1)[0] &#125;, shift() &#123; return this.splice(0, 1)[0] &#125;, unshift(...items: any[]): number &#123; const adm = this[$mobx] adm.spliceWithArray(0, 0, items) return adm.values.length &#125;, reverse(): any[] &#123; // 开发环境提示用户 reverse 方法不会改变观察数据的内容 const clone = (&lt;any&gt;this).slice() return clone.reverse.apply(clone, arguments) &#125;, sort(compareFn?: (a: any, b: any) =&gt; number): any[] &#123; // 开发环境提示用户 sort 方法不会改变观察数据的内容 const clone = (&lt;any&gt;this).slice() return clone.sort.apply(clone, arguments) &#125;, remove(value: any): boolean &#123; const adm: ObservableArrayAdministration = this[$mobx] const idx = adm.dehanceValues(adm.values).indexOf(value) if (idx &gt; -1) &#123; this.splice(idx, 1) return true &#125; return false &#125;, get(index: number): any | undefined &#123; const adm: ObservableArrayAdministration = this[$mobx] if (adm) &#123; if (index &lt; adm.values.length) &#123; adm.atom.reportObserved() return adm.dehanceValue(adm.values[index]) &#125; // 提示用户超过数组长度 &#125; return undefined &#125;, set(index: number, newValue: any) &#123; const adm: ObservableArrayAdministration = this[$mobx] const values = adm.values if (index &lt; values.length) &#123; checkIfStateModificationsAreAllowed(adm.atom) const oldValue = values[index] if (hasInterceptors(adm)) &#123; const change = interceptChange&lt;IArrayWillChange&lt;any&gt;&gt;(adm as any, &#123; type: \"update\", object: this as any, index, newValue &#125;) if (!change) return newValue = change.newValue &#125; newValue = adm.enhancer(newValue, oldValue) const changed = newValue !== oldValue if (changed) &#123; values[index] = newValue adm.notifyArrayChildUpdate(index, newValue, oldValue) &#125; &#125; else if (index === values.length) &#123; adm.spliceWithArray(index, 0, [newValue]) &#125; else &#123; // 超过数组长度，报错处理 &#125; &#125;&#125;;[ \"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\", \"toString\", \"toLocaleString\"].forEach(funcName =&gt; &#123; arrayExtensions[funcName] = function () &#123; const adm: ObservableArrayAdministration = this[$mobx] adm.atom.reportObserved() const res = adm.dehanceValues(adm.values) return res[funcName].apply(res, arguments) &#125;&#125;) 可以看出，arrayExtensions 对象封装了数组的原型方法，便于通过 Proxy 语法构建代理，为原始数据提供响应式的数组操作。在 mobx 中，创建原始数组的代理通过 createObservableArray 函数实现。源码如下： 代码段 5，为数组创建代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function createObservableArray&lt;T&gt;( initialValues: any[] | undefined, enhancer: IEnhancer&lt;T&gt;, name = \"ObservableArray@\" + getNextId(), owned = false): IObservableArray&lt;T&gt; &#123; const adm = new ObservableArrayAdministration(name, enhancer, owned) addHiddenFinalProp(adm.values, $mobx, adm) const proxy = new Proxy(adm.values, arrayTraps) as any adm.proxy = proxy if (initialValues &amp;&amp; initialValues.length) &#123; const prev = allowStateChangesStart(true) adm.spliceWithArray(0, 0, initialValues) allowStateChangesEnd(prev) &#125; return proxy&#125;const arrayTraps = &#123; get(target, name) &#123; if (name === $mobx) return target[$mobx] if (name === \"length\") return target[$mobx].getArrayLength() if (typeof name === \"number\") &#123; return arrayExtensions.get.call(target, name) &#125; if (typeof name === \"string\" &amp;&amp; !isNaN(name as any)) &#123; return arrayExtensions.get.call(target, parseInt(name)) &#125; if (arrayExtensions.hasOwnProperty(name)) &#123; return arrayExtensions[name] &#125; return target[name] &#125;, set(target, name, value): boolean &#123; if (name === \"length\") &#123; target[$mobx].setArrayLength(value) return true &#125; if (typeof name === \"number\") &#123; arrayExtensions.set.call(target, name, value) return true &#125; if (!isNaN(name)) &#123; arrayExtensions.set.call(target, parseInt(name), value) return true &#125; return false &#125;, preventExtensions(target) &#123; fail(`Observable arrays cannot be frozen`) return false &#125;&#125; 通过创建代理对象，mobx 数组的处理效果就等同使用 Object.defineProperty 方法处理后的对象，赋值呈现响应式，取值获得更新后的值。 ObservableMapmobx 介入对象处理的着眼点是属性，而对于 map 数据结构，其着眼点在于实例方法 set, get, has 等。因此，ObservableMap 与 ObservableArrayAdminstriation 处理上有相似的地方，都是对原始数据提供代理对象。在 ObservableArrayAdminstriation 的实现中，真正的代理对象需要在 createObservableArray 函数执行环节才能创建出 proxy 实例，而 ObservableMap 实例即是原始 map 结构的代理。 代码段 6，ObservableMap 的部分实例方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990has(key: K): boolean &#123; if (this._hasMap.has(key)) return this._hasMap.get(key)!.get() return this._updateHasMapEntry(key, false).get()&#125;set(key: K, value: V) &#123; const hasKey = this._has(key) if (hasInterceptors(this)) &#123; const change = interceptChange&lt;IMapWillChange&lt;K, V&gt;&gt;(this, &#123; type: hasKey ? \"update\" : \"add\", object: this, newValue: value, name: key &#125;) if (!change) return this value = change.newValue! &#125; if (hasKey) &#123; this._updateValue(key, value) &#125; else &#123; this._addValue(key, value) &#125; return this&#125;private _updateHasMapEntry(key: K, value: boolean): ObservableValue&lt;boolean&gt; &#123; let entry = this._hasMap.get(key) if (entry) &#123; entry.setNewValue(value) &#125; else &#123; entry = new ObservableValue(value, referenceEnhancer, `$&#123;this.name&#125;.$&#123;key&#125;?`, false) this._hasMap.set(key, entry) &#125; return entry&#125;private _updateValue(key: K, newValue: V | undefined) &#123; const observable = this._data.get(key)! newValue = (observable as any).prepareNewValue(newValue) as V if (newValue !== UNCHANGED) &#123; const notifySpy = isSpyEnabled() const notify = hasListeners(this) const change = notify || notifySpy ? &lt;IMapDidChange&lt;K, V&gt;&gt;&#123; type: \"update\", object: this, oldValue: (observable as any).value, name: key, newValue &#125; : null if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportStart(&#123; ...change, name: this.name, key &#125;) observable.setNewValue(newValue as V) if (notify) notifyListeners(this, change) if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportEnd() &#125;&#125;private _addValue(key: K, newValue: V) &#123; checkIfStateModificationsAreAllowed(this._keysAtom) transaction(() =&gt; &#123; const observable = new ObservableValue( newValue, this.enhancer, `$&#123;this.name&#125;.$&#123;key&#125;`, false ) this._data.set(key, observable) newValue = (observable as any).value // value might have been changed this._updateHasMapEntry(key, true) this._keysAtom.reportChanged() &#125;) const notifySpy = isSpyEnabled() const notify = hasListeners(this) const change = notify || notifySpy ? &lt;IMapDidChange&lt;K, V&gt;&gt;&#123; type: \"add\", object: this, name: key, newValue &#125; : null if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportStart(&#123; ...change, name: this.name, key &#125;) if (notify) notifyListeners(this, change) if (notifySpy &amp;&amp; process.env.NODE_ENV !== \"production\") spyReportEnd()&#125; 上述代码中，除了常规的 interceptChange, notifyListeners, spyReportStart, spyReportEnd 以外，mobx 构建了两个 observable 实例集合，其一是 this._hasMap（由 ObservableValue 实例构成），其二是 this._data（由 enhancer 构建的 observable 实例构成）。其中，this._hasMap 用于协助 map.has 方法的响应式特征，其实际存储的值也是布尔类型；this._data 用于协助 map.set 方法的响应式特征，其存储的就是用户设置的数据。这两个 observable 实例集合可能同时会通过 reportChanged 方法上报数据变更（this.keysAtom 也会上报 map 集合所有的 key 键变化），因此在代码的组织中，ObservableMap 构造函数使用了 mobx 内置的 tansaction 函数，用于在多次数据变更信息上报时协调事务，只有在最后一次数据上报时，才执行观察者 observer 的处理逻辑。 接口层图 6，observable 接口层处理流程 结合上图和前文，可得出 mobx 接口层的一些处理逻辑： 对于普通数据、map 数据结构的处理即是直接生成 ObservableValue, ObservableMap 实例。 对于数组，则通过 createObservableArray 创建 Proxy 代理实例，该代理实例的方法体中将调用 ObservableArrayAdminstrition 实例的响应式操作。 对于对象，则分为两种情况，当 options.proxy 为否值，只生成 ObservableObjectAdminstrition，再通过装饰器插入计算属性或可观察属性；当 options.proxy 为真值，创建 Proxy 代理实例，同样的，该代理实例的方法体中将调用 ObservableObjectAdminstrition 实例的响应式操作，再通过装饰器插入计算属性或可观察属性。 以上3点之外，mobx 通过 enhancer 决定对深层数据结构的处理操作，如 observable.deep 装饰器使用 deepEnhancer 增强器，将数据的深层结构统统转换为 observable 实例（默认操作）；observable.shallow 装饰器使用 shallowEnhancer 增强器，只将数据的首层转换为 observable 实例；observable.ref 装饰器使用 referenceEnhancer 增强器，不会将数据转换为 observable 实例（除非新值就是个 observable 实例）；observable.struct 装饰器使用 refStructEnhancer 增强器，同样不会将数据转换为 observable 实例，与 referenceEnhancer 区别是，当数据未作变更时，refStructEnhancer 将以引用对象形式返回原始数据，而不是值相同的新数据。 值得说明的是，mobx 处理对象时会批量添加计算属性或可观察属性，所以实现中使用 startBatch, endBatch 开启事务，使观察者的处理逻辑只执行一次。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"react-redux源码分析","slug":"frontend/library/react-redux源码分析","date":"2018-07-07T16:00:00.000Z","updated":"2020-03-08T10:50:15.845Z","comments":true,"path":"2018/07/08/frontend/library/react-redux源码分析/","link":"","permalink":"http://xzfyu.com/2018/07/08/frontend/library/react-redux源码分析/","excerpt":"","text":"概述react-redux 类库的意义是将 redux 状态注入到组件中，且在状态更新时驱动组件重绘。在这个类库的设计和实现上，需要面临两个问题：如何将 store 中缓存的状态注入到组件中；在状态更新时，如何驱动组件重绘。 对于第一个问题，react-redux 解决手法也极为简单且常见。通过顶层 Provider 容器接受 store 作为 props，再将 store 作为 context 内容传入子孙组件；在用户端实际消费状态的组件（自定义组件）外层构造直属父级容器（HOC 高阶组件），由直属父级容器将通过 context.store 属性获取的状态数据输入为自定义组件的 props。 对于第二个问题，react-redux 解决手法是：通过 store.subscribe 方法注册状态变更后待执行的回调函数 listener，在该回调函数执行直属父级容器的 forceUpdate 或 setState 方法，重新计算注入自定义组件的 props 数据，由此重绘自定义组件。在这个过程中，无论 store 中的状态数据作何种更新，均会触发 listener 回调的执行，因而实现上有一个优化性能的关键点，即怎样使组件在指定状态更新时启用重绘机制。这一优化点通过重新计算注入自定义组件的 props 实现。在 react-redux 源码中，重新计算 props 数据由 selector 筛选器完成。除此以外，react-redux 还有另一处优化：为减少 listener 的数量，当某个 HOC 组件的重绘机制（在 redux 源码中，表现为该 HOC 组件的 onStateChange 方法）已挂载为 listener 时，其下子孙容器（同样是 HOC 组件）的重绘机制将在这个 listener 的函数体中实现。 图 1，react-redux 执行流程 图 1 中，store, action, listener 概念来自于 redux，可参见react源码分析；context 用于为子孙组件传入数据，概念来自于 react；Provider 作为顶层容器，由 react-redux 提供；Component，实际为自定义组件的直属父级容器，由 react-redux 提供；selector 是 react-redux 机制中将state、dispatch 和 boundAction 转化为自定义组件所需的 props 的筛选器。 selectorselector 筛选器注入组件的 props 有两种：store 中存储的状态值、驱动状态值变更的方法 boundAction（包含 store.dispatch 方法）。这两份数据分别通过用户配置项 mapStateToProps, mapDispatchToProps 获得，再由用户配置的 mergeProps = (stateProps, dispatchProps, ownProps) =&gt; props 获取注入组件的 props（ownProps 是由父组件注入自定义组件的 props）。 主要处理流程： 采用泛职责链模式处理用户配置项 mapStateToProps, mapDispatchToProps 的多态特征（配置项类型可能为函数、对象或 undefined），转换成 mapStateToProps = (state, ownProps) =&gt; stateProps, mapDispatchToProps = (dispatch, ownProps) =&gt; dispatchProps。链式处理参数多态的手法值得借鉴。 mapStateToProps, mapDispatchToProps 经由 wrapMapToPropsConstant, wrapMapToPropsFunc 函数封装为 initSelector = (dispatch, options) =&gt; sourceSelector 函数（在源码中，initSelector 函数实际表现为 connect/wrapMapToProps 模块中的 initConstantSelector, initProxySelector 函数，作归一化处理需要）。initSelector 的参数 dispatch 由组件传入。sourceSelector 为 (stateOrDispatch, ownProps?) =&gt; props 函数形式，返回值为 stateProps, dispatchProps，参数同样由组件注入（与 dispatch 不同的是，参数 state 是动态的），用于获取 stateProps, dispatchProps。封装的意义，就是将 selector 筛选器从组件中独立出来。 将前两步的处理逻辑复合为 mapStateToPropsFactory = mapStateToProps =&gt; initSelector, mapDispatchToPropsFactory = mapDispatchToProps =&gt; initSelector，可在构建父级直属容器时直接使用。返回值 initSelector = (dispatch, options) =&gt; stateOrDispatchSelector 通过父级指数容器获得入参 store.dispatch，并生成 stateOrDispatchSelector = (stateOrDispatch, ownProps) =&gt; props 。stateOrDispatchSelector 用于获得注入组件的 props，在源码中实际表现为 mapStateToPropsProxy, mapdispatchToPropsSelector。 stateOrDispatchSelector 由 selectorFctory 函数调用，并在 selectorFctory 函数体内通过 mergeProps 将 stateProps, dispatchProps 复合成待传入组件的 props（mergeProps 的多态特征也经过链式处理）。selectorFctory 函数的特殊意义是，如果 state 或 ownProps 未作更改，沿用缓存的 stateProps, dispatchProps，以提升性能。 图 2，selector 总体执行流程 mapToPropsFactorymapToPropsFactory 包含 mapStateToPropsFactory, mapDispatchToPropsFactory，这里只概述 mapDispatchToPropsFactory 的处理流程。mapStateToPropsFactory 实现同 mapDispatchToPropsFactory。 图 3，mapToPropsFactory 执行流程 代码段 1，mapToPropsFactory1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// connect/mapDispatchToPropsimport &#123; bindActionCreators &#125; from 'redux'import &#123; wrapMapToPropsConstant, wrapMapToPropsFunc &#125; from './wrapMapToProps'export function whenMapDispatchToPropsIsFunction(mapDispatchToProps) &#123; return (typeof mapDispatchToProps === 'function') ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps') : undefined&#125;export function whenMapDispatchToPropsIsMissing(mapDispatchToProps) &#123; return (!mapDispatchToProps) ? wrapMapToPropsConstant(dispatch =&gt; (&#123; dispatch &#125;)) : undefined&#125;export function whenMapDispatchToPropsIsObject(mapDispatchToProps) &#123; return (mapDispatchToProps &amp;&amp; typeof mapDispatchToProps === 'object') ? wrapMapToPropsConstant(dispatch =&gt; bindActionCreators(mapDispatchToProps, dispatch)) : undefined&#125;export default [ whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]// connect/wrapMapToPropsexport function wrapMapToPropsConstant(getConstant) &#123; return function initConstantSelector(dispatch, options) &#123; const constant = getConstant(dispatch, options) function constantSelector() &#123; return constant &#125; constantSelector.dependsOnOwnProps = false return constantSelector &#125;&#125; export function wrapMapToPropsFunc(mapToProps, methodName) &#123; return function initProxySelector(dispatch, &#123; displayName &#125;) &#123; const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) &#123; return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch) &#125; proxy.dependsOnOwnProps = true proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) &#123; proxy.mapToProps = mapToProps // getDependsOnOwnProps 判断 mapToProps 是否依赖于父组件传入的 props // 通过 mapToProps.dependsOnOwnProps 属性进行判断 proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps) let props = proxy(stateOrDispatch, ownProps) if (typeof props === 'function') &#123; proxy.mapToProps = props proxy.dependsOnOwnProps = getDependsOnOwnProps(props) props = proxy(stateOrDispatch, ownProps) &#125; return props &#125; return proxy &#125;&#125; 代码段 1 中，wrapMapToPropsFunc 函数的写法相当有趣。如果想使用 ownProps 的某个方法决定当前组件需要 store 中的哪些状态值，首先需设定 mapStateToProps.dependsOnOwnProps 为真值，其次用户配置的 mapDispatchToProps 函数须以 ownProps 的那个方法作为返回值，该返回值将构成新的 mapDispatchToProps 函数，用于计算 dispatchProps。在源码编写上，react-redux 采用在函数执行过程中改变函数指向，两次调用自身的方式实现。以 proxy 字样命名函数也值得借鉴，因为 mapToPropsProxy 函数与 mapToProps 功能相同。 mergePropsmergeProps 处理流程可以参见上文，其意义是针对复杂的应用场景，能设置更灵活的 props 获取方式。 代码段 2，mergeProps 机制，mergePropsProxy 实现参看源码，与 mapToPropsFactory 相似123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// connect/selectorFactoryfunction impureFinalPropsSelectorFactory( mapStateToProps, mapDispatchToProps, mergeProps, dispatch) &#123; return function impureFinalPropsSelector(state, ownProps) &#123; return mergeProps( mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps ) &#125;&#125;function pureFinalPropsSelectorFactory( mapStateToProps, mapDispatchToProps, mergeProps, dispatch, &#123; areStatesEqual, areOwnPropsEqual, areStatePropsEqual &#125;) &#123; let hasRunAtLeastOnce = false let state let ownProps let stateProps let dispatchProps let mergedProps function handleFirstCall(firstState, firstOwnProps) &#123; state = firstState ownProps = firstOwnProps stateProps = mapStateToProps(state, ownProps) dispatchProps = mapDispatchToProps(dispatch, ownProps) mergedProps = mergeProps(stateProps, dispatchProps, ownProps) hasRunAtLeastOnce = true return mergedProps &#125; function handleNewPropsAndNewState() &#123; stateProps = mapStateToProps(state, ownProps) if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps) mergedProps = mergeProps(stateProps, dispatchProps, ownProps) return mergedProps &#125; function handleNewProps() &#123; if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps) if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps) mergedProps = mergeProps(stateProps, dispatchProps, ownProps) return mergedProps &#125; function handleNewState() &#123; const nextStateProps = mapStateToProps(state, ownProps) const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps) stateProps = nextStateProps if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps) return mergedProps &#125; function handleSubsequentCalls(nextState, nextOwnProps) &#123; const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps) const stateChanged = !areStatesEqual(nextState, state) state = nextState ownProps = nextOwnProps if (propsChanged &amp;&amp; stateChanged) return handleNewPropsAndNewState() if (propsChanged) return handleNewProps() if (stateChanged) return handleNewState() return mergedProps &#125; return function pureFinalPropsSelector(nextState, nextOwnProps) &#123; return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps) &#125;&#125;// initMapStateToProps, initMapDispatchToProps 为 _图 6_ 中的 initSelector// 源码中实际表现为 wrapMapToProps 模块的 initProxySelector// 通过传参 dispatch, options，获取实际可用的 mapStateToProps, mapDispatchToPropsfunction finalPropsSelectorFactory(dispatch, &#123; initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options&#125;) &#123; const mapStateToProps = initMapStateToProps(dispatch, options) const mapDispatchToProps = initMapDispatchToProps(dispatch, options) const mergeProps = initMergeProps(dispatch, options) const selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory return selectorFactory( mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options )&#125; connect如前文所指出的，dispatch 只能通过直属父级容器获得，state 又在 listener（直属父级容器的方法）执行过程中获取，因此对于用户配置项 mapStateToProps, mapDispatchToProps, mergeProps，react-redux 通过 connect 函数构建直属父级容器的时候将其转变为 initSelector, mergeProps，并注入直属父级容器中。当直属父级容器获得 store.dispatch 时，initSelector, mergeProps 又会通过 selectorFactory 转变为最终的 sourceSelector = (state, ownProps) =&gt; props，用于获取注入自定义组件的 props（包含状态值以及驱动状态转变的方法）。 在上述过程中，react-redux 为了实现逻辑的灵活性，connect 通过 createConnect 函数生成，执行逻辑中所使用的 mapStateToPropsFactory, mapDispatchToPropsFactory, mergePropsFactory, selectorFactory 均为 createConnect 的入参。而 sourceSelector 又用于构建直属父级容器的 this.selector，其 run 方法用于重新计算 props，shouldComponentUpdate 属性用于判断 props 是否便能，props 属性即是注入自定义组件的 props。 当 state 状态变更时，直属父级容器的 onStateChange 方法将以 listener 回调形式被执行。在 onStateChange 方法体中，首先调用 selector.run 重新计算 props，若变更，调用直属父级容器的 setState 方法重绘自定义组件。同时，无论 props 变更与否，直属父级容器都会驱动其子孙组件父容器的 onStateChange 执行。 图 4，connect 执行流程，不包含驱动子孙容器 onStateChange 执行部分 代码段 3，HOC 驱动自定义组件重绘，省略 displayName 等处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176// connect/connect.js// 上文 selector 内容输出的模块import defaultMapDispatchToPropsFactories from './mapDispatchToProps'import defaultMapStateToPropsFactories from './mapStateToProps'import defaultMergePropsFactories from './mergeProps'import defaultSelectorFactory from './selectorFactory'import connectAdvanced from '../components/connectAdvanced'import shallowEqual from '../utils/shallowEqual'function createConnect(&#123; connectHOC = connectAdvanced, mapStateToPropsFactories = defaultMapStateToPropsFactories, mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories, mergePropsFactories = defaultMergePropsFactories, selectorFactory = defaultSelectorFactory&#125; = &#123;&#125;) &#123; return function connect( mapStateToProps, mapDispatchToProps, mergeProps, &#123; pure = true, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, ...extraOptions &#125; = &#123;&#125; ) &#123; // match 用于使用 factory 链式处理 mapToProps，以获得 initSelector = (dispatch, options) =&gt; selector const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps') const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps') const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps') return connectHOC(selectorFactory, &#123; initMapStateToProps, initMapDispatchToProps, initMergeProps, pure, areStatesEqual, areOwnPropsEqual, areStatePropsEqual, areMergedPropsEqual, ...extraOptions &#125;) &#125;&#125;// components/connectAdvanced.jsimport hoistStatics from 'hoist-non-react-statics'const dummyState = &#123;&#125;function noop() &#123;&#125;function makeSelectorStateful(sourceSelector, store) &#123; const selector = &#123; run: function runComponentSelector(props) &#123; try &#123; const nextProps = sourceSelector(store.getState(), props) if (nextProps !== selector.props || selector.error) &#123; selector.shouldComponentUpdate = true selector.props = nextProps selector.error = null &#125; &#125; catch (error) &#123; selector.shouldComponentUpdate = true selector.error = error &#125; &#125; &#125; return selector&#125;function connectAdvanced( selectorFactory, &#123; storeKey = 'store' &#125; = &#123;&#125;) &#123; const subscriptionKey = storeKey + 'Subscription' const contextTypes = &#123; [storeKey]: storeShape, // 子孙容器的 onStateChange 挂载到当前父容器创建的 listener 中，用于减少 listener 的数量 [subscriptionKey]: subscriptionShape, &#125; const childContextTypes = &#123; [subscriptionKey]: subscriptionShape, &#125; return function wrapWithConnect(WrappedComponent) &#123; class Connect extends Component &#123; constructor(props, context) &#123; super(props, context) this.state = &#123;&#125; this.store = context[storeKey] this.initSelector() this.initSubscription() &#125; getChildContext() &#123; const subscription = this.subscription return &#123; [subscriptionKey]: this.subscription || this.context[subscriptionKey] &#125; &#125; componentDidMount() &#123; this.subscription.trySubscribe() this.selector.run(this.props) if (this.selector.shouldComponentUpdate) this.forceUpdate() &#125; componentWillReceiveProps(nextProps) &#123; this.selector.run(nextProps) &#125; componentWillUnmount() &#123; if (this.subscription) this.subscription.tryUnsubscribe() this.subscription = null this.notifyNestedSubs = noop this.store = null this.selector.run = noop this.selector.shouldComponentUpdate = false &#125; initSelector() &#123; const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions) this.selector = makeSelectorStateful(sourceSelector, this.store) this.selector.run(this.props) &#125; initSubscription() &#123; const parentSub = this.context[subscriptionKey] this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this)) this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription) &#125; onStateChange() &#123; this.selector.run(this.props) if (!this.selector.shouldComponentUpdate) &#123; this.notifyNestedSubs() &#125; else &#123; this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate this.setState(dummyState) &#125; &#125; notifyNestedSubsOnComponentDidUpdate() &#123; this.componentDidUpdate = undefined this.notifyNestedSubs() &#125; render() &#123; const selector = this.selector selector.shouldComponentUpdate = false if (selector.error) &#123; throw selector.error &#125; else &#123; return createElement(WrappedComponent, selector.props) &#125; &#125; &#125; Connect.childContextTypes = childContextTypes Connect.contextTypes = contextTypes Connect.propTypes = contextTypes return hoistStatics(Connect, WrappedComponent) &#125;&#125; 代码段 3 展示了直属父级容器的构建过程，其实例化过程中首先创建 selector 筛选器和 subscription 订阅器。随后，在 componentDidMount 生命周期执行过程中，将容器的 onStateChange 方法挂载为 store 的 listener 回调；调用 selector.run 方法重新计算 props，若 props 值变更，调用 forceUpdate 方法重绘组件。在 componentWillReceiveProps 生命周期中，再次调用 selector.run 方法重新计算 props，因为 ownProps 的变更可能影响注入自定义组件的 state, boundAction 数据（react-redux 为直属父级容器的 componentWillReceiveProps 和 componentDidUpdate 方法分派了不同的职能，前者驱动 ownProps, stateProps, dispatchProps 变更时自定义组件的重绘，后者驱动 stateProps, dispatchProps 变更时子孙容器的重绘。因此在 stateProps, dispatchProps 无变更的情形下，componentDidUpdate 方法将置为 undefined）。在 componentWillUnmount 生命周期里，将重置 selector 筛选器和 subscription 订阅器。 在状态值变更的情形下，容器的 onStateChange 方法将以 listener 回调形式得到执行，其将调用 selector.run 方法重新计算 props。若 props 已变更，调用 setState 方法驱动直属父级容器重绘；在自定义组件重绘完成后，通过 componentDidUpdate 生命周期方法通知子孙容器状态已更新，尝试执行其 onStateChange 方法。若 props 未作变更，直接通知子孙容器状态已更新，尝试执行其 onStateChange 方法。 subscription 用于将直属父级容器的 onStateChange 方法挂载为 store 中的 listener 回调，而子孙容器的 onStateChange 方法将存储在 subscription.listeners 数组中。当 action 被派发引起 state 变更时，直属父级容器的 onStateChange 方法自然会执行，而子孙容器的 onStateChange 方法则需要在当前直属父级容器中通过调用 subscription.notifyNestedSubs 执行（其执行时机参见 代码段 3，即在当前直属父级容器的 onStateChange 方法调用过程中唤起执行）。 代码段 4，subscription 订阅器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const CLEARED = nullconst nullListeners = &#123; notify() &#123;&#125; &#125;function createListenerCollection() &#123; let current = [] let next = [] return &#123; clear() &#123; next = CLEARED current = CLEARED &#125;, notify() &#123; const listeners = current = next for (let i = 0; i &lt; listeners.length; i++) &#123; listeners[i]() &#125; &#125;, get() &#123; return next &#125;, subscribe(listener) &#123; let isSubscribed = true if (next === current) next = current.slice() next.push(listener) return function unsubscribe() &#123; if (!isSubscribed || current === CLEARED) return isSubscribed = false if (next === current) next = current.slice() next.splice(next.indexOf(listener), 1) &#125; &#125; &#125;&#125;export default class Subscription &#123; constructor(store, parentSub, onStateChange) &#123; this.store = store this.parentSub = parentSub this.onStateChange = onStateChange this.unsubscribe = null this.listeners = nullListeners &#125; addNestedSub(listener) &#123; this.trySubscribe() return this.listeners.subscribe(listener) &#125; notifyNestedSubs() &#123; this.listeners.notify() &#125; isSubscribed() &#123; return Boolean(this.unsubscribe) &#125; trySubscribe() &#123; if (!this.unsubscribe) &#123; this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange) this.listeners = createListenerCollection() &#125; &#125; tryUnsubscribe() &#123; if (this.unsubscribe) &#123; this.unsubscribe() this.unsubscribe = null this.listeners.clear() this.listeners = nullListeners &#125; &#125;&#125; 后记俗语，”麻雀虽小，五脏俱全“，”苔米花虽小，也学牡丹开“。使用 react-redux 无非 ‘Provider store={store}’ 和 ‘connect(mapStateToProps, mapDispatchToProps)(Component)’ 两段代码，而在 react-redux 的设计和实现上，我们又可以看见丰富的矿藏，真是”人不可貌相，海不可斗量，代码不可管窥“。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"redux源码分析","slug":"frontend/library/redux源码分析","date":"2018-07-01T16:00:00.000Z","updated":"2020-03-08T10:45:48.826Z","comments":true,"path":"2018/07/02/frontend/library/redux源码分析/","link":"","permalink":"http://xzfyu.com/2018/07/02/frontend/library/redux源码分析/","excerpt":"","text":"前言为使页面组件和业务逻辑解耦，前端相继涌现出 MVC（Model-View-Controller）、MVP（Model-View-Presenter）、 MVVM（Model-View-ViewModel） 模式。在双向数据流的实现中，同一个 View 可能会触发多个 Model 的更新，并间接引起另一个 View 的刷新，使得状态变更的线索及影响变得错综复杂。redux 延续了 flux 架构，倡导单向数据流模式、不能通过访问器属性修改数据，这样就便于追踪状态变化的线索。 图 1，redux 数据流图 在 redux 的设计中，state 为全局缓存的状态（存储于 Store 中），action 为状态变更的标识，派发特定的 action 将引起指定的 state 变更。不得不指出，首先，在视图组件的实现上，多个 View 可能会复用相同的 state，因此，在一个 View 中派发的 action 可能会影响另一个 View 的状态，这样的话，状态管理上仍会有错综的线索，并不具备清晰性。其次，redux 以状态变更的动作为着眼点，通过 redux 组织业务逻辑，不如包含数据及其变更动作的 Model 直观。 源起redux 最初需要聚焦于实现 state = fn(state, action) 函数，用于刷新缓存的状态值。在这个函数中，state 可能包含多个状态属性；action 的职责有两种，其一使用 type 属性标识状态值作何变更，其二携带的附属信息将作为引导状态值变更的数据源。对于多种状态值变更，可采用分治的思想将其简化，即 childState = fn(childState, action)。 代码段 1，状态变更的雏形12345678910111213141516171819202122232425262728293031323334353637383940414243444546let state = &#123; todoList: [&#123; text: 'Eat food', completed: true &#125;, &#123; text: 'Exercise', completed: false &#125;], visibilityFilter: 'SHOW_COMPLETED'&#125;;function visibilityFilter(state = 'SHOW_ALL', action) &#123; if (action.type === 'SET_VISIBILITY_FILTER') &#123; return action.filter; &#125; else &#123; return state; &#125;&#125;;function todos(state = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return state.concat([&#123; text: action.text, completed: false &#125;]); case 'TOGGLE_TODO': return state.map((todo, index) =&gt; action.index === index ? &#123; text: todo.text, completed: !todo.completed &#125; : todo ) default: return state; &#125;&#125;;function todoApp(state = &#123;&#125;, action) &#123; return &#123; todos: todos(state.todos, action), visibilityFilter: visibilityFilter(state.visibilityFilter, action) &#125;;&#125;;const Add_Todo_Action = &#123; type: 'ADD_TODO', text: 'Go to swimming pool' &#125;;const Toggle_Todo_Action = &#123; type: 'TOGGLE_TODO', index: 1 &#125;;const Set_Visibility_Filter_Action = &#123; type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' &#125;;todoApp(state, Add_Todo_Action); 通过这份来自官网的代码示例，我们既能瞧见源码作者最初聚焦的视点，又能看见 redux 的一大原则 —— 使用纯函数实现状态更新。 在 redux 中，函数 state = fn(state, action) 被称为 reducer。与 Array.prototype.reduce(arrReducer, result) 方法相同的是，在数组的原型方法中，result 的终值通过递归调用 arrReducer 获得；redux 中的 state 更新也是通过逐个调用 reducer 函数实现。如果我们把采用策略模式分而治之的示例代码转变为采用职责链模式实现，即 childState = fn(childState, action) 替换为 state = fn(state, action) 函数，传入 reducer 中的为全量 state 数据，多个 reducer 构成链式结构，当前一个执行完成后，再执行下一个，这样就更接近于 Array.prototype.reduce 方法的执行机制，我们也就更能看出更新状态的函数为什么会被叫做 reducer 了。 图 2，reducer 工作的两种可能性 在 redux 源码中，串联多个 state 实际采用的是策略模式。与示例代码不同的是，state 状态会以业务模块的组织划分成多个状态管理模块，同一个状态管理模块内部又包含多个状态值。对于前者，redux 提供了 combineReducers 方法，用于复合多个 reducer 函数。对于后者，需要使用者手动复合。 实现store上一节提到了状态转换的机制，这是在 action 被派发以后所执行的动作。这一节我们将串联整个链路，包含 action 怎样被派发，状态值如何作缓存，以及更新等。 针对根据 action 触发 reducer 执行这一命题，我们自然地会想到使用发布-订阅模式加以处理，将 action.type 视为订阅的主题，action 中其余属性作为提供给订阅者的额外信息。然而 redux 的宗旨是使状态变化的线索变得清晰，易于追踪和调试，发布-订阅模式和这一宗旨相悖。因为在发布-订阅模式中，同一主题可以有多个订阅者，也就意味着同一个 action 可以触发多个 reducer，线索就会变得错综。在 redux 的设计中，一个 action 只能触发某个特定的reducer 执行。这样，我们就解释了为什么在 redux 源码中，针对独立状态集的多个子 reducer 可以被复合成一个单一的全局总 reducer（简单的，可以通过 switch 语句实现），用于负责处理全局状态的变更。当 action 被派发时，只需调用缓存的全局总 reducer，就可以实现全局状态的更新。 如果我们把总 reducer 称为 finalReducer，全局状态称为 globalState，派发 action 的过程其实只在于唤起 finalReducer 的执行。在 redux 源码中，无论 finalReducer，还是 globalState，都在 store 中维护。 图 3，store 的执行机制 为了实现上述机制，store 将 finalReducer, globalState 实现为缓存数据，并提供 getState, dispatch, replaceReducer 方法。其中，store.getState 用于获取全局缓存的状态值，store.dispatch 用于派发 action，store.replaceReducer 用于替换 finalReducer。在 redux 源码中，store 表现为 createStore 模块，其提供 createStore(reducer, initialState) 函数，用于设置 finalReducer, globalState 的初始值。 从源码中抽出这部分内容，即为如下代码（剔除参数校验）： 代码段 2，store 基本功能1234567891011121314151617181920212223242526272829303132333435function createStore(reducer, preloadedState) &#123; let currentReducer = reducer let currentState = preloadedState function getState() &#123; return currentState &#125; function dispatch(action) &#123; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) &#125; currentState = currentReducer(currentState, action) return action &#125; function replaceReducer(nextReducer) &#123; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;) &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, getState, replaceReducer &#125;&#125; 从上述代码中，redux 在创建 store 的过程，会派发 action = { type: ActionTypes.INIT }，意味着可以在应用初始化过程中更新 state；而 store.replaceReducer 方法的存在通常是为了支持编码时的热加载功能，同时又会派发 action = { type: ActionTypes.REPLACE }。从设计的角度考量源码，这是无需多加关注的细节。 middleware从 图 3 中，我们也能看出，action 经由 dispatch 函数直接交给 finalReducer 函数，middleware 中间件的意义是在 action 传入 dispatch 函数前，对 action 进行转换等特殊处理，功能类似 sevelet 中对请求进行转换、过滤等操作的 filter，或者 koa 中间件。redux 中间件的实现上也采用泛职责链模式，前一个中间件处理完成，交由下一个中间件进行处理。 图 4，中间件转换 action 流程 redux 只能从 dispatch 函数的参数中截取到 action，因此在固有程序插入中间件的机制是通过封装 dispatch 函数来完成的，即函数 newDispatch = middleware(dispatch)。这样，在newDispatch 函数体内，我们就能获得使用者传入的 action。 在多个中间件的串联上，redux 借助 Array.prototype.reduce 方法实现。redux 又将 getState, dispatch 作为参数传入 middleware 中，作为工具函数。 使用 redux 时，编写中间件采用 ({ getState, dispatch }) =&gt; dispatch =&gt; action =&gt; { } 形式。再次申明，参数 { getState, dispatch } 为 redux 中间件机制中传入的辅助函数，参数 dispatch 为本次 action 派发过程中唤起执行的 store.dispatch 方法，其意义就是通过封装该函数获取它的参数 action，参数 action 就是本次实际被派发的 action，中间件实际需要处理的转换对象。 图 5，单个中间件的处理流程 代码段 3，中间件机制123456789101112131415161718192021222324252627282930313233343536function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125;applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; let chain = [] const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 通过上述代码，我们也能看出，redux 植入中间件机制是通过 applyMiddleware 函数封装 createStore 完成的。在重新构建的 createStore 函数体内，其实现也如上文指出的，就是逐个调用中间件函数，对 store.dispatch 方法进行封装。值得借鉴的是，通过包装函数增强原函数的功能，可以使新功能点无缝地插入到原代码逻辑中。 回过头再看 createStore 模块，我们发现，redux 在 createStore 函数的实现上还有第三个参数 enhancer，其主要目的就是为 applyMiddleware 函数提供一个便捷的接口，enhancer 参数的意义也就在于包装 createStore 函数。 代码段 3，createStore 函数功能增强123456789function createStore(reducer, preloadedState, enhancer) &#123; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125;&#125; listener以上内容无不与状态更新环节相关联，并没有涉及 store 与视图层 view 怎样完成交互。针对这一命题，redux 采用了发布-订阅模式。实际表现为，当 store 派发一个 action 时（可视为发出一个消息），都会促使监视器 listener 与观察者 observer （可视为消息的接受者）运作其处理逻辑。 在具体实现过程中，监视器 listener 通过 store.subscribe 方法添加到 listeners 缓存队列中；当 action 被派发时，其将被取出执行。对于观察者 observer，首先通过 store.observable 方法获得接口层面的可观察对象，其次调用该可观察对象的 subscribe 方法，将 observer.next 转化为 listener，并添加到 listeners 缓存队列中。这样，当 action 被派发时，无论监视器 listener，还是观察者 observer 的 next 方法都将得到执行。不同的是，listener 为无参执行，observer.next 将以即时的 globalState 作为参数。 图 6，listener, observer 执行流程 代码段 4，listener, observer 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function createStore(reducer, preloadedState, enhancer) &#123; function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; function subscribe(listener) &#123; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See http://redux.js.org/docs/api/Store.html#subscribe for more details.' ) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; function observable() &#123; const outerSubscribe = subscribe return &#123; subscribe(observer) &#123; if (typeof observer !== 'object') &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125; &#125; function dispatch(action) &#123; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; return &#123; // ... subscribe, [$$observable]: observable &#125;&#125; 关于 listener 的用法，我将在下一节，以特例 react-redux 源码分析中穿插说明。 utilsredux 提供了三个工具函数，分别是 代码段 3 给出的 compose 函数，以及 bindActionCreators, combineReducers 函数。 compose 函数的功能和实现，可参见上文。 bindActionCreators 函数的意义在于支持动态配置 action。其实现原理是通过 actionCreator 函数生成 action，再调用 store.dispatch 方法加以派发。 代码段 5，bindActionCreators12345678910111213141516171819202122232425262728293031function bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125;function bindActionCreators(actionCreators, dispatch) &#123; if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; if (typeof actionCreators !== 'object' || actionCreators === null) &#123; throw new Error( `bindActionCreators expected an object or a function, instead received $&#123; actionCreators === null ? 'null' : typeof actionCreators &#125;. ` + `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?` ) &#125; const keys = Object.keys(actionCreators) const boundActionCreators = &#123;&#125; for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const actionCreator = actionCreators[key] if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; combineReducers 函数的意义在于复合 reducer。其实现过程中校验了初始状态，状态的 key 值是否有与之匹配的 reducer。 代码段 6，combineReducers1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function combineReducers(reducers) &#123; const reducerKeys = Object.keys(reducers) const finalReducers = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key \"$&#123;key&#125;\"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) let unexpectedKeyCache if (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125; &#125; let shapeAssertionError try &#123; // assertReducerShape 校验 reducer 返回初始状态非 undefined，且有兜底 state assertReducerShape(finalReducers) &#125; catch (e) &#123; shapeAssertionError = e &#125; return function combination(state = &#123;&#125;, action) &#123; if (shapeAssertionError) &#123; throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; // getUnexpectedStateShapeWarningMessage 函数校验 state 初始值和 reducer 各键的匹配程度 // state 初始值可通过 ActionTypes.INIT 设定或参数注入 const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; // reducer 返回值为 undefined 时，由 getUndefinedStateErrorMessage 函数拼接错误文案 const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; 其他为简化 redux 使用过程中的编码量，可参考 dva 设计 redux-model 模块，通过 namespace 复合 constants, actions, reducers 文件。 异步请求的 loading 状态可制作 redux-loading-middleware 中间件模块作统一处理。 以上两点，以及状态数据的设计（在状态管理模块确定之后，如何高效、稳妥地组织状态数据通常是编写业务代码的重心），介于篇幅和能力的限制，我将不再作阐述。 后记对我这样半道出家的人来说，阅读源码比如专研一本好书。先从薄处入手，藉由丰富的关联性思想到每个可挖掘的点，视野渐渐变得开阔，纸张上的字句也会渐渐变得厚实。再从厚处着眼，借着内在已储备的知识量，更容易拨开阻碍视线的枝蔓，洞见维系着本质的主干，作者构思的线条也会变得越来越简明。像每一段求索经历，这是一个从薄到厚、再从厚到薄的过程，就中的滋味不乏刑侦、推理的乐趣。但是，阅读源码譬如靠经验增进技艺，对知识的汲取往往流于碎片化。对那些才能稍嫌拙劣、又想一探究竟的人来说，以阅读源码的方式攀升到系统化认知的高度，这当中所需的演绎过程将置那些流行、已成熟的技术体系于不顾，势必会耗费莫大的心力，譬如绕一段未必能达到终点的远路。我认为，科班生有一种高屋建瓴的视角，较之半道出家的人，他们具备更为全面的认知，更容易跳过沿途遭遇的细节，理出解决命题的主要线索。当然，假如有个人以一种谈不上正确的方式探寻 api 或数学公式背后的奥秘，他的动机是值得鼓励的。只是等他回落在简单的哲学中，那就需要一段或长或短的时间了。 吴军博士在《数学之美》中引用了牛顿的一句话，”（人们发觉）真理在形式上从来都是简单的，而不是复杂和含混的。“在阅读这本书的过程中，我既能感受到作者行文简明扼要的美感，又能从作者的描述中体会到简单哲学的分量。因为简单，可以助人在错综的表象中洞悉本质，可以摆脱心理上的弊病，免于将学识敷在脸面上。我想，演绎得越多，仰赖于记忆的成分也越少，深藏在海平面下的设计矿产也越加丰富（在其上方形成的概念可以理解为变动不居的表象）。秉持着对简单哲学的信奉，我开始写作这篇分析 redux 源码的文章，虽然对简单哲学的应用以现有的编程功底仍旧有力所不逮的感觉。 总之，这篇文章是逐渐摸索的产物，其中难免错谬与勉强，却是我试图在编程行业中登堂入室的中转站。 参考[深入 React 技术栈 - 陈屹]Redux 中文文档","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"}]},{"title":"职责链模式","slug":"计算机科学/设计模式/职责链模式","date":"2018-06-23T16:00:00.000Z","updated":"2020-03-08T11:07:27.517Z","comments":true,"path":"2018/06/24/计算机科学/设计模式/职责链模式/","link":"","permalink":"http://xzfyu.com/2018/06/24/计算机科学/设计模式/职责链模式/","excerpt":"","text":"概述职责链模式(Chain of Responsibility)的主要实现逻辑为，将请求的处理对象构造为链式结构，然后在这条链上依序传递请求，直到请求被某个对象处理，或者最终得不到处理。 《设计模式:可复用面向对象软件的基础》一书将职责链模式描述为： Avoid coupling the sender of a request to its receiver by giving morethan one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it. 经典实现职责链模式包含下列组件： Handler: 处理请求对象的抽象接口，包含 handle 抽象方法，用于处理请求或调用下一个处理对象处理请求；setNextHandler 方法（可选），用于设定下一个处理对象；nextHandler 属性为下一个处理对象。 ConcerteHandler: 处理请求的具体类，包含 handle, setNextHandler 方法的实现，nextHandler 属性访问下一个处理对象。 Client: 用于向链上的具体处理者传递请求。 以下代码使用职责链模式揣测浏览器事件冒泡机制的简要实现。与浏览器不同的是，示例代码只演示父子层级关系中，子节点如何将事件对象转交给父节点，并触发绑定在父节点上的事件处理函数。不过，通过这段简要的代码实现，可以猜想事件对象 stopPropagation 方法的实现。事件对象可在鼠标或键盘点击时构造；在浏览器中，指定下一个处理对象这一过程，也可以在解析 dom 树的时候实现，使父节点自然成为子节点的下一个处理对象。关于事件捕获的实现，疑似通过事件对象的坐标属性和元素的位置属性比对实现： 12345678910111213141516171819202122232425262728293031323334353637383940abstract class Handler&#123; nextHandler; handle()&#123;&#125; setNextHandler(nextHandler)&#123; this.nextHandler = nextHandler; &#125;&#125;;class Node extends Handler&#123; clickHandlers = []; handle(event)&#123; switch(event.type)&#123; case 'onClick': for ( const handler of this.clickHandlers )&#123; handler(); &#125;; break; default: if ( this.nextHandler ) this.nextHandler.handle(event); break; &#125;; &#125; onClick(handler)&#123; this.clickHandlers.push(handler); &#125;&#125;;class ParentNode extends Node&#123;&#125;;class ChildNode extends Node&#123;&#125;;const parentNode = new ParentNode();const childNode = new ChildNode();childNode.setNextHandler(parentNode);const mouseEvent = new MouseEvent();childNode.handle(mouseEvent); 通过上述代码示例，我们也可以猜想 JavaScript 语言中原型链的实现。 职责链模式具有如下特点： 处理对象呈链式结构，因此，天然可以用来处理流程。在实现上，可以使用 setNextHandler 方法指定下一个处理对象，也可以使用一条已有的链，如父子结构形成的层级关系，或者队列形式（队列内若存储函数，当函数返回值为 false 时，表示不再将请求转交给下一个处理对象）。通常情况下，职责链模式表现为，根据请求的不同，再唤醒链上的某个处理对象加以操作，效果等同于策略模式。介于其链式处理的特征，职责链模式有一个变种，即请求经由前一个处理对象封装后，再交由下一个处理对象，这和浏览器的事件冒泡机制相仿（这样的链式操作，也可以通过函数队列或者迭代器模式实现）。 当链未明确指定时，可在链中灵活地添加处理对象、并指定下一个处理对象，跳过不必要的处理逻辑。 请求对象可以采用最简单的硬编码形式，也可以采用复杂的对象形式、或者使用特定的 Request 类加以构造，甚至使用转换函数从标识符中获取到传入处理对象的数据。这里要指出职责链模式的另一个变种，即可通过处理对象对请求进行特定包装后，再唤醒下一个处理对象。如第一点指出的，对于简单的请求对象，我们可以换用策略模式实现多样的处理机制；甚至对于复杂的请求对象，我们也可以制定规则转换引擎将其转换为简单的标识符形式，再通过策略模式加以处理。但是策略模式只能选中一种算法，且没有呈现出链式结构，因此策略模式不能像职责链模式那样不能用于控制流程，如审批流。 职责链模式可用于降低请求发送者和接受者的耦合度，处理对象也不需要知道链的结构。 过长的职责链影响程序的性能，同时也占用内存开销。在某些情况下，传入的请求会得不到处理，这时可以在链的尾端添加一个兜底函数处理请求。 js 中的职责链模式在 js 中，可借助 AOP 切面实现职责链模式，在实现上呈现出函数式特征。 12345678910111213function handler1()&#123; &#125;;function handler2()&#123; &#125;;Function.property.after = nextHandler =&gt; &#123; return () =&gt; &#123; let ret = this.apply(this, arguments); if ( !!ret ) return nextHandler.apply(this, arguments); return ret; &#125;;&#125;;handler1.after(handler2); 应用如前文所说，职责链模式可应用于呈现出父子结构的图形界面上，以实现事件处理或者其他图形效果。 职责链也可用于流程控制，如审批流等。 在已知的应用中，职责链模式见于 servelt 过滤器的实现，redux、koa 中间件的实现，koa-router 路由的实现。 参考[设计模式:可复用面向对象软件的基础][Javascript 设计模式和开发实践 - 曾探]","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"设计模式","slug":"计算机科学/设计模式","permalink":"http://xzfyu.com/categories/计算机科学/设计模式/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"js设计模式","slug":"js设计模式","permalink":"http://xzfyu.com/tags/js设计模式/"}]},{"title":"jquery 动效分析","slug":"frontend/library/jquery 动效分析","date":"2018-06-12T16:00:00.000Z","updated":"2020-03-08T11:03:25.614Z","comments":true,"path":"2018/06/13/frontend/library/jquery 动效分析/","link":"","permalink":"http://xzfyu.com/2018/06/13/frontend/library/jquery 动效分析/","excerpt":"","text":"动效基础在阅读 jquery/effects 模块源码之前，有必要先了解一下制作前端动效的一些基本知识，其内容包含动效实现的基本原理、缓动函数等。对于以上内容，笔者将在这一小节一一加以介绍。 基本原理动效实现的基本原理如同逐帧制作动画，相隔时间较短的两帧动画可以促使人类视觉误以为那是连续的一个过程。术语刷新率 fps 指每秒更新多少帧画面。通常，每秒刷新 24 张画面最适宜于人类视觉，也就是单张画面的滞留时间为 25 毫秒。因此，制作小球动效等价于在时间轴上计算小球当前的运动位置这一数学命题，即算术表达式 x = fn(t)。 缓动函数常规的缓动函数表达式为 x = fn(t, b, c, d)，其中 x 为当前样式，t 为动画执行事件，b 为起始样式，c 为最终样式，d 为动画总时长。在已知 b, c, d 三个参数的情形下，缓动函数可以表述为 x = fn(t)，其斜率为速度，二次导数为加速度。 常见的缓动函数可以查看 缓动函数速查表。缓动函数名中，后缀 In 表示加速，Out 表示减速，InOut 标识先加速、后减速；后缀 Sine 表示由三角函数实现，Quad 表示由二次方函数实现，Cubic 为三次方，Quart 为四次方，Quint 为五次方，Circ 为开平方根，Expo 为开立方根，Elastic 为结合三角函数和开立方根的初级弹簧效果，Back 为使用常数 1.70158 计算的回退效果，Bounce 为高级弹簧效果。linear 为线性函数。 jquery.esing 类库列出了多种缓动函数集合，参数 p 为动画已执行时间占动画总时长的百分比，返回值当前移动距离占总移动距离的百分比。代码如下（包含 jquery 中提供的 linear, swing 函数）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134const c1 = 1.70158;const c2 = c1 * 1.525;const c3 = c1 + 1;const c4 = ( 2 * Math.PI ) / 3;const c5 = ( 2 * Math.PI ) / 4.5;$.esing = &#123; linear(p)&#123; return p; &#125;, swing(p)&#123; return 0.5 - Math.Math.cos( p * Math.PI ) / 2; &#125;, easeInQuad(p)&#123; return p * p; &#125;, easeOutQuad(p)&#123; return 1 - ( 1 - p ) * ( 1 - p ); &#125;, easeInOutQuad(p)&#123; return p &lt; 0.5 ? 2 * p * p : 1 - Math.pow( -2 * p + 2, 2 ) / 2; &#125;, easeInCubic(p)&#123; return p * p * p; &#125;, easeOutCubic(p)&#123; return 1 - Math.pow( 1 - p, 3 ); &#125;, easeInOutCubic(p)&#123; return p &lt; 0.5 ? 4 * p * p * p : 1 - Math.pow( -2 * p + 2, 3 ) / 2; &#125;, easeInQuart(p)&#123; return p * p * p * p; &#125;, easeOutQuart(p)&#123; return 1 - Math.pow( 1 - p, 4 ); &#125;, easeInOutQuart(p)&#123; return p &lt; 0.5 ? 8 * p * p * p * p : 1 - Math.pow( -2 * p + 2, 4 ) / 2; &#125;, easeInQuint(p)&#123; return p * p * p * p * p; &#125;, easeOutQuint(p)&#123; return 1 - Math.pow( 1 - p, 5 ); &#125;, easeInOutQuint(p)&#123; return p &lt; 0.5 ? 16 * p * p * p * p * p : 1 - Math.pow( -2 * p + 2, 5 ) / 2; &#125;, easeInSine(p) &#123; return 1 - Math.cos( p * Math.PI/2 ); &#125;, easeOutSine(p)&#123; return Math.sin( p * Math.PI/2 ); &#125;, easeInOutSine(p)&#123; return -( Math.cos( Math.PI * p ) - 1 ) / 2; &#125;, easeInEppo(p)&#123; return p === 0 ? 0 : Math.pow( 2, 10 * p - 10 ); &#125;, easeOutEppo(p)&#123; return p === 1 ? 1 : 1 - Math.pow( 2, -10 * p ); &#125;, easeInOutEppo(p)&#123; return p === 0 ? 0 : p === 1 ? 1 : p &lt; 0.5 ? Math.pow( 2, 20 * p - 10 ) / 2 : ( 2 - Math.pow( 2, -20 * p + 10 ) ) / 2; &#125;, easeInCirc(p)&#123; return 1 - Math.sqrt( 1 - Math.pow( p, 2 ) ); &#125;, easeOutCirc(p)&#123; return Math.sqrt( 1 - Math.pow( p - 1, 2 ) ); &#125;, easeInOutCirc(p)&#123; return p &lt; 0.5 ? ( 1 - Math.sqrt( 1 - Math.pow( 2 * p, 2 ) ) ) / 2 : ( Math.sqrt( 1 - Math.pow( -2 * p + 2, 2 ) ) + 1 ) / 2; &#125;, easeInElastic(p)&#123; return p === 0 ? 0 : p === 1 ? 1 : -Math.pow( 2, 10 * p - 10 ) * Math.sin( ( p * 10 - 10.75 ) * c4 ); &#125;, easeOutElastic(p)&#123; return p === 0 ? 0 : p === 1 ? 1 : Math.pow( 2, -10 * p ) * Math.sin( ( p * 10 - 0.75 ) * c4 ) + 1; &#125;, easeInOutElastic(p)&#123; return p === 0 ? 0 : p === 1 ? 1 : p &lt; 0.5 ? -( Math.pow( 2, 20 * p - 10 ) * Math.sin( ( 20 * p - 11.125 ) * c5 )) / 2 : Math.pow( 2, -20 * p + 10 ) * Math.sin( ( 20 * p - 11.125 ) * c5 ) / 2 + 1; &#125;, easeInBack(p)&#123; return c3 * p * p * p - c1 * p * p; &#125;, easeOutBack(p)&#123; return 1 + c3 * Math.pow( p - 1, 3 ) + c1 * Math.pow( p - 1, 2 ); &#125;, easeInOutBack(p)&#123; return p &lt; 0.5 ? ( Math.pow( 2 * p, 2 ) * ( ( c2 + 1 ) * 2 * p - c2 ) ) / 2 : ( Math.pow( 2 * p - 2, 2 ) *( ( c2 + 1 ) * ( p * 2 - 2 ) + c2 ) + 2 ) / 2; &#125;, easeInBounce(p)&#123; return 1 - bounceOut( 1 - p ); &#125;, easeOutBounce(p) &#123; var n1 = 7.5625, d1 = 2.75; if ( p &lt; 1 / d1 ) &#123; return n1 * p * p; &#125; else if ( p &lt; 2 / d1 ) &#123; return n1 * (p -= (1.5 / d1)) * p + 0.75; &#125; else if ( p &lt; 2.5 / d1 ) &#123; return n1 * (p -= (2.25 / d1)) * p + 0.9375; &#125; else &#123; return n1 * (p-=(2.625/d1))*p + 0.984375; &#125;; &#125;, easeInOutBounce(p)&#123; return p &lt; 0.5 ? ( 1 - bounceOut( 1 - 2 * p ) ) / 2 : ( 1 + bounceOut( 2 * p - 1 ) ) / 2; &#125;&#125;; 关于各式缓动函数的由来、及其与贝塞尔曲线的关系，笔者暂时没能力加以分析。 requestAnimationFrame有了缓动函数，就需要通过定时器运作动画脚本，间隔 25 毫秒刷新元素的显示样式。通常，我们会使用 setInterval 函数创建定时器，但在这种情况下，当页面上有多个动画脚本时，创建的多个定时器无疑会影响性能，就容易造成动画的执行延时。为了优化性能，我们可借助于创建队列的方式，把待执行的动画脚本添加到队列中，再使用单个定时器在 25 毫秒取出队列中的函数加以执行。 123456789101112131415161718192021222324252627const millisec = 25;const queue = new Map();const uuid = 0;function animate()&#123; [...queue.values()].map(fn =&gt; &#123; fn(new Date); &#125;);&#125;;window.setInterval(animate, millisec);const request = handler =&gt; &#123; uuid++; queue.set(uuid, handler); return uuid;&#125;;const cancel = id =&gt; &#123; queue.delete(id);&#125;;export default &#123; request, cancel&#125;; 对于上述 js 代码，浏览器端提供的 requestAnimationFrame 接口也实现了相同的功能，由浏览器管控 dom 渲染的时机、事件队列等，刷新率为 60 帧左右，不能快进，也不能放慢，不适用于帧率要求较高的动画，如游戏等。requestAnimationFrame 函数的返回值为 ID，可用于终止动画；通过调用 cancelAnimationFrame 接口的方式。 12345678910111213141516171819202122232425262728293031323334353637function getAnimationFrame()&#123; const &#123; requestAnimationFrame, cancelAnimationFrame, mozRequestAnimationFrame, mozCancelAnimationFrame, webiketRequestAnimationFrame, webkitCancelAnimationFrame &#125; = window; const EmptyFunction = timestamp =&gt; &#123;&#125;; // IE10, Chrome24 if ( requestAnimationFrame )&#123; return &#123; request: requestAnimationFrame, cancel: cancelAnimationFrame &#125;; // FireFox 11 以下没有实现 mozCancelAnimationFrame 接口 // 且 mozRequestAnimationFrame 接口只用于触发 'MozBeforePaint' 事件 &#125; else if ( mozRequestAnimationFrame &amp;&amp; mozCancelAnimationFrame )&#123; return &#123; request: mozRequestAnimationFrame, cancel: mozCancelAnimationFrame &#125;; // webkit 某个版本没有返回 id，动画不能清除 // webkit 某个版本没有给动画函数注入 time 参数 // webkit 早期版本使用 webkitCancelRequestAnimationFrame 清除动画 &#125; else if ( webiketRequestAnimationFrame &amp;&amp; webiketRequestAnimationFrame(EmptyFunction) )&#123; return &#123; request: fn =&gt; &#123; return webiketRequestAnimationFrame(() =&gt; &#123; return fn(new Date); &#125;); &#125;, cancel: webkitCancelAnimationFrame || webkitCancelRequestAnimationFrame &#125;; &#125;&#125;; 备注除了 setInterval, requestAnimationFrame 方法，还可以借助 setTimeout 函数（通过递归调用）、postMessage 异步方法（同 setImmediate 函数，在所有页面脚本执行完成后被调用，通过 addEventListener 方法监听 ‘message’ 事件）实现动画，IE10 还可以借助 setImmediate 方法。 通过自制脚本，可以侦测 setInterval, setTimeout, requestAnimationFrame, postMessage 诸方法在 1s 时间内的最小帧数，最大帧数以及平均帧数，并以图形化界面输出。关于这部分内容，可参考司徒正美的《Javascript 框架设计》一书第 381 页。笔者不作详谈。 关于 setImmediate 方法以及 node 端 process.nextTick 方法的实现原理，笔者将在后续的文章中加以分析。 动画队列动画队列是指以联动方式组织同一个元素的动画流程，当前一个动画执行完成后，再执行下一个动画。 jQuery 基础这部分内容将介绍 jQuery/effects 动画模块所涉及的 jQuery 接口。关于这些接口的实现，读者可参详网上内容。当然，笔者也将在后续的文章加以详谈。 Promise 对象$.deferred 方法用于创建 Promise 延迟对象。该Promise 对象中，promise 方法，可以为 Promise 对象添加额外的属性和方法；progress, done, fail, always 方法可用于挂载回调函数；notifyWith, resolveWith, rejectWith 方法用于触发回调函数的执行。 Promise 对象在动效模块中的表现就是在动画执行期间或动画执行完成后，触发特定回调函数的执行。 在 jQuery 动效源码中，我们也将看到嵌套使用 promise.done 方法（defaultPrefilter 函数中嵌套使用 anim.always 方法，以清除缓存中的 queue 属性），以确保某个回调函数必然最后执行。因为该回调函数在包裹它的回调执行期间，被添加回调队列中，也就是回调队列中的最后一项。 css 操作$.css(prop, [val]) 方法用于获取或设置元素的显示样式。 $.cssHooks 集合形式，为指定 css 样式设置 $.css 方法的执行逻辑，如 $.cssHooks.borderRadius 是为对圆角进行处理，其值为 { get: (elem, computed, extra) =&gt; {}, set: (elem, value) =&gt; {}, expand: value =&gt; {} } 形式的对象。其中，get, set 方法影响 css 样式的取值、赋值操作，expand 方法对样式的值进行处理。 adjustCSS(elem, prop, valueParts, tween)，内部方法，转换并获得待设置的 css 样式值。参数 valueParts 为新设置的 css 属性，包含 +/- 符号、数值和单位，有两种设定形式，包含 +/- 号时，在原值上累加；不包含，取 valueParts 中的数值作为新的样式值。在第一种情形下，valueParts 中的单位若与获取到的样式值的原单位不符，需要将原样式值转换为新单位下的相应值。参数 tween 在动画情形中使用，其 cur 方法用于获取当前样式值，在 adjustCSS 方法执行过程中，其 unit, start, end 属性将相应得到修正。 showHide(elems, showFlag)，内部方法，用于显式或隐藏元素。 data 缓存jQuery 中创建的 Data 实例，是通过挂载在特定的节点上实现的，又分为两类，第一类通过 dataPriv 函数创建私有的 Data 实例，第二类通过 dataUser 函数创建外部使用的 Data 实例。data 实例又包含 cache(owner), get(owner, key), set(owner, key, value), access(owner, key, [value]), remove(owner, key), hasData(owner) 方法，其中，参数 owner 为挂载缓存数据的对象，通常为节点。 当全量取出 data 缓存数据时（在不设定 key 键的情况下），作为引用对象，修改其值，也将影响缓存数据。这一点在 jQuery 动效源码中 defaultPrefilter 处理 queue 队列时有使用。 queue 队列jQuery.queue(elem, type, data) 方法通过 dataPriv 数据缓存创建、添加或获取以 ${queueName}queue 为主键的函数队列。 jQuery.dequeue(elem, type) 方法取出 ${queueName}queue 函数队列中首个函数并执行。每个队列函数获得的参数为 elem, next, hooks，其中，next 借助于 jQuery.dequeue 方法执行第二个队列函数，hooks 为 ${queueName}queueHooks 钩子函数集合。当 type 为默认的 ‘fx’ 时，在队列顶端插入 ‘inprogress’ 字符串，标记当前有队列函数在执行中，阻止 $.queue 方法运作过程取出首个队列函数并执行，而只能通过 $.dequeue 或 jQuery.dequeue 方法执行队列函数。不得不说，jQuery 中的多态性、各模块间的耦合度几至于芜杂，并不简单明朗，也许借助于类的方式可以写得更为晓畅明白。 jQuery._queueHooks(elem, type) 方法取出 ${queueName}queueHooks 钩子函数集合，或其默认值。默认的钩子函数集合只包含 empty 方法，即如前所述，其用于从 dataPriv 缓存中移除 ${queueName}queue 属性。 $.queue(queueName, [queue || callback]) 创建、添加或获取 ${queueName}queue 函数队列。当添加队列函数时，其会调用 jQuery.dequeue 取出居于首位的队列函数并执行，若其取出的 ${queueName}queue 首项不是 ‘inprogress’ 字符串。 $.dequeue(queueName) 方法从 ${queueName}queue 函数队列中取出顶端的函数并执行，且下一个队列函数将作为参数 next 传入前一个队列函数中，queue 缓存数据则会即时移除该顶端函数；所有队列函数取出执行后，调用 ${queueName}queueHooks 钩子函数集合中的 empty 方法，用于从 dataPriv 缓存中移除 ${queueName}queue 属性。 $.clearQueue(queueName) 方法用于清空 ${queueName}queue 函数队列。 queue 队列在动效模块中的表现就是组织动画队列。jQuery 的动画可分为两种情形，其一立即执行，多个动画也将并行执行，其二使用动画队列，挨个执行。jQuery 默认使用动画队列方式处理动效。 使用 $.queue 方法添加动画函数时，默认首个动画会立即执行。当再度调用 $.queue 方法添加第二个动画函数时，因为其从 queue 队列中取出的首项为 ‘inprogress’ 字符串（将阻止通过 $.queue 执行首个队列函数，而只能采用 jQuery.dequeue 方法予以执行），第二个动画函数在 $.queue 方法执行期间得不到执行。若在此时，第一个动画函数执行完成后的回调中使用 jQuery.dequeue 方法，则将触发第二个动画函数的执行。按上述实现，在动画执行结束后，因为有 ‘inprogress’ 字符串存储在队列中，无论调用 $.queue 还是 $.animate 方法添加队列函数，都将不能自动执行。这是 jQuery 队列中的诡异现象，需要调用 jQuery.dequeue 方法或者清除队列，才能使 $.queue, $.animate 方法添加的队列函数不再被阻塞。源码参见下文。 下文中，queue 队列指代本节中的 ${queueName}queue 函数队列，queueHooks 钩子函数集合指代 ${queueName}queueHooks 钩子函数集合，queueHooks.empty 指代钩子函数集合中的 empty 方法，dataPriv.queue 指代 dataPriv[${queueName}queue] 队列函数。 动效模块设计jQuery 对动效模块的设计中，首先映入眼帘的是 Animation 函数，其基本骨架是以 deferred 模块组织异步逻辑。其中，tick 内含定时任务函数用于计算动画已执行时长百分比，并触发挂载在 promise 对象上的 progress, done, fail 回调函数的执行；animation 内部变量既包含基本的动画属性和方法，又兼有 promise 对象的属性和方法，随后通过该 animation 对象挂载 progress, done, fail 回调。 在 Animation 函数中，propFilter 函数用于转换 Animation 函数参数中的样式配置项及缓动配置项；Animation.prefilters 数组为动画执行前的一组预处理函数，既能影响应用于动画上的一些属性，又能通过 animation 的 progress, done, fail, always 方法影响异步回调。默认的 defaultPrefilter 函数用于清空 queue 队列，以及对显示隐藏动画作特殊处理。 tick 定时任务通过 jQuery.fx.timer 函数执行，其实现是添加到 jQuery.timers 动画队列中，由 schedule 调度函数通过 window.requestAnimationFrame 方法或 window.setTimeout 函数在一定时间内取出执行。所以，jQuery 中所有动画可理解为均借助于单个定时器实现。在 schedule 函数调度实现的基础上，jQuery 中所有动画可以通过 jQuery.fx.stop 函数终止动画的运作。 以上描述均不涉及 jQuery 动画中的样式变更凭何实现，那么 jQuery 动画中的样式变更到底是怎么实现的呢？原来在定时任务 tick 执行过程中，jQuery 会取出 animation.tweens 数组并执行数组项的 run 方法。tween 又是怎样一个概念呢？tween 针对单个 css 样式属性，通过当前样式值及动画已执行时长计算待调整的样式值，并对元素的样式做出调整。因此在 Animation 函数的实现中，程序首先将遍历待变更的 css 样式属性创建 tween；当 jQuery.fx.timer 函数触发 tick 定时任务函数执行时，在 tick 函数执行过程中，将遍历 tween 数组并执行其 run 方法，促使元素的样式得到更新。 以上内容，可以分为三个板块： 以 jQuery.fx.timer 等函数为核心的定时任务调用机制。 Tween 实例的创建和执行。其执行过程中，将使用缓动函数更新节点样式。 基于 promise 实现的 Animation 函数，其将创建 tick 定时任务，添加 promise 回调，设置回调的执行时机。抛开这些，Animation 函数还将对参数作适当的转化处理，并执行 prefilter 预处理器。 基于以上三点，就能实现单个元素的动画效果，但是没有涉及动画队列。虽然在 jQuery 中，对队列函数的控制主要在 queue 模块中，而 effects 动效模块与此交互的部分却落在接口层，如 $.animate, $.stop, $.finish 方法的实现中。这在实现部分将予以详述。 动效模块实现jQuery.fx.timer 定时任务当有定时任务 timer 函数，通过 jQuery.fx.timer 函数存入 jQuery.timers 定时任务队列中，再调用 jQuery.fx.start 函数，以启动定时任务调用程序。当用户反复调用 jQuery.fx.timer 函数时，为了避免定时任务调用程序多次执行，jQuery.fx.start 函数中带有 inProgress 标识。当定时任务调用程序已启动，inProgress 标识置为真值，实际的调度函数 schedule 将不再被重复调用。 通过 jQuery.fx.start 函数调用的调度函数 schedule 中，或者借助于 window.requestAnimationFrame 方法或者借助于 window.setTimeout 方法，以在间隔一定时间内递归调用 schedule 函数，从而触发 jQuery.fx.tick 函数的执行。 jQuery.fx.tick 函数中，程序将取出 jQuery.timers 队列中的所有定时任务并同步执行执行，若定时任务返回否值，则将其从 jQuery.timers 队列中移除。即当某个定时任务返回真值时，该定时任务将在一定时间间隔后再次被调用，直到其返回否值。 借助于 inProgress 标识为真值时，实际的调度函数 schedule 才会遍历 jQuery.timers 队列中的定时任务并予以执行，jQuery.fx.stop 方法通过将 inProgress 标识置为 null 的方式，可用于终止定时任务调用程序。而在 schedule 调度函数的执行逻辑中，当 jQuery.timers 队列已清空，也会通过调用 jQuery.fx.stop 方法，将 inProgress 标识置为 null。 在 jQuery 动画模块中，作为 timer 定时任务函数的是，Animation 函数体内创建的 tick 函数，其执行逻辑为在动画执行期间更新样式并触发 progress 回调，在动画完成后触发 done, fail 回调。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455let fxNow;jQuery.timers = [];jQuery.fx.interval = 13;jQuery.fx.timer = function( timer ) &#123; jQuery.timers.push( timer ); jQuery.fx.start();&#125;;jQuery.fx.start = function() &#123; if ( inProgress ) &#123; return; &#125; inProgress = true; schedule();&#125;;function schedule() &#123; if ( inProgress ) &#123; if ( document.hidden === false &amp;&amp; window.requestAnimationFrame ) &#123; window.requestAnimationFrame( schedule ); &#125; else &#123; window.setTimeout( schedule, jQuery.fx.interval ); &#125; jQuery.fx.tick(); &#125;&#125;jQuery.fx.tick = function() &#123; var timer, i = 0, timers = jQuery.timers; fxNow = Date.now(); for ( ; i &lt; timers.length; i++ ) &#123; timer = timers[ i ]; // Run the timer and safely remove it when done (allowing for external removal) if ( !timer() &amp;&amp; timers[ i ] === timer ) &#123; timers.splice( i--, 1 ); &#125; &#125; if ( !timers.length ) &#123; jQuery.fx.stop(); &#125; fxNow = undefined;&#125;;jQuery.fx.stop = function() &#123; inProgress = null;&#125;; Tween 样式更新Tween 构造函数Tween 在实例化过程中，首先记录关联的节点 this.elem、待更新的样式属性 this.prop、缓动函数类型 this.easing、选项 this.options（包含动画执行时长 duration、步进函数 step = (currentStyle, tween) =&gt; {}。其中，步进函数执行时的上下文为节点元素，即 this.elem），随后计算起始样式值 this.start，并记录结束样式值 this.end、样式的单位 this.unit。 在 Tween 实例的 run 方法中，将更新节点的样式值。其实现的具体逻辑为，根据传参动 percent 画已执行时长百分比，通过缓动函数 eased = fn(percent, duration * percent, 0, 1, duration)，计算样式已变更值占所需变更值的百分比 eased，并存入 this.pos 属性中，由此获得新的样式值 this.now。（缓动函数见前文） 在 Tween 实例的执行逻辑中，jQuery 额外构建了一套节点样式取值、赋值机制，即通过 Tween.propHooks 样式处理集合进行操作。其所需面对的一种情形是，this.elem 不是节点元素，或者指定的样式属性 this.prop 不是节点所有的属性，来自于用户自定义。在这种情况下，Tween.propHooks 作为一种钩子处理集合，将截获样式的获取和赋值，由 elem 引用对象以 elem[this.prop] = this.now 的形式存储待更新的样式。同时针对 IE 9 及其以下浏览器，scrollTop 作为特殊的样式，其样式赋值操作将直接作用于 elem 元素，而不是 elem.style 样式集合中。 与此同时，若用户在 jQuery.fx.step 步进函数集合中注册了针对某一个样式的特殊行为，样式赋值操作将只唤醒该行为，而不会对节点 this.elem 进行处理。如需对 this.elem 节点的样式进行处理，仍需要由用户承担额外的开发工作。 关于选项中的步进函数 options.step，其可用于以日志形式记录待更新样式的值、或者在样式更新的某个值上作特殊处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112function Tween( elem, options, prop, end, easing ) &#123; return new Tween.prototype.init( elem, options, prop, end, easing );&#125;jQuery.Tween = Tween;Tween.prototype = &#123; constructor: Tween, init: function( elem, options, prop, end, easing, unit ) &#123; this.elem = elem; this.prop = prop; this.easing = easing || jQuery.easing._default; this.options = options; this.start = this.now = this.cur(); this.end = end; this.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ); &#125;, cur: function() &#123; var hooks = Tween.propHooks[ this.prop ]; return hooks &amp;&amp; hooks.get ? hooks.get( this ) : Tween.propHooks._default.get( this ); &#125;, run: function( percent ) &#123; var eased, hooks = Tween.propHooks[ this.prop ]; if ( this.options.duration ) &#123; this.pos = eased = jQuery.easing[ this.easing ]( percent, this.options.duration * percent, 0, 1, this.options.duration ); &#125; else &#123; this.pos = eased = percent; &#125; this.now = ( this.end - this.start ) * eased + this.start; if ( this.options.step ) &#123; this.options.step.call( this.elem, this.now, this ); &#125; if ( hooks &amp;&amp; hooks.set ) &#123; hooks.set( this ); &#125; else &#123; Tween.propHooks._default.set( this ); &#125; return this; &#125;&#125;;Tween.prototype.init.prototype = Tween.prototype;Tween.propHooks = &#123; _default: &#123; get: function( tween ) &#123; var result; // Use a property on the element directly when it is not a DOM element, // or when there is no matching style property that exists. if ( tween.elem.nodeType !== 1 || tween.elem[ tween.prop ] != null &amp;&amp; tween.elem.style[ tween.prop ] == null ) &#123; return tween.elem[ tween.prop ]; &#125; // Passing an empty string as a 3rd parameter to .css will automatically // attempt a parseFloat and fallback to a string if the parse fails. // Simple values such as \"10px\" are parsed to Float; // complex values such as \"rotate(1rad)\" are returned as-is. result = jQuery.css( tween.elem, tween.prop, \"\" ); // Empty strings, null, undefined and \"auto\" are converted to 0. return !result || result === \"auto\" ? 0 : result; &#125;, set: function( tween ) &#123; // Use step hook for back compat. // Use cssHook if its there. // Use .style if available and use plain properties where available. if ( jQuery.fx.step[ tween.prop ] ) &#123; jQuery.fx.step[ tween.prop ]( tween ); &#125; else if ( tween.elem.nodeType === 1 &amp;&amp; ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) &#123; jQuery.style( tween.elem, tween.prop, tween.now + tween.unit ); &#125; else &#123; tween.elem[ tween.prop ] = tween.now; &#125; &#125; &#125;&#125;;// Support: IE &lt;=9 only// Panic based approach to setting things on disconnected nodesTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = &#123; set: function( tween ) &#123; if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) &#123; tween.elem[ tween.prop ] = tween.now; &#125; &#125;&#125;;jQuery.easing = &#123; linear: function( p ) &#123; return p; &#125;, swing: function( p ) &#123; return 0.5 - Math.cos( p * Math.PI ) / 2; &#125;, _default: \"swing\"&#125;;// Back compat &lt;1.8 extension pointjQuery.fx.step = &#123;&#125;; 创建 Tween 实例不得不说，jQuery 有五花八门的拦截机制，部分是为了满足吊诡的开发需要，部分是为了便于对 jQuery 作一层封装。其实既不借助于事件系统，也不像 webpack 那样采用回调链的方式（适用于异步形式，可以拦截后续的流程），而是使用注册 hooks 集合，针对属性对原始行为作一些拓展。Tween 构造函数中如此，创建 Tween 实例也是如此。 在 Animation 函数中，jQuery 将针对每个待调整的样式属性创建各自的 Tween 实例，默认采用 animition.createTween 方法。这一过程由 Animation.tweeners[ ““ ] 方法实现，当样式值带有 +, - 号时，adjustCSS 用于调整结束样式。除此之外，用户可以使用 Animation.tweener(callback) 方法改变 Animation.tweeners[ ““ ] 方法的行为，或者使用 Animation.tweener(prop, callback) 方法创建自定义的 tween，用于变更样式值。 需要指明的一点是，只要调用 createTween 函数，就会将新创建的 tween 添加到 animation.tweens 数组中，动画执行期间，均会刷新样式。jQuery 源码中，创建 tween 的时机有两个，其一在 Animation 函数中根据待变更的样式创建 tween，其二在 defaultPrefilter 预处理器中针对 slideUp 等动效，用于处理元素的宽高属性更新。源码见下文。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function createTween( value, prop, animation ) &#123; var tween, collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ), index = 0, length = collection.length; for ( ; index &lt; length; index++ ) &#123; if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) &#123; // We're done with this property return tween; &#125; &#125;&#125;function Animation( elem, properties, options ) &#123; // ... var animation = deferred.promise( &#123; tweens: [], createTween: function( prop, end ) &#123; var tween = jQuery.Tween( elem, animation.opts, prop, end, animation.opts.specialEasing[ prop ] || animation.opts.easing ); animation.tweens.push( tween ); return tween; &#125;, // ... &#125; ); jQuery.map( props, createTween, animation ); // ...&#125;jQuery.Animation = jQuery.extend( Animation, &#123; tweeners: &#123; \"*\": [ function( prop, value ) &#123; var tween = this.createTween( prop, value ); adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween ); return tween; &#125; ] &#125;, tweener: function( props, callback ) &#123; if ( isFunction( props ) ) &#123; callback = props; props = [ \"*\" ]; &#125; else &#123; props = props.match( rnothtmlwhite ); &#125; var prop, index = 0, length = props.length; for ( ; index &lt; length; index++ ) &#123; prop = props[ index ]; Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || []; Animation.tweeners[ prop ].unshift( callback ); &#125; &#125;&#125; Animation 动画函数剥离 jQuery.fx.timer 定时任务执行机制和 Tween 样式变更机制后，Animation 函数的实现也极为简单。其主要逻辑为，借助 deferred 模块创建 promise 对象（其表现为 animation 对象），构建 tick 函数用于设置 promise 回调的执行时机以及调用 tween.run 方法更新样式，为 promise 对象设置回调函数。 在 animation 对象中，createTween 方法用于创建 tween，并存入 animation.tweens 数组中，动画执行期间，再取出数组项刷新元素样式。stop 方法通过将 stopped 置为 true，以终止动画，若其传参 gotoEnd 为真值，则逐个遍历 animation.tweens 数组，将动画执行到末端状态。stop 方法中触发回调的机制也由 gotoEnd 传参决定，若其为真，触发成功回调，反之，触发失败回调；回调参数带有 gotoEnd 标识。 除了设置 promise 回调相关内容、启动定时任务执行脚本外，Animation 函数还有一些预处理操作。其中，propFilter 对参数进行预处理；Animation.prefilters 对 queue 队列以及特殊样式进行预处理，其返回值中的 stop 方法将注册为 queueHooks 钩子函数集合的 stop 方法；选项 options.start 由用户对 animation 进行一些预处理操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function Animation( elem, properties, options ) &#123; var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always( function() &#123; // Don't match elem in the :animated selector delete tick.elem; &#125; ), tick = function() &#123; if ( stopped ) &#123; return false; &#125; var currentTime = fxNow || createFxNow(), remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ), // Support: Android 2.3 only // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497) temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; for ( ; index &lt; length; index++ ) &#123; animation.tweens[ index ].run( percent ); &#125; deferred.notifyWith( elem, [ animation, percent, remaining ] ); // If there's more to do, yield if ( percent &lt; 1 &amp;&amp; length ) &#123; return remaining; &#125; // If this was an empty animation, synthesize a final progress notification if ( !length ) &#123; deferred.notifyWith( elem, [ animation, 1, 0 ] ); &#125; // Resolve the animation and report its conclusion deferred.resolveWith( elem, [ animation ] ); return false; &#125;, animation = deferred.promise( &#123; elem: elem, props: jQuery.extend( &#123;&#125;, properties ), opts: jQuery.extend( true, &#123; specialEasing: &#123;&#125;, easing: jQuery.easing._default &#125;, options ), originalProperties: properties, originalOptions: options, startTime: fxNow || createFxNow(), duration: options.duration, tweens: [], createTween: function( prop, end ) &#123; var tween = jQuery.Tween( elem, animation.opts, prop, end, animation.opts.specialEasing[ prop ] || animation.opts.easing ); animation.tweens.push( tween ); return tween; &#125;, stop: function( gotoEnd ) &#123; var index = 0, // If we are going to the end, we want to run all the tweens // otherwise we skip this part length = gotoEnd ? animation.tweens.length : 0; if ( stopped ) &#123; return this; &#125; stopped = true; for ( ; index &lt; length; index++ ) &#123; animation.tweens[ index ].run( 1 ); &#125; // Resolve when we played the last frame; otherwise, reject if ( gotoEnd ) &#123; deferred.notifyWith( elem, [ animation, 1, 0 ] ); deferred.resolveWith( elem, [ animation, gotoEnd ] ); &#125; else &#123; deferred.rejectWith( elem, [ animation, gotoEnd ] ); &#125; return this; &#125; &#125; ), props = animation.props; propFilter( props, animation.opts.specialEasing ); for ( ; index &lt; length; index++ ) &#123; result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts ); if ( result ) &#123; if ( isFunction( result.stop ) ) &#123; jQuery._queueHooks( animation.elem, animation.opts.queue ).stop = result.stop.bind( result ); &#125; return result; &#125; &#125; jQuery.map( props, createTween, animation ); if ( isFunction( animation.opts.start ) ) &#123; animation.opts.start.call( elem, animation ); &#125; // Attach callbacks from options animation .progress( animation.opts.progress ) .done( animation.opts.done, animation.opts.complete ) .fail( animation.opts.fail ) .always( animation.opts.always ); jQuery.fx.timer( jQuery.extend( tick, &#123; elem: elem, anim: animation, queue: animation.opts.queue &#125; ) ); return animation;&#125; propFilterpropFilter 函数以引用对象形式对传参样式属性集合 props, 缓动函数类型集合 specialEasing 进行处理。首先，其将 props 属性转化为驼峰式书写形式，同时 props 属性的值支持以二元数组形式约定样式和缓动函数类型。其次，当传入的 props 属性作为复合属性、且在 jQuery.cssHooks 注册了预处理集合，且该集合中存在 expand 处理，传入的 props 属性的值将经过 expand 方法处理，由返回值定义该操作哪些样式。 123456789101112131415161718192021222324252627282930313233343536function propFilter( props, specialEasing ) &#123; var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass for ( index in props ) &#123; name = camelCase( index ); easing = specialEasing[ name ]; value = props[ index ]; if ( Array.isArray( value ) ) &#123; easing = value[ 1 ]; value = props[ index ] = value[ 0 ]; &#125; if ( index !== name ) &#123; props[ name ] = value; delete props[ index ]; &#125; hooks = jQuery.cssHooks[ name ]; if ( hooks &amp;&amp; \"expand\" in hooks ) &#123; value = hooks.expand( value ); delete props[ name ]; // Not quite $.extend, this won't overwrite existing keys. // Reusing 'index' because we have the correct \"name\" for ( index in value ) &#123; if ( !( index in props ) ) &#123; props[ index ] = value[ index ]; specialEasing[ index ] = easing; &#125; &#125; &#125; else &#123; specialEasing[ name ] = easing; &#125; &#125;&#125; Animation.prefiltersjQuery.Animation.prefilters 作为预处理函数队列，可通过 jQuery.Animation.prefilter 添加，默认只有一个预处理函数 defaultPrefilter。 1234567891011jQuery.Animation = jQuery.extend( Animation, &#123; prefilters: [ defaultPrefilter ], prefilter: function( callback, prepend ) &#123; if ( prepend ) &#123; Animation.prefilters.unshift( callback ); &#125; else &#123; Animation.prefilters.push( callback ); &#125; &#125;&#125; ); defaultPrefilter 函数的处理内容有两块，其一针对即时执行的动画，当类型为 ‘fx’ 的 queue 队列的长度变为 0 时，也即队列等待执行的动画时，使用 queueHooks.empty 方法移除 dataPriv 中与当前 queue 相关的属性；其二针对 slideUp 等动效，不只元素的 display 属性需要在动画起始、结束时作特殊处理，元素的宽高等样式也需要通过计算获得。 对于内容一，有一点疑问，既然动画没有添加到 queue 队列中，为什么还要调用 queueHooks 钩子清除缓存中的数据呢？作为用于避免内存浪费的保证吗？ 内容一的实现，在于缓存在元素上的 hooks.unqueued 标识，动画执行期间加 1，动画执行完成后减 1，由此可以判断所有动画是否均已执行完成。当 hooks.unqueued 标识重新变成 0 值时，且缓存中的 queue 队列长度也为 0，调用钩子集合中的 empty 方法，移除 dataPriv.queue 属性。 12345678910111213141516171819202122232425262728293031323334function defaultPrefilter( elem, props, opts ) &#123; var hooks, oldfire, isBox = \"width\" in props || \"height\" in props, anim = this, orig = &#123;&#125;; // Queue-skipping animations hijack the fx hooks if ( !opts.queue ) &#123; hooks = jQuery._queueHooks( elem, \"fx\" ); if ( hooks.unqueued == null ) &#123; hooks.unqueued = 0; oldfire = hooks.empty.fire; hooks.empty.fire = function() &#123; if ( !hooks.unqueued ) &#123; oldfire(); &#125; &#125;; &#125; hooks.unqueued++; anim.always( function() &#123; // Ensure the complete handler is called before this completes anim.always( function() &#123; hooks.unqueued--; if ( !jQuery.queue( elem, \"fx\" ).length ) &#123; hooks.empty.fire(); &#125; &#125; ); &#125; ); &#125; // ...&#125;; 内容二的处理逻辑为，在 slideUp 等动效执行期间，需要对元素的显示动效作处理，从隐藏到显示或者从显示到隐藏；当动效包含宽高属性的变动时，需要将 display 从 ‘none’ 或 ‘inline’ 转换成 ‘inline-block’，以使 slideUp 等动效发生过程中，宽高样式能在视图中正常显示；当动效包含 overflow 属性变更时（作为参数 opts 选项的属性，而不像其他样式变更那样在 props 参数中），在动效执行期间，将元素的 overslow 属性设置 ‘hidden’，在动效执行完成后，再切换为配置值。 内容二的实现，借助于 dataShow 缓存数据，该缓存用于记录动效起始状态，其包含 display, hidden 属性，也包含 slideUp 等动效相关的 height, marginTop, paddingTop, [width] 属性。 dataShow.display 属性取决于元素本身的 display 样式。情形一，若其为 ‘none’，则尝试先将该元素展示在视图上，然后取其 display 样式，并存入 dataShow.display 缓存中。在这种情况下，缓存 dataShow.display 的意义在于，动画执行期间将元素的 display 样式设定为缓存值（当元素显示的 display 样式为 ‘inline’ 或 ‘inline-block’，进入情形二中的处理逻辑），以使动画得以展示。情形二，若其为 ‘inline’ 或 ‘inline-block’，dataShow.display 属性直接取元素的 display 样式。在这种情形下，缓存 dataShow.display 的意义在于，首次动画执行期间将元素的 display 样式设为 ‘inline-block’，以使 width 属性能正常变更；且对于 slideUp 等滑动、渐隐类特效（在源码中的表现为，传入 Animation 的参数为 { marginLeft: ‘show’ } 等形式），等动画执行结束后，元素的 display 样式仍回设为 dataShow.display 缓存值；当首次动画执行期间、再启动第二个动画时，则跳过上述处理逻辑、沿用第一个动画将 display 样式置为 ‘inline-block’ 的做法。 以上处理存在两个疑点。其一，上文也有指出，当元素包含除 slideUp 等类型以外的动效时，动画执行结束后，元素的 display 属性将定格为 ‘inline-block’，而不是初始的 ‘inline’。这种做法是为了满足下一个动画改变元素宽度的需求吗？其二，当第一个动画类型为 slideUp 等，在该动画执行期间插入第二个动画，当第一个动画执行完成后，元素的 display 样式将可能被设为 ‘inline’，这是否会影响第二个动画的执行？这种处理方式仍取决于动画通常以队列方式添加，而不是即时执行吗（即两个动画并行执行的可能很小）？ 内容二中，最后的处理逻辑是，使用 dataShow 缓存记录元素的初始 height, marginTop, paddingTop, [width] 等属性（这些数据经 createTween 函数处理后获得），并在动画执行前后使用 display 属性切换元素的显示状态，这样就不会影响元素原有的宽高属性。与此同时，程序将使用 createTween 函数在 animation.tweens 数组中添加 tween，该 tween 用于在动画执行期间刷新元素的 height, marginTop, paddingTop, [width] 等属性，从而实现动画效果。 上述处理逻辑的设计，基于接口层面需实现 $.slideUp 等方法。如果以类的方式构造动画模块，可以用继承类实现 slideUp 等动效，而不需要像 jQuery 那样在一体化处理逻辑掺杂 slideUp 等动效的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149var rfxtypes = /^(?:toggle|show|hide)$/；function defaultPrefilter( elem, props, opts ) &#123; var prop, value, toggle, propTween, restoreDisplay, display, isBox = \"width\" in props || \"height\" in props, anim = this, orig = &#123;&#125;, style = elem.style, hidden = elem.nodeType &amp;&amp; isHiddenWithinTree( elem ), dataShow = dataPriv.get( elem, \"fxshow\" ); // ... // Detect show/hide animations for ( prop in props ) &#123; value = props[ prop ]; if ( rfxtypes.test( value ) ) &#123; delete props[ prop ]; toggle = toggle || value === \"toggle\"; if ( value === ( hidden ? \"hide\" : \"show\" ) ) &#123; // Pretend to be hidden if this is a \"show\" and // there is still data from a stopped show/hide if ( value === \"show\" &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) &#123; hidden = true; // Ignore all other no-op show/hide data &#125; else &#123; continue; &#125; &#125; orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop ); &#125; &#125; // Bail out if this is a no-op like .hide().hide() propTween = !jQuery.isEmptyObject( props ); if ( !propTween &amp;&amp; jQuery.isEmptyObject( orig ) ) &#123; return; &#125; // Restrict \"overflow\" and \"display\" styles during box animations if ( isBox &amp;&amp; elem.nodeType === 1 ) &#123; // Support: IE &lt;=9 - 11, Edge 12 - 15 // Record all 3 overflow attributes because IE does not infer the shorthand // from identically-valued overflowX and overflowY and Edge just mirrors // the overflowX value there. opts.overflow = [ style.overflow, style.overflowX, style.overflowY ]; // Identify a display type, preferring old show/hide data over the CSS cascade restoreDisplay = dataShow &amp;&amp; dataShow.display; if ( restoreDisplay == null ) &#123; restoreDisplay = dataPriv.get( elem, \"display\" ); &#125; display = jQuery.css( elem, \"display\" ); if ( display === \"none\" ) &#123; if ( restoreDisplay ) &#123; display = restoreDisplay; &#125; else &#123; // Get nonempty value(s) by temporarily forcing visibility showHide( [ elem ], true ); restoreDisplay = elem.style.display || restoreDisplay; display = jQuery.css( elem, \"display\" ); showHide( [ elem ] ); &#125; &#125; // Animate inline elements as inline-block if ( display === \"inline\" || display === \"inline-block\" &amp;&amp; restoreDisplay != null ) &#123; if ( jQuery.css( elem, \"float\" ) === \"none\" ) &#123; // Restore the original display value at the end of pure show/hide animations if ( !propTween ) &#123; anim.done( function() &#123; style.display = restoreDisplay; &#125; ); if ( restoreDisplay == null ) &#123; display = style.display; restoreDisplay = display === \"none\" ? \"\" : display; &#125; &#125; style.display = \"inline-block\"; &#125; &#125; &#125; if ( opts.overflow ) &#123; style.overflow = \"hidden\"; anim.always( function() &#123; style.overflow = opts.overflow[ 0 ]; style.overflowX = opts.overflow[ 1 ]; style.overflowY = opts.overflow[ 2 ]; &#125; ); &#125; // Implement show/hide animations propTween = false; for ( prop in orig ) &#123; // General show/hide setup for this element animation if ( !propTween ) &#123; if ( dataShow ) &#123; if ( \"hidden\" in dataShow ) &#123; hidden = dataShow.hidden; &#125; &#125; else &#123; dataShow = dataPriv.access( elem, \"fxshow\", &#123; display: restoreDisplay &#125; ); &#125; // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\" if ( toggle ) &#123; dataShow.hidden = !hidden; &#125; // Show elements before animating them if ( hidden ) &#123; showHide( [ elem ], true ); &#125; /* eslint-disable no-loop-func */ anim.done( function() &#123; /* eslint-enable no-loop-func */ // The final step of a \"hide\" animation is actually hiding the element if ( !hidden ) &#123; showHide( [ elem ] ); &#125; dataPriv.remove( elem, \"fxshow\" ); for ( prop in orig ) &#123; jQuery.style( elem, prop, orig[ prop ] ); &#125; &#125; ); &#125; // Per-property setup propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim ); if ( !( prop in dataShow ) ) &#123; dataShow[ prop ] = propTween.start; if ( hidden ) &#123; propTween.end = propTween.start; propTween.start = 0; &#125; &#125; &#125;&#125; 接口设计在动效接口部分，笔者将拆分为两类加以分析，其一是通用的动画接口，其二是 slideUp 等特殊动效。前者提供 $.animate, $.stop, $.finish 方法；后者基于前者的 animate 方法实现。 通用动画接口$.animate 方法的处理逻辑为： 首先，使用 jQuery.speed 方法处理传参，且该方法将把 jQuery.dequeue 方法挂载到动画的回调函数中，以使前一个动画执行完成后，能取出 queue 队列中的下一个动画或普通函数并执行。特别的，当 jQuery.fx.off 开关置为真值时，样式变更将在下一个定时任务中即时得到完成。 其次，在 $.animate 方法中，如果传参 speed.queue 为 false，那么就以立即执行方式调用 Animation 函数；反之，以动画队列方式处理 Animation 函数。Animation 函数通过 doAnimation 函数封装，后续将指出为什么要用 doAnimation 函数进行封装。 $.stop 方法的处理逻辑为： 首先，视传参 clearQueue 是否为真值，清空 queue 队列函数。 其次，调用 queueHooks 钩子中的 stop 方法，并传入 gotoEnd 参数。该 stop 一则可以通过添加返回值带有 stop 方法的 prefilter 函数实现，一则可以调用 jQuery._queueHooks 注册。 其次，通过 queue 类型和 elem 属性，从 jQuery.timers 定时任务队列中取出待执行的 animation 对象，执行其 stop 方法，阻止元素样式更新或者将样式更新为最终状态（由 gotoEnd 入参决定）；并从 jQuery.timers 缓存中剔除当前元素的动画任务，基于 queue 类型判断，存储在同一个 queue 队列中的动画都将被移除。 最后，如果 gotoEnd 入参为否值，或者动画函数尚没有添加到 jQuery.timers 定时任务队列中（其情形为，动画函数在 queue 队列中等待执行。这种情形发生在调用 $.animate 方法在 queue 队列中创建 ‘inprogress’ 字符串的时候，等该动画执行完后，再使用 $.animate, $.queue 方法都将只把动画或普通函数添加到队列中，而不会自动执行，这部分可参见 jQuery 基础 - queue 队列一节），那么调用 jQuery.dequeue 方法，取出下一个动画函数并执行。如果 jQuery 对 stop 方法的设计采用如 requestAnimationFrame 的形式，即将 animation 对象输出给用户，由用户手动调用该 animation 的 stop 方法，就不会出现如上问题，而且对终止动画的操作也更具颗粒性。也许使用类的编码方式会更加合理。 $.finish 方法的处理逻辑为： 首先，从 queue 队列中取出 $.animate 方法创建的 doAnimation 函数，将 dataPriv.finish 缓存属性置为真。 其次，将 queue 队列置为空数组。 其次，调用 queueHooks.stop 钩子。 其次，根据 queue 类型和 elem 属性，遍历 jQuery.timers 定时任务队列，执行 animation.stop 方法，并从 jQuery.timers 队列中移除动画。 其次，执行 doAnimation.finish 方法，即 doAnimation 本身，这里仍是针对动画在队列中排队、得不到执行的情形。 最后，移除 dataPriv.finish 标识，意味着 doAnimation 函数中的 dataPriv.finish 只可能发生于 $.finish 方法执行期间。 由以上可以看出，jQuery 在顾全某些特殊情形时，各模块、各函数间的耦合度相当高，编码极不明朗，在程序设计上大有不可取的姿态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160var rrun = /queueHooks$/;jQuery.speed = function( speed, easing, fn ) &#123; var opt = speed &amp;&amp; typeof speed === \"object\" ? jQuery.extend( &#123;&#125;, speed ) : &#123; complete: fn || !fn &amp;&amp; easing || isFunction( speed ) &amp;&amp; speed, duration: speed, easing: fn &amp;&amp; easing || easing &amp;&amp; !isFunction( easing ) &amp;&amp; easing &#125;; // Go to the end state if fx are off if ( jQuery.fx.off ) &#123; opt.duration = 0; &#125; else &#123; if ( typeof opt.duration !== \"number\" ) &#123; if ( opt.duration in jQuery.fx.speeds ) &#123; opt.duration = jQuery.fx.speeds[ opt.duration ]; &#125; else &#123; opt.duration = jQuery.fx.speeds._default; &#125; &#125; &#125; // Normalize opt.queue - true/undefined/null -&gt; \"fx\" if ( opt.queue == null || opt.queue === true ) &#123; opt.queue = \"fx\"; &#125; // Queueing opt.old = opt.complete; opt.complete = function() &#123; if ( isFunction( opt.old ) ) &#123; opt.old.call( this ); &#125; if ( opt.queue ) &#123; jQuery.dequeue( this, opt.queue ); &#125; &#125;; return opt;&#125;;jQuery.fn.extend( &#123; animate: function( prop, speed, easing, callback ) &#123; var empty = jQuery.isEmptyObject( prop ), optall = jQuery.speed( speed, easing, callback ), doAnimation = function() &#123; // Operate on a copy of prop so per-property easing won't be lost var anim = Animation( this, jQuery.extend( &#123;&#125;, prop ), optall ); // Empty animations, or finishing resolves immediately if ( empty || dataPriv.get( this, \"finish\" ) ) &#123; anim.stop( true ); &#125; &#125;; doAnimation.finish = doAnimation; return empty || optall.queue === false ? this.each( doAnimation ) : this.queue( optall.queue, doAnimation ); &#125;, stop: function( type, clearQueue, gotoEnd ) &#123; var stopQueue = function( hooks ) &#123; var stop = hooks.stop; delete hooks.stop; stop( gotoEnd ); &#125;; if ( typeof type !== \"string\" ) &#123; gotoEnd = clearQueue; clearQueue = type; type = undefined; &#125; if ( clearQueue &amp;&amp; type !== false ) &#123; this.queue( type || \"fx\", [] ); &#125; return this.each( function() &#123; var dequeue = true, index = type != null &amp;&amp; type + \"queueHooks\", timers = jQuery.timers, data = dataPriv.get( this ); if ( index ) &#123; if ( data[ index ] &amp;&amp; data[ index ].stop ) &#123; stopQueue( data[ index ] ); &#125; &#125; else &#123; for ( index in data ) &#123; if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) &#123; stopQueue( data[ index ] ); &#125; &#125; &#125; for ( index = timers.length; index--; ) &#123; if ( timers[ index ].elem === this &amp;&amp; ( type == null || timers[ index ].queue === type ) ) &#123; timers[ index ].anim.stop( gotoEnd ); dequeue = false; timers.splice( index, 1 ); &#125; &#125; // Start the next in the queue if the last step wasn't forced. // Timers currently will call their complete callbacks, which // will dequeue but only if they were gotoEnd. if ( dequeue || !gotoEnd ) &#123; jQuery.dequeue( this, type ); &#125; &#125; ); &#125;, finish: function( type ) &#123; if ( type !== false ) &#123; type = type || \"fx\"; &#125; return this.each( function() &#123; var index, data = dataPriv.get( this ), queue = data[ type + \"queue\" ], hooks = data[ type + \"queueHooks\" ], timers = jQuery.timers, length = queue ? queue.length : 0; // Enable finishing flag on private data data.finish = true; // Empty the queue first jQuery.queue( this, type, [] ); if ( hooks &amp;&amp; hooks.stop ) &#123; hooks.stop.call( this, true ); &#125; // Look for any active animations, and finish them for ( index = timers.length; index--; ) &#123; if ( timers[ index ].elem === this &amp;&amp; timers[ index ].queue === type ) &#123; timers[ index ].anim.stop( true ); timers.splice( index, 1 ); &#125; &#125; // Look for any animations in the old queue and finish them for ( index = 0; index &lt; length; index++ ) &#123; if ( queue[ index ] &amp;&amp; queue[ index ].finish ) &#123; queue[ index ].finish.call( this ); &#125; &#125; // Turn off finishing flag delete data.finish; &#125; ); &#125;&#125; ); 特殊动效jQuery 中的特殊动效包含 toggle, show, hide, slideUp, slideDown, fadeIn, fadeOut, fadeToggle，主要为滑动及渐隐。 对于 toggle, show, hide，其处理逻辑为区分是即时的样式改变，还是动画。 对于其他样式，则需要通过 genFx 函数获取注入 Animation 函数的 props。如针对 $.slideUp 方法，genFx 函数的返回值为 { height: ‘show’, marginTop: ‘show’, paddingTop: ‘show’, marginBottom: ‘show’, paddingottom: ‘show’ }。前文已经提到，这样的数据作为参数 props 注入 Animation 函数时，将被 defaultProfilter 预处理器所拦截，并创建 tween 已更新元素的相关样式，构成滑动效果。余同 123456789101112131415161718192021222324252627282930313233343536373839404142// Generate parameters to create a standard animationfunction genFx( type, includeWidth ) &#123; var which, i = 0, attrs = &#123; height: type &#125;; // If we include width, step value is 1 to do all cssExpand values, // otherwise step value is 2 to skip over Left and Right includeWidth = includeWidth ? 1 : 0; for ( ; i &lt; 4; i += 2 - includeWidth ) &#123; which = cssExpand[ i ]; attrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type; &#125; if ( includeWidth ) &#123; attrs.opacity = attrs.width = type; &#125; return attrs;&#125;jQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) &#123; var cssFn = jQuery.fn[ name ]; jQuery.fn[ name ] = function( speed, easing, callback ) &#123; return speed == null || typeof speed === \"boolean\" ? cssFn.apply( this, arguments ) : this.animate( genFx( name, true ), speed, easing, callback ); &#125;;&#125; );jQuery.each( &#123; slideDown: genFx( \"show\" ), slideUp: genFx( \"hide\" ), slideToggle: genFx( \"toggle\" ), fadeIn: &#123; opacity: \"show\" &#125;, fadeOut: &#123; opacity: \"hide\" &#125;, fadeToggle: &#123; opacity: \"toggle\" &#125;&#125;, function( name, props ) &#123; jQuery.fn[ name ] = function( speed, easing, callback ) &#123; return this.animate( props, speed, easing, callback ); &#125;;&#125; ); 感悟这几天，我总想用一种形象化的比喻来描述自己管窥中的程序设计。有想过把它比作为流水线上的零部件加工，可使这样的形容不足以说明程序设计的复杂度。在源码阅读过程中，我发现，程序设计里对模块的使用并不像产业工人那样只是做简单的拼装。模块间的耦合度会因为设计的不合理、开发者能力的局限、问题的复杂度，而显出一定的复杂度。譬如，在 jQuery 中，queue 模块会内嵌许多针对动效的处理逻辑，基于类的形式构建程序处理的多样性会比在函数体内设置标识、或者通过传参判断，条理会更清晰明朗；在 webpack 中，module 的编译流程会散落在多个模块中，各个模块间的关联性并不是那么容易理清。程序设计并不像对汽车零部件的加工，走完这道工序，就是那一道工序。它更像从史记中理出某个历史事件，比如汉武帝听从大行王恢的建议在马邑对匈奴设伏，事件的枝节会散落在各个人物传记中；各方人物的心理也小挖掘；针对史料，又需要摸索作者的曲笔、晦言；当把事件置入历史长河、国内外局势中，则需要作一番更深远的考量。换回到工业层面，也许可以把程序设计思想为，模块就好比一台可以加工多种产品的设备，模块间的铰链就好比产品在多个设备中周转，程序设计像是创建一个工厂、一套工程，而不止于一个产品。 思考 参考 Java 中多线程 Thread 的设计，使用类的形式构建 Animation 模块。 是否能构建一个独立的流程控制器，用于在制作模块时，控制其执行流程，并对外提供钩子。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"jquery","slug":"jquery","permalink":"http://xzfyu.com/tags/jquery/"}]},{"title":"策略模式","slug":"计算机科学/设计模式/策略模式","date":"2018-05-18T16:00:00.000Z","updated":"2020-03-08T11:28:50.986Z","comments":true,"path":"2018/05/19/计算机科学/设计模式/策略模式/","link":"","permalink":"http://xzfyu.com/2018/05/19/计算机科学/设计模式/策略模式/","excerpt":"","text":"概述状态模式(Strategy pattern，也称为算法簇模式)的主要实现逻辑为，构建多个策略类用于封装不同的算法，并将这些算法的其中一个以引用形式注入给上下文对象，以使上下文对象可以将其行为委托给策略类处理。相较于状态模式内部封装了状态切换，上下文对象的行为多数委托给状态对象加以处理，策略模式委托给策略类的处理通常只是单个行为，即算法，并且，设置策略（即替换算法）的过程由外部调用者完成。 《设计模式:可复用面向对象软件的基础》一书将状态模式描述为： Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently fromclients that use it. 经典实现策略模式包含下列组件： Context: 以引用对象形式持有某个 ConcreteStrategy，对外暴露的交互接口通过将行为委托给 ConcreteStrategy 实现。 Strategy: 策略类，定义算法的抽象接口。 ConcreteStrategy: 具体策略子类，实现 Strategy 抽象类中定义的算法。 以下代码使用策略模式实现了排序算法，通过 ArrayList 实例的 setSortStragery 方法即可切换排序算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227abstract class SortPolicy&#123; constructor(context)&#123; this.context = context;// 通过引用属性访问 Context 实例，可访问实例属性，以处理状态切换操作；可改为传参实现 &#125; sort()&#123;&#125;&#125;;// 冒泡排序，比较相邻元素，将最小值左移class BubbleSort extends SortPolicy &#123; sort()&#123; const arr = this.context.target; const len = arr.length; for ( let i = 0; i &lt; len; i++ )&#123; for ( let j = 0; j &lt; len - 1 - i; j++ )&#123; if ( arr[j] &gt; arr[j+1] ) this.context.swap(j, j + 1); &#125; &#125; &#125;&#125;;// 选择排序，选取最小值，排在左侧class SelectionSort extends SortPolicy &#123; sort()&#123; const arr = this.context.target; const len = arr.length; let minIndex;// 最小值序号 for ( let i = 0; i &lt; len - 1; i++ )&#123; minIndex = i; for ( let j = i; j &lt; len; j++ )&#123; if ( arr[minIndex] &gt; arr[j] ) minIndex = j; &#125; if ( i !== minIndex ) this.context.swap(i, minIndex); &#125; &#125;&#125;;// 插入排序，将后一位比较项顺序插入到之前已排序的数组中class InsertionSort extends SortPolicy &#123; sort()&#123; const arr = this.context.target; const len = arr.length; for ( let i = 1; i &lt; length; i++ )&#123; let j = i; let temp = arr[i]; while ( j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp )&#123; arr[j] = arr[j - 1]; j--; &#125;; arr[j] = temp; &#125;; &#125;&#125;;// 归并排序，将数组项拆分后分别排序，再合并排序class MergeSort extends SortPolicy &#123; sort()&#123; const arr = this.context.target; this.mergeSortRec(arr); &#125; // 分治 mergeSortRec(arr)&#123; const len = arr.length; if ( len === 1 ) return arr; let mid = Math.floor(len / 2); let left = arr.slice(0, mid); let right = arr.slice(mid, len); return this.merge(this.mergeSortRec(left), this.mergeSortRec(right)); &#125; // 合并两个已排序数组 merge(left, right)&#123; const leftLen = left.length; const rightLen = right.length; let leftIndex = 0; let rightIndex = 0; let result = []; while ( leftIndex &lt; leftLen &amp;&amp; rightIndex &lt; rightLen )&#123; if ( left[leftIndex] &lt; right[rightIndex] ) result.push(left[leftIndex++]); else result.push(right[rightIndex++]); &#125;; while ( leftIndex &lt; leftLen )&#123; result.push(left[leftIndex++]); &#125;; while ( rightIndex &lt; rightLen )&#123; result.push(right[rightIndex++]); &#125;; return result; &#125;&#125;;// 快速排序，选取中间项，将左右两边元素按和中间相的比较结果对调，递归该过程，实现数组排序class QuickSort extends SortPolicy &#123; sort()&#123; const arr = this.context.target; const len = arr.length; this.quick(arr, 0, len); &#125; // 递归，实现分治 quick(arr, left, right)&#123; const len = arr.length; let index; if ( len &gt; 1 )&#123; index = this.partition(arr, left, right); if ( left &lt; index -1 ) this.quick(arr, left, index - 1); if ( index &lt; right ) this.quick(arr, index, right); &#125; &#125; // 按中间项对调元素，大值放在右边，小值放在左边 partition(arr, left, right)&#123; let pivot = arr[Math.floor((right + left) / 2)]; let i = left; let j = right; while ( i &lt;= j )&#123; while ( arr[i] &lt; pivot )&#123; i++; &#125;; while ( arr[j] &gt; pivot )&#123; j--; &#125;; if ( i &lt;= j )&#123; this.context.swap(arr, i, j); i++; j--; &#125;; &#125;; return i; &#125;&#125;;// 堆排序class HeapSort extends SortPolicy &#123; sort()&#123; const arr = this.context.target; let heapSize = arr.length; this.buildHeap(arr); while ( heapSize &gt; 1 )&#123; heapSize--; this.context.swap(arr, 0, heapSize); this.heapify(arr, heapSize, 0); &#125; &#125; buildHeap(arr)&#123; const heapSize = arr.length; for ( let i = Math.floor(heapSize / 2); i &gt;= 0; i-- )&#123; this.heapify(arr, heapSize, i); &#125;; &#125; heapify(arr, heapSize, i)&#123; let left = 2 * i + 1; let right = 2 * i + 2; let largest = i; if ( left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest] ) largest = left; if ( right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest] ) largest = right; if ( largest !== i )&#123; this.context.swap(arr, i, largest); this.heapify(arr, heapSize, largest); &#125;; &#125;&#125;class ArrayList &#123; constructor()&#123; this.target = []; this.sortStragery = new BubbleSort(this);// 排序策略 &#125; insert(item)&#123; this.target.push(item); &#125; // 元素互换 swap(i, j)&#123; let arr = this.target; let temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; setSortStragery(Stragery)&#123; this.sortStragery = new Stragery(this); &#125; sort()&#123; this.sortStragery.sort(); &#125; toString()&#123; return this.target.join(); &#125;&#125;; 策略模式需要注意的点： 调用者需要对策略模式提供的算法足够了解。 Context 类既可以通过调用时向 ConcreteStrategy 具体策略子类注入参数实现，也可以将自身作为引用存储在 ConcreteStrategy 具体策略子类中。同时 ConcreteStrategy 具体策略子类可以从 Strategy 抽象接口继承属性，其自身也可以实现为有状态值的。 Context 类可设置多个，以针对不同的需求，如不同的设备。 js 中的策略模式同状态模式，js 可以使用对象字面量声明多个策略子类，通过访问对象属性的方式调用算法。 动效算法切换本节以前端动效为例，试图说明策略模式在该领域中的应用。读者若想对前端动效有更深入的理解，可参见笔者的另一篇文章，jquery 动效分析。 动效实现的基本数学思想是通过动画执行时长 duration、起始位置 beginning val、结束位置(即要变化的总量) change 计算动画已执行时间 timestamp 的所处位置 pos，即函数 pos = fn(t, b, c, d)。在动效中，位置这个概念会被起始样式和结束样式所替换。策略模式的用武之地即在于设定不同的缓动函数，以计算当前样式值。 在表达式 pos = fn(t, b, c, d) 中，参数 t 动画已执行时间, b 起始样式 由程序计算获得，参数 c 结束样式, d 动画总时长 由调用方提供。为扼要说明起见，示例代码将不提供计算样式和设置样式值的 getStyles, setStyles 方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const Easings = &#123; linear(t, b, c, d)&#123; return c * t / d + b; &#125;, easeIn(t, b, c, d)&#123; return c * (t / d) * t + b; &#125;, easeOut(t, b, c, d)&#123; return -c * (t / d) * (t - 2) + b; &#125;, easeInOut(t, b, c, d)&#123; if ( 2t / d &lt; 1 ) return c / 2 * t * t + b; return - c / 2 * ((--t) * (t - 2) - 1) + b; &#125;&#125;;class Animation &#123; node = null; startTime = 0; startStyles = null; endStyles = null; duration = null; easing = null; running = false; constructor(node, styles, duration, easing)&#123; this.node = node; this.startTime = +new Date; this.startStyles = getStyles(node); this.endStyles = styles; this.duration = duration; this.easing = Easings[easing]; this.run(); &#125; run()&#123; const that = this; this.running = true; let timer = setInterval(() =&gt; &#123; that.tween(); if ( !running ) clearInterval(timer); &#125;, 10); &#125; tween()&#123; const &#123; node, startTime, startStyles, endStyles, duration, easing &#125; = this; const currentTime = +new Date; const t = currentTime - startTime; if ( t &gt;= this.duration )&#123; setStyles(node, endStyles); this.running = false; return; &#125;; let currentStyles = &#123;&#125;; Object.keys(endStyles).map(key =&gt; &#123; let startStyle = startStyles[key]; let endStyle = endStyles[key]; currentStyles[key] = easing(t, startStyle, endStyle, duration); &#125;); setStyles(this.node, currentStyles); &#125;&#125;; 上述代码中，由调用方提供缓动函数算法名，animation 实例将根据将通过指定的缓动函数计算节点的当前样式，并作相应更新。关于前端动效（包含缓动函数，动画队列等）的细微说明，笔者将在后续的文章加以展开。 校验算法切换策略模式也可以应用于数据校验中，即通过对某个字段设定校验规则，通过该规则从校验函数集合中选取函数，并对相应的数据做出校验。若需深入理解数据校验过程，可参看笔者的另一篇文章 浅析async-validator源码。 1234567891011121314151617181920212223242526272829303132333435const stratrgies = &#123; notEmpty(value, rule)&#123; if ( value === '' ) return rule.msg; &#125;, minLength(value, rule)&#123; if ( value.length &lt; rule.length ) return rule.msg; &#125;&#125;;class Validator &#123; this.rules = null; constructor(rules)&#123; this.rules = rules; &#125; validate(data)&#123; const &#123; rules &#125; = this; let errors = null; Object.keys(data).map(key =&gt; &#123; const rule = rules[key]; const value = data[key]; const validateMethod = stratrgies[rule.type]; const msg = validateMethod(value, rule); if ( msg )&#123; if ( !errors ) errors = &#123;&#125;; errors[key] = msg; &#125;; &#125;); return errors; &#125;&#125;; 参考[设计模式:可复用面向对象软件的基础][Javascript 设计模式和开发实践 - 曾探]","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"设计模式","slug":"计算机科学/设计模式","permalink":"http://xzfyu.com/categories/计算机科学/设计模式/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"js设计模式","slug":"js设计模式","permalink":"http://xzfyu.com/tags/js设计模式/"}]},{"title":"状态模式","slug":"计算机科学/设计模式/状态模式","date":"2018-03-23T16:00:00.000Z","updated":"2020-03-08T11:28:43.668Z","comments":true,"path":"2018/03/24/计算机科学/设计模式/状态模式/","link":"","permalink":"http://xzfyu.com/2018/03/24/计算机科学/设计模式/状态模式/","excerpt":"","text":"概述状态模式(State pattern) 的主要处理逻辑为，构建多个状态对象(state object)以维护特定状态下的行为集，和一个上下文对象(context)以引用形式维护与当前状态对应的状态对象，并将与状态相关的行为委托给这个状态对象加以处理；当状态更新时，上下文对象将重设其实际引用的状态对象，而其行为也将得到变更。通常，状态以标识符形式（有时候表现为内部数据值，即除了标识符以外，还有额外的数据）存储，在编写上下文对象的行为时，会使用大量的条件语句，通过当前的状态值判断实际需要执行的动作；对于新添加的状态，上下文对象的行为也需要相应改变其处理逻辑。当状态以引用对象的形式存储后，状态对象的行为可直接调用其引用的状态对象的方法；对于新添加的状态，只需要构建新的状态对象，即可加以实现。 状态模式的表现即如《设计模式:可复用面向对象软件的基础》一书中所说的： Allow an object to alter its behavior when its internal state changes.The object will appear to change its class. 经典实现状态模式包含下列组件： Context: 定义交互接口，以引用对象形式持有某个 ConcreteState，其行为通过委托给 ConcreteState 实现；当状态更新时，其持有的 ConcreteState 引用也将得到更新。 State: 状态对象，定义行为的抽象类。 ConcreteState: 具体状态子类，实现 State 抽象类中定义的行为。 使用状态模式的效果： 使用特定的类维护特定状态的行为，该类可以共享，且不同状态的类之间相互没有耦合。 状态转换更加显式化。从 Context 的角度看，状态转换只需更新其下引用的状态对象，其过程是原子的。而以内部数据值存储状态时，更新状态时，需要同时更新多个内部数据值。 以下载状态为例，其简单实现为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// typescript 编码abstract class State&#123; constructor(context)&#123; super(context); this.context = context;// 通过引用属性访问 Context 实例，可访问实例属性，以处理状态切换操作；可改为传参实现 &#125; download()&#123;&#125; pause()&#123;&#125; fail()&#123;&#125; finish()&#123;&#125;&#125;;class ReadyState extends State &#123; @override download()&#123; this.context.setState(this.context.downloadingState()); console.log(\"Start Download!\"); &#125; @override pause()&#123;&#125; @override fail()&#123;&#125; @override finish()&#123;&#125;&#125;;// DownLoadState, PauseState, FailState, FinishState 实现class DownLoad &#123; constructor()&#123; this.readyState = new ReadyState(this); this.downLoadState = new DownLoadState(this); this.pauseState = new PauseState(this); this.failState = new FailState(this); this.finishState = new FinishState(this); this.state = this.readyState; &#125; download()&#123; this.state.download(); &#125; pause()&#123; this.state.pause(); &#125; fail()&#123; this.state.fail(); &#125; finish()&#123; this.state.finish(); &#125; setState(State)&#123; this.state = State; &#125;&#125;; 上述实现存在的问题： 状态转换在 ConcreteState 具体状态子类中实现，这样 ConcreteState 就存在相互依赖关系，其中一个必须知道后继状态是哪一个。同时对于状态转换策略不同的业务场景，也不能共享状态对象。状态转换也可以放在 Context 中完成，这样做不利于状态转换的扩展，同时，状态转换较为复杂时（如开叉后再汇合，就像 git 的提交记录），其中的处理逻辑就会显得繁复。 状态对象在 Context 初始化过程中即予创建，且始终不销毁，而不是在需要使用的时候再行创建，使用完以后即予销毁。状态变更较为频繁的场景推荐在 Context 初始化过程中一次性创建所有状态对象；状态变更不频繁且初始状态未知的场景推荐使用即时创建状态对象。 因此，实现可以改写为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 使用时创建状态对象，状态切换仍由状态对象完成abstract class State&#123; download(context)&#123;&#125; pause(context)&#123;&#125; fail(context)&#123;&#125; finish(context)&#123;&#125;&#125;;class ReadyState extends State &#123; @override download(context)&#123; context.setState(new DownLoadState()); console.log(\"Start Download!\"); &#125; @override pause(context)&#123;&#125; @override fail(context)&#123;&#125; @override finish(context)&#123;&#125;&#125;;// DownLoadState, PauseState, FailState, FinishState 实现class DownLoad &#123; constructor()&#123; this.state = new ReadyState(this); &#125; download()&#123; this.state.download(this); &#125; pause()&#123; this.state.pause(this); &#125; fail()&#123; this.state.fail(this); &#125; finish()&#123; this.state.finish(this); &#125; setState(State)&#123; this.state = State; &#125;&#125; js 中的状态模式在 js 中，可直接使用对象字面量声明状态对象，同时，借助于 Function.prototype.call 方法可以将上下文对象的行为委托给状态对象加以处理。实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const FSM = &#123; ready: &#123; download: () =&gt; &#123; this.state = FSM.download; console.log(\"Start Download!\"); &#125;, pause: () =&gt; &#123; &#125;, fail: () =&gt; &#123; &#125;, finish: () =&gt; &#123; &#125; &#125;, download: &#123; download: () =&gt; &#123; &#125;, pause: () =&gt; &#123; this.state = FSM.pause; console.log(\"Download is paused!\"); &#125;, fail: () =&gt; &#123; this.state = FSM.fail; console.log(\"Download is failed!\"); &#125;, finish: () =&gt; &#123; this.state = FSM.finish; console.log(\"Download is finished!\"); &#125;, &#125;, // pause, fail, success 状态实现&#125;;class DownLoad &#123; constructor()&#123; this.state = FSM.ready; &#125; download()&#123; this.state.download.call(this); &#125; pause()&#123; this.state.pause.call(this); &#125; fail()&#123; this.state.fail.call(this); &#125; finish()&#123; this.state.finish.call(this); &#125;&#125; 将上述代码中 Function.prototype.call 方法作进一步封装，可实现为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const delegate = (context, delegation) =&gt; &#123; return &#123; download: (...args) =&gt; &#123; return delegation.download.call(context, ...args); &#125;, pause: (...args) =&gt; &#123; return delegation.pause.call(context, ...args); &#125;, fail: (...args) =&gt; &#123; return delegation.fail.call(context, ...args); &#125;, finish: (...args) =&gt; &#123; return delegation.finish.call(context, ...args); &#125; &#125;;&#125;;const FSM = &#123; ready: &#123; download: () =&gt; &#123; this.state = this.download; console.log(\"Start Download!\"); &#125;, pause: () =&gt; &#123; &#125;, fail: () =&gt; &#123; &#125;, finish: () =&gt; &#123; &#125; &#125;, download: &#123; download: () =&gt; &#123; &#125;, pause: () =&gt; &#123; this.state = this.pause; console.log(\"Download is paused!\"); &#125;, fail: () =&gt; &#123; this.state = this.fail; console.log(\"Download is failed!\"); &#125;, finish: () =&gt; &#123; this.state = this.finish; console.log(\"Download is finished!\"); &#125;, &#125;, // pause, fail, success 状态实现&#125;;class DownLoad &#123; constructor()&#123; this.ready = delegate(this, FSM.ready); this.download = delegate(this, FSM.download); this.pause = delegate(this, FSM.pause); this.fail = delegate(this, FSM.fail); this.success = delegate(this, FSM.success); this.state = this.ready; &#125; download()&#123; this.state.download(); &#125; pause()&#123; this.state.pause(); &#125; fail()&#123; this.state.fail(this); &#125; finish()&#123; this.state.finish(this); &#125;&#125; 通过 Proxy 代理实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const FSM = &#123; ready: &#123; download: (context) =&gt; &#123; context.state = FSM.download; console.log(\"Start Download!\"); &#125;, pause: (context) =&gt; &#123; &#125;, fail: (context) =&gt; &#123; &#125;, finish: (context) =&gt; &#123; &#125; &#125;, download: &#123; download: (context) =&gt; &#123; &#125;, pause: (context) =&gt; &#123; context.state = FSM.pause; console.log(\"Download is paused!\"); &#125;, fail: (context) =&gt; &#123; context.state = this.fail; console.log(\"Download is failed!\"); &#125;, finish: (context) =&gt; &#123; context.state = this.finish; console.log(\"Download is finished!\"); &#125;, &#125;, // pause, fail, success 状态实现&#125;;class DownLoad &#123; constructor()&#123; this.state = FSM.ready; &#125;&#125;const download = new Proxy(new Download(), &#123; get(target, propKey, receiver)&#123; if ( Object.keys(target.state).indexOf(propKey) !== -1 )&#123; return (...args) =&gt; &#123; target.state[propKey](target, ...args); &#125;; &#125;else&#123; return target[propKey]; &#125; &#125;&#125;) 表驱动的状态模式表驱动的状态模式，其处理逻辑为使用表结构约定每种状态在特定条件下（该条件也可以是执行状态转换逻辑的函数名）的后继状态为谁，就此实现状态转换。 借助于 Proxy 代理，实现表驱动的简易代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const FSM = &#123; ready: &#123; download: () =&gt; &#123; console.log(\"Start Download!\"); &#125;, pause: () =&gt; &#123; &#125;, fail: () =&gt; &#123; &#125;, finish: () =&gt; &#123; &#125; &#125;, download: &#123; download: () =&gt; &#123; &#125;, pause: () =&gt; &#123; console.log(\"Download is paused!\"); &#125;, fail: () =&gt; &#123; console.log(\"Download is failed!\"); &#125;, finish: () =&gt; &#123; console.log(\"Download is finished!\"); &#125;, &#125;, // pause, fail, success 状态实现&#125;;class DownLoad &#123; constructor()&#123; // 状态转换规则 this.rules = &#123; ready: [&#123; transition: 'download', to: 'downloading' &#125;], download: [&#123; transition: 'pause', to: 'paused' &#125;,&#123; transition: 'fail', to: 'failed' &#125;,&#123; transition: 'finish', to: 'finished' &#125;], pause: [&#123; transition: 'download', to: 'downloading' &#125;] &#125;; this.state = 'ready'; &#125;&#125;const download = new Proxy(new Download(), &#123; get(target, propKey, receiver)&#123; const state = target.state; const stateObject = FSM[state]; const rules = target.rules[state]; if ( Object.keys(stateObject).indexOf(propKey) !== -1 )&#123; return (...args) =&gt; &#123; stateObject[propKey](target, rules, ...args); // 状态装换 const rule = rules.filter(rl =&gt; rl.transition === propKey)[0]; if ( rule ) target.state = rule.to; &#125;; &#125;else&#123; return target[propKey]; &#125; &#125;&#125;) 通过上述代码可以发现，基于表结构实现的状态转换需要从表中查询后继状态，没有函数调用直观便捷，同时，状态转换过程需要扩展的动作也难以添加。 javascript-state-machinejavascript-state-machine 是基于表结构实现的状态转换管理器。相较于状态模式使用状态对象管理状态，并借此改变上下文对象的行为，其重心在于不同状态下行为的不同，换句话说，就是不同模式下不同的业务表现。因此，《设计模式:可复用面向对象软件的基础》书中描述了 GUI 编程使用状态模式协调不同的绘图控件。而 javascript-state-machine 模块的重心在于状态转换的流程，由此种状态进入另一种状态，通过事件执行钩子函数。 javascript-state-machine 模块有如下几个概念： transition: 事务，设定状态切换的方法名，并制定该方法状态切换的规则，从 [from] 状态转变为 [to] 状态。当切换前的 [from] 状态不同时，可使用同一个事务定制多种状态切换规则。由 transitions = [{ name, from, to }] 选项注入。 state: 状态。通过 transitions 选项转换得来。特别的，transition.to 状态可以用函数形式设定，在状态转换过程中注入 states 状态集中。 lifecycle events: 生命周期事件，即执行钩子，分为两类，以 onBefore, onAfter 为前缀的事务执行前后的生命周期钩子，以 onEnter, onLeave 为前缀的状态变更前后的生命周期钩子。特殊的，onBeforeTransition, onLeaveState, onTransition, onEnterState, onAfterTransition 为全局声明周期钩子。事件名由 transitions 选项注入，绑定函数由 methods = { eventName: () =&gt; {} } 选项注入，或者通过调用 fsm.observer({ eventName: () =&gt; {} }) 方法注入。 observer: 观察者，即绑定函数。可以通过 methods 选项添加，或者通过 StateMachine 实例的 observe 方法添加，以数组形式存储对象 { event: ({ transition, from, to, fsm, event }) =&gt; {} }。当事件发生时，再取出串行执行，通过 promise 实现了异步执行机制。 在 javascript-state-machine 模块的构造中，整体架构： config 模块提供 Config 类，用于管理 states, transitions, lifecycle, data, methods, plugins 等实例属性。其中 state 以 this.states 数组形式存储，transitions 以 this.transitions 数组形式存储方法名，this.map = { [from]:{ [name]: transition } } 存储转换规则（其中，transition 为 transitions 选项中的数组项，from 为 transition.from，name 为 transition.name）,this.lifecycle = { onBefore: { transition, …customTransitionName }, onAfter, on, onEnter: { state, …customStateName }, onLeave } 形式存储事件名（其中，this.lifecycle.onBefore.transition 等为全局事件名 ）。Config 还提供 transitionFor(state, transition) 用于查找切换后的状态。 jsm 模式提供 JSM 类，用于组织状态切换及触发钩子函数的逻辑。通过 this.config 访问 Config 实例，this.context 访问 StateMachine 实例，其 init 方法将 config.data 注入为 StateMachine 实例的属性；在 JSM 实例化过程中，又将注入到 StateMachine 实例方法的config.methods 绑定函数注入为 jsm.observers 属性中，通过 observersForEvent(event) 方法取出绑定函数，再交由 observeEvents 方法统筹一次状态变更过程中执行依序执行的事件、并执行绑定函数（以取出的 observer = { eventName: ({ transition, from, to, fsm, event }) =&gt; {} } 作为上下文，特别的，首个 observer 的就是 StateMachine 实例），最终提供 jsm.fire(transition, args) 方法将当前状态更改为 transition 事务下指定的后继状态（并导出为 stateMachine 实例的 transition 同名方法）、以及 jsm.transit(transition, from, to, args) 方法将状态转换到 to，并指定状态时的 transition, from。事件触发、执行绑定函数过程，绑定函数中的异步逻辑通过返回 promise 处理；状态变更期间，jsm.pending 属性置为真，直到状态变更完毕或报错。 app 模块提供 StateMachine 类，暴露用户接口。StateMachine 类实例化过程中会将 config 实例的 methods, data 属性转变为其实例属性，同时添加以 transition.name 标识的实例方法，因此三者的命名不能冲突。以 config, jsm, app 三个模块实现 StateMachine 类的好处是尽量少地暴露出交互接口。可通过 StateMachine 实例访问当前的状态 stateMachine.state，公共方法 is(state), can(transition), cannot(transition), observe({ event: () =&gt; {} }), transitions(), allTransitions(), allStates(), onInvalidTransition(transition, from, to), onPendingTransition(transition, from, to)，以及通过选线注入的实例属性或方法如 data, transitions, methods 选项。 需要留意的特性包含： data 选项依赖注入。当 data 选项包含方法时，其参数依赖注入的机制通过工厂函数 StateMachine.factory 实现，创建并返回 StateMachine 的另一种构造函数，该构造函数只将参数注入为 data 方法的参数；选项由 StateMachine.factory 注入。其目的是让多个 StateMachine 实例握有不同的 data 数据，但在不同状态中定制 data 数据需要借助于常规的状态模式。 to 状态转换的条件性。javascript-state-machine 模块没有设置 condition 条件（在匹配 condition 条件下，才从 from 状态转换到 to 状态），而是可以用函数形式设置 to，以使切换后的状态可以在转换阶段获得。 插件机制。如同 Vue, mocha 的插件机制，javascript-state-machine 模块的插件在 StateMachine 实例化过程中就会执行 plugin 函数或 plugin.configure 方法，其返回值中的 methods, properties 属性注入为 StateMachine 实例的方法或属性、init, lifecycle 方法将在状态初始化及变更期间被唤起执行。插件通过 plugins 选项或者 StateMachine.plugin 静态属性注入。 内置 history 插件，通过 require(‘javascipt-state-machine/lib/history’) 引用，记录状态变更历史，通过 fsm.transit 方法实现回撤、前进功能。 内置 visualize 工具，通过 require(‘javascipt-state-machine/lib/visualize’) 引用，将状态转变为 .dot 语句，借助于 GraphViz 类库表现为图形。 具体请参考 javascript-state-machine 类库文档及源码。","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"设计模式","slug":"计算机科学/设计模式","permalink":"http://xzfyu.com/categories/计算机科学/设计模式/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"js设计模式","slug":"js设计模式","permalink":"http://xzfyu.com/tags/js设计模式/"}]},{"title":"修饰器","slug":"frontend/js/Decorator","date":"2018-03-17T04:59:49.000Z","updated":"2020-03-08T10:38:45.794Z","comments":true,"path":"2018/03/17/frontend/js/Decorator/","link":"","permalink":"http://xzfyu.com/2018/03/17/frontend/js/Decorator/","excerpt":"","text":"概述修饰器是 es7 中的一个提案，其本质为编译期间执行的一个函数，用于装饰类、方法、属性等，不能用于装饰函数（因为函数存在声明提升）。 使用 decorator(target, property?, desciptor?){} 语句声明修饰器函数，其中，参数 target 为目标函数，property 为属性，desciptor 为属性描述符，后两个参数用于装饰方法或属性的情景下。装饰类，在修饰器中直接操纵类即可；装饰方法或属性时，通过返回新的属性描述符实现。 代码段 1：装饰类1234567function test(target)&#123; target.isTestable = true; target.prototype.isTestable = true;&#125;@testclass A&#123;&#125; 代码段 2：装饰属性或方法1234567891011121314function readonly(target, name, descriptor)&#123; descriptor.writable = false; return descriptor;&#125;class Person&#123; constructor(name, age, tel)&#123; this.name = name; this.id = id; &#125; @readonly id()&#123;return this.id&#125;;&#125; core-decoratorscore-decorators.js 是一个第三方模块，提供了常见的修饰器。 @readonly 修饰属性或方法为只读。通过将 descriptor.writable 赋值为 false 实现。 @nonconfigurable 修饰属性或方法为不可配置。通过将 descriptor.configurable 赋值为 false 实现。 @decorate(decorator, …args) 以指定函数装饰方法或属性。通过执行 decorator(fn|value, …args) 实现，其中 fn|value 为 descriptor.get 或 target[property]。 @extendDescriptor 继承父类的 get/set 方法。通过 Object.getPrototypeOf(target) 获取父类实现。 @nonenumerable 修饰属性不可枚举。通过将 descriptor.enumerable 赋值为 false 实现。 @lazyInitialize 在访问时延迟赋值属性。通过在访问属性时执行 descriptor.initializer 方法实现。 @autobind 将方法的上下文赋值为 target，即便方法通过 fn = target.method 语句赋值给某函数 fn，在函数 fn 执行期间，其上下文仍为 target。通过 fn.bind(target) 实现。autobind 修饰器可用于装饰类。 @deprecate(message, {url}?)|@deprecated(message, {url}?) 在方法执行期间予以已废除提示。通过将 descriptor.value 赋值为封装了提示动作的函数实现。 @override 检查子类是否正确覆盖了父类的同名方法，descriptor.value 形式时校验类型是否相同；descriptor.get, descriptor.set 形式校验父类、子类是否存在对等的设置。 @time 打印方法的执行时间，借助于 console.time, console.timeEnd 实现，可通过改写 defaultConsole 实现自定义设置。 @profile 浏览器端监测方法的执行性能，借助于 console.profile, console.profileEnd 实现。 babel 转码借助于 babel-plugin-transform-decorators-legacy 插件，可以将修饰符降级为 es5。 babel-plugin-transform-decorators-legacy 原理","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"es","slug":"frontend/es","permalink":"http://xzfyu.com/categories/frontend/es/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"js","slug":"js","permalink":"http://xzfyu.com/tags/js/"}]},{"title":"Vue 源码分析 - 数据侦测","slug":"frontend/vue/数据绑定","date":"2018-03-14T16:00:00.000Z","updated":"2020-03-08T10:53:32.796Z","comments":true,"path":"2018/03/15/frontend/vue/数据绑定/","link":"","permalink":"http://xzfyu.com/2018/03/15/frontend/vue/数据绑定/","excerpt":"","text":"序言数据侦测，也称为数据绑定，即是监测数据的更新状况，当数据更新时，触发后续动作的执行。以伪语法的形式，可以用 表达式 1 概括说明。 表达式 11234when(data changed)&#123; do compute do reaction&#125; 基于 表达式 1 ，有如下概念（基于 mobx 文档 整理）： 概念 112345Observable: 监测数据，可以是状态，更新其值将触发执行 compute 及 reactionaction: 促使 Observable 更新的动作，可用于收集 Observable 更新前后的状况compute: Observable 更新后，触发执行的动作，用于获取计算属性reaction: Observable 更新后，触发执行的动作，用于执行副作用derivations: 衍生，Observable 更新后触发动作的统称，包含 compute 及 reaction 程序实现 表达式 1 中的逻辑，主要有两种方式。第一种方式是使用定时器周期性检测 Observable 数据（下文中的响应式数据，即指监测数据 Observable）的变更，当数据变更时，触发执行后续的动作。第二种方式是借助于硬编码或钩子，将后续执行动作添加到数据更新的过程 action 之后。本篇文章旨在讨论基于观察者模式（即钩子函数的底层实现）这一种解决方案。上述两种方式都聚焦于解决怎样在数据更新后、引起后续动作的执行。当使用观察者模式实现数据侦测时，所要面临的难题是，怎样推断单个 Observable 数据被哪些 derivations 订阅（也可以称为观察或监测，当数据更新时，将引起这些 derivations 的执行），以及单个 derivations 订阅了哪些 Observable 数据（在这些数据更新后，都会引起 derivations 的执行），即确定 Observable 和 derivations 的依赖关系。 这篇文章首先将探讨使用观察者模式实现数据侦测的基本思路（见诸 _探讨_ 一节），随后分析 Vue 源码对数据侦测功能的实现（见诸 Vue 实现 一节），其次分析数据侦测在 Vue 中的实际使用，表现为 Vue 实例的配置项以及 Vue 对外提供的接口（见诸 Vue 应用 一节），最后将借鉴 mobx 的 api，简单制作一个相应类库（见诸 _延伸_ 一节）。需要说明的是，无论探讨一节，还是延伸一节，都是基于笔者对 Vue 源码的领悟，思路也因而有所局限。对于实现数据侦测功能的多种技术方案，笔者譬如井底之蛙。在这方面，读者可自行翻阅实现了数据侦测功能的其他类库或框架，免使思维陷入这篇文章的小小格局。 在阅读后续章节前，读者可以酌情先了解下 观察者模式，或者跟随笔者的思路拾级而上。 探讨数据侦测用观察者模式实现的简易原理是，当访问数据时，调用 Observer.subscribe(topic, listener) 方法，以绑定函数（下文将用订阅函数代称）形式添加订阅者；当更新数据时，调用 Observer.publish(topic, …args) 方法，执行后续的动作，即调用 listener(…args) 函数。通过在更新数据前，先访问数据，就可以使绑定函数观察这份数据变更，在数据变更后自动执行绑定函数。 代码段 112345678910111213141516171819202122232425262728293031323334import handlebars from 'handlebars';import Observer from './observer';function rerender(key, data)&#123; let el = document.getElementById(\"entry\"); let template = el.innerHTML; let compiler = handlebars.compile(template); let html = compiler(data) el.innerHTML = html;&#125;;class Observable &#123; data = null; construtor(data)&#123; this.data = data; &#125; get(key)&#123; Observer.subscribe(key, rerender); return this[key]; &#125; set(key, val)&#123; let oldVal = this.get(key); if ( oldVal !== val )&#123; this.data[key] = val; Observer.publish(key, this.data); &#125; &#125;&#125;let ob = new Observable(&#123; name: 'jack' &#125;);ob.set('name', 'andy');// 通过执行绑定函数 rerender 重绘视图 上述代码就是用观察者模式表现硬编码形式的 data.name = ‘andy’; rerender(data) 语句的处理逻辑。有关 Observer 类的实现，请参详 观察者模式 一文。然而，上述代码存在下述问题： 问题清单 1 代码书写风格的问题。ob.set(key, val) 可否简化为 data[key] = val 形式，使其同样能唤起后续动作的执行？ 显式指明的订阅函数和硬编码风格相差无几，对于 derivations 多样的业务场景并不适用，能否将其解耦，使 derivations 的执行过程更为灵活？ 解决方案 1 针对 问题 1，可通过调用 Object.defineProperty(targer, key, descriptor) 方法，将 代码段 1 中 get, set 方法的处理逻辑写进访问器属性中，得到解决。而 Object.defineProperty 方法，也是 Vue 相关源码的实现内核所在。 针对 问题 2，可通过将硬编码的 rerenderView 订阅函数演化为更灵活的订阅者管理器 SubscriberManager 类实现。即在响应式数据变更过程中，由 SubscriberManager 实例实时查找同这些响应式数据相关的订阅函数，并触发订阅函数的执行。 为着实现 SubscriberManager 类，将要面临如何解决 Observable 和 derivations 之间依赖关系管理的问题。 问题清单 2 Observable 和 derivations 的依赖关系问题。思想如由 getFullname 计算函数获得的 fullname 依赖于响应式数据中 firstname, secondname 属性的场景，即 firstname, secondname 属性变更时，将触发调用 getFullname 订阅函数的执行，而当其他属性变更时，并不触发 getFullname 的执行。getFullname 订阅函数和 firstname, secondname 监测属性有相互依赖关系。当 firstname, secondname 属性移除后，getFullname 订阅函数不再执行；当 getFullname 函数移除后，firstname, secondname 属性更新不再通知 getFullname 函数。并且，依赖关系问题不只包含当响应式数据或订阅函数移除时如何重置依赖，还包含当新增一项 derivations 观察的数据或者新增一项订阅 Observable 的函数时如何更新依赖。 解决方案 2 针对 问题 1，在没有使用 Object.defineProperty(targer, key, descriptor) 方法的场景中，可以通过 Observer.subscribe(observale, key, listener) 方式显式指明订阅函数 listener 需要在 observale[key] 数据变更后执行。这种显式指明的方式譬如手动添加，其依赖关系也必然要手动移除，需要费一番功夫才能实现自动化更新和重置依赖。虽然，可以将订阅函数 listener 以 { bindTo: [ keyPath ], linstener } 形式存储到 observale._listening 属性中（其中，keyPath 为键路径），或者以 Map 映射存储响应式对象键路径和订阅函数，通过 id 号搜寻依赖，以避免对外暴露依赖关系。在这方面，可以参考 backbone 及 emberjs 的实现。对这两者，笔者的领悟还不够充分。 继上，在使用 Object.defineProperty(targer, key, descriptor) 方法的场景中，订阅函数 listener 若以 observale 为上下文，在其执行过程中并访问 this[key] 属性时，descriptor.get 方法将得到调用。可以确知的是，descriptor.get 方法在 listener 执行背景下得到调用。当使用变量缓存 listener 时（必要情况下，可再使用先进后出队列存储执行中的订阅函数数组，其意义是在多个订阅函数嵌套执行的场景中获取当前执行的订阅函数），就可以从容建立当前订阅函数 listener 和监测数据 target[key] 的互为依赖关系。 代码段 212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879let currentSubscriber = null;class Watcher &#123; constructor(reactiveData, subscriber)&#123; currentSubscriber = subscriber.bind(reactiveData); subscriber.call(reactiveData); currentSubscriber = null; &#125;&#125;;class SubscriberManager &#123; subscribers = []; refreshSubscribers()&#123; // 实时查找订阅者 let &#123; subscribers &#125; = this; if ( subscribers.indexOf(currentSubscriber) !== -1 ) return; subscribers.push(currentSubscriber); &#125; notify()&#123; // 通知订阅者数据已变更 this.subscribers.map(subscriber =&gt; &#123; subscriber(); &#125;); &#125;&#125;;function convertToReactiveData(target, key, val)&#123; const subscriberManager = new SubscriberManager();// target 的每个属性，都需要一个订阅者管理器 const property = Object.getOwnPropertyDescriptor(target, key); if (property &amp;&amp; property.configurable === false) return; const getter = property &amp;&amp; property.get; const setter = property &amp;&amp; property.set; Object.defineProperty(target, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(target) : val; if ( currentSubscriber ) subscriberManager.refreshSubscribers(); return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(target) : val; if ( newVal === value ) return; if ( setter ) setter.call(target, newVal); else val = newVal; subscriberManager.notify(); &#125; &#125;);&#125;;class ReactiveDataManager &#123; constructor(data)&#123; data.__reactiveDataManager__ = this; Object.keys(data).map(key =&gt; &#123; let val = data[key]; convertToReactiveData(data, key, val); &#125;); &#125;&#125;;let data = &#123; firstname: 'Steven', secondname: 'Spielberg' &#125;;new ReactiveDataManager(data);function computeFullname()&#123;// 将构建两个 SubscriberManager 实例 console.log(`computed fullname is $&#123;this.firstname&#125; $&#123;this.secondname&#125;.`); return `$&#123;this.firstname&#125; $&#123;this.secondname&#125;`;&#125;;new Watcher(data, computeFullname);// 'computed fullname is Steven Spielberg.'data.secondname = 'Jobs';// 'computed fullname is Steven Jobs.' 代码段 2 即为 Vue 扼要的实现逻辑，至于怎样将数组和深度嵌套的数据转变成响应式数据，以及如何重置依赖关系，将在下一节分析 Vue 源码的过程中予以说明。 Vue 实现在 Vue 源码中，src/core/oberser 目录下各模块用于实现数据侦测。下文将用 oberser 包代称 src/core/oberser 目录。 目录结构 1123456|--- observer |--- index.js # 将对象或数组转化为响应式数据 |--- array.js # 提供改写数组 push 等原型方法的工具包 |--- watcher.js # 将订阅函数实现为订阅者 Watcher 实例 |--- dep.js # 管理响应式数据和订阅者 Watcher 的依赖关系，在 Vue 中视为 observable └--- scheduler.js # 用于调度订阅者的延迟执行 本节主要针对 index, array, watcher, dep, scheduler 模块予以扼要分析，与 Vue 实例、重新渲染机制的交互过程将在下一节予以分析。 响应式数据在 Vue 中，index 模块提供的 new Observer(value) 类用于将普通数据 value 转化成响应式数据，当响应式数据更新时，将自动订阅函数的执行。value 的数据类型可以是对象或数组。若 value 为对象，遍历其属性，通过 defineReactive 函数将属性的存取过程转变为响应式，取值时更新依赖，赋值时触发订阅函数的执行。若 value 为数组，改写其 push, pop, shift, unshift, splice, sort, reverse 原型方法，将其变异为响应式数组，上述方法执行时将触发订阅函数的执行；并通过创建新的 Observer 实例将数组项转化为响应式数据。 因此，将普通数据转化为响应式数据基于 defineReactive(target, key, value) 函数。如前文所述，defineReactive 函数通过 Object.defineProperty(obj, key, descriptor) 方法改写属性描述符实现，其中，getter 方法用于更新订阅者，setter 方法用于触发订阅函数的执行。因为 obj[key] 等同于一个主题对象，因此在 defineReactive 函数执行过程，会针对每个 key 键创建一个 Dep 依赖管理实例，再由 getter 访问器属性调用 dep.depend 方法刷新依赖。刷新依赖的机制，可参见前文，也即订阅函数(在 Vue 表现为 Watcher 实例)在执行过程中需要访问 obj[key]，就可以将 watcher 实例赋值给 Dep.target 静态属性，并促使 dep 实例和 watcher 实例相互建立引用关系(其中，dep.subs 数组存储 watchcer 实例，即与主题对象相关的订阅函数；watcher.deps 数组存储 dep 实例，即与订阅函数相关的主题对象)。当 setter 访问器执行过程中(即 action 促使数据更新时。在 Vue 中，action 表现为 method)，将由 dep.notify 方法调用 dep.subs 数组中每个 watchcer 实例的update，进而执行 watcher 挂载的订阅函数。 当 obj 为深度嵌套的数据结构时，需要作怎样的处理才能将其转变为响应式数据？易于想到的处理方式是，遍历对象的属性，当其为复杂数据结构时，递归调用 new Observer(obj[key]) 将该属性转化为响应式数据，自顶向下(或者如backbone的实现，自底向上构建响应式数据)。Vue 另辟蹊径，既然每次调用 setter 访问器时，同样需要将 newValue 转变为响应式数据，将 obj[key] 初始值转化为 observer 实例也在属性描述符中处理。对于深度嵌套的数据结构，defineReactive 函数也多了入参 sallow，用于指定是否将复杂数据结构的子属性转化为响应式数据。 代码段 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// observer/array.jsconst arrayProto = Array.prototypeconst arrayMethods = Object.create(arrayProto);[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) ob.dep.notify() return result &#125;)&#125;)// observer/index.jsfunction protoAugment (target, src: Object, keys: any) &#123; target.__proto__ = src&#125;function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125;&#125;function dependArray (value: Array&lt;any&gt;) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() if (Array.isArray(e)) &#123; dependArray(e) &#125; &#125;&#125;class Observer &#123; value: any; dep: Dep; constructor (value: any) &#123; this.value = value this.dep = new Dep() def(value, '__ob__', this) if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment// protoAugment(target, src) 执行 target.__proto__ = src : copyAugment// copyAugment(target, src, keys) 遍历 keys，将 src[key] 赋值给 target[key] augment(value, arrayMethods, arrayKeys)// 将数组的 push 等方法改写为响应式 this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i], obj[keys[i]]) &#125; &#125; observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125;function observe (value: any): Observer | void &#123; if (!isObject(value)) &#123; return &#125; let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) ) &#123; ob = new Observer(value) &#125; return ob&#125;function defineReactive ( obj: Object, key: string, val: any, shallow?: boolean) &#123; const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;// 更新前后均为 NaN return &#125; if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125; &#125;)&#125; 上述代码中，数组的依赖(指需要访问数据的订阅函数，即实际的订阅者)更新仍旧基于 Object.defineProperty 方法，可以得知的是，observer 不能单纯地将数组转变为响应式数据，数组必须是某个响应式对象的子属性。因此，vue 中的数据侦测实现不能单独作为类库使用。这在下一节中将作再度说明。 当 observer 实例对应的原始数据为数组时，observer 实例的 dep 属性存在的意义是，用于在 getter 访问器属性中通过该 dep 值(即 childOb.dep.depend)更新依赖，以使数组的 push 等方法执行时，好通过调用 dep.notify 方法，触发订阅函数的执行。同时，Vue 也不支持通过 arr[idx] = item 或 arr.length = len 语句触发订阅函数的调用。 介于 Object.defineProperty 方法只能对存在的属性起作用，Vue 中提供 set(target, key, value), del(target, key) 函数用于实现新增和删除属性同样需要触发订阅函数的场景。针对数组项，调用改写的原型方法 unshift, pop, splice 即可以移除数组项，并触发订阅函数的执行。然而，Vue 中提供的 set, del 函数将调用变异的 splice 方法处理数组，在数组项新增或删除时也触发订阅函数的执行。因此，set(arr, idx, item) 函数可用于代替 arr[idx] = item。 若 set, del 函数为响应式对象，将调用该对象相应的 observer 实例的 dep.notify 方法，也因而，observer 实例的 dep 属性存在的另一层意义是，用于促使 set, del 函数中的 observer.dep.notify 方法调用过程中，唤起订阅函数的执行。更新依赖仍旧在于 getter 访问器属性中的 childOb.dep.depend 方法。 代码段 41234567891011121314151617181920212223242526272829303132333435function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key) target.splice(key, 1, val) return val &#125; if (hasOwn(target, key)) &#123; target[key] = val return val &#125; const ob = (target: any).__ob__ if (!ob) &#123; target[key] = val return val &#125; defineReactive(ob.value, key, val) ob.dep.notify() return val&#125;function del (target: Array&lt;any&gt; | Object, key: any) &#123; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.splice(key, 1) return &#125; const ob = (target: any).__ob__ hasOwn(target, key)) &#123; return &#125; delete target[key] if (!ob) &#123; return &#125; ob.dep.notify()&#125; 依赖管理参见探讨一节中所示的最后一段代码，每个访问属性及其订阅函数的依赖关系可以通过 SubscriberManager 类加以管理。在 Vue 中，将 SubscriberManager 类分拆为 Dep 和 Watcher 两个类。 其中，Dep 根据对象的每个访问属性、或 Observer 实例(原始数据为对象或数组)，管理其依赖(即订阅函数)，因此，Vue 又将 Dep 实例注释为 observable 监视数据。依赖更新过程通过在 index.js 模块中调用 dep.depend 实现。dep.depend 方法执行过程中，将会调用 Dep.target. depend 方法更新该 dep 实例和 Dep.target(即当前运行中的订阅者 watcher 实例) 的依赖关系，也即更新 watcher.deps 数组(数组项为 Dep 实例)，表示订阅者 watcher 正在监测哪些响应式数据的变更；更新 dep.subs 数组(数组项为 Watcher 实例)，表示监视数据需要把状态更新通知哪些订阅者。这样就建立了 watcher 和 dep 互为引用关系。需要强调的是，更新依赖基于 getter 访问器属性中的 dep.depend 执行语句，getter 访问器又通过显式调用订阅函数才能触发，因此，在 Watcher 类的实现中，以 expOrFn 入参形式设定的订阅函数需要在响应式数据更新前得到调用，这也就是为什么在 Vue 中 Watcher 构造函数中会执行 this.get 方法的原因了。 因为实际的开发者可能嵌套两个以上订阅函数，所以 Vue 中使用 targetStack 以堆栈形式存储 Dep.target，以使嵌套调用的两个订阅函数中，后一个订阅函数执行完成后，将 Dep.target 回滚到前一个订阅函数的相关 Watcher 实例。 代码段 51234567891011121314151617181920212223242526272829303132333435363738394041424344454647// observer/dep.jslet uid = 0class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify () &#123; const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;// 针对嵌套使用订阅函数的场景Dep.target = nullconst targetStack = []export function pushTarget (_target: Watcher) &#123; if (Dep.target) targetStack.push(Dep.target) Dep.target = _target&#125;export function popTarget () &#123; Dep.target = targetStack.pop()&#125; 如前文所述，在 Vue 中，Watcher 构造函数的参数 expOrFn 为实际的订阅函数，而参数 cb 为响应式数据变更后待执行的回调函数，expOrFn 决定 cb 关联哪些响应式数据或其监测属性。 在 Watcher 类的实现中，参数 expOrFn 将被包装为 watcher.getter 方法，执行时以 vm 为上下文及首参，并通过 watcher.get 方法调用。watcher.get 方法的主要流程为，在 watcher.getter 执行前，通过 pushTarget(this) 将 Dep.target 赋值为当前的 watcher 实例，以使 dep.depend 方法执行过程中可以更新 watcher.deps 及 dep.subs 依赖；在 watcher.getter 执行后，通过调用 popTarget 函数释放 Dep.target，并调用 watcher 实例的 cleanupDeps 方法重置依赖。参数 expOrFn 可以是以 ‘.’ 分割的键名或普通函数。前者用于获取入参 vm 的深层属性，并作为返回值，意味着该属性及其祖先属性的更新将引起 cb 函数的执行(当返回值为复杂结构属性，可通过传参 options.deep 监测其子属性的更新，其实现原理是，利用 traverse 函数访问 watcher.getter 方法返回值的子孙属性或数组项，以此刷新依赖)；后者通过访问响应式数据 this 或首参 vm 的属性更新依赖，允许用户在 expOrFn 函数中自定义需要侦测哪个响应式数据的变更。 watcher 实例的依赖更新过程为，addDep 方法将新增的 dep 实例(通过和 newDepIds 比较判断新增与否)添加到 newDeps, newDepIds 中，所包含的 dep 实例为订阅函数执行过程中访问的响应式数据及其监测属性的相关 dep；cleanupDeps 方法将 newDeps, newDepIds 赋值给 deps, depIds，并置空 newDeps, newDepIds，即 newDeps, newDepIds 仅保留本次订阅函数执行过程中 dep 依赖，针对场景如订阅函数中使用条件语句变更访问的响应式数据等。 可以看见的是，Vue 更新 dep 和 watcher 的依赖关系都基于实际访问函数 expOrFn 的执行过程，却没法感知订阅函数的存在与否，这就造成了一个问题，当订阅函数删除时，dep.subs 中仍会有该订阅函数的相关 watcher 实例，这将促使订阅函数在响应式数据更新时再度执行。为此，Vue 提供了 watcher.teardown 实例方法，通过显式调用，能将当前 watcher 实例从 dep.subs 及 vm._watchers 数组中剔除掉。watcher.teardown 执行过程中，将this.active 标识符置为否，针对异步更新响应式数据过程时、手动调用 watcher.teardown 方法移除订阅函数的场景。而 watcher.depend 实例方法用于显式更新关联 dep 实例的依赖，即将当前 watcher 实例添加到各关联 dep.subs 数组中。 上述说明的 Watcher 类如下： 代码段 6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128let uid = 0class Watcher &#123; vm: Component; expression: string; cb: Function; id: number; active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: ISet; newDepIds: ISet; getter: Function; value: any; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) &#123; this.vm = vm vm._watchers.push(this) if (options) &#123; this.deep = !!options.deep &#125; else &#123; this.deep = false &#125; this.cb = cb this.id = ++uid // uid for batching this.active = true this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = function () &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: \"$&#123;expOrFn&#125;\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) &#125; &#125; this.value = this.get() &#125; get () &#123; pushTarget(this) let value const vm = this.vm try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; throw e &#125; finally &#123; if (this.deep) &#123; traverse(value)// 通过访问复杂结构数据 value 的子孙属性及数组项，实现依赖刷新 &#125; popTarget() this.cleanupDeps() &#125; return value &#125; addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; cleanupDeps () &#123; let i = this.deps.length while (i--) &#123; const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this) &#125; &#125; let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 &#125; update () &#123; if (this.active) &#123; const value = this.get() const oldValue = this.value this.cb.call(this.vm, value, oldValue) &#125; &#125; depend () &#123; let i = this.deps.length while (i--) &#123; this.deps[i].depend() &#125; &#125; teardown () &#123; if (this.active) &#123; remove(this.vm._watchers, this) let i = this.deps.length while (i--) &#123; this.deps[i].removeSub(this) &#125; this.active = false &#125; &#125;&#125; 上述代码存在的问题： 问题清单 3 每次响应式数据变更时，都会唤起订阅函数的执行，如一前一后分别改变 firstname 和 secondname 将会两次调用 getFullname 函数。有没有办法何必更新，只触发调用 derivations 执行一次呢？ 订阅函数的执行时机由响应式数据有否更新决定。当开发者使用 computed 选项声明了一个计算属性，无论他有没有实际使用这个计算属性，当数据更新时，仍会触发 computed 方法的执行，这是不必要的。该问题的一般意义是，怎样只注册订阅函数，而订阅函数的执行时机仍由开发者决定，该订阅函数执行时，又能获取到更新后的数据？ 作为 derivations 的 watcher.getter 兼有 action 更新响应式数据的能力，因其以响应式数据 observale 为执行上下文。用户可以在传入的 expOrFn 函数中使用 this[key] = value 语句唤起订阅函数的执行，该过程将再次调用 expOrFn 函数中的赋值语句，若 value 值每次都在改变（如赋值为 Math.random()），将造成死循环。 解决方案 3 针对 问题 1，可以将与当前触发本次响应式数据变更的 action 函数的所有相关 watcher 依赖添加到队列中，等待 action 执行完成后，再取出 watcher 实例加以执行。当然，这样处理存在的问题是，多个 action 更新同一份数据时，仍会造成订阅函数执行多次。在 Vue 的实现中，watcher 实例由 nextTick 函数添加到异步队列中，在主线程任务跑完后，才会执行异步队里中的 watcher 实例，而不是等待当前的 action 执行完成。这样处理的意义也解决了另一个问题，Vue 可以在模板中使用 _js_ 语句更新响应式数据，这会造成承载着重绘职责的 watcher 实例变成深度嵌套结构。使用 nextTick 函数后，须等待前一个重绘流程完成，再执行下一个重绘流程。关于这部分内容，将在下一节再度予以分析。Vue 默认将 watcher 添加到异步队列中，与之平级的还有 lazy, sync 模式。顾名思义，sync 模式指，响应式数据变更后，当即触发订阅函数的执行。 针对 问题 2，Vue 中提供了 lazy 模式，通过传参 options.lazy = true 设置。该模式下，在响应式数据更新后，只引起 watcher.dirty 状态被置为 true，触发 watcher.get 方法需要主动调用 watcher.evaluate 方法。在 watcher.evaluate 方法执行过程中，watcher.getter 方法的返回值将存储在 watcher.value 中，由此对外提供访问属性，用于获取新的计算值。可以想见，使用 lazy 模式也能处理同一个 action 函数更新多个响应式数据、触发订阅函数执行多次的 问题 1。Vue 中的计算属性即基于 lazy 模式实现，即在视图更新时访问计算属性，以此主动调用 watcher.evaluate 方法，firstname 和 secondname 属性的前后变更都只将触发 getFullname 执行一次，而更新 watcher.dirty 状态的动作仍会执行两次。关于计算属性相关内容，将在下一节 Vue 应用 中予以再次分析。 异步队列仅能解决同一个 action 更新多个响应式数据引起的订阅函数执行多次的问题，但是，不能用于处理同一个 action 反复更新同一个响应式数据引起的死循环。对于 问题 3 中的特例 – 使用 lazy 模式处理的计算属性，响应式数据变更时实际触发的动作只是将 watcher.dirty 置为真值，而没有调用 watcher.getter 方法，derivations 并不兼有 action 更新响应式数据的能力，也就不会引起死循环问题。对于没有采用 lazy 模式的 watcher 实例，当监测中的响应式数据前后相继更新时，其 watcher.getter 方法仍会执行多次，而由外部传入的 expOrFn 函数以及 cb 回调也会执行多次。这也是 Vue 实例中 watch 选项存在的问题。当 watch 选项中某方法将关联的响应式属性赋值为 Math.random() 时，会引起死循环。参考计算属性的实现，订阅函数单次执行的场景，也许可使用 vue.$watch(expOrFn, null, { lazy: true }) 处理，这也将在下一节予以分析。 解决方案 3 是不完全的，需要开发者遵从一种规约，譬如变异数组不能通过 arr[index] = item 语句触发订阅函数的执行一样。通过计算属性这个特例，也可以发现，在 Vue 使用过程中，需注意区分参数 expOrFn 及 cb 的职责。非 lazy 模式下，expOrFn 主要用于引导订阅者 watcher 监测哪些响应式数据变更，定位监测数据通过在函数形式 expOrFn 使用 this 关键字访问数据，或者通过键路径形式的 expOrFn 设定观察属性，或者通过 options.deep 选项监测两者的返回值。cb 仅在非 lazy 模式下使用，作为回调函数，有可能在响应式数据变更后执行。Vue 为 cb 设定的执行条件为，watcher.getter 方法返回值与原有值不等，或返回了对象，或 options.deep 为真值。这样的条件，也未见逻辑上的妥帖。非 lazy 模式下，在 expOrFn 中作除依赖收集之外的处理时须谨慎。lazy 模式下，cb 回调没有机会得到触发执行（除非 Vue 对外暴露 watcher 实例，可以显示调用 watcher.run 方法），expOrFn 的执行时机由 observer 模块的使用者调用 watcher.evaluate 方法决定（非 lazy 模式由 Vue 决定其执行时机）。计算属性这个特例就使用了 lazy 模式，expOrFn 的返回值用于更新 watcher.value 并输出。非 lazy 模式或 lazy 模式下，都需要避免在 expOrFn 或 cb 中修改响应式数据（cb 同样以全量的 observable 为执行上下文），以免再次触发订阅函数的执行。当然，若足够 Vue 实现的原理，在 expOrFn 或 cb 中修改响应式数据也许能开启某些黑魔法，这些黑魔法也可能因为 Vue 版本的升级而惨遭淘汰。 在 Vue 中，Watcher 实例化过程还接受 user 选项，用于判断当前 watcher 实例是 Vue 内建的，还是来自于开发者。而当 user 选项置真值时，Vue 只负责校验 expOrFn 键路径能否正确取值或者函数能否正确执行，而没有包含依赖关系的梳理、死循环的避免等等。 为实现 lazy, sync 模式，代码段 3 中 update 方法将被拆解为 update, run 方法。update 方法用于判断当前使用的模式，run 方法调用 watcher.get 更新依赖，再执行 cb 回调。 代码段 412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &#123; queueWatcher &#125; from './scheduler'class Watcher &#123; // ... user: boolean; lazy: boolean; dirty: boolean; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) &#123; // ... if (options) &#123; this.user = !!options.user this.lazy = !!options.lazy &#125; else &#123; this.user = this.lazy = false &#125; // ... this.value = this.lazy ? undefined : this.get()// 当即执行，收集 watcher 观察的响应式数据，建立依赖关系 &#125; update()&#123; if ( this.lazy )&#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125; &#125; run () &#123; if (this.active) &#123; const value = this.get() if ( value !== this.value || isObject(value) || this.deep ) &#123; const oldValue = this.value this.value = value if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher \"$&#123;this.expression&#125;\"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125; &#125;&#125; 调度器代码段 4 中的 queueWatcher 函数由 scheduler 模块提供。scheduler 模块通过 nextTick 函数将 watcher 添加到异步队列中，等待主线程任务执行完成后，再予以执行 watcher.run 方法。 scheduler 模块主要逻辑为当主线程任务尚在执行过程中，将 watcher 实例添加到 queue 异步队列中；若异步队列已经开始执行，则将 watcher 按 id 顺序添加 queue 队列中。特殊情况是，若在 watcher 中更新响应式数据，触发当前 watcher 再度被添加到异步队列中、并等待执行，即如 问题清单 3 中 问题 3 中的描述，通过 circular 记录当前 watcher 执行次数，若超过 MAX_UPDATE_COUNT 个数，予以警告提示。 异步队列中，watcher 实例的执行顺序以 watcher实例的创建顺序为准，通过 watcher.id 判断，主要目的是保证组价的重绘动作放在响应式数据更新时尾端，同时保证父子组件的重绘顺序，这部分内容，将在下一节予以分析。 代码段 51234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const MAX_UPDATE_COUNT = 100// 开发环境同一个 watcher 在单次异步队列中最大执行次数const queue: Array&lt;Watcher&gt; = []let has: &#123; [key: number]: ?true &#125; = &#123;&#125;let circular: &#123; [key: number]: number &#125; = &#123;&#125;let waiting = false// 异步队列等待执行中状态标识let flushing = false// 异步队列执行中状态标识let index = 0function resetSchedulerState () &#123; index = queue.length = 0 has = &#123;&#125; if (process.env.NODE_ENV !== 'production') &#123; circular = &#123;&#125; &#125; waiting = flushing = false&#125;function flushSchedulerQueue () &#123; flushing = true let watcher, id queue.sort((a, b) =&gt; a.id - b.id)// watcher 重排序 for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] id = watcher.id has[id] = null watcher.run() if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( 'You may have an infinite update loop ' + ( watcher.user ? `in watcher with expression \"$&#123;watcher.expression&#125;\"` : `in a component render function.` ), watcher.vm ) break &#125; &#125; &#125; resetSchedulerState()&#125;function queueWatcher (watcher: Watcher) &#123; const id = watcher.id if (has[id] == null) &#123; has[id] = true // 主线程尚在执行中 if (!flushing) &#123; queue.push(watcher) // 异步队列开始执行 &#125; else &#123; let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; if (!waiting) &#123; waiting = true nextTick(flushSchedulerQueue) &#125; &#125;&#125; Vue 应用创建 Vue 实例（下文中 vm 即指 Vue 实例）过程中，调用 observe 包的模块主要包含 core/instance 目录下的 state, inject, lifecycle 模块。state 模块用于将 Vue 选项 prop, data, methods, computed, watch 注入数据侦测功能，并导出数据侦测功能相关的实例属性或方法如 $props, $data, $set, $del, $watch。inject模块用于将 Vue 选项 inject 注入数据侦测功能。lifecycle 模块用于将 updateComponent 组件更新函数绑定为订阅函数。 prop, data, methods, computed, watch注入 Vue 实例且与数据侦测功能相关的选项包含 prop, data, methods, computed, watch。其中 props 为父组件传入的属性或方法，data 将转化为实际的响应式数据，methods 为影响响应式数据变更的 action，computed 为响应式数据变更后执行的计算函数，watch 为响应式数据变更后执行的副作用函数。props, data, methods, computed 均将通过代理导出为 Vue 实例的实例属性或方法，意味着 props, data, methods, computed 中的属性或方法名不能相重，Vue 实例代理的优先级为 props, methods，data, computed。 代码段 6123456789101112131415161718192021222324252627function proxy (target: Object, sourceKey: string, key: string) &#123; sharedPropertyDefinition.get = function proxyGetter () &#123; return this[sourceKey][key] &#125; sharedPropertyDefinition.set = function proxySetter (val) &#123; this[sourceKey][key] = val &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125;// initState 函数将在 Vue 实例化过程中通过 _init 实例方法得到执行function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) // Firefox 中，普通对象含有 watch 原型方法，nativeWatch 即该原型方法 if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 代码段 6 中，initState 函数将在 Vue 实例化过程中通过 vm._init 实例方法得到执行，其中，initProps, initMethods, initData, initComputed, initWatch 分别对 props, data, methods, computed, watch 选项进行处理操作。proxy 函数提供通过 vm 代理取值和赋值的功能。 props代码段 7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function initProps (vm: Component, propsOptions: Object) &#123; const propsData = vm.$options.propsData || &#123;&#125; const props = vm._props = &#123;&#125; const keys = vm.$options._propKeys = []// 辅助遍历 const isRoot = !vm.$parent observerState.shouldConvert = isRoot for (const key in propsOptions) &#123; keys.push(key) const value = validateProp(key, propsOptions, propsData, vm) if (process.env.NODE_ENV !== 'production') &#123; const hyphenatedKey = hyphenate(key) if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( `\"$&#123;hyphenatedKey&#125;\" is a reserved attribute and cannot be used as component prop.`, vm ) &#125; defineReactive(props, key, value, () =&gt; &#123; if (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123; warn( `Avoid mutating a prop directly since the value will be ` + `overwritten whenever the parent component re-renders. ` + `Instead, use a data or computed property based on the prop's ` + `value. Prop being mutated: \"$&#123;key&#125;\"`, vm ) &#125; &#125;) &#125; else &#123; defineReactive(props, key, value) &#125; if (!(key in vm)) &#123; proxy(vm, `_props`, key) &#125; &#125; observerState.shouldConvert = true&#125;function stateMixin (Vue: Class&lt;Component&gt;) &#123; const propsDef = &#123;&#125; propsDef.get = function () &#123; return this._props &#125; if (process.env.NODE_ENV !== 'production') &#123; propsDef.set = function () &#123; warn(`$props is readonly.`, this) &#125; &#125; Object.defineProperty(Vue.prototype, '$props', propsDef) // ...&#125; 代码段 7 中，通过 defineReactive 函数监测从父组件传入的 props 变更，该变更过程发生在更新子组件时，见于 core/instance/lifecycle.js 模块中的 updateChildComponent 函数。当渲染的是顶层根节点时，将 observerState.shouldConvert 标识符置为真值，意味着当顶层根节点的 props 子属性为复杂结构数据且不是响应式数据时，将其转换为响应式数据。当渲染的是其他节点是，props 子属性保持原有的数据状态，即其传入响应式数据，则输出响应式数据；传入普通数据，则输出普通数据。因为 props 是响应式数据，Vue 在开发环境下提示使用者修改 props 须谨慎。通过 stateMixin 函数导出的 vm.$props 在开发环境也是只读的。但用户仍可以修改 vm.$props 的子属性。 同时，代码段 7 中 observe 函数改写为 代码段 7 中形式，添加 observerState.shouldConvert 标识符阻止将子组件获得的 props 子属性转变为 Observer 实例。 代码段 8123456789101112131415161718192021const observerState = &#123; shouldConvert: true&#125;function observe (value: any): Observer | void &#123; if (!isObject(value)) &#123; return &#125; let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( observerState.shouldConvert &amp;&amp;// 阻止将子组件获得的 props 子属性转变为 Observer 实例 (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue// 排除 Vue 实例 ) &#123; ob = new Observer(value) &#125; return ob&#125; data代码段 9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function getData (data: Function, vm: Component): any &#123; try &#123; return data.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, `data()`) return &#123;&#125; &#125;&#125;function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // 将 data 转变为响应式数据 observe(data, true /* asRootData */)&#125;function stateMixin (Vue: Class&lt;Component&gt;) &#123; const dataDef = &#123;&#125; dataDef.get = function () &#123; return this._data &#125; if (process.env.NODE_ENV !== 'production') &#123; dataDef.set = function (newData: Object) &#123; warn( 'Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this ) &#125; &#125; Object.defineProperty(Vue.prototype, '$data', dataDef) // ...&#125; 代码段 9 中，通过 observe 函数将 data 选项转变为响应式数据。data 选项可以是对象或函数形式，当其为函数时，可以通过上下文或首参 Vue 实例获取从父组件注入的 props。initData 函数中，通过代理将 data 导出为 Vue 实例的属性，开发者也可以通过 vm._data 或 vm.$data 获取全量数据。 methods代码段 10123456789101112131415161718192021222324252627function initMethods (vm: Component, methods: Object) &#123; const props = vm.$options.props for (const key in methods) &#123; if (process.env.NODE_ENV !== 'production') &#123; if (methods[key] == null) &#123; warn( `Method \"$&#123;key&#125;\" has an undefined value in the component definition. ` + `Did you reference the function correctly?`, vm ) &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a prop.`, vm ) &#125; if ((key in vm) &amp;&amp; isReserved(key)) &#123; warn( `Method \"$&#123;key&#125;\" conflicts with an existing Vue instance method. ` + `Avoid defining component methods that start with _ or $.` ) &#125; &#125; vm[key] = methods[key] == null ? noop : bind(methods[key], vm) &#125;&#125; 对 methods 选项的处理无他，也就是将 Vue 实例作为其执行上下文。methods 作为更新响应式数据的 action，仍是开发者需要遵从的一种规则。通过 methods 各方法对 Vue 实例中的响应式数据执行赋值操作，既可以触发订阅函数的执行。也可以通过直接赋值 vm.$data 的子属性触发订阅函数的执行，但不推荐。 computed代码段 1112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const computedWatcherOptions = &#123; lazy: true &#125;function initComputed (vm: Component, computed: Object) &#123; const watchers = vm._computedWatchers = Object.create(null) for (const key in computed) &#123; const userDef = computed[key] const getter = typeof userDef === 'function' ? userDef : userDef.get if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) &#123; warn( `Getter is missing for computed property \"$&#123;key&#125;\".`, vm ) &#125; watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ) if (!(key in vm)) &#123; defineComputed(vm, key, userDef) &#125; else if (process.env.NODE_ENV !== 'production') &#123; if (key in vm.$data) &#123; warn(`The computed property \"$&#123;key&#125;\" is already defined in data.`, vm) &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn(`The computed property \"$&#123;key&#125;\" is already defined as a prop.`, vm) &#125; &#125; &#125;&#125;function defineComputed ( target: any, key: string, userDef: Object | Function) &#123; const shouldCache = !isServerRendering() if (typeof userDef === 'function') &#123; sharedPropertyDefinition.get = createComputedGetter(key) sharedPropertyDefinition.set = noop &#125; else &#123; sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop sharedPropertyDefinition.set = userDef.set ? userDef.set : noop &#125; if (process.env.NODE_ENV !== 'production' &amp;&amp; sharedPropertyDefinition.set === noop) &#123; sharedPropertyDefinition.set = function () &#123; warn( `Computed property \"$&#123;key&#125;\" was assigned to but it has no setter.`, this ) &#125; &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125;function createComputedGetter (key) &#123; return function computedGetter () &#123; const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key] if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate() &#125; if (Dep.target) &#123; watcher.depend() &#125; return watcher.value &#125; &#125;&#125; 代码段 11 中，通过创建 lazy 模式的 Watcher 实例处理计算属性。通过代码，也可以看出，开发者传入的 computed 选项，其属性 userDef 可以是函数或对象形式。若 userDef 为函数，当响应式数据未更新，使用 vm[computedKey] 取值时将获取缓存中的 watcher.value；当响应式数据已更新，则调用 watcher.evaluate 方法（即在模板 template 中使用计算属性时）重新计算值。若 userDef 为对象，且 userDef.cache 属性为真值，vm[computedKey] 取值方式与 userDef 为函数的情形相同；而 vm[computedKey] 赋值操作以 vm 为上下文，可以手动操作响应式数据，也就有可能触发 userDef.get 的再次执行，须谨慎。若 userDef 为对象，且 userDef.cache 属性为否值，vm[computedKey] 的取值、赋值操作仍以 vm 为上下文，两者在响应式数据更新后均不会触发执行，但可以可以手动操作响应式数据。 watcher代码段 1212345678910111213141516171819202122232425262728function initWatch (vm: Component, watch: Object) &#123; for (const key in watch) &#123; const handler = watch[key] if (Array.isArray(handler)) &#123; for (let i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]) &#125; &#125; else &#123; createWatcher(vm, key, handler) &#125; &#125;&#125;function createWatcher ( vm: Component, keyOrFn: string | Function, handler: any, options?: Object) &#123; if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; if (typeof handler === 'string') &#123; handler = vm[handler] &#125; return vm.$watch(keyOrFn, handler, options)&#125; 对 watcher 选项处理，即是创建 Watcher 实例的过程。watcher 选项的属性名可以是键路径，作为 Watcher 构造函数的入参 keyOrFn；而其值可以是函数或对象，若为对象，以 watch[key].handler 作为 Watcher 构造函数的入参 cb，其余属性作为入参 options。vm.$watch 方法见下一小节。 $set, $del, $watch, Vue.set, Vue.del代码段 131234567891011121314151617181920212223242526function stateMixin (Vue: Class&lt;Component&gt;) &#123; // ... Vue.prototype.$set = set Vue.prototype.$delete = del Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object ): Function &#123; const vm: Component = this if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125; options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) &#123; cb.call(vm, watcher.value) &#125; return function unwatchFn () &#123; watcher.teardown() &#125; &#125;&#125; vm.$set, vm.$del 即取 observe 包导出的 set, del 函数。vm.$watch 方法允许次参 cb 为对象，并将 options.user 选项置为真值，标识为用户设定的 watcher；若 options.immediate 选项为真值，当即执行 cb；返回函数用于在 derivations, observale 依赖关系中释放该 watcher。 Vue.set, Vue.del 方法同 vm.$set, vm.$del。 provide, inject代码段 141234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function initProvide (vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === 'function' ? provide.call(vm) : provide &#125;&#125;function initInjections (vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) if (result) &#123; observerState.shouldConvert = false Object.keys(result).forEach(key =&gt; &#123; if (process.env.NODE_ENV !== 'production') &#123; defineReactive(vm, key, result[key], () =&gt; &#123; warn( `Avoid mutating an injected value directly since the changes will be ` + `overwritten whenever the provided component re-renders. ` + `injection being mutated: \"$&#123;key&#125;\"`, vm ) &#125;) &#125; else &#123; defineReactive(vm, key, result[key]) &#125; &#125;) observerState.shouldConvert = true &#125;&#125;export function resolveInject (inject: any, vm: Component): ?Object &#123; if (inject) &#123; const result = Object.create(null) const keys = hasSymbol ? Reflect.ownKeys(inject).filter(key =&gt; &#123; return Object.getOwnPropertyDescriptor(inject, key).enumerable &#125;) : Object.keys(inject) for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const provideKey = inject[key].from let source = vm while (source) &#123; if (source._provided &amp;&amp; provideKey in source._provided) &#123; result[key] = source._provided[provideKey] break &#125; source = source.$parent &#125; if (!source) &#123; if ('default' in inject[key]) &#123; const provideDefault = inject[key].default result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn(`Injection \"$&#123;key&#125;\" not found`, vm) &#125; &#125; &#125; return result &#125;&#125; provide, inject 选项用于实现组件间的跨级传递，其基本实现同 props 选项，可参考 props 一小节。 vm._watcherVue 中，将更新后的响应式数据重绘到页面上，这一过程借助于在挂载组件时执行 vm._watcher = new Watcher(vm, updateComponent, noop) 语句创建 Watcher 实例实现。需要更新视图时，通过 vm._watcher.update 方法即可更新视图。这条执行语句见于 lifecycle 模块中的 mountComponent 函数，updateComponent 函数将作为 Watcher 构造函数的入参 expOrFn，即当在 vm 中响应式数据变更后，调用 updateComponent 函数更新组件、重绘视图。这部分内容，笔者将在后续的文章中加以分析。 前文提到的 computed, watch 选项和 $watch 方法均会创建 watcher 实例；同时这一小节也指明，各组件的 mountComponent 函数执行过程中均会创建 watcher 实例。可以预知的是，与组件 updateComponent 函数相关的重绘 watcher 实例会在与 computed, watch 选项相关的一般 watcher 实例后创建，因此上文中的 scheduler 模块通过 watcher.id 排序执行各 watcher.run 方法，以保证一般 watcher 实例在重绘 watcher 实例之后执行；重绘 watcher 实例按父子组件的顺序执行；当子组件移除时，其下的各 watcher 实例又将被跳过（响应式数据删除后，相关 watcher 实例便不再被唤起执行）。实现参见 代码段 5。 当 updateComponent 函数执行过程中，模板中设定的 _js_ 函数可以更新响应式数据，在该函数执行过程中，与一般 watcher 实例执行过程触发响应式数据变更一样，都会将后续的 watcher 实例添加到异步队列中，并在同一个异步队列中执行完成。在 updateComponent 函数，须执行组件的 update 钩子，组件 Vue 实例通过 watcher.vm 获取；以及 keep-alive 组件的 activated 钩子。关于这部分内容，笔者将在后续的文章中再加以分析 改写 scheduler 模块中 flushSchedulerQueue 的函数如下： 代码段 1512345678910111213141516171819202122232425262728293031323334353637function flushSchedulerQueue () &#123; // ... resetSchedulerState() callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) // devtool hook if (devtools &amp;&amp; config.devtools) &#123; devtools.emit('flush') &#125;&#125;function callUpdatedHooks (queue) &#123; let i = queue.length while (i--) &#123; const watcher = queue[i] const vm = watcher.vm if (vm._watcher === watcher &amp;&amp; vm._isMounted) &#123; callHook(vm, 'updated') &#125; &#125;&#125;// createComponent 函数执行时调用，添加 keep-alive 组件function queueActivatedComponent (vm: Component) &#123; vm._inactive = false activatedChildren.push(vm)&#125;function callActivatedHooks (queue) &#123; for (let i = 0; i &lt; queue.length; i++) &#123; queue[i]._inactive = true activateChildComponent(queue[i], true /* true */) &#125;&#125; 以上即为 Vue 内部对数据监测功能的使用。 延伸本节将根据 mobx 的 api 接口设计响应式 model。 class Model { @observable data = { firstname: ‘steven’, secondname: ‘spielberg’ }; @action changeData(){ this.data = { firstname: ‘steven’, secondname: ‘jobs’ } } @computed get fullname(){ return ${this.firstname}.${this.secondname}; } @reaction log(){ console.log(‘name changed’); }};","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"vue","slug":"frontend/vue","permalink":"http://xzfyu.com/categories/frontend/vue/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"vue","slug":"vue","permalink":"http://xzfyu.com/tags/vue/"}]},{"title":"观察者模式","slug":"计算机科学/设计模式/观察者模式","date":"2018-03-03T16:00:00.000Z","updated":"2020-03-08T11:28:56.173Z","comments":true,"path":"2018/03/04/计算机科学/设计模式/观察者模式/","link":"","permalink":"http://xzfyu.com/2018/03/04/计算机科学/设计模式/观察者模式/","excerpt":"","text":"概述观察者模式(Observer pattern)也称为发布-订阅模式(publish-subscribe pattern)，其处理逻辑即是当主题对象(a subject or a observable，也称为目标)的状态发生变更时，自动以广播的形式通知依赖于它的多个观察者(observers)，促使这些观察者执行后续的动作。其一般意义即为，在一对多的依赖关系中，当依赖更新时，所有依赖于它的对象(dependent)都会自动接收通知，并启用后续的处理流程。 在《设计模式:可复用面向对象软件的基础》一书中，观察者模式被定义为 One or more observers are interested in the state of a subject and register their interest with the subject by attaching themselves. When something changes in our subject that the observer may be interested in, a notify message is sent which calls the update method in each observer. When the observer is no longer interested in the subject’s state, they can simply detach themselves. 经典实现观察者模式包含下列组件： Subject: 维护 observers 清单，可添加或移除 observer。由 Subject 衍生出具象类 ConcreteSubject，通过继承或 extend。 Observer: 提供 update 接口。当 observer 对象接到 subject 状态更新的通知时，自动调用 update 方法。由 Observer 衍生出具象类 ConcreteObserver。 ConcreteSubject: 在 Subject 基础上构建，存储主题状态。当状态更新时，通知所有 ConcreteObserver 具体观察者。 ConcreteObserver: 在 Observer 基础上构建，存储 ConcreteSubject 的引用，实现 update 接口。该接口调用时，具体观察者的内部状态 observerState 将与 ConcreteSubject 具体主题对象的 subjectState 状态保持一致。 简单实现为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Subject &#123; observers = new ObserverList(); attach(observer)&#123; this.observers.push(observer); &#125; detach(observer)&#123; this.observers = this.observers.filter(ob =&gt; ob !== observer); &#125; notify()&#123; this.observers.map(observer =&gt; observer.update()); &#125;&#125;class Observer &#123; update()&#123; // ... &#125;&#125;class ConcreteSubject extends Subject &#123; subjectState = null; attach(concreteObserver)&#123; concreteObserver.concreteSubject = this; super.attach(concreteObserver); &#125; detach(concreteObserver)&#123; concreteObserver.concreteSubject = null; super.detach(concreteObserver); &#125; getState()&#123; return this.subjectState; &#125; setState(state)&#123; this.subjectState = state; this.notify(); &#125;&#125;class ConcreteObserver &#123; observerState = null; concreteSubject = null; update()&#123; this.observerState = this.concreteSubject.getState(); // ... &#125;&#125; 上述实现存在的问题： 观察者需要监听多个主题对象的更新状态。可将 subject 实例作为 update 方法的参数，以使 observer 知晓哪个主题对象触发了更新。 多个状态更新过程，将触发同样多个 notify，造成效率低。可由 observer 实例在合并多个状态更新后，控制 notify 方法的调用。 观察者接受通知时，需要额外的附属信息。可由 subject 实例在调用 update 方法时注入参数实现。按参数信息量的大小，可分为推模型(push model)、拉模型(pull model)两类。推模型，subject 将全量信息注入 update 方法；拉模型，subject 只将少量信息注入 update 方法，再由 observer 实例获取 subject 实例的状态。 观察者只对主题对象的部分信息感兴趣。可由 attach(observer, interset?) 方法中添加 interset 参数实现，interset 表示观察者实际感兴趣的方面(aspects)。 当主题对象和观察者的依赖关系较为复杂时，需要实现更改管理器 ChangeManager 来管理依赖关系。ChangeManager 的目的尽量减少观察者反映其主题对象的状态变化所需的工作量。ChangeManager 包含三种职责，维护主体对象到观察者的映射，因此就不需要主题对象维护观察者的引用，也不需要观察者维护主题对象的引用；定义一个特定的更新策略；根据主题对象的请求，更新所有观察者。有两种特殊的 ChangeManager，SimpleChangeManager 总是更新每一个主题对象的所有观察者；DAGChangeManager 处理主题对象及其观察者之间依赖关系构成的无环有向图，两个或多个主题对象改变产生冗余更新时，DAGChangeManager 将保证观察者仅接受一个更新。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class ChangeManager &#123; subjectToObserverMap = new Map; register(subject, observer)&#123; let observers = this.subjectToObserverMap.get(subject); let has = observers.some(ob =&gt; ob === observer); if ( !has ) observers.push(observer); this.subjectToObserverMap.set(subject, observers); &#125; unregister(subject, observer)&#123; let observers = this.subjectToObserverMap.get(subject); observers = observers.some(ob =&gt; ob !== observer); this.subjectToObserverMap.set(subject, observers); &#125; notify()&#123; // ... &#125;&#125;class SimpleChangeManager extends ChangeManager &#123; notify()&#123; subjectToObserverMap.keys.map(subject =&gt; &#123; subjectToObserverMap.get(subject).map(observer =&gt; &#123; observer.update(subject); &#125;); &#125;) &#125;&#125;class DAGChangeManager extends ChangeManager &#123; notify()&#123; let shouldUpdate = false; subjectToObserverMap.keys.map(subject =&gt; &#123; if (/* subject */) shouldUpdate = true; &#125;); subjectToObserverMap.keys.map(subject =&gt; &#123; subjectToObserverMap.get(subject).map(observer =&gt; &#123; if (shouldUpdate) observer.update(); &#125;); &#125;); &#125;&#125; 结合主题对象和观察者，将其接口结合在一个类中实现，这样可以避免多重继承。 发布订阅模式发布订阅模式(或者事件模型)即是观察者模式的一个变种。观察者模式基于在主题对象(the object firing event)中维护观察者(the object wishing receive topic notiffications)，状态更新时触发观察者的行为实现；当观察者仅对主题对象的部分数据感兴趣时，需要在 attach(observer, interset?) 方法执行过程中注入参数 interset。发布订阅模式通过主题频道(topic channel or event channel，也称为事件频道)关联订阅者(subscribers, the object wishing receive topic notiffications)和发布者(publisher, the object firing event)。简单地说，观察者模式基于主题对象、观察者这两个类实现，各自维护另一方的引用；发布订阅模式基于事件模型实现，订阅者以绑定函数形式存储于 topics 或 events 内部属性中，发布过程即取出绑定函数并执行。 123456789101112131415161718192021222324252627282930313233343536// 基于发布订阅语义let subUid = -1;class Pubsub &#123; topics = &#123;&#125;; subscribe(topic, func)&#123; if (!this.topics[topic]) this.topics[topic] = []; let token = (++subUid).toString(); this.topics[topic].push(&#123; token: token, func: func &#125;); return token; &#125; publish(topic, ...args)&#123; if (!this.topics[topic]) return false; this.topics[topic].map(subscriber =&gt; &#123; subscriber.func(topic, ...args); &#125;); &#125; unsubscribe(token)&#123; this.topics.map(topic =&gt; &#123; this.topics[topic] = this.topics[topic].filter(subscribe =&gt; subscribe.token !== token); &#125;); return false; &#125;&#125; 123456789101112131415161718192021222324252627282930// 基于事件模型语义class Event &#123; events = &#123;&#125;; on(event, handler)&#123;// 也可实现为 linsten, bind 方法 if (!this.events[event]) this.events[event] = []; this.events[event].push(handler); return this; &#125; emit(event, ...args)&#123;// 也可实现为 trigger, fire 方法 if (!this.events[event]) return false; this.events[event].map(handler =&gt; &#123; handler(event, ...args); &#125;); &#125; off(event, handler)&#123;// 也可实现为 remove 方法 if ( !this.events[event] ) return false; if ( !handler ) this.events[event] = []; else this.events[event] = this.events[event].filter(fn =&gt; handler !== fn); &#125;&#125; 应用延迟订阅在事件模型中，通常需要先添加订阅者，然后再发布事件。在实际业务场景中，有可能存在先发布，发布时还没有订阅者的情景，如 QQ 的离线消息。这时需要构建一个存放离线事件的堆栈(offlineStack)存储发布的消息，当有对象订阅这条消息时，再遍历堆栈，取出事件执行。 1234567891011121314151617181920212223class OfflineEvent &#123; offlineStack = []; on(event, handler, last)&#123; super.on(event, handler); if ( last )&#123; this.offlineStack.pop()(); &#125;else&#123; this.offlineStack.map(fn =&gt; &#123; fn(); &#125;) &#125; &#125; emit(event, ...args)&#123; let fn = () =&gt; &#123; supper.emit.call(this, event, ...args) &#125;; this.offlineStack.push(fn); &#125; off(event, handler)&#123; super.off(event, handler); &#125;&#125; node: events 模块events 模块提供 EventEmitter 类，主要实现逻辑见前述 Event 类。 不同的是: once(event, linstener): node 中的 events 模块实现了 once 方法，其实现逻辑为用包装函数(wrapped)装饰 listener，在 emit 方法触发事件调用后，由触发执行的包装函数(wrapped)移除 listener，即调用 eventEmitter.removeListener(event, listener) 方法。 prependListener(event, listener): events 模块还实现了 prependListener 方法，用于在 this._events[event] 数组头部插入 listener，addListener 或 on 方法为尾部插入。 removeListener, removeAllListeners: removeListener(event, listener) 方法只能移除某个绑定函数，即需要指定参数 listener；removeAllListeners(event) 用于移除所有绑定函数，或者某个事件的绑定函数(当指定 event 参数时)，其移除过程中，先移除普通事件的绑定函数，再移除 ‘removeListener’ 事件的绑定函数，即在普通事件的绑定函数移除过程中，仍会触发 ‘removeListener’ 事件。 ‘error’ 事件: 对于 ‘error’ 事件，即便没有注册绑定函数，也会以抛出错误对象的形式加以处理。 ‘newListener’ 事件: 以 ‘newListener’ 添加的绑定函数，若未曾调用 emit 方法显式触发事件，在下一次 addListener, prependListener 方法执行过程中，将取出 ‘newListener’ 事件的绑定函数，率先执行，即 ‘newListener’ 特殊事件在注册绑定函数时触发执行。 ‘removeListener’ 事件: 同 ‘newListener’ 事件，为 events 模块的特殊事件，即在移除绑定函数时触发执行。 在注册绑定函数的过程中，单个绑定函数将以函数形式存储，多个存储为数组形式。 listeners(event), rawListeners(event): 用于获取某个事件的绑定函数。 listenerCount(event): 在 events 模块中，添加和移除绑定函数，都会更新 this._eventsCount 属性(绑定函数个数)，然而 listenerCount(event) 方法用于获取某个事件的绑定函数个数。 setMaxListeners(num), getMaxListeners: 在 events 模块中，this._maxListeners 属性用于限定可注册绑定函数的最大个数，setMaxListeners(num), getMaxListeners 方法即用于设置或获取该值。 具体代码，请翻看 node/lib/events.js 文件(version = 9.7.1)。 疑问 关于 DAGChangeManager？ 参考[设计模式:可复用面向对象软件的基础]学习 Javascript 设计模式[Javascript 设计模式和开发实践 - 曾探]","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://xzfyu.com/categories/计算机科学/"},{"name":"设计模式","slug":"计算机科学/设计模式","permalink":"http://xzfyu.com/categories/计算机科学/设计模式/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"js设计模式","slug":"js设计模式","permalink":"http://xzfyu.com/tags/js设计模式/"}]},{"title":"vue整体架构","slug":"frontend/vue/vue整体架构","date":"2018-02-27T16:00:00.000Z","updated":"2020-03-08T10:53:27.601Z","comments":true,"path":"2018/02/28/frontend/vue/vue整体架构/","link":"","permalink":"http://xzfyu.com/2018/02/28/frontend/vue/vue整体架构/","excerpt":"","text":"目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326|--- compiler # 将 html 脚本编译为字符串函数体，作为 Vue 实例的 render 方法??? |--- codegen # 将 ast 转化成字符串拼接的函数内容体 |--- events.js # 提供 genHandlers(events, isNative, warn) 将 # el.events = &#123; name: ['handler1', 'handler2'] &#125; 事件转化为字符串 # `on:&#123;$&#123;name&#125;:handler1,handler2&#125;` 形式。html 中绑定事件接受三种形式， # 纯函数形式，函数名或方法名，或函数体，由 vue 注入 $event 事件对象 └--- index.js # 提供 generate(ast, options) 函数，将抽象语法树转化成 # 字符串拼接的函数 render = `with(this)&#123;return $&#123;code&#125;&#125;`，返回值为 # &#123; render, staticRenderFns &#125; 对象。options 通过 CodegenState 类 # 注入全局指令及 options.modules['transformCode'|'genData'] |--- directives # 注入为 CodegenState 实例的 directives 属性，在 html # 中为节点注入指令属性时，在 codegen/index.js 脚本执行 genDirectives 函数 # 阶段，通过指令属性名获取相应的全局指令脚本 directive，并执行 # directives(el, dir, warn)，其中 dir 为指令名 |--- bind.js |--- index.js |--- model.js └--- on.js |--- parser # 将 html 字符串转化成 ast 抽象语法树 |--- entity-decoder.js |--- html-parser.js # 提供 parseHtml(html, options) 函数，解析 html， # 通过 options['start'| 'end'|'comment'|'chars'] 提取 # 节点标签(含属性)、注释和节点内外字符集 |--- index.js # 提供 parse(template, options) 函数，内部调用 parseHtml # 函数，将 html 字符串转化成抽象语法树，树节点 el 注入 parent, children, # events, props, attrs, if, for, key, ref 等属性 |--- filter-parser.js # 提供 parseFilters(exp) 函数， # 将 exp = `$&#123;expression&#125;|$&#123;filter&#125;|...` 转换成特定字符串 # `_f(\"$&#123;filter&#125;\")($&#123;exp&#125;)` └--- text-parser.js # 提供 parseText(text, delimiters?) 函数， # 区分对待普通字符串和由分隔符包裹的字符串(应用过滤器， # 以 token = `_s($&#123;exp&#125;)` 形式返回)，最终生成 tokens 数组 |--- optimizer.js # 提供 optimize(root, options) 函数，为视图中不会 # 改变的静态节点注入 static = true 属性，为只包含文本的静态节点注入 # staticRoot = true 属性及 staticInFor 属性 |--- create-compiler.js # 提供 createCompilerCreator(baseCompile) # 函数，返回 createCompiler(template, options) 函数，用于创建 # &#123; compile, compileToFunctions &#125;。compile 方法，即由通过调用 # baseCompile 函数，先执行 parse 函数，后执行 generate 函数， # 返回 &#123; render, staticRenderFns, errors,tips &#125; 对象。 # compileToFunctions 方法即 createCompileToFunctionFn(compile) 返回值 |--- to-function.js # 提供 createCompileToFunctionFn(compile) 函数， # 返回 compileToFunctions(template, options?, vm?) 函数。 # compileToFunctions 函数同样返回 &#123; render, staticRenderFns &#125; 对象， # 其中 render 方法用于将 compile().render 字符串构建为函数并执行 |--- index.js # 通过为 createCompilerCreator 函数注入 baseCompile 回调， # 返回 &#123; compile, compileToFunctions &#125; 对象，见 create-compiler.js 文件注释 |--- error-detector.js └--- helpers.js # 工具函数|--- core |--- components |--- index.js └--- keep-alive.js |--- global-api |--- use.js # 添加 Vue.use(plugin, ...args) 静态方法，插件机制，直接执行插件 # plugin 函数或 plugin.install 函数 |--- mixin.js # 添加 Vue.mixin(obj) 静态方法，参数 obj 将混入到 Vue.options 属性中 |--- extend.js # 添加 Vue.extend(options) 静态方法，基于 Vue 构造函数，创建子构造函数 # 可用于创建生成 vue 实例的工厂函数，由 instance/init.js 模块将各类的 options 注入为 # Vue 实例的 $options 属性 |--- assets.js # 添加 Vue['component'|'directive'|'filter'](id, definition?) # 静态方法，获取或添加 Vue.options['components'|'directives'|'filters'][id]， # 用于创建全局组件、指令或过滤器 └--- index.js # 添加 Vue.config 静态属性，Vue.util 工具函数集合， # Vue.['set'|'delete'|'nextTick'] 静态方法 |--- instance |--- render-helpers |--- bind-object-listeners.js |--- bind-object-props.js |--- check-keycodes.js |--- index.js |--- render-list.js |--- render-slot.js |--- render-static.js |--- resolve-filter.js └--- resolve-slots.js |--- init.js # initMixin(Vue) 为 Vue 添加 _init(options) 原型方法， # 合并祖先组件的 options 及 options 入参，赋值给 vm.$options， # 相继调用 initProxy, initLifecycle, initEvents, initRender, # initInjections, initState, initProvide 方法，执行 'beforeCreate', 'mounted' # 生命周期方法，条件调用 $mount(vm.$options.el) 挂载组件 |--- proxy.js # initProxy(vm)，赋值vm._renderProxy，用户通过 vm._renderProxy # 获取不存在的 vm 属性时将会予以警告 |--- lifecycle.js # initLifecycle(vm)，初始化生命周期相关属性 # lifecycleMixin(Vue) 为 Vue 添加 _update, $forceUpdate, $destory 原型方法； # mountComponent(vm, el, hydrating?) 构建 Watcher 实例，回调中执行 # vm._update 方法，执行 'beforeCreate', 'mounted' 方法； # update(vm, propsData, listeners, parentVnode, renderChildren) 调用 # vm.$forceUpdate 方法更新视图??? # activateChildComponent(vm, direct?), deactivateChildComponent(vm, direct?)； # callHook(vm, hook) 执行 vm.$options[hook]，条件调用 vm.$emit(`hook:$&#123;hook&#125;`) |--- events.js # initEvents(vm) 通过 vm.$on, vm.$once 绑定 # vm.$options._parentListeners 函数；eventMixin(Vue) 为 Vue 添加 # $on, $once, $off, $emit 原型方法，注册事件存储在 vm._events 属性中 |--- render.js # initRender(vm) 设置 vm['$node'|'$slot'|'$scopeSlots'| # '$createElement'|'_c'] 属性或方法，调用 defineReactive 使 # vm['$attrs'|'listeners'] 为响应式；renderMixin(Vue) 为 Vue 添加 # $nextTick, _render(调用 vm.$options.render 创建 Vnode), # _o, _n, _s, _l, ... (注入 compile 函数)等方法 |--- inject.js # 组件跨级传递数据。initProvider(vm) 将 vm.$options.provide # 赋值给 vm._provide；initInjections 调用 defineReactive 将先辈组件传入的 # 数据响应式化；resolveInject 获取先辈组件的数据 |--- state.js # proxy(target, sourceKey, key) 将 target[sourceKey][key] # 代理为 target[key]；initState(vm) 调用 initProps, initMethods, initData, # initComputed, initWatch，间接使用 defineReactive 或 new Watch 响应化 # 数据或观察数据；stateMixin(Vue) 为 Vue 添加 $data, $props 只读属性， # $set, $delete, watch(expOrFn, cb, options?) 原型方法 └--- index.js # Vue 构造函数，调用 initMixin(Vue), stateMixin(Vue), # eventsMixin(Vue), lifecycleMixin(Vue), renderMixin(Vue) 注入原型方法 |--- observer |--- index.js # observerState.shouldConvert 是否将新值转换为响应式； # new Observer(value)，若 value 为数组，改写 push 方法，递归为数组项生成 # Observer 实例；若 value 为对象，调用 defineReactive 函数使属性响应化， # value.__ob__ 挂载 Observer 实例；observer(value, asRootData?) 创建 # 并返回 value 对应的 Observer 实例；defineReactive 函数调用 # Object.defineProperty 方法重写属性的访问器属性，set 方法触发 dep.notify， # get 方法触发 dep.depend 方法；set 函数将新添加的属性转化为响应式； # delete 函数删除属性触发 dep.notify 方法 |--- array.js # arrayMethods 提供改写数组 push 等方法的对象，push 等方法 # 执行时触发 dep.notify 方法调用 |--- dep.js # Dep 类，管理订阅者，addSub, removeSub 添加或移除订阅者， # depend 使 dep 和 Dep.target = watcher 实例相互关联，notify 调用 # 订阅者的 update 方法；pushTarget, popTarget 更改 Dep.Target |--- watcher.js # new Watcher(vm, expOrFn, cb, options?) 通过更改 # 响应式数据，触发 dep.notify 调用 watcher.update，执行 cb 回调 └--- scheduler.js # queueWatcher(watcher) 将 watcher 置入队列， # 通过 nextTick 在下次渲染完成后调用 watcher 队列的 run 方法，执行其 # cb 回调，并调用 'updated', 'activated' 生命周期方法； # queueActivatedComponent(vm) 将 vm 加入 activatedChildren 队列， # 用于触发 'activated' 生命周期方法 |--- util |--- debug.js |--- env.js |--- error.js |--- index.js |--- lang.js |--- options.js |--- perf.js └--- props.js |--- vdom |--- helpers |--- extract-props.js |--- get-first-component-child.js |--- index.js |--- is-async-placeholder.js |--- merge-hook.js |--- normalize-children.js |--- resolve-async-component.js └--- update-listeners.js |--- modules |--- directives.js |--- index.js └--- ref.js |--- vnode.js # Vnode 类，虚拟节点，其 context 属性通常为 vm 实例； # createEmptyNode(text) 创建注释节点，createTextNode(text) 创建文本节点 # cloneNode(vnode, deep?), cloneNodes(vnodes, deep?) 复制节点 |--- create-element.js # 提供 _createElement(context, tag?, data?, # children, normalizationType?) 函数，区分固有元素、已定义组件名、组件的 # 构造函数等情况，创建 Vnode 实例；createElement 函数，调用 _createElement， # 构建 vm._c, vm.$createElement，创建 Vnode 实例 |--- create-component.js # 提供 createComponent(Ctor, data, context, # children, tag?) 参数 Ctor 为构造函数、options 对象或 async 函数， # context 为 vm 实例，data 来自 ast，当 options.functional 为真值， # 为无状态组件，最终创建 Vnode |--- create-functional-component.js # 提供 createFunctionalComponent # (Ctor, propsData, data, contextVm, children) 函数，无状态组件， # 不会生成 Vue 实例，没有 data，最终创建 Vnode └--- patch.js # 提供 createPatchFunction(backend) 函数，参数 backend 中， # nodeOpts 属性为平台节点操作，modules 数组为平台属性、样式、事件操作以及 # Vue 特有的指令、ref 引用操作，生成 patch(oldVnode, Vnode, hydrating, # removeOnly, parentElm, refElm) 函数，绘制或重绘视图 |--- config.js └--- index.js |--- platforms |--- web |--- compiler |--- directives |--- html.js |--- index.js |--- model.js └--- text.js |--- modules |--- class.js |--- index.js |--- model.js └--- style.js |--- index.js |--- options.js └--- util.js |--- runtime |--- components |--- index.js |--- transition-group.js └--- transition.js |--- directives |--- index.js |--- model.js └--- show.js |--- modules |--- attrs.js # 浏览器端 updateAttrs(oldVnode, vnode) 更新 attr 属性 # 返回 &#123; create: updateAttrs, update: updateAttrs &#125; |--- class.js # 浏览器端 updateClass(oldVnode, vnode) 更新 class 属性 # 返回 &#123; create: updateClass, update: updateClass &#125; |--- dom-props.js # 浏览器端 updateDOMProps(oldVnode, vnode) 更新 prop 属性 # 返回 &#123; create: updateDOMProps, update: updateDOMProps &#125; |--- events.js # 浏览器端 updateDOMListeners(oldVnode, vnode) 更新绑定事件， # updateDOMListeners 将为 core/vdom/helpers/index.js 模块注入 add, remove， # 返回 &#123; create: updateDOMListeners, update: updateDOMListeners &#125; |--- style.js # 浏览器端 updateStyle(oldVnode, vnode) 更新 style 属性 # 返回 &#123; create: updateStyle, update: updateStyle &#125; |--- transition.js └--- index.js # 用于构建传入 createPatchFunction(backend) 函数中的 # backend.modules 数组，浏览器端节点属性、类、事件、样式操作 |--- class-util.js # 浏览器端 addClass(el, cls), removeClass(el, cls) 函数 |--- transition-util.js # resolveTransition(def?) 构建 transition 类名； # transitionProp, transitionEndEvent, animationProp, animationEndEvent # 相关事件名；nextFrame(fn) 通过 requestAnimationFrame 或 setTimeout # 执行 fn 函数；addTransitionClass(el, cls), removeTransitionClass(el, cls)， # 类操作；getTransitionInfo(el, expectedType?) 通过 el 样式获取相关属性； # whenTransitionEnds(el, expectedType, cb) 通过事件执行 cb 回调 |--- node-ops.js # 浏览器端 createElement(tagName, vnode), # createElementNS(namespace, tagName), createTextNode(text), # createComment(text), insertBefore(parentNode, newNode, referenceNode), # removeChild(node, child), appendChild(node, child), parentNode(node), # nextSibling(node), tagName(node), setTextContext(node), # setAttribute(node, key, val) 函数 # 用于构建传入 createPatchFunction(backend) 函数中的 backend.nodeOpts |--- patch.js # 通过 core/vdom/patch.js 模块构建 patch 函数 └--- index.js # 添加 Vue.config 属性；添加 Vue.options.directives 指令， # 添加 Vue.options.components 组件；添加 __patch__, $mount 原型方法； # devtools 触发 'emit' 事件；导出 Vue |--- server |--- directives |--- index.js └--- show.js |--- modules |--- attrs.js |--- class.js |--- dom-props.js |--- index.js └--- style.js |--- compiler.js └--- util.js |--- util |--- attrs.js |--- class.js |--- compat.js |--- element.js |--- index.js └--- style.js |--- entry-runtime.js # 导出 web/runtime/index.js 文件中的 Vue 构造函数 |--- entry-compiler.js |--- entry-runtime-with-compiler.js # 改写 $mount 原型方法，通过 template # 节点、html 字符串或节点 id，设置 options.render 方法，随后挂载组件； # 添加 Vue.compile = compileToFunctions 静态方法 |--- entry-server-basic-renderer.js └--- entry-server-renderer.js └--- weex |--- compiler |--- directives |--- index.js └--- model.js |--- modules |--- append.js |--- class.js |--- index.js |--- props.js └--- style.js └--- index.js |--- runtime |--- components |--- index.js |--- richtext.js |--- transition-group.js └--- transition.js |--- directives └--- index.js |--- modules |--- attrs.js |--- class.js |--- events.js |--- index.js |--- style.js └--- transition.js |--- index.js |--- node-ops.js |--- patch.js └--- text-node.js |--- util └--- index.js |--- entry-compiler.js |--- entry-framework.js └--- entry-runtime-factory.js|--- server |--- bundle-renderer.js |--- create-bundle-renderer.js |--- create-bundle-runner.js └--- source-map-support.js |--- optimizing-compiler.js |--- codegen.js |--- index.js |--- modules.js |--- optimizer.js └--- runtime-helpers.js |--- template-renderer.js |--- create-async-file-mapper.js |--- index.js |--- parse-template.js └--- template-stream.js |--- webpack-plugin.js |--- client.js |--- server.js └--- util.js |--- create-basic-renderer.js |--- create-renderer.js |--- render-context.js |--- render-stream.js |--- render.js |--- util.js └--- write.js |--- sfc └--- parser.js └--- shared |--- constants.js # 导出 SSR_ATTR 服务器端渲染, ASSET_TYPES 静态成员名 # (component, directive, filter), LIFECYCLE_HOOKS 生命周期钩子 └--- util.js","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"vue","slug":"frontend/vue","permalink":"http://xzfyu.com/categories/frontend/vue/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"vue","slug":"vue","permalink":"http://xzfyu.com/tags/vue/"}]},{"title":"typescript文档笔记","slug":"frontend/js/typescript文档笔记","date":"2018-02-24T16:00:00.000Z","updated":"2020-03-08T10:38:28.622Z","comments":true,"path":"2018/02/25/frontend/js/typescript文档笔记/","link":"","permalink":"http://xzfyu.com/2018/02/25/frontend/js/typescript文档笔记/","excerpt":"","text":"基础类型ts 基础类型包含 boolean, number, string, array, tuple 元祖, enum, any 任意类型, void 非任意类型(可赋值为 undefined 或 null，通常用于函数无返回值时), undefined, null, never 永不存在值的类型(通常用于函数报错或陷入死循环时), symbol。 其中，数值类型支持十进制、十六进制、八进制和二进制字面量。 字符串类型支持 es6 模板字符串。 数组类型 Array 限定元素类型一致，使用 let list: number[] = [1, 2, 3]; 或 let list: Array = [1, 2, 3]; 声明。ReadonlyArray 只读数组类型，不能将其赋值给普通数组，但可以通过类型断言将其转化为普通数组，如 numberReadonlyArray as number[]。 元祖类型预先声明元素类型，元素类型可以不一致。如 let x: [string, number]; x = [‘hello’, 10]; 同时，对于新增的元素，其类型必须在已声明类型中。上述示例中，x[6] = true; 将报错。 枚举从 0 开始为元素编号，也可以手动编号，如 enum Color {Red = 1, Green, Blue}; 通过 Color.Red 或 Color[1] 可以获取枚举值。 symbol 类型的值是通过 Symbol 构造函数创建，其值不可改变且唯一，如 let sym = Symbol()。es6 支持。 类型断言类型断言使用 value 或 value as Type；JSX 中只能使用 as，不能使用尖括号。TS 尝试做类型转换，而没有类型检查和结构。 Symbol Symbol.hasInstance 方法，instanceof 运算符内部调用 Symbol.hasInstance 方法。 Symbol.iterator 方法，for-of语句内部调用 Symbol.iterator 方法，返回对象的默认迭代器。 Symbol.isConcatSpreadable 属性，Array.prototype.concat 方法内部使用 Symbol.isConcatSpreadable 判断数组是否可展开。 Symbol.match 方法，String.prototype.match 方法内部调用 Symbol.match 方法。 Symbol.replace 方法，String.prototype.replace 方法内部调用 Symbol.replace 方法。 Symbol.search 方法，String.prototype.search 方法内部调用 Symbol.search 方法。 Symbol.split 方法，String.prototype.split 方法内部调用 Symbol.split 方法。 Symbol.toStringTag 方法，Object.prototype.toString 方法内部调用 Symbol.toStringTag 方法。 Symbol.species 构造函数，用于创建派生对象。 Symbol.toPrimitive 方法，ToPrimitive 抽象操作调用 Symbol.toPrimitive 方法，把对象转换为相应的原始值。 Symbol.unscopables 对象，它自己拥有的属性会被with作用域排除在外。 变量let 为块级作用域，用于修正 var 为函数、模块级作用域的怪异问题。const 块级作用域，常量。 块级作用域var 变量的声明会在编译阶段上移到函数、模块头部，因此造成怪异一为在 if, for 语句中声明的 var 变量可以在条件或循环语句外访问；造成怪异二为在内外两层 for 语句条件体内声明的同一变量引用同一个变量；造成怪异三为 for 语句执行过程有延迟，其最终引用的是条件体执行完成的结果。 推想 let 修正块级作用域的过程，就是在编译过程中用匿名函数包裹代码块(if, for, {} 平级)，var 变量在该匿名函数中声明，可以解决怪异一、二；使用闭包包裹延迟函数，可以在延迟函数等待期间保留原有的作用域，这可能会导致内存泄漏。 解构数组使用 [ item1, item2, …rests ] = arr; 语法解构，如 [first, second] = [second, first]; 即为变量交换数据。 对象使用 { prop1, prop2, …rests } = obj; 语法解构。 属性重命名采用 “:”，默认值采用 “=”，如 { prop1 = “default”, prop2: “key” }。 解构适用于函数入参。 展开展开同样使用 “…”，如 val = { prop1: “value”, …obj }。 接口接口作为类型当使用 value: Interface 语法将接口用于类型检查时，value 必须满足 Interface 声明的结构化类型，即 value 作为对象时，其属性需满足 Interface 属性的类型规则，允许 value 包含接口未声明的额外属性；value 作为函数时，其入参、返回值须满足接口约定的类型规则，value 参数名可与 Interface 定义的名字不同。 接口类型使用 “?” 后缀声明可选属性，当可选属性存在时，且 value 为对象字面量时，将不允许 value 包含接口未声明的额外属性；若 value 为变量，则允许。 使用 “readonly” 修饰符声明只读属性。 使用 [propName: Type1]: Type2 索引签名可用于接受特定类型的属性，Type1 用于约定索引的类型(索引包含对象的属性和数组项)，Type2 用于约定值类型。索引签名 Type1 可以是 “string”, “number” 中的一个，数字通过转化为字符串索引对象，因此数字索引的返回值必须是字符串索引的返回值的子类型。 12345678910111213141516interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125;interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;// 关于索引类型interface NumberDictionary &#123; [index: string]: number; length: number;// 可以，length是number类型 name: string// 错误，`name`的类型与索引类型返回值的类型不匹配&#125; 接口用于实现接口描述了类的公共部分，但不包含私有部分。 当类实现了接口时，只对其实例部分进行类型检查，而 constructor 方法属于类的静态部分。对 constructor 方法进行校验需要由工厂函数完成。 12345678910111213141516171819interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick();&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;let digital = createClock(DigitalClock, 12, 17); 接口可以继承接口，且一个接口可以继承多个接口。 接口可以继承类。当接口继承类时，接口会继承类的private和protected成员，但不包含类的实现。继承类的接口只能被该类及其子类继承。 类子类通过 super 关键字访问父类，如 super() 用于执行父类的构造函数。 public 关键字用于声明公共属性，默认使用 public 修饰符；protected 关键字用于声明保护属性；private 关键字用于声明私有属性。实例含有相同的公共属性、私有属性，且这些公共属性、私有属性声明在同一个类中，两个实例就是兼容的，就可以互相赋值，否则会报错。 constructor 构造函数也能被标注为 protected，意味着这个类不能在包含它的类外被实例化，但是能被继承。 对构造函数的入参使用 private, protected, public 修饰符时，类初始化将构建同名私有属性、保护属性、公共属性。 readonly 关键字用于声明只读属性，只读属性必须在声明时或构造函数里被初始化。 get, set 关键字用于声明存取器属性，需要将编译器设置为输出ECMAScript 5或更高，只带有 get 不带有 set的存取器自动被推断为 readonly。 static 关键字用于声明静态属性。 123456789101112131415161718192021class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee 能够继承 Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\"); // 错误: 'Person' 的构造函数是被保护的. 抽象类abstract 关键字用于声明抽象类。在抽象类，abstract 关键字还可以用于声明抽象方法，抽象方法只定义方法签名但不包含方法体，即不包含实现。由子类提供具体方法。 Mixins混入ts 中的类，可以用 implements 关键字实现多个类，即将类视为接口，需要在实现类中添加接口类的成员属性，再通过 applyMixins 等自定义函数将接口类的原型属性赋给实现类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Disposable Mixinclass Disposable &#123; isDisposed: boolean; dispose() &#123; this.isDisposed = true; &#125;&#125;// Activatable Mixinclass Activatable &#123; isActive: boolean; activate() &#123; this.isActive = true; &#125; deactivate() &#123; this.isActive = false; &#125;&#125;class SmartObject implements Disposable, Activatable &#123; constructor() &#123; setInterval(() =&gt; console.log(this.isActive + \" : \" + this.isDisposed), 500); &#125; interact() &#123; this.activate(); &#125; // Disposable isDisposed: boolean = false; dispose: () =&gt; void; // Activatable isActive: boolean = false; activate: () =&gt; void; deactivate: () =&gt; void;&#125;applyMixins(SmartObject, [Disposable, Activatable]);let smartObj = new SmartObject();setTimeout(() =&gt; smartObj.interact(), 1000);////////////////////////////////////////// In your runtime library somewhere////////////////////////////////////////function applyMixins(derivedCtor: any, baseCtors: any[]) &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;); &#125;);&#125; 函数定义函数时，可以声明参数和返回值的类型，如 (arg: Type1) =&gt; Type2 {} 或 function(arg: Type1): Type2 {}。 函数重载通过定义多个函数类型来实现。 1234567891011121314151617181920let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123;suit: string; card: number; &#125;;function pickCard(x): any &#123; if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125;else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); this关键字非方法式调用会将 this 视为 window(在严格模式下，this 为 undefined)。fn(…args) 等同 fn.call(window [ES5-strict: undefined], …args)。obj.method(…args) 等同 obj.method.call(obj, …args)。 方法若以闭包形式书写，其返回函数的 this 始终指向 undefined 或 window，而不是挂载的对象。箭头函数即用于将返回函数的 this 指向挂载对象。不同于函数在调用时才获知 this 的指向，箭头函数在定义时就声明了 this 的指向。 推想函数 this 指向，就是在编译过程通过判断调用方式是函数还是方法，将 this 赋值为 undefined 或相关对象。箭头函数改写 this 的实现过程也即是，在编译阶段通过包装函数调用 bind 方法将箭头函数的 this 改写为函数所在的 this 或方法的上层对象。箭头函数的 this 指向在包装函数内实现，因此不能改变 this 的指向。 12345678910111213141516171819202122232425262728interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck // 使用 this 参数将 this 的类型从 any 变更成 Deck 类型 createCardPicker: function(this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 泛型声明时不确定类型，调用时设定类型，促使定义的函数或类适用于不同的类型，同时能避免使用 any 时跳过类型校验的情景。 泛型使用 ‘&lt;’, ‘&gt;’ 包裹。 泛型函数使用 function(arg: T): T { } 或 function(arg: Array): T { } 等形式。 泛型类使用 class ClassName { method: (arg: T) =&gt; T } 等形式。 泛型可使用继承接口的形式加以约束 12345678910111213141516171819202122232425// 泛型函数interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity;// 泛型类class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;// 使用泛型创建工厂函数function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123; return new c();&#125; 枚举枚举类型在编译阶段通过函数赋值对象的方式构建，每个枚举成员包含枚举值和枚举名，生成枚举值到枚举名的双向映射。在编译阶段，枚举值通过直接求值获得；若未指定枚举值，首个枚举成员的枚举值初始化为 0，其余枚举成员的枚举值由前一个枚举成员的枚举值加 1 获得。 123456789enum Directions &#123; Up, Down, Left, Right&#125;;Directions.Up;// 0Directions[0];// \"Up\" 高级类型交叉类型使用 Type1 &amp; Type2 &amp; Type3 语法，被校验数据须包含所有声明类型的特性。 联合类型使用 Type1 | Type2 | Type3 语法，被校验数据可以是所有声明类型的其中之一。 标签联合仍使用 Type1 | Type2 | Type3 语法，且 Type1, Type2, Type3 中包含可辨识的标签属性，用于区分到底属于哪个类型。 索引类型使用 keyof T 校验对象属性, T[K] 校验值。 1234567891011121314151617181920212223242526272829// 标签联合interface Square &#123; kind: \"square\"; size: number;&#125;interface Rectangle &#123; kind: \"rectangle\"; width: number; height: number;&#125;interface Circle &#123; kind: \"circle\"; radius: number;&#125;type Shape = Square | Rectangle | Circle;function area(s: Shape) &#123; switch (s.kind) &#123; case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; &#125;&#125;// 索引类型function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] &#123; return o[name]; // o[name] is of type T[K]&#125; 映射类型，通过 [P in keyof T] 遍历旧类型的值 T[P]，以构建新类型。 12345678910111213// Readonly, Partial, Pick, Record 包含在 ts 标准库中type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;type Record&lt;K extends string, T&gt; = &#123; [P in K]: T;&#125; 类型别名类型别名使用 type Alias = Type 语法。 12345678910111213type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125;// 泛型类型别名type Container&lt;T&gt; = &#123; value: T &#125;; 模块模块有其自身的作用域，通过模块加载器导入其他模块。模块导入使用 import 关键字，导出使用 export 关键字，默认导出使用 default 关键字(数值、类和函数声明可以直接被标记为默认导出)。 模块导入导出也可以使用 export = xxx; import module = require(“module”); 语法。 根据编译时指定的模块目标参数，编译器会生成相应的供Node.js (CommonJS)，Require.js (AMD)，isomorphic (UMD), SystemJS或ECMAScript 2015 native modules (ES6)模块加载系统使用的代码。编译时，使用 –module commonjs，将转化为 CommonJS 模块；使用 –module amd，将转化为 AMD 模块； 1234567891011121314151617// 导出重命名class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;export &#123; ZipCodeValidator &#125;;export &#123; ZipCodeValidator as mainValidator &#125;;// 重新导出export &#123;ZipCodeValidator as RegExpBasedZipCodeValidator&#125; from \"./ZipCodeValidator\";export * from \"./ZipCodeValidator\";// 导入重命名import &#123; ZipCodeValidator as ZCV &#125; from \"./ZipCodeValidator\";import * as validator from \"./ZipCodeValidator\"; 模块解析策略ts 共有两种模块解析策略，Node 和 Classic，默认值为使用了 –module AMD | System | ES2015 模块系统的 Classic 策略。当使用 Classic 策略时，查找非相对模块通过从包含导入文件的目录开始依次向上级目录遍历，以定位匹配的声明文件。当使用 Node 策略时，查找相对模块先定位到同名文件，再定位到同名目录(根据目录下 package.json 文件中的 types 属性定位文件，或者定位到目录下 index.ts 文件)；查找相对模块通过先上遍历目录，定位到每层 node_modules 目录下与 模块同名的目录，再通过 package.json 或 index.ts 定位模块文件。 tsconfig.json 文件中的 compilerOptions.baseUrl, compilerOptions.paths 属性用于设定查找文件的基础路径以及特定模块的查找路径。 123456789101112&#123; \"compilerOptions\": &#123; \"baseUrl\": \".\", // 相对于当前路径进行计算，compilerOptions.paths 存在时须指定 baseUrl \"paths\": &#123; \"jquery\": [\"node_modules/jquery/dist/jquery\"], // 此处映射是相对于\"baseUrl\" \"*\": [// 其他模块分别在 projectRoot 或 projectRoot/generated 目录下查找 \"*\", \"generated/*\" ], &#125; &#125;&#125; 命名空间命名空间使用 namespace Name {} 声明，使用 export 关键字将命名空间内部声明的数据导出，没有使用 export 修饰的数据只能在命名空间内使用。编译阶段，在全局空间下构建一个普通对象，export 导出的数据构成该对象的属性或方法，因此，从命名空间中导出的数据通过 Name.exportName 加以引用。 可以将同一个命名空间内声明的多个类放置在不同的文件中，仍旧使用同一个命名空间，再使用引用标签可以告知编译器这些文件之间的关联。 1234567891011121314151617181920212223242526272829303132namespace Validation &#123; export interface StringValidator &#123; isAcceptable(s: string): boolean; &#125; const lettersRegexp = /^[A-Za-z]+$/; const numberRegexp = /^[0-9]+$/; export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125; &#125; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125; &#125;&#125;let strings = [\"Hello\", \"98052\", \"101\"];let validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;validators[\"ZIP code\"] = new Validation.ZipCodeValidator();validators[\"Letters only\"] = new Validation.LettersOnlyValidator();for (let s of strings) &#123; for (let name in validators) &#123; console.log(`\"$&#123; s &#125;\" - $&#123; validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" &#125; $&#123; name &#125;`); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 使用多个文件分解命名空间// Validation.tsnamespace Validation &#123; export interface StringValidator &#123; isAcceptable(s: string): boolean; &#125;&#125;// LettersOnlyValidator.ts/// &lt;reference path=\"Validation.ts\" /&gt;namespace Validation &#123; const lettersRegexp = /^[A-Za-z]+$/; export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return lettersRegexp.test(s); &#125; &#125;&#125;// ZipCodeValidator.ts/// &lt;reference path=\"Validation.ts\" /&gt;namespace Validation &#123; const numberRegexp = /^[0-9]+$/; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125; &#125;&#125;// Test.ts/// &lt;reference path=\"Validation.ts\" /&gt;/// &lt;reference path=\"LettersOnlyValidator.ts\" /&gt;/// &lt;reference path=\"ZipCodeValidator.ts\" /&gt;let strings = [\"Hello\", \"98052\", \"101\"];let validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;validators[\"ZIP code\"] = new Validation.ZipCodeValidator();validators[\"Letters only\"] = new Validation.LettersOnlyValidator();for (let s of strings) &#123; for (let name in validators) &#123; console.log(\"\"\" + s + \"\" \" + (validators[name].isAcceptable(s) ? \" matches \" : \" does not match \") + name); &#125;&#125; 12345678910// 使用 import q = x.y.z 语法以别名形式导出常用命名空间内的类，import 相较于 var，会构建新的引用namespace Shapes &#123; export namespace Polygons &#123; export class Triangle &#123; &#125; export class Square &#123; &#125; &#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); // Same as \"new Shapes.Polygons.Square()\" 声明合并ts 的声明会创建以下三种实体，命名空间，类型或值。创建命名空间的声明会新建一个命名空间，用 “.” 访问其下设定的值(包含类，函数等)。创建类型的声明会用声明的模型创建一个类型并绑定到给定的名字上，包含类，枚举，接口，类型别名。创建值的声明会创建在 js 输出中看到的值，包含函数，变量。给定名字相同时，ts 会将声明合并。 合并接口ts 合并接口时，后声明接口中的函数成员具有较高优先级(当该函数的参数类型更为精细时，则该函数成员具有更高优先级)；同名非函数成员有不同类型时，会造成编译错误。 1234567891011121314151617181920interface Document &#123; createElement(tagName: any): Element;&#125;interface Document &#123; createElement(tagName: \"div\"): HTMLDivElement; createElement(tagName: \"span\"): HTMLSpanElement;&#125;interface Document &#123; createElement(tagName: string): HTMLElement; createElement(tagName: \"canvas\"): HTMLCanvasElement;&#125;// 合并后interface Document &#123; createElement(tagName: \"canvas\"): HTMLCanvasElement; createElement(tagName: \"div\"): HTMLDivElement; createElement(tagName: \"span\"): HTMLSpanElement; createElement(tagName: string): HTMLElement; createElement(tagName: any): Element;&#125; 合并命名空间ts 合并命名空间时，当某个命名空间有非导出成员，编译时将会报错。 12345678910111213141516namespace Animals &#123; export class Zebra &#123; &#125;&#125;namespace Animals &#123; export interface Legged &#123; numberOfLegs: number; &#125; export class Dog &#123; &#125;&#125;// 合并后namespace Animals &#123; export interface Legged &#123; numberOfLegs: number; &#125; export class Zebra &#123; &#125; export class Dog &#123; &#125;&#125; 合并命名空间和类为类添加静态属性，可用于创建内部类。 123456class Album &#123; label: Album.AlbumLabel;&#125;namespace Album &#123; export class AlbumLabel &#123; &#125;// 必须导出&#125; 合并命名空间和函数为函数添加属性。 12345678function buildLabel(name: string): string &#123; return buildLabel.prefix + name + buildLabel.suffix;&#125;namespace buildLabel &#123; export let suffix = \"\"; export let prefix = \"Hello, \";&#125; 合并命名空间和枚举为枚举添加属性。 1234567891011121314151617181920enum Color &#123; red = 1, green = 2, blue = 4&#125;// 调用 Color.mixColor 添加枚举成员namespace Color &#123; export function mixColor(colorName: string) &#123; if (colorName == \"yellow\") &#123; return Color.red + Color.green; &#125; else if (colorName == \"white\") &#123; return Color.red + Color.green + Color.blue; &#125; else if (colorName == \"magenta\") &#123; return Color.red + Color.blue; &#125; else if (colorName == \"cyan\") &#123; return Color.green + Color.blue; &#125; &#125;&#125; 装饰器装饰器使用 @expression 语法，可以修饰类，属性，方法，访问符或参数，可以添加多个装饰器，由内至外依次求值。装饰器为普通函数，可以通过创建装饰器工厂的方式向装饰器注入特定的依赖。 类装饰器只接受类的构造函数作为参数，如 function classDecorator (constructor){}。 属性装饰器接受类的构造函数(当方法属于静态成员)或类的原型对象(当方法属于实例成员)，成员的名字作为参数，如 function propDecorator (target, propertyKey)。 方法装饰器接受类的构造函数(当方法属于静态成员)或类的原型对象(当方法属于实例成员)，成员的名字，成员的属性描述符作为参数，如 function methodDecorator (target, propertyKey, descriptor)。 访问器装饰器接受类的构造函数(当方法属于静态成员)或类的原型对象(当方法属于实例成员)，成员的名字，成员的属性描述符作为参数，但不能同时装饰 get, set 访问器，如 function vistitorDecorator (target, propertyKey, descriptor)。 参数装饰器接受接受类的构造函数(当方法属于静态成员)或类的原型对象(当方法属于实例成员)，成员的名字，参数在函数参数列表中的索引，如 function parameterDecorator (target, propertyKey, parameterIndex)。 ts 中使用装饰器需要将 tsconfig.json 配置文件中的 compilerOptions.experimentalDecorators 属性置为真，且 compilerOptions.target 属性至少为 “ES5”。 12345678910111213141516// 类装饰器function classDecorator&lt;T extends &#123;new(...args:any[]):&#123;&#125;&#125;&gt;(constructor:T) &#123; return class extends constructor &#123; newProperty = \"new property\"; hello = \"override\"; &#125;&#125;@classDecoratorclass Greeter &#123; property = \"property\"; hello: string; constructor(m: string) &#123; this.hello = m; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839// 方法装饰器和参数装饰器import \"reflect-metadata\";const requiredMetadataKey = Symbol(\"required\");function required(target: Object, propertyKey: string | symbol, parameterIndex: number) &#123; let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || []; existingRequiredParameters.push(parameterIndex); Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);&#125;function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;) &#123; let method = descriptor.value; descriptor.value = function () &#123; let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName); if (requiredParameters) &#123; for (let parameterIndex of requiredParameters) &#123; if (parameterIndex &gt;= arguments.length || arguments[parameterIndex] === undefined) &#123; throw new Error(\"Missing required argument.\"); &#125; &#125; &#125; return method.apply(this, arguments); &#125;&#125;class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; @validate greet(@required name: string) &#123; return \"Hello \" + name + \", \" + this.greeting; &#125;&#125; 迭代器当一个对象实现了 Symbol.iterator 属性时，该对象就是可迭代的。内置类型如 Array, Map, Set, String, Int32Array, Uint32Array等都实现了各自的 Symbol.iterator 属性。for…of 语句基于调用对象上的 Symbol.iterator 方法，用于遍历值。for…of 遍历索引，可以操作任何对象。 JSXts 支持三种 jsx 模式，preserve, react, react-native，这些模式只在代码生成阶段产生影响。preserve 模式下生成代码中会保留 .jsx，由后续的工具(如 Babel)转换输出，生成文件带有 jsx 扩展名；react 模式会生成 React.createElement 等代码，无需再作转换，生成文件扩展名为 .js；react-native 模式相当于 preserve，保留 jsx 代码，生成文件的扩展名为 .js。 ts 中，编写 jsx 代码，须使用 .tsx 文件扩展名。.tsx 文件禁用 id 形式的类型断言，类型断言可以使用 id as Type。 固有元素固有元素使用特殊的接口 JSX.IntrinsicElements 来查找。默认情况下，这个接口没有指定，不对固有元素进行类型检查。 若这个接口存在，那么固有元素的名字需在 JSX.IntrinsicElements 接口的属性里查找。 123456789declare namespace JSX &#123; interface IntrinsicElements &#123; foo: any;// 校验属性通过 foo: &#123; bar?: boolean &#125;，相应元素可写成 &lt;foo bar /&gt;; // [elemName: string]: any; 字符串索引 &#125;&#125;&lt;foo /&gt;;// 正确&lt;bar /&gt;;// 错误 无状态组件无状态组件为普通函数，类型检查同函数。 12345678910111213141516interface ClickableProps &#123; children: JSX.Element[] | JSX.Element&#125;interface HomeProps extends ClickableProps &#123; home: JSX.Element;&#125;interface SideProps extends ClickableProps &#123; side: JSX.Element | string;&#125;function MainButton(prop: HomeProps): JSX.Element;function MainButton(prop: SideProps): JSX.Element &#123; ...&#125; 类组件1234567891011121314151617181920212223242526272829303132declare namespace JSX &#123; interface ElementAttributesProperty &#123; props; // 指定用来使用的属性名 &#125; interface ElementChildrenAttribute &#123; children: &#123;&#125;; // 指定 children &#125; interface ElementClass &#123;// 用于校验元素类型 render: any; &#125;&#125;class MyComponent &#123; props: &#123; foo?: string; &#125; render() &#123;&#125;&#125;function MyFactoryFunction() &#123; return &#123; render: () =&gt; &#123;&#125; &#125;&#125;&lt;MyComponent foo=\"bar\" /&gt;; // 正确&lt;MyFactoryFunction /&gt;; // 正确class NotAValidComponent &#123;&#125;function NotAValidFactoryFunction() &#123; return &#123;&#125;;&#125;&lt;NotAValidComponent /&gt;; // 错误&lt;NotAValidFactoryFunction /&gt;; // 错误 疑问 类型推论??? 类型兼容性??? 高级类型中的类型保护??? 模块按需加载，在 ts 中加载其他模块系统的模块??? 外部模块??? 模块 + 声明合并 tsconfig.json 配置文件??? 装饰器中的元数据，reflect-metadata库??? 三斜线指令??? 编写声明文件 .d.ts???","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"js","slug":"frontend/js","permalink":"http://xzfyu.com/categories/frontend/js/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"js","slug":"js","permalink":"http://xzfyu.com/tags/js/"}]},{"title":"flow使用指南","slug":"frontend/js/flow使用指南","date":"2018-02-23T16:00:00.000Z","updated":"2020-03-08T10:38:25.784Z","comments":true,"path":"2018/02/24/frontend/js/flow使用指南/","link":"","permalink":"http://xzfyu.com/2018/02/24/frontend/js/flow使用指南/","excerpt":"","text":"概述flow 是 facebook 推出的 js 代码类型检查工具。 flow 可借助 babel 编译，添加 babel-preset-flow 即可；babel-preset-react 包含 babel-preset-flow。或者借助安装 flow-bin 启动类型检查，flow-remove-types 移除类型标记。 通过在脚本前添加 // @flow 或 / @flow / 将文件标注为需要类型校验的，否则将会跳过 flow 校验（除非执行 flow check –all 命令校验所有文件）。 类型标注/Type Annotations基础类型/Primitive Typesflow 支持校验的基础数据类型包含 boolean, string, number, null, undefined（在 flow 中，使用 void 标注）。es6 的 symbol 类型尚不支持。 boolean, string, number 字面量使用小写形式标注类型；包装对象如 new Number(10) 使用大写形式标注类型。 12345678910111213// @flowfunction method(x: number, y: string, z: boolean) &#123; // ...&#125;method(3.14, \"hello\", true);// @flowfunction method(x: Number, y: String, z: Boolean) &#123; // ...&#125;method(new Number(42), new String(\"world\"), new Boolean(false)); 字面量类型/Literal Typesflow 允许使用字面量作为类型标注，约定仅接受该字面量，如 value: 2 将仅接受数值 2，其他报错。 混合类型/Mixed Types、任意类型/Any types使用 mixed 标注可接受任意类型数据，但在使用时需显示校验类型。 使用 any 标注可接受任意类型数据，且在使用时也跳过校验。若作为对象，其下的所有属性均采用 any 类型形式。需要避免使用 any 类型。 123456789101112131415161718// @flowfunction stringify(value: mixed) &#123; // $ExpectError return \"\" + value; // Error!&#125;stringify(\"foo\");// @flowfunction stringify(value: mixed) &#123; if (typeof value === 'string') &#123; return \"\" + value; // Works! &#125; else &#123; return \"\"; &#125;&#125;stringify(\"foo\"); 数组/Array Types数组通过 Array 或 Type[] 标注，元素的类型必须一致，但可以是 undefined 或 null，如 Array 或 number[]。 元祖/Tuple Types元祖通过 [type, type, type] 形式标注，即元素的类型单独标注，且元素不能增删，因此不能使用 push, pop 等数组原型方法，但可以使用 join 等方法，不同长度的元祖不能相互赋值，元祖和数组之间也不能相互赋值，如 [number, boolean, void]，该元祖标识可接受赋值如 [1, true]。 函数/Function Typesflow 可标注函数入参和返回值，如 function concat(a: string, b: string): string { return a + b; }。 可选参数通过 ‘?’ 后缀标注，如 function acceptsOptionalString(value?: string) { }，参数可以是 undefined。 默认参数可使用如下形式 function method(value: string = “default”) { / … / }，参数可以是 undefined，但不能为 null。 解构参数通过数组类型标注，如 function method(…args: Array) { }。 函数类型校验或者通过添加设定入参返回值标注，或者通过添加设定 Funtion 标注，如 function method(func: () =&gt; mixed) { } 或 function method(func: Function) { }。 对象/Object Types对象通过 { propname: Type } 形式标注，如 var obj2: { foo: number, bar: boolean, baz: string, } = { foo: 1, bar: true, baz: ‘three’, }。 可选属性通过 ‘?’ 后缀标注，如 { propertyName?: string }，propertyName 属性可以是 undefined。 类/Class Types类本身可作为类型标识。 12345class MyClass &#123; // ...&#125;let myInstance: MyClass = new MyClass(); 在类中，方法标识同函数，属性在使用前必须先标识。 1234567// @flowclass MyClass &#123; prop: number; method(): void &#123; this.prop = 42; &#125;&#125; 类支持泛型标识。将泛型标识的类作为标识时，必须为所有泛型传递参数。 12345678910111213141516// @flowclass MyClass&lt;A, B, C&gt; &#123; property: A; method(val: B): C &#123; // ... &#125;&#125;// @flowclass MyClass&lt;A, B, C&gt; &#123; constructor(arg1: A, arg2: B, arg3: C) &#123; // ... &#125;&#125;var val: MyClass&lt;number, boolean, string&gt; = new MyClass(1, true, 'three'); 接口/Interface Types接口作为类型标识接口可作为类型校验标识（结构类型校验/Structural typing，非名义类型校验/Nominal typing ）。 123456789101112131415// @flowinterface Serializable &#123; serialize(): string;&#125;class Foo &#123; serialize() &#123; return '[Foo]'; &#125;&#125;class Bar &#123; serialize() &#123; return '[Bar]'; &#125;&#125;const foo: Serializable = new Foo(); // Works!const bar: Serializable = new Bar(); // Works! 接口类型通过 ‘+’, ‘-‘ 符号设置只读、只写属性。 12345678910// 当接口作为类型标识interface MyInterface &#123; +readOnly: number | string; -writeOnly: number | string;&#125;var value: MyInterface = &#123; readOnly: 3,// 可读，不可写 writeOnly: number | string// 可写，不可读&#125;; 接口作为类实现标准接口用于类实现/implements，一个类可以实现多个接口。 123456789101112interface MyInterface &#123; method(value: string): number; property?: string; [key: string]: number;&#125;// 使用泛型interface MyInterface&lt;A, B, C&gt; &#123; foo: A; bar: B; baz: C;&#125; 泛型/Generic Types泛型用于在运行时注入特定的类型。以类型标识的变量使用接口中未声明的属性时，须先作校验属性是否存在。 12345678910111213141516171819202122232425262728293031323334353637// 函数中使用泛型function method&lt;T&gt;(value: T): T &#123; return value;&#125;// 类使用泛型class Class&lt;T&gt; &#123; prop: T; constructor(param: T) &#123; &#125; method(): T &#123; &#125;&#125;// 类型别名使用泛型type TypeAlias&lt;T&gt; = &#123; key: T&#125;;// 接口使用泛型interface Interface&lt;T&gt; &#123; prop: T&#125;// @flowfunction logFoo&lt;T: &#123; foo: string &#125;&gt;(obj: T): T &#123; console.log(obj.foo); // Works! return obj;&#125;logFoo(&#123; foo: 'foo', bar: 'bar' &#125;); // Works!// @flowtype Item&lt;T: number = 1&gt; = &#123; prop: T,&#125;;let foo: Item&lt;&gt; = &#123; prop: 1 &#125;;let bar: Item&lt;2&gt; = &#123; prop: 2 &#125;; 可能的类型/Maybe types可能的类型通过 ‘?’ 前缀标注，如 ?string，其值可以是 null 或 undefined。 联合类型/Union Types联合类型使用 ype1 | Type2 | … | TypeN 标注，被标识数据应满足其中一个类型校验。 1234567891011121314// 联合类型在处理响应的情景中使用，'| ... |'用于避免 success, error 属性冲突// @flowtype Success = &#123;| success: true, value: boolean |&#125;;type Failed = &#123;| error: true, message: string |&#125;;type Response = Success | Failed;function handleResponse(response: Response) &#123; if (response.success) &#123; var value: boolean = response.value; // Works! &#125; else &#123; var error: string = response.error; // Works! &#125;&#125; 交叉类型/Intersection Types交叉类型使用 Type1 &amp; Type2 &amp; … &amp; TypeN 标识，被标识数据应满足所有类型校验，需要由开发者避免类型冲突。 123456789101112// @flowtype A = &#123; a: number &#125;;type B = &#123; b: boolean &#125;;type C = &#123; c: string &#125;;function method(value: A &amp; B &amp; C) &#123; // ...&#125;method(&#123; a: 1 &#125;); // Error!method(&#123; a: 1, b: true &#125;); // Error!method(&#123; a: 1, b: true, c: 'three' &#125;); // Works! 类型别名/Type Aliases为常用的类型设置别名，采用如右形式语法 type Alias = Type。设置别名后，方便复用该类型。 12345678910111213141516171819type NumberAlias = number;type ObjectAlias = &#123; property: string, method(): number,&#125;;type UnionAlias = 1 | 2 | 3;type AliasAlias = ObjectAlias;type GenericsObjectAlias&lt;A, B, C&gt; = &#123; property: A, method(val: B): C,&#125;;var val: ObjectAlias = &#123; /* ... */ &#125;;function method(val: ObjectAlias) &#123; /* ... */ &#125;class Foo &#123; constructor(val: ObjectAlias) &#123; /* ... */ &#125; &#125;var myObject: GenericsObjectAlias&lt;number, boolean, string&gt; = &#123; property: 1, method(val: boolean): string &#123; return ''; &#125;&#125;; 不透明的类型别名/Opaque Type Aliases不透明的类型别名不允许在定义该类型别名的文件外使用其基础类型，如 opaque type Alias = Type; 或 opaque type Alias: SuperType = Type 用于约定父类型，Type 必须是 SuperType的子类型，且在声明文件外使用该父类型校验。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 示例 1// exports.jsexport opaque type NumberAlias = number;// imports.jsimport type &#123;NumberAlias&#125; from './exports';(0: NumberAlias) // Error: 0 is not a NumberAlias!function convert(x: NumberAlias): number &#123; return x; // Error: x is not a number!&#125;// 示例 2// exports.jsexport opaque type ID: string = string;// imports.jsimport type &#123;ID&#125; from './exports';function formatID(x: ID): string &#123; return \"ID: \" + x; // Ok! IDs are strings.&#125;function toID(x: string): ID &#123; return x; // Error: strings are not IDs.&#125;// 示例 3 - 泛型// @flowopaque type MyObject&lt;A, B, C&gt;: &#123; foo: A, bar: B &#125; = &#123; foo: A, bar: B, baz: C,&#125;;var val: MyObject&lt;number, boolean, string&gt; = &#123; foo: 1, bar: true, baz: 'three',&#125;;// 示例 4 - 使用声明declare opaque type Foo;declare opaque type PositiveNumber: number; typeoftypeof 操作符返回 flow 的数据类型，可能是开发者设置的类型标识。对基本类型，typeof 操作符返回名义类型；对类，typeof 操作符返回结构类型。 123456789101112131415161718192021222324// @flowlet num1 = 42;let num2: typeof num1 = 3.14; // Works!let num3: typeof num1 = 'world'; // Error!let bool1 = true;let bool2: typeof bool1 = false; // Works!let bool3: typeof bool1 = 42; // Error!let str1 = 'hello';let str2: typeof str1 = 'world'; // Works!let str3: typeof str1 = false; // Error!// @flowclass MyClass &#123; method(val: number) &#123; /* ... */ &#125;&#125;class YourClass &#123; method(val: number) &#123; /* ... */ &#125;&#125;let test1: typeof MyClass = YourClass; // Error!let test1: typeof MyClass = MyClass; // Works! 类型断言/Type Casting Expressions类型断言可使用 (value: Type) 语法，flow 尝试将 value 转换为 Type 类型，且不作类型校验。 flow 中只允许相关类型转换，由低级到高级，即 42 能转换到 number，不能转换到 string，number 类型不能转换为 42。通过 any 关键字可以将 42 从数值型转换到字符串型。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// @flowlet value = 42;(value: number); // Works!(value: string); // Error!let newValue = ((value: any): string);(newValue: number); // Error!(newValue: string); // Works!// @flowfunction cloneObject(obj) &#123; const clone = &#123;&#125;; Object.keys(obj).forEach(key =&gt; &#123; clone[key] = obj[key]; &#125;); return ((clone: any): typeof obj); // &lt;&lt;&#125;const clone = cloneObject(&#123; foo: 1, bar: true, baz: 'three'&#125;);(clone.foo: 1); // Works!(clone.bar: true); // Works!(clone.baz: 'three'); // Works!// @flowfunction cloneObject(obj) &#123; (obj: &#123; [key: string]: mixed &#125;); // &lt;&lt; const clone = &#123;&#125;; // ... return ((clone: any): typeof obj);&#125;const clone = cloneObject(&#123; foo: 1, bar: true, baz: 'three'&#125;);(clone.foo: 1); // Works!(clone.bar: true); // Works!(clone.baz: 'three'); // Works! 工具类型/Utility Types$Keys$Keys 以对象或类型的属性构建联合类型。 1234567891011// @flowconst countries = &#123; US: \"United States\", IT: \"Italy\", FR: \"France\"&#125;;type Country = $Keys&lt;typeof countries&gt;;const italy: Country = 'IT';const nope: Country = 'nope'; // 'nope' is not a Country $Values$Values 以对象或类型的值构建联合类型。 12345678910111213// @flowtype Props = &#123; name: string, age: number,&#125;;// The following two types are equivalent:type PropValues = string | number;type Prop$Values = $Values&lt;Props&gt;;const name: Prop$Values = 'Jon'; // OKconst age: Prop$Values = 42; // OKconst fn: Prop$Values = () =&gt; &#123;&#125;; // Error! $ReadOnly$ReadOnly 用于将对象或类型的属性转化为只读属性。 1234567// The following two types are equivalent:type ReadOnlyObj = &#123; +key: any, // read-only field, marked by the `+` annotation&#125;;type ReadOnlyObj = $ReadOnly&lt;&#123; key: any,&#125;&gt;; $Exact$Exact&lt;{name: string}&gt; 语法和 {| name: string |} 等价，用于避免对象属性冲突。 12345678// @flowtype ExactUser = $Exact&lt;&#123;name: string&#125;&gt;;type ExactUserShorthand = &#123;| name: string |&#125;;const user2 = &#123;name: 'John Wilkes Booth'&#125;;// These will both be satisfied because they are equivalent(user2: ExactUser);(user2: ExactUserShorthand); $Diff&lt;A, B&gt;$Diff&lt;A, B&gt; 语法中，待校验数据须包含 A 仅有的属性，能包含 B 有的属性，且 B 中不能有 A 没有的属性。 123456789101112// @flowtype Props = &#123; name: string, age: number &#125;;type DefaultProps = &#123; age: number &#125;;type RequiredProps = $Diff&lt;Props, DefaultProps&gt;;function setProps(props: RequiredProps) &#123; // ...&#125;setProps(&#123; name: 'foo' &#125;);setProps(&#123; name: 'foo', age: 42, baz: false &#125;); // you can pass extra props toosetProps(&#123; age: 42 &#125;); // error, name is required $Rest&lt;A, B&gt;$Rest&lt;A, B&gt; 语法中，待校验数据只能包含 A 仅有的属性，不能包含 B 有的属性。 1234567// @flowtype Props = &#123; name: string, age: number &#125;;const props: Props = &#123;name: 'Jon', age: 42&#125;;const &#123;age, ...otherProps&#125; = props;(otherProps: $Rest&lt;Props, &#123;|age: number|&#125;&gt;);otherProps.age; // Error $PropertyType&lt;T, k&gt;$PropertyType&lt;T, k&gt; 语法用于获取特定属性的类型。 123456789101112131415161718// @flowimport React from 'react';class Tooltip extends React.Component &#123; props: &#123; text: string, onMouseOver: (&#123;x: number, y: number&#125;) =&gt; void &#125;;&#125;const someProps: $PropertyType&lt;Tooltip, 'props'&gt; = &#123; text: 'foo', onMouseOver: (data: &#123;x: number, y: number&#125;) =&gt; undefined&#125;;const otherProps: $PropertyType&lt;Tooltip, 'props'&gt; = &#123; text: 'foo' // Missing the `onMouseOver` definition&#125;; $ElementType&lt;T, k&gt;$ElementType&lt;T, k&gt; 语法用于获取特定元素的类型，包含数组项、元祖项、对象属性。 1234567891011121314151617// @flow// Using objects:type Obj = &#123; name: string, age: number,&#125;('Jon': $ElementType&lt;Obj, 'name'&gt;);(42: $ElementType&lt;Obj, 'age'&gt;);(true: $ElementType&lt;Obj, 'name'&gt;); // Nope, `name` is not a boolean(true: $ElementType&lt;Obj, 'other'&gt;); // Nope, property `other` is not in Obj// Using tuples:type Tuple = [boolean, string];(true: $ElementType&lt;Tuple, 0&gt;);('foo': $ElementType&lt;Tuple, 1&gt;);('bar': $ElementType&lt;Tuple, 2&gt;); // Nope, can't access position 2 $ObjMap&lt;T, F&gt;$ObjMap&lt;T, F&gt; 遍历 T 对象或类型，以函数 F 重新构建属性类型。 1234567891011121314151617181920// @flow// let's write a function type that takes a `() =&gt; V` and returns a `V` (its return type)type ExtractReturnType = &lt;V&gt;(() =&gt; V) =&gt; Vfunction run&lt;A, O: &#123;[key: string]: () =&gt; A&#125;&gt;(o: O): $ObjMap&lt;O, ExtractReturnType&gt; &#123; return Object.keys(o).reduce((acc, k) =&gt; Object.assign(acc, &#123; [k]: o[k]() &#125;), &#123;&#125;);&#125;const o = &#123; a: () =&gt; true, b: () =&gt; 'foo'&#125;;(run(o).a: boolean); // Ok(run(o).b: string); // Ok// $ExpectError(run(o).b: boolean); // Nope, b is a string// $ExpectErrorrun(o).c; $TupleMap&lt;T, F&gt;$TupleMap&lt;T, F&gt; 遍历 T 元祖或类型，以函数 F 重新构建元祖项。 1234567891011// @flowtype ExtractReturnType = &lt;V&gt;(() =&gt; V) =&gt; Vfunction run&lt;A, I: Array&lt;() =&gt; A&gt;&gt;(iter: I): $TupleMap&lt;I, ExtractReturnType&gt; &#123; return iter.map(fn =&gt; fn());&#125;const arr = [() =&gt; 'foo', () =&gt; 'bar'];(run(arr)[0]: string); // OK(run(arr)[1]: string); // OK(run(arr)[1]: boolean); // Error $Call$Call 调用 F 函数，函数返回值用于校验类型，参数在 F 后添加。 12345678910// @flow// Takes an object type, returns the type of its `prop` keytype ExtractPropType = &lt;T&gt;(&#123;prop: T&#125;) =&gt; T;type Obj = &#123;prop: number&#125;;type PropType = $Call&lt;ExtractPropType, Obj&gt;; // Call `ExtractPropType` with `Obj` as an argumenttype Nope = $Call&lt;ExtractPropType, &#123;nope: number&#125;&gt;; // Error: argument doesn't match `Obj`.(5: PropType); // OK(true: PropType); // Error: PropType is a number(5: Nope); // Error ClassClass 指用类 T 校验类型。 12345678910111213// @flowclass Store &#123;&#125;class ExtendedStore extends Store &#123;&#125;class Model &#123;&#125;function makeStore(storeClass: Class&lt;Store&gt;) &#123; return new storeClass();&#125;(makeStore(Store): Store);(makeStore(ExtendedStore): Store);(makeStore(Model): Model); // error(makeStore(ExtendedStore): Model); // Flow infers the return type * 用于以占位符形式指明存在类型/Existential Type。 123456// @flowfunction makeParamStore&lt;T&gt;(storeClass: Class&lt;ParamStore&lt;T&gt;&gt;, data: T): * &#123; return new storeClass(data);&#125;(makeParamStore(ParamStore, 1): ParamStore&lt;number&gt;);(makeParamStore(ParamStore, 1): ParamStore&lt;boolean&gt;); // failed because of the second parameter 模块/Module Types123456789// @flowexport default class Foo &#123;&#125;;export type MyObject = &#123; /* ... */ &#125;;export interface MyInterface &#123; /* ... */ &#125;;export class MyClass &#123; /* ... */ &#125;;// @flowimport type Foo, &#123;MyObject, MyInterface&#125; from './exports';import typeof &#123;MyClass&#125; from './exports';","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"js","slug":"frontend/js","permalink":"http://xzfyu.com/categories/frontend/js/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"js","slug":"js","permalink":"http://xzfyu.com/tags/js/"}]},{"title":"Pro Git 笔记","slug":"读书笔记/Pro Git读书笔记","date":"2018-02-20T16:00:00.000Z","updated":"2019-02-03T13:34:30.931Z","comments":true,"path":"2018/02/21/读书笔记/Pro Git读书笔记/","link":"","permalink":"http://xzfyu.com/2018/02/21/读书笔记/Pro Git读书笔记/","excerpt":"","text":"Getting Started原理git 版本管理通过 SHA-1 哈希算法为工作区的文件生成快照实现，存放于本地暂存区或版本库中（.git 目录下保存所有快照信息）。hash 算法基于文件内容和目录结构，git 保存的信息都通过 hash 值(SHA-1 哈希算法校验和/SHA-1 checksum)进行索引。修改工作区/working tree 的文件后(modified)，通过 git add 命令提交到暂存区/staging range(staged)，再通过 git commit 命令提交到版本库/git directory(commited)；若文件未变更，将沿用原有的快照。因此本地多版本管理不需要远程交互。 当文件提交到暂存区时(stage)，git 会为每个文件计算校验和/checksum，在 git 仓库中保存 blob 对象以引用文件快照，校验和将保存到暂存区中。当提交到版本库时(commit)，git 会计算目录的校验和并构建树对象(blod 文件对象将以索引形式存储在树对象中)，随后创建提交对象，该提交对象包含作者名、电邮、message、指向上述树对象的指针、指向之前提交版本的指针。git 仓库可理解为存储系列提交对象的单链表结构(以哈希算法的校验和值作为索引)。在多分支开发的特殊情况下，提交对象会转变为树形结构(单链表可视为只有主干的树)，即多个提交对象的 parent 指针可以指向同一个提交对象父节点，提交历史产生分叉。在提交对象模型的基础上，git 分支就是指向某个提交对象的移动指针(通过校验和指向提交对象，文件形式存储)，其提交历史来自于提交对象模型，形成单链表结构。多分支管理、及单分支的回滚和提交动作均衍生于树结构的提交对象模型，分支仅承担着指向改变的任务；创建新分支即是创建一个指向当前提交对象的指针；提交时，创建新的提交对象，并改变当前分支的指向。在 git 中，HEAD 指针用于指向当前工作的分支，通过改变 HEAD 指针的指向即为切换分支操作。需要说明的是，当切换回较旧的分支时，不只改变了 HEAD 指针的指向，同时也使工作目录变更为该分支指向的提交对象，即资源快照。多分支开发时，新的提交对象将作为提交对象模型的叶子节点，这一过程也可以通过 HEAD 指针感知当前的提交对象属于哪个分支。因此在 git 中，分支不是多次提交记录的集合，而是在抽象所有提交记录为单一的模型后、衍伸而来的理念。遵照这样的设计，master 分支和其他分支拥有相同的特征，只是 master 分支会在 git 仓库初始化时被创建。 在 git 中，HEAD 指针指向版本库，INDEX 指针指向暂存区，版本库和暂存区都存储在 .git 文件夹中。因此，git add 命令将工作区内容复制到暂存区/INDEX。git commit 将暂存区内容复制到版本库/HEAD。git status 比较工作区、暂存区、版本库内容是否相同，若工作区和暂存区内容不相同，提示 not staged，需要通过 git add 暂存；若暂存区和版本库内容不同，提示 not committed，需要通过 git commit 提交。执行 git checkout, git clone 命令时，先将 HEAD 指针指向切换的分支，再将版本库内容复制到暂存区，再将暂存区内容复制到工作区。 git 提供了 git reset 命令，执行该命令，不仅改变 HEAD 指针的指向，同时将工作分支指向 checksum 提交对象上。如果 HEAD 指向 master 分支，运行 git reset 9e5e64a 将会使 master 指向 9e5e64a，将撤销 9e5e64a 之后的提交，也可以用于重置 9e5e64a 之后的提交；git reset 命令默认将暂存区内容也替换为 9e5e64a 指向的提交对象，这和显式执行 git reset –mixed 命令相同。git reset –soft 命令只将版本库中内容替换为指定的提交对象。git reset –hard 命令可同时将版本库、暂存区和工作区内容替换为指定的提交对象。使用 git reset 或 git reset 命令将目标从提交对象转向 filepath 路径指定的文件或目录，操作是从指定的提交对象中获取内容，复制到暂存区。 在 git checkout 命令执行过程中，会比较工作区和暂存区的差别，并尝试合并，这是 git reset 命令所没有的操作。当执行 git checkout 命令时，该命令不仅会影响暂存区，同时会尝试合并工作区，这也是 git reset 命令所没有的操作。 合并/merge 分支时，会向上遍历文档对象模型，寻找共同的祖先节点作为合并基础。若待合并分支的提交/commit 动作在当前工作分支(work-in-progress branch)之后产生，当前分支将采用快进/fast-forward 方式修改，即将当前分支指向待合并分支的提交对象，指针右移。合并分叉分支时，即待合并的两个分支为同时开发，将获取这两个分支的提交对象，以及他们共同祖先节点的提交对象作为合并基础，作三方合并(three-way merge)，最终将构建出新的提交对象(该提交对象有两个父节点，使文档对象模型由树结构转变为合流结构)。若两个分叉分支同时对同一块区域做更改，git 不会自动合并，将产生一个合并冲突(merge conflict)，并阻止 git 的后续执行流程，如构建新的提交对象等，git 还会为冲突文件注入标准的冲突解决标记(standard conflict-resolution markers)。通过 git status 命令可查看冲突文件。冲突解决标记中，以 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 起始部分为当前工作分支内容，以 &gt;&gt;&gt;&gt;&gt;&gt;&gt; branchname 结束部分为待合并分支内容，中间以 =======。解决冲突后，需要依序提交到暂存区和版本库中，将产生一条合并记录，可能包含冲突解决记录。合并分支可使用 git mergetool 命令，启用图形化合并工具，参看 Git Branching。 git merge 合并发生冲突时，暂存区/stages 下缓存着共同祖先版本/stage-0，当前工作版本/stage-1，待合并的版本/stage-2。通过 git show :1|2|3: &gt; fileName 可以以拷贝形式导出冲突的共同祖先文件等。其中，:1|2|3: 为各冲突文件 bolb 对象相关 SHA-1 值的简写形式，:1: 为祖先冲突文件，:2: 为工作分支文件，:3: 为待合并文件。导出三份拷贝文件后，手工修复冲突，可使用 git merge-file 命令合并冲突文件，使用 git diff 命令可比较冲突结果与待比较文件的差异，git clean 命令用于清理为合并拷贝出来的文件。 另外，在合并发生冲突时，使用 git checkout –conflict=diff3 命令可以查看不止于当前工作分支的冲突文件和待合并的冲突文件，还包含共同祖先的冲突文件。默认只查看当前工作分支的冲突文件和待合并的冲突文件，即 git checkout –conflict=merge 命令。使用 git config –global merge.conflictstyle diff3 命令，将全局的合并方案改成 diff3。git checkout –ours 合并时使用当前工作分支文件内容；git checkout –theirs 合并时使用待合并分支文件内容。git 在合并过程中，会将合并成功的文件提交到暂存区，因此 git diff 命令可以查看冲突文件；解决冲突后，仍可使用 git diff 或 git log –cc -p -1 命令查看解决冲突后的文件。 若想撤销文件合并，可使用 git reset –hard HEAD~ 命令将合并取消，提交记录返回到合并前；或者使用 git revert -m 1 basebranch 命令撤销合并，将提交对象撤回到 basebranch 分支内容。需要注意的是，git revert -m 1 basebranch 命令将无法合并待合并分支起始的提交内容，针对这一问题，可使用 git revert 撤销还原。参看 Git Tools。 远程引用(remote references)是对远程仓库中分支、标签等的引用或指针。更恰当的说，引用内容即为远程分支中的提交对象模型，单链表形式。远程跟踪分支(remote-tracking branches)将远程分支的引用保存在本地，不受用户影响，git fetch|pull|push 操作时更新引用，使本地 shortname/branchname 指向远程服务器的同名分支。远程引用采用 shortname/branchname 形式命名分支。当 git clone 命令执行时，将在本地创建 origin/master 分支和 master 分支，两者均指向相同的提交对象模型。当用户在 master 分支开发并提交时，另一用户将自己的代码 push 到远程 master 分支上，本地 origin/master 的指向将不作改变；假使在这时候执行 git fetch 命令，将抓取远程仓库新添加的提交对象，本地 origin/master 也将右移、指向另一用户创建的提交对象上，提交对象模型转化为树形结构。 变基/rebase 是 git 中除了 merge 以外整合两个分支的另一种方式。当提交历史呈分叉状态，可以将其中一个分叉的提交记录基于合并基础、提取为更新补丁，再将其合并到另一个分叉中，这个过程就是变基。变基命令在提取为补丁的分支上执行行，因此需要切换到该分支如 patch 分支，然后执行 git rebase basebaranch 命令，提取补丁并以该补丁产生新的提交对象(patch 分支指向该提交对象)，此时分叉的提交历史将转变为单链表形式，而 basebaranch 分支的指向仍保持不变。切换到 basebaranch 分支，再执行 git merge patch 命令，可以将 basebaranch 分支的指针右移，指向 rebase 命令新创建的提交对象。经过上述步骤后，整个开叉分支的整合操作也就完成了，patch 分支的提交对象将被抹去，但 patch 分支仍然存在，需要手动删除。变基同合并比较，最大的优点即是使提交历史呈线性状态，而不是分叉、合流结构。在开源项目中贡献代码通常采用变基命令。使用 git rebase basebranch patch 命令执行变基操作时，可以不用将工作分支切换到 patch 上，即提取 patch 分支的修改补丁，基于修改补丁在 basebranch 分支上创建新的提交对象。执行 git rebase –onto basebranch patch1 patch2 命令，获取 patch2 分支不同于 patch1 分支的修改补丁，基于修改补丁再在 basebranch 分支上创建新的提交对象。 执行变基操作有一条原则，即不能在你的本地仓库执行变基操作。变基操作能改变本地仓库的提交历史，进而影响远程仓库的提交记录，但是对于协作者而言，在分支开叉时拉取编程变更，又在变基后拉取远程变更，他本地远程引用的提交记录中即会保留变基前的开叉，又会有变基后新增的提交对象。git 变基的实现原理是，在每次提交时，git 不只计算本次提交的校验和，还会计算本次修改内容的校验和 patch-id。通过 patch-id，git 能分辨出新增的本地修改。在本地分支上，使用 git rebase remote/branch 命令将本地修改变基到远程引用，同时本地的提交历史将转变为单链表结构，这能解决前述变基前后的操作同时提交到远程仓库的问题。 除了合并和变基以外，git 支持拣选/cherry-pick 操作，其意义以校验和获取某次提交补丁，再应用到当前工作分支上。因为操作时间的不同，通过拣选在当前分支创建的提交会重新计算校验和。具体命令如 git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf。其中，e43a6fd3e94888d76779ad79fb568ed180e5fcdf 为之前提交对象的校验和/checksum，作为提交对象的索引。 参考：分支简介分支的新建与合并变基重置揭密 配置git 配置分为三类，系统级，用户级，和项目级；优先级从右到左。git config 命令中，–system 选项指定系统级，–global 选项指定用户级，两者均没有为项目级。 1234567891011121314151617181920212223242526272829303132git config --list # 查看配置git config user.name # 查看用户配置git config --global user.name &lt;name&gt; # 指定用户git config --global user.email &lt;email&gt; # 指定邮箱git config --global core.editor emacs # 指定编辑器，默认为系统自带编辑器，可选 vim, emacs, notepad++git config --global commit.template &lt;filepath&gt; # 以 filepath 文件作为提交信息模板，打开编辑器时作为前缀git config --global core.pager '' # 设置 git log|diff 命令的分页器，可选值 more, less。'' 空字符串为完整显示git config --global user.signingkey &lt;gpg-key-id&gt; # 设置 GPG 签署密钥，影响 git tag -s &lt;tag-name&gt; 命令git config --global core.excludesfile &lt;filepath&gt; # 设置忽略的文件git config --global help.autocorrect 1 # 输入命令有误时，0.1s 后自动执行模糊匹配的命令git config --global credential.helper cache # 将 https 推送需要的用户密码缓存在内存中，时效为几分钟git config --global color.ui false # 禁用有彩色输出git config --global color.[diff|branch|interactive|status].meta \"blue black bold\" # 设置命令的颜色git config --global core.autocrlf true # Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 Mac 和 Linux 只使用换行（LF）一个字符。core.autocrlf 设置为 true，提交时自动将回车和换行转换成换行，检出时将换行转换成回车和换行。core.autocrlf 设置为 input，提交时自动把回车和换行转换成换行，检出时不转换git config --global core.whitespace \\ trailing-space,space-before-tab,indent-with-non-tab # 空格检测。默认开启项 blank-at-eol，查找行尾的空格；blank-at-eof，盯住文件底部的空行；space-before-tab，警惕行头 tab 前面的空格。默认关闭项 indent-with-non-tab，揪出以空格而非 tab 开头的行（你可以用 tabwidth 选项控制它）；tab-in-indent，监视在行头表示缩进的 tab；cr-at-eol，告诉 Git 忽略行尾的回车。git diff 时将应用空格检测；git apply --whitespace=warn &lt;patch&gt; 应用补丁时检测空格；git apply --whitespace=fix &lt;patch&gt; 自动修复；git rebase --whitespace=fix 变基时自动修复# 别名git config --global alias.co checkout # git co 将等价于 git checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.unstage 'reset HEAD --' # git unstage 将等价于 git reset Head -- git config --global alias.last 'log -1 HEAD' # git last 查看最后一次提交信息git config --global alias.visual '!npm' # git visual 将调用外部命令 npmgit config --global pull.rebase true # 更改 pull.rebase 的默认配置git config --global merge.conflictstyle diff3 # 以 diff3 方式查看冲突文件，包含当前工作分支、待合并分支、共同祖先分支的冲突文件内容git config --system receive.fsckObjects true # 推送生效前检验每个对象的有效性以及 SHA-1 检验和是否保持一致git config --system receive.denyNonFastForwards true # 禁用强制更新 git push -fgit config --system receive.denyDeletes true # 避免删除远程分支后，再推送本地分支 帮助123git help config # 打印 git config 命令的完整手册man git-confgi # 同上git-config -h|--help # 简要帮助信息 疑问 保存快照不吃磁盘空间吗？git 命令在运行时比较文件差异，如 add, commit？那执行效率如何提升？ 数据库怎样存储历史版本数据？ 游戏在用户端以补丁形式下载并更新，若代码使用 git 管理，怎样做到根据文件差异只做局部封信，而不是全量下载并更新？同样的，git pull 等命令怎样做到效率地只修改局部资源？ 在多分支开发，又相继合并到 master 分支的情形下，提交对象链表会形成怎样的构造？根据提交时间形成单链表形式？ git reset 命令执行后，如何改变提交历史，新的提交对之前提交历史的影响？如重置第三次提交，新的提交会在第一次提交之后创建提交对象，还是在之前创建提交对象？ git checkout 命令可以针对某次提交对象，即可以执行 git checkout 命令？ Git Basics创建本地仓库创建 git 本地仓库，指定 git init 或 git clone [projectName] 命令（projectName 用于指定本地目录名）。git clone 将拷贝远程仓库的所有版本及所有文件（当服务器磁盘损坏时，方便使用本地仓库的命令将远程仓库的资源回滚到拷贝前），创建 .git 目录，并检出最新分支。git clone 时，可使用 https 协议 或 git:// 起始的 SSH 协议。 12git init # 创建 git 本地仓库git clone &lt;url&gt; [projectName] # 克隆远程仓库，指定远程仓库的简称默认为 origin，且本地 master 分支将跟踪/track 远程 master，可使用 git pull|push 命令 文件状态工作区的文件状态有两种，已追踪/tracked, 未追踪/untracked。暂存区的最新快照中包含某文件，该文件即被追踪；若不包含，该文件即未追踪。已追踪文件又分为三种状态，未变更/unmodified, 已变更/modified, 已提交到暂存区/staged。在切换分支时，git 会校验工作区的文件改动是否提交到版本库中，未提交，则阻止切换，用以防止丢失工作区的改动。 1234567891011121314git status # 获取文件状态git status -s|--short # 文件状态扼要信息。?? 未追踪文件，A 新增文件提交到到暂存区，M 修改文件提交到暂存区，MM 暂存区和工作区文件状态git diff # 工作区和暂存区文件差异，显示文件更新细节，包括添加的行、删除的行，合称为文件更新补丁/patchgit diff --staged|--cached # 暂存区和版本库文件差异git difftool # 使用 Araxis, emerge, vimdiff 等软件以图形化或其他格式显示文件差异git difftool -tool-help # 查看系统支持的 git diff 插件git add &lt;files&gt; # 工作区文件提交到暂存区，将产生暂存区的历史快照/historical snapshort。参数为文件或目录路径git commit # 暂存区快照提交版本去，需由命令行编辑器设置 message，# 起始内容将被忽略。命令行编辑器中默认以 # 添加 git status 输出内容。-v 选项可用于注入 git diff 完整信息git commit -m 'message' # 设置 message 并提交git commit -a # 直接将工作区中已追踪的文件提交到版本库，跳过暂存区git rm &lt;pattern&gt; # 暂存区删除文件，工作区也作相应删除，需要提交到版本库。直接删除工作区中文件，不会影响暂存区git rm -f|--force &lt;pattern&gt; # 修改后文件提交到暂存区，与版本库中文件有差异，需使用 -f 选项强制删除git rm --cached &lt;pattern&gt; # 暂存区删除文件，但保留工作区文件，适用于未配置 .gitignore 的文件git mv file_from file_to # 移动文件，可实现文件重命名。重命名时，等同于 mv file_from file_to; git rm file_from; git add file_to。git 没有显式追踪文件移动操作，通过执行的命令获知用户重命名行为 .gitignore.gitignore 配置文件，即忽略文件列表。可设置多个 .gitignore 文件，当前文件所在目录自底向上获取 .gitignore 文件，作为优先级顺序。编写 .gitignore 文件可使用标准 glob 模式(shell 中简易正则，* 零或多个任意字符，** 任意中间目录，其余同正则)；空行或 ‘#’ 开头将被忽略；’/‘ 开头相对于工程目录；’/‘ 结尾匹配目录；’!’ 开头置否值。 commit 历史记录无论本地仓库，还是克隆下来的远程仓库，都可以使用 git log 命令查看提交记录。 123456789101112131415161718192021git log # 显示提交记录，反序排列，包含 SHA-1 哈希算法校验和(作为索引), 作者, 日期, messagegit log -p|--patch # 显示内容差异git log --stat # 显示每次更新的文件修改统计信息git log --shortstat # 只显示 --stat 中最后的行数修改添加移除统计git log --name-only # 仅在提交信息后显示已修改的文件清单git log --name-status # 显示新增、修改、删除的文件清单git log --abbrev-commit # 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符git log --relative-date # 使用较短的相对时间显示，如 '2 weeks ago'git log --graph # 显示 ASCII 图形表示的分支合并历史git log --pretty=oneline # 指定显示格式，--pretty 选项的可选值为 oneline, short, full, fuller, format。其中，oneline 以一行展示提交信息git log --pretty=format:\"%h - %an, %ar : %s\" # 指定输出信息的模板字符串，用于提取分析报告。占位符包含 %H 提交对象/commit的完整哈希字串, %h 提交对象的简短哈希字串, %T 树对象/tree的完整哈希字串, %t, %P 父对象/parent的完整哈希字串, %p, %an 作者, %ae 作者的邮箱, %ad 作者修订日期, %ar 作者的相对修订日期, %cn 提交者, %ce, %cd, %cr, %s 说明git log --oneline # --pretty=oneline --abbrev-commit 简写形式git log -&lt;n&gt; # -n 指定只显示最后两次提交记录，如 -2。通常不需要使用。因为 git log 显示采用分页形式，用户只能看到第一页git log --since|--after=2.weeks # --since 选项指定起始时间，可用相对时间或绝对时间，如 '2 years 1 day 3 minutes ago'git log --until|--before=\"2008-01-15\" # 同上，指定结束时间git log --author=authorname # 过滤作者git log --committer=committername # 过滤提交者git log --grep=messagekey # 按 message 中关键字检索，与 --author 合用时为或匹配，添加 --all-match 选项强制匹配 grep 指定关键字git log -S function_name # 指定字符串检索更改相应字符串的提交记录git log --no-merges # 不显示 merge 记录git log --filename # 作为最后一个选项，检索更改相应文件或目录的提交记录 撤销撤销操作不能回滚，容易引起数据丢失。 123git commit --amend # 合并上一次提交记录，适用于文件漏提交等轻微改动场景。若暂存区文件未作更新，commit 快照将保持不变，只更改 message 或者连 message 也未作更改。只保留当前的提交记录；撤销上一次提交记录，即不会存在于提交记录中git reset HEAD &lt;filename&gt; # 暂存区文件重置为提交前状态。执行 git status 命令，工作位已更改文件的状态为 unstaged。git reset 命令不加选项，只更改暂存区。git reset --hard 命令将可能导致工作区的当前进度全部丢失，相当危险git checkout -- &lt;file&gt; # 使用暂存区的文件替换工作区的文件，即工作区文件回滚 远程协作1234567891011git remote # 列出远程服务器的简称，默认为 origingit remote -v # 列出远程服务器的简称和 url 列表，同一个项目可能指定了多个远程仓库。fetch, push 操作的服务器资源也可能不同，由远程仓库决定remote add &lt;shortname&gt; &lt;url&gt; # 添加远程仓库git fetch &lt;shortname|url&gt; # 抓取远程仓库资源，包含所有分支，并创建本地远程跟踪分支，却不会创建可修改、供开发的本地同名分支。只下载远程仓库资源，需手动 mergegit pull # 若本地分支跟踪远程分支，git pull 命令自动拉取远程仓库中指定的分支，并尝试 mergegit pull &lt;remotename&gt; &lt;branchname&gt; # 拉取远程分支资源，并尝试 merge。选项 remotename 指定远程仓库，branchname 指定分支git push # 若本地分支跟踪远程分支，git push 将资源推送到远程仓库下的指定分支git push &lt;remotename&gt; &lt;branchname&gt; # 推送资源到指定远程下的指定分支git remote show &lt;remotename&gt; # 查看远程仓库 fetch|push 操作的 url，包含的分支，以及跟踪分支信息git remote rename shortname_before shortname_after # 改写远程仓库的简称，同时改变分支名，如更新为 shortname_after/mastergit remote remove|rm &lt;remotename&gt; # 本地移除某远程仓库，同时影响其下分支和配置，对远程仓库无影响 打标签git 标签分为两种，轻量标签lightweight, 附注标签 annotated。轻量标签通过 git tag 不带选项创建，附注标签通过 git tag -a 创建。附注标签以对象形式存储在 git 数据库中，包含标签作者，电邮，日期，标签信息/message，并且可以使用 GPG 签名和验证。git tag 命令通常用来发布不再修改的版本(通过 git push 命令)，且发布以后，不能再作修改，需要在本地创建新分支拉取标签资源，作适当修改后再发布。 12345678910git tag # 列出所有标签，以字母顺序罗列git tag -l|-list &lt;pattern&gt; # 只罗列匹配的标签，如 git tag -l \"v1.8.5*\"。pattern 中若含有通配符，-l 选项不可缺失git tag &lt;tagname&gt; # 创建轻量标签，git show &lt;tagname&gt; 时只显示 commit 信息git tag -a &lt;tagname&gt; -m \"message\" # 创建附注标签，git show &lt;tagname&gt; 时除显示 commit 信息外，还显示标签作者，电邮，日期，标签信息等git show &lt;tagname&gt; # 查看标签信息及对应的提交信息git tag -a &lt;tagname&gt; &lt;checksum&gt; # 提交后再打标签，选项 checksum 为 hash算法校验和，即快照的索引，可以只包含部分 hash 值git push origin &lt;tagname&gt; # 将标签推送到远程共享服务器上git push --tags # 将本地所有标签推送到服务器上git checkout &lt;tagname&gt; # 检出标签，但不能真正检出标签，本地仓库会进入 \"detached HEAD\" 状态，提交将不从属于任何分支，只有 commit checksum 校验和能被 git 感知到git checkout -b &lt;branchnam&gt; &lt;tagname&gt; # 在本地创建新分支，并拉取指定标签资源。修改后，重新创建标签并 push 疑问 暂存区存在的意义？ 强制删除的意义？ commit 提交记录以何种形式存储，才能实现快速检索？关于 git database？ 本地版本库如何回滚？ git pull|push 只拉取或推送快照，还是所有历史记录？ git 远程服务器对版本管理的实现是否和本地相同，可否指定局域网中某台机器作为拉取资源的源头？ 打标签只针对 commit 操作？且标签只针对不会再修改的版本？git push origin [tagname] 推送到共享服务器和 git push origin [branchname] 的差异？ 切换分支时，为什么需要提交到版本库，而不是暂存库，这样就可以避免工作区的变更丢失了？ Git Branching基本命令分支原理见 Getting Started。 1234567891011121314151617git log --oneline --decorate # --decorate 选项用于查询各个分支及 HEAD 指针指向哪个提交对象git log --oneline --decorate --graph --all # 查看提交历史的分叉情况，各个分支及 HEAD 指针的指向git branch # 查看所有分支，带 '*' 的为当前分支git branch -v # 查看所有分支最后一次提交记录git branch --merged # 查看已合并到当前分支的所有分支git branch --no-merged # 查看未合并到当前分支的所有分支git branch --merged &lt;branchname&gt; # 查看已合并到 branchname 分支的所有分支git branch --no-merged &lt;branchname&gt; # 查看未合并到 branchname 分支的所有分支git branch &lt;branchname&gt; # 创建分支，但不切换分支git branch -d &lt;branchname&gt; # 删除分支，branchname 未合并到当前分支，将不予删除git branch -D &lt;branchname&gt; # 强制删除分支git checkout &lt;branchname&gt; # 切换分支，即改变 HEAD 指针指向。修改文件但未提交到版本库的，git 将阻止切换git checkout -b &lt;branchname&gt; # 创建并切换分支git merge &lt;branchname&gt; # 将 branchname 分支合并到当前分支git status # 查看冲突文件git mergetool # 使用图形化工具解决冲突，默认使用 opendiff 工具，可选用工具包含 opendiff, kdiff3, tkdiff, xxdiff, meld, tortoisemerge, gvimdiff, diffuse, diffmerge, ecmerge, p4merge, araxis, bc3, codecompare, vimdiff, emergegit mergetool --tool-help # 合并工具帮助信息 工作流推荐使用的本地开发工作流/workflow 有两种，长期分支模式(Long-Running Branches)，特性分支模式(Topic Branches)。当然，这只是一种参考。 长期分支模式根据稳定性创建分支，需要较高稳定性的分支创建在前，较低稳定性的创建在后，如 master 分支先于 develop 分支，develop 分支先于 topic 分支，合并时依序将 topic 分支合并到 develop 分支，develop 分支合并到 master 分支。适用于大型项目，作为分支创建的基础结构，在每个分支可以再次使用特性分支模式。 特性分支模式适用于开发者想法多变的场景，比如在 master 分支基础创建 hotfix 分支，接着创建 hotfix_v2，同时开发 hotfix, hotfix_v2 分支，最终又启用 hotfix 分支；与此同时，开发过程中 master 分支不只产生了新的提交，后续又创建了实现新想法的 idea 分支，最后将 hotfix_v2, idea 分支合并到 master 分支。 远程分支12345678910111213git ls-remote &lt;shortname&gt; # 查看远程引用清单git remote show &lt;shortname&gt; # 查看远程引用详细信息git push &lt;shortname&gt; &lt;branch&gt; # 将当前分支的提交内容推送到远程 branch 分支，git 自动将分支名扩展为 refs/heads/branch:refs/heads/branch，意为将本地 branch 分支推送并更新远程 branch 分支git push shortname localebranch:remotebranch # 推送本地 localebranch 分支，将其作为远程 remotebranch 分支git merge shortname/branchname # 将远程跟踪分支 shortname/branchname 合并到当前分支，合并前须 git fetchgit checkout -b localebranch shortname/remotebranch # 通过远程跟踪分支创建本地分支，自动跟踪远程分支，可使用 git pull|push 简化拉取、提交操作；且可以在命令行中使用 @&#123;upstream&#125; 或 @&#123;u&#125; 代替 shortname/remotebranchgit checkout --track shortname/remotebranch # 上一条命令的简写形式，创建 remotebranch 同名分支git checkout remotebranch # 上一条命令的简写形式，条件是本地未存在 remotebranch 同名分支，远程存在git branch -u|--set-upstream-to shortname/remotebranch # 当前分支切换跟踪远程 remotebranch 分支。-u 选项可用于 pull, push 命令git branch -vv # 查看本地分支在跟踪哪个远程分支，以及ahead, behind, up to date等提交状态。这条命令基于最后一次 fetch 的数据，命令本身没有连接服务器git fetch &lt;shortname|url&gt; # 抓取远程仓库资源，包含所有分支，并创建本地远程跟踪分支，却不会创建可修改、供开发的本地同名分支。只下载远程仓库资源，不会更改工作区内容，需手动 mergegit pull # git fetch, git merge 命令的结合，拉取数据并合并git push origin --delete remotebranch # 删除远程分支 变基12345git rebase &lt;basebranch&gt; # 将当前分支以补丁形式在 basebranch 分支上创建新的提交对象。完成开叉分支的整合操作还需要在 basebranch 分支上 merge 当前分支git rebase &lt;basebranch&gt; &lt;topicbranch&gt; # 同上，该命令不需要切换到 topicbranch 分支后执行git rebase --onto &lt;basebranch&gt; &lt;topicbranch1&gt; &lt;topicbranch2&gt; # --onto 选项用于获取在 topicbranch2 分支内但不在 topicbranch1 内的文件修改补丁，并在 basebranch 分支上创建新的提交对象，即变基到 basebranch git rebase remote/branch # 将本地修改变基到远程引用 remote/branch 分支上git pull --rebase remote/branch # 等同 git fetch, get rebase remote/branch Git on the Server传输协议git 可以使用四种传输资料的协议：Local 本地协议，Http 协议，SSH 协议和 Git 协议。 Local 协议常见于协作者对同一个共享的文件系统(如一个挂载的 NFS)都有访问权限。git clone /opt/git/project.git 命令将采用硬链接或直接拷贝文件；git clone file:///opt/git/project.git 将触发用于网路传输资料的进程，传输效率较低；git remote add local_proj /opt/git/project.git 命令用于增加本地版本库。 Http 协议既支持像 git:// 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。Git 协议，要么谁都可以克隆这个版本库，要么谁也不能。 搭建 git 服务器首先需要把现有 git 仓库导出为一个裸仓库，即不包含工作目录的仓库。这一过程通过 –bare 选项完成，具体命令为 git clone –bare my_project my_project.git。其次将裸仓库放在服务器上，若已在 git.example.com 搭好服务器，且需要在 /opt/git 目录下放置所有 git 仓库，通过执行 scp -r my_project.git user@git.example.com:/opt/git 复制裸仓库到 /opt/git 目录下。此时，对服务器 /opt/git 目录拥有可读权限的用户就可以通过 git clone user@git.example.com:/opt/git/my_project.git 克隆仓库。若在仓库中执行 git init –bare –shared 命令，可将仓库的权限设为可写(基于服务器文件系统权限)。连接服务器的权限通过服务器自有的 SSH 服务实现，创建访问账户也针对服务器，而不是 git 仓库。访问权限也可以在服务器创建 git 账户，然后将需要写权限的用户的 SSH 公钥加入 git 账户的 ~/.ssh/authorized_keys 文件中；或者让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。 生成 SSH 公钥通过以下步骤完成：通过 ssh-keygen 命令创建公钥(存放在 id_dsa.pub 文件中)和密钥(存放在 id_dsa 文件中)；将公钥复制到 git 账户的 ~/.ssh/authorized_keys 文件中(通过 git 服务器管理员完成，或自动化脚本实现)。 在服务器创建 git 账户时，将使所有获得授权的用户都能以系统用户 git 的身份登录服务器从而获得一个普通 shell，即能对服务器进行一定操作。若想对此加以限制，则需要修改 passwd 文件中(git 用户所对应)的 shell 值；或者通过 git 软件包自带的 git-shell 工具代替 bash 或 csh 作为用户的登录 shell，用户即不能通过登录 shell 执行非 git 命令(上述过程，通过 sudo chsh git 命令改变系统用户的登录 shell 实现)。 1234git clone --bare my_project my_project.git # 通过 --bare 选项创建裸仓库cp -Rf my_project/.git my_project.git # 同上git init --bare # 新疆一个空仓库git init --bare --shared # 新疆一个空仓库，并将仓库的权限设为可写 疑问 协议相关知识再梳理？ 搭建 git 服务器过程再梳理，包含守护进程、git-http-backend 脚本在Apache 服务器上的使用、GitWeb 网页查看、GitLab 服务器等？ Distributed Git分布式工作流分布式工作流有三种，包含集中式工作流、集成管理者工作流、司令官和副官工作流。一般项目采用集中式工作流，当 A 用户提交了代码后，B 用户再次提交前，先须拉取代码并合并，然后才能提交；否则会报提交失败。集成管理者工作流通常在 github 开源代码中采用，即作为开源代码的贡献者，先须 fork 该项目，创建一个自己的仓库，更新提交后，发送消息给开源代码的维护者，等待维护者合并贡献者的代码并提交。司令官和副官工作流见于 linux 开发项目，普通开发者完成开发后，基于司令官的 master 执行变基操作；副官再将普通开发者的分支合并到自己的 master 分支上；司令官合并所有副官的 master 分支并提交。 提交准则 避免空白错误。 尝试让每一个提交成为一个逻辑上的独立变更集，即针对每个问题，独立提交一次。 完善提交信息，使用 vim 编辑提交信息，推荐使用 标题 + 空行 + 正文 形式。 贡献代码私有小型团队用户 A 创建特性分支 feature1 并作修改后，再将特性分支合并到 master 分支上。用户 B 创建了特性分支 feature2 并作修改后，若在此时，用户 B 想把 feature2 内容合并到 master 分支并作提交，那他需要在 master 分支上执行 git fetch; git merge origin/master; git merge feature2 命令，即合并本地特性分支和远程协作者提交内容后，才可以正式提交代码。这样的工作流程最常见于实际项目中。 私有大型团队用户 A 和 B 在特性分支 feature1 上工作，用户 B 和 C 在特性分支 feature2 上工作。工作流程采用了整合-管理者工作流程，即独立小组的工作只能被特定的工程师整合，主仓库的 master 分支只能被那些工程师更新。当 feature1, feature2 开发并测试完成后，再由整合者将两个分支的内容合并到 master 分支上。对于 feature1, feature2 的开发工作流程，同小型私有团队，即提交前先要合并协作者上传到远端的代码。 派生的公开项目首先 clone 项目，然后在本地创建 feature1 分支(使 master 分支保持干净，避免维护者不采用你的代码时，需要回滚 master 分支到最初 clone 时的状态)，fork 仓库(即派生项目)后提交到远程自己的同名仓库中。通知开源项目的维护者拉取你的改动，这通常被称为拉取请求(pull request)，可通过执行 git request-pull origin/master feature 命令告知维护者改动是在你 fork 的仓库的 feature 分支上完成的。 通过邮件的公开项目有几个历史悠久的、大型的项目会通过一个开发者的邮件列表接受补丁。使用 git format-patch 来生成可以邮寄到列表的 mbox 格式的文件 - 它将每一个提交转换为一封电子邮件，提交信息的第一行作为主题，剩余信息与提交引入的补丁作为正文。-M 选项用于告诉 Git 查找重命名。通过 git config 设置 imap 区块的 folder = “[Gmail]/Drafts”, host = imaps://imap.gmail.com, user = user@gmail.com, pass = p4ssw0rd, port = 993, sslverify = false 属性(如果 IMAP 服务器不使用 SSL，无需设置 port, sslverify 属性，host 的值会是 imap:// 而不是 imaps://)；再执行 git imap-send 可以将补丁序列放在特定 IMAP 服务器的 Drafts 文件夹。或者通过 git config 设置 sendemail 区块的 smtpencryption = tls, smtpserver = smtp.gmail.com, smtpuser = user@gmail.com, smtpserverport = 587 属性；再执行 git send-email 通过 SMTP 服务器发送补丁。 1234git diff --check # 检查空白错误。空白错误是指行尾的空格、Tab 制表符，和行首空格后跟 Tab 制表符的行为git format-patch -M origin/master # 生成 .patch 扩展名的补丁文件，可以编辑该文件，添加额外信息cat *.patch |git imap-send # 通过 IMAP 发送正确格式化的补丁git send-email *.patch # 通过 SMTP 服务器发送补丁 维护项目应用补丁若补丁通过 git diff 生成，使用 git apply 命令可在当前工作分支中应用文件补丁。应用补丁前，使用 git apply –check 命令可检查补丁是否可以顺利应用。 若补丁通过 format-patch 生成，使用 git am 命令可以提取出 mbox 文件中的实际变更并应用，且自动创建新的提交。 合并工作流合并工作流，可以将特性分支逐次合并到 master 分支上；或者保持 master 分支的稳定性，再创建 develop 长期分支，将特性分支合并 develop 分支，等 develop 分支稳定后，再合并到 master 分支上；或者在 master 之外创建 next, pu(proposed updates，用于新工作), maint(maintenance backports，用于维护性向后移植工作) 分支，安全的特性分支先合并入 next 分支，再合并到 master 分支上。 拣选执行 git cherry-pick，见原理。 重用冲突解决方案/reuse recorded resolution执行 git config –global rerere.enabled true 缓存冲突解决方案。执行 git rerere 命令将从缓存中查找相似的冲突，并应用对应的解决方案。 12345678910111213141516171819202122232425git apply *.patch # 在当前分支中应用补丁git apply --check *.patch # 检查补丁是否可被顺利应用git am *.patch # 读取 mbox 文件实际变更并应用git am -3 *.patch # -3 选项将使用三方合并应用补丁git am -3 -i mbox # 使用交互模式应用多个补丁git am --resolved # git am 报错后，手动解决冲突，执行下一个补丁的应用git am --skip # 跳过当前补丁git am --abort # 当前分支回退到应用补丁前状态，终止补丁应用git log branch1 --not branch2 # 找出仅属于 branch1 但不属于 branch2 的提交记录git diff branch # 当前工作分支与 branch 分支比较差异git merge-base branch1 branch2 # 找出 branch1 和 branch2 的共同祖先git diff branch1...branch2 # 比较 branch1 的最新提交和两个分支的共同祖先之间的差异git cherry-pick &lt;checksum&gt; # 以某个提交对象为基底在当前工作分支上创建新的提交对象，将重新计算校验和，如 git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdfgit config --global rerere.enabled true # 开启冲突解决方案缓存git rerere # 查找相似的冲突解决方案并应用# 发布git tag -s &lt;version&gt; -m 'message' # 打标签gpg --list-keys # 查找 GPG 公钥gpg -a --export &lt;gpgkey&gt; | git hash-object -w --stdin # git hash-object 命令以 blob 对象形式在 git 中导入公钥，并返回该 blob 对象的 SHA-1 值。该 SHA-1 值可以用于发布标签，如 git tag -a &lt;tagname&gt; &lt;sha-1&gt;git show &lt;tagname&gt; | gpg --import # 开发者获取并导入公钥，用于贡献代码git describe &lt;branch&gt; # 生成构建号，包含最近的标签名、自该标签之后的提交数目和你所描述的提交的部分 SHA-1 值git archive master --prefix='project/' | gzip &gt; `git describe master`.tar.gz # 创建 .tar.gz 压缩包git archive master --prefix='project/' --format=zip &gt; `git describe master`.zip # 创建 .zip 压缩包git shortlog --no-merges master --not v1.0.1 # 生成自 v1.0.1 版本发布以来所有提交的总结 疑问： 公共项目的发布问题？ Githubgithub 钩子和服务订制、API，参见：https://git-scm.com/book/zh/v2/GitHub-脚本-GitHubhttps://developer.github.com Git Tools选取提交记录根据提交对象的 SHA-1 值查看提交记录。引用日志只在本地生成，不能通过远程交互被协作者拷贝。 12345678910111213141516git log --abbrev-commit --pretty=oneline # 获取简短且唯一的 SHA-1 值git show &lt;sha-1&gt;|&lt;branch&gt; # 显示提交记录git rev-parse &lt;branch&gt; # 获取最近一次提交的 SHA-1 值git reflog # 查看引用日志，引用日志记录了最近几个月的 HEAD 和分支引用所指向的历史，包含提交对象的简短 SHA-1 值、HEAD 记录和提交信息git show HEAD@&#123;5&#125; # 查看第五次提交记录git show &lt;branch&gt;@&#123;yesterday&#125; # 查看 branch 分支昨天指向了哪个提交git show HEAD^ # ^ 引用指上一次提交，HEAD^ 即上一次提交，HEAD^^ 即之前第二次提交git show &lt;sha-1&gt;^ # 特定提交的上一次提交git show HEAD~ # ~ 指父引用，~2 指之前第二次提交git show &lt;sha-1&gt;~num # 特定提交前第 num 次提交git log branch1..branch2 # branch1..branch2 指在 branch2 分支中而不在 branch1 分支中的提交，branch2 留空，自动以 HEAD 填充，如 git log origin/master..HEAD 或 git log origin/master..。branch1..branch2可用于其他命令git log refA refB ^refC # 指定被 refA, refB 包含，但不被 refC 包含的提交记录git log refA refB --not refC # 同上git log branch1...branch2 # 选出不被两个分支同时包含的提交记录git log --left-right branch1...branch2 # 选出不被两个分支同时包含的提交记录，并显示提交对象属于 branch1 还是 branch2 交互式暂存12345git add -i|--interactive # --interactive 选项用于开启交互式暂存命令行，执行后左侧显示已暂存的，右侧显示未暂存的；根据提示命令面板执行后续操作，如 1/status 显示状态, 2/update 提交到暂存区, 3/revert 从暂存区撤回, 4/add untracked 提交未追踪文件到暂存区, 5/patch 暂存补丁，可将部分修改提交到暂存区, 6/diff 查看已暂存内容的区别git add -p|--patch # 暂存部分文件git reset --patch # 部分重置文件git checkout --patch # 部分检出文件git stash save --patch # 部分暂存文件 储藏通过 git stash 命令可以将工作区的改动储藏起来，却不是提交到暂存区；再使用 git stash apply 应用之前的储藏(可以在另一个分支上应用储藏；且当前分支做过修改后，仍可以应用储藏，必要时需解决冲突)。 12345678910111213git stash # 储藏工作区的改动，可用于切换分支前避免与远程代码的合并git stash save # 同上git stash --keep-index # 同上，--keep-index 选项将不储藏已使用 git add 暂存的内容git stash -u|--include-untracked # 默认 git stash 不包含未追踪的文件，--include-untracked 选项将包含未追踪的文件git stash --patch # 交互式地指引用户需要将那些改动储藏，那些改动保存在工作区git stash --all # 移除修改，并储藏起来git stash list # 查看所有储藏内容git stash apply # 将储藏重新应用在工作分支上，默认为最近的储藏git stash apply stash@&#123;num&#125; # 将第 num 次储藏应用在工作分支上，0 为最近的储藏git stash apply --index # 应用储藏，同时应用暂存git stash branch &lt;branchname&gt; # 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，并扔掉储藏git stash drop stash@&#123;num&#125; # 移除储藏git stash pop stash@&#123;num&#125; # 应用并移除储藏 清理12345git clean # 从工作目录中移除未被追踪的文件git clean -f -d # 强制移除工作目录中所有未追踪的文件以及空的子目录git clean -d -n # 移除项预览git clean -n -d -x # git clean 默认不移除 .gitignore 中匹配的文件，-x 选项将移除该类文件git clean -x -i|--interactive # 交互式执行 clean 命令 签署标签参考：https://git-scm.com/book/zh/v2/Git-工具-签署工作 搜索12345678910git grep string/regexp # 从提交历史或工作目录中查找匹配正则或字符串的内容，--and 选项用于设置更复杂字符串或正则匹配规则git grep string/regexp &lt;filepath&gt; &lt;version&gt; # 指定文件或文件夹、版本号搜索git grep -n string/regexp # 输出行号git grep -p string/regexp # 查看匹配的行属于哪一个方法或函数git grep -count string/regexp # 输出概要信息git grep --break --heading string/regexp # 使输出更易读# 日志搜索git log -string --oneline # 从提交历史或 diff 内容中检索匹配字符串或正则的提交记录，-S 选项只查看新增和删除匹配内容的提交，-G 选项使用正则表达式检索git log -L :string:filepath # 行日志搜索，搜索特定文件中 string 变更的提交记录 重写历史git commit –amend 用于修改前一次提交。git rebase -i 交互式修改多次提交记录，可拆分，可弃用，可合并，可重置等。须在本地环境中使用，提交到线上再调用变基，会使协作者变得不方便。git filter-branch 使用脚本的方式改写大量提交记录。 12345678910111213git commit --amend # 修改前一次提交记录，修改暂存区再执行该命令时可改变提交内容，否则只是改变提交信息git rebase -i HEAD~2^|HEAD~3 # -i 选项开启交互式变基命令，将唤起编辑器，反序修改前三次提交，最后一次修改在前。因为之前的提交已提交，显示 p, pick 默认提交，修改为 r, reword 重写提交信息；e, edit 使用 git commit --amend 重置提交，可用于拆分提交；s, squash 将提交信息合并到之前执行 pick 命令的提交对象中，且将多次提交信息合并；f, fixup 同 squash，但丢弃提交信息，x, exec，唤起 shell 提交。弃用某次提交记录，可直接从 git rebase -i HEAD~2^|HEAD~3 显示的列表中删除git filter-branch --tree-filter 'rm -f passwords.txt' HEAD # --tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。--all 选项用于改写所有分支git filter-branch --subdirectory-filter trunk HEAD # 让 trunk 子目录作为每一个提交的新的项目根目录git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ]; then GIT_AUTHOR_NAME=\"Scott Chacon\"; GIT_AUTHOR_EMAIL=\"schacon@example.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD # 修改多个项目的提交邮箱，且重写每个提交的校验和，不只匹配邮箱地址的提交 重置揭密参考原理。 12345678910git cat-file -p HEAD # 查看版本库当前提交信息git ls-tree -r HEAD # 查看版本库中提交文件的 checksum 及其文件名git ls-files -s # 查看暂存区中文件的 checksum 及其文件名git reset &lt;checksum&gt; # 将版本库和暂存区内容替换为 checksum 指向的提交对象git reset --soft &lt;checksum&gt; # 将版本库内容替换为 checksum 指向的提交对象git reset --mixed &lt;checksum&gt; # 将版本库和暂存区内容替换为 checksum 指向的提交对象git reset --hard &lt;checksum&gt; # 将版本库、暂存区和工作区内容替换为 checksum 指向的提交对象git reset &lt;filepath&gt; # 从 HEAD 中获取 filepath 文件或目录，复制到暂存区git reset &lt;checksum&gt; &lt;filepath&gt; # 从 checksum 中获取 filepath 文件或目录，复制到暂存区 高级合并合并前可以通过保存到临时分支或通过执行 git stash 命令储藏起来，避免合并对工作区的影响，使工作区内容丢失。 子树合并是项目某目录下包含一个子工程，同时 git 分支也包含一个从属于子工程的分支，从而引起子分支和子工程目录的合并操作。 1234567891011121314151617181920212223242526272829303132333435git merge --abort # 退出合并，工作区内容恢复到合并前git reset --hard HEAD # 退出合并，将版本库、暂存区和工作区内容重置到合并前git merge -Xignore-space-change # 忽略任意数量的已有空白的修改git merge -Xignore-space-change # 忽略所有空白修改git show :1:&lt;conflictFileName&gt; &gt; commonFileName # 拷贝并导出冲突的共同祖先文件git show :2:&lt;conflictFileName&gt; &gt; oursFileName # 拷贝并导出冲突的工作目录文件git show :3:&lt;conflictFileName&gt; &gt; theirsFileName # 拷贝并导出冲突的待合并文件git ls-files -u # 查看冲突文件的完整 SHA-1 值git merge-file -p \\ oursFileName commonFileName theirsFileName &gt; fileName # oursFileName, commonFileName, theirsFileName 拷贝的冲突文件手工解决冲突后，合并冲突文件git diff --ours # 查看合并结果和当前工作分支的差别，-b 选项用于移除空格比较，--base 选项查看比较文件两边是如何改动的git diff --theirs # 查看合并结果和待合并分支的差别git clean -f # 清理为合并拷贝的文件，如 commonFileName 等git checkout --conflict=diff3 # 查看工作分支、待合并分支、共同祖先分支的冲突文件git checkout --conflict=merge # 默认，查看工作分支、待合并分支的冲突文件git checkout --ours # 合并时使用当前工作分支文件内容git checkout --theirs # 合并时使用待合并分支文件内容git log --oneline --left-right branch1...branch2 # 查看合并文件的提交记录来源git log --oneline --left-right --merge # 查看合并过程中，有冲突文件的提交记录来源git diff # 查看冲突文件或冲突结果git log --cc -p -1 # 查看冲突结果git reset --hard HEAD~ # 撤销合并，将版本库撤回到合并前状态git revert -m 1 basebranch # 撤销合并，将提交对象撤回到 basebranch 分支内容。-m 1 标记指出 “mainline” 需要被保留下来的父结点。此时将无法合并待合并分支的内容git revert &lt;checksum&gt; # 撤销 git revert -m 1 basebranch 命令git merge -Xours &lt;branch&gt; # 选用当前工作分支内容进行合并git merge -Theirs &lt;branch&gt; # 选用待合并分支内容进行合并git merge-file --ours &lt;filepath&gt; # 选用当前工作分支内容进行合并git merge-file --theirs &lt;filepath&gt; # 选用待合并分支内容进行合并git merge -s ours &lt;branch&gt; # 假合并，直接将当前工作分支内容作为合并结果# 子树合并git read-tree --prefix=dirname/ -u sub_project_branch # 将子工程分支的内容拷贝到 dirname 目录中git merge --squash -s recursive -Xsubtree=dirname sub_project_branch # 将 sub_project_branch 分支内容合并到 dirname 目录中git diff-tree -p sub_project_branch # 查看差异git diff-tree -p &lt;remote&gt;/&lt;branch&gt; # 和远程引用相比较 rerere 命令通过 git config –global rerere.enabled true 命令开启 rerere 功能。rerere 记录冲突解决方案，自动解决冲突。 1234git config --global rerere.enabled true # 开启 rerere 功能git rerere status # 查看合并前的状态git rerere diff # 查看解决前后的文件内容差异。冲突解决后，可查看 git rerere 将要记录的内容git ls-files -u # 查看各冲突文件 checksum 使用 git 调试使用 git blame 命令可以查看文件内容的历次更改，适用在确知某方法会引起 bug 的场景，可查看该方法的改动细节。 使用 git bisect 命令可以定位哪次提交引起了异常。 12345678910git blame -L startLine,endLine filepath # 查看 filepath 文件自 startLine 起始、到 endLine 行结束的变更记录。-L 选项用于限制行号。-C 选项会分析拷贝之后再重命名文件的原始出处git bisect start # 启动二分查找git bisect bad # 告知 git 当前提交有问题git bisect good &lt;checksum&gt; # 告知 git 将 checksum 指向的提交对象标记为好的。由 git 告知用户在正常提交和错误提交之间有多少次提交，二次查找中间那次提交，通过 git bisect bad 或 git bisect good 标记好坏。git 会自动定位到提交中点，再由用户判断提交结果的好坏git bisect reset # 重置 HEAD 指针# 通过执行脚本定位 bug 来源。checksum1 是坏的提交，checksum2 是好的提交git bisect start &lt;checksum1&gt;|HEAD &lt;checksum2&gt;git bisect run filepath 子模块子模块虽然在工程目录中创建了子目录，但是若不在该子目录中，git 并不会跟踪子模块的文件内容，而是将它看作该仓库中的一个特殊提交。子模块提交时标记为 160000 模式，意味着将一次提交记作一项目录记录，而非将它记录成一个子目录或者一个文件。 123456789101112131415161718192021git submodule add &lt;remoteurl&gt; &lt;dirname&gt; # 克隆远程仓库，以远程仓库名创建文件夹，或者自定义文件夹。同时会添加 .gitmodules 文件，用于保存本地目录和远程仓库地址git config submodule.&lt;dirname&gt;.url &lt;url&gt; # 重设远程仓库地址git diff --cached --submodule # 查看子模块的文件差异git submodule init # 子模块初始化git submodule update # 获取远程仓库数据，并检出父项目中属于子模块的提交git clone --recursive mainurl # mainurl 为父项目的 url，同时更新子模块git submodule update --remote subproject # 在父项目工作目录中进行更新，避免手动进入子模块抓取和合并git submodule update --remote --merge # 合并git submodule update --remote --rebase # 变基git submodule update --init # 初始化拉取远程内容git log -p --submodule # 查看子模块的提交日志git push --recurse-submodules=check # 推送时校验子项目有否提交git push --recurse-submodules=on-demand # 推送子模块，或者子项目中执行 git push 命令git submodule foreach 'git stash' # 在所有子模块中运行 git stash 命令git rm -r &lt;dirname&gt; # 从暂存区移除子项目目录rm -Rf &lt;dirname&gt; # 移除子项目目录# 子模块命令别名git config alias.sdiff '!'\"git diff &amp;&amp; git submodule foreach 'git diff'\"git config alias.spush 'push --recurse-submodules=on-demand'git config alias.supdate 'submodule update --remote --merge' 打包123456git bundle create bundlefilename HEAD &lt;branch&gt; # 将 branch 分支所有提交数据打包到 bundlefilename 文件中git bundle create bundlefilename &lt;branch&gt; ^&lt;checksum&gt; # 设定提交区间，并打包文件。提交区间可以用 ... 等符号操作git clone bundlefilename dirname # 将打包文件解压到 dirname 目录中git bundle verify bundlefilename # 校验打包文件是不是合法的 Git 包git bundle list-heads bundlefilename # 查看打包文件包含哪些提交对象和分支git fetch bundlefilename branch:local-branch # 将打包文件中的分支导入本地工程中 替换大型项目可分成一个短历史提交记录和一个长历史提交记录，短历史供新的开发者使用，后者给喜欢数据挖掘的人使用。制作短历史提交记录通过 git commit-tree 命令合并提交记录，再通过 git rebase 命令将必要的提交变基到刚创建的合并提交记录上，就可以制作短历史提交记录。执行 git replace 命令，可以查看长历史提交记录。 123456git branch &lt;branch&gt; &lt;checksum&gt; # 以提交对象 checksum 创建分支 branchgit push remote localbranch:remotebranch # 将本地 localbranch 分支推送到远程仓库 remote 下的 remotebranch 分支git commit-tree &lt;checksum&gt;^&#123;tree&#125; # 将 checksum 提交对象及其前的提交合并为新的提交对象，返回新提交对象的 SHA-1 git rebase --onto checksum1 checksum2 # 将 checksum2 后的提交变基到 checksum1 上，checksum1 后产生新的提交记录git replace checksum1 checksum2 # 将 checksum1 及其前的提交记录替换为 checksum2 及其前的提交记录git cat-file -p &lt;checksum&gt; # 查看 checksum 提交的提交树 SHA-1 值及其父提交 凭证存储使用 SSH 连接远端，且设置了一个没有口令的密钥，这样就可以在不用输入用户名和密码的情况下安全连接远端。使用 HTTP 存储，每一个连接都需要输入用户名和密码。git 凭证机制默认不存储用户名和密码，’cache’ 模式内存中暂时存储用户名和密码，’store’ 模式将用户名和密码存储在磁盘中，mac 下 ‘osxkeychain’ 以加密方式将凭证缓存到系统用户的钥匙串，windows 下可借助 ‘winstore’ 工具以加密方式将凭证存储在磁盘中。 1234git config --global credential.helper cache|store # 设置凭证存储模式git config --global credential.helper store --file &lt;path&gt; # 设置存储目录git config --global credential.helper cache --timeout &lt;seconds&gt; # 设置过期时间git credential fill # 交互式设置凭证，通过 protocol/协议, host/主机名 设置 疑问 获取某个特定的提交对象后，可否对该提交对象进行操作？ 关于签署标签？ 关于 git filter-branch？ 关于子模块？ Customizing Git自定义合并、比较工具借助 Perforce 图形化合并工具（P4Merge）来合并文件和解决冲突。 下载 P4Merge。 创建一个名为 extMerge 的脚本包装 merge 命令，让它把参数转发给 p4merge 二进制文件。 123# cat /usr/local/bin/extMerge#!/bin/sh/Applications/p4merge.app/Contents/MacOS/p4merge $* 创建一个名为 extDiff 的脚本包装 diff 命令，让它把参数转发给 p4merge 二进制文件。git 传递以下参数给 diff：path old-file old-hex old-mode new-file new-hex new-mode。实际仅需要 old-file 和 new-file 参数。 123# cat /usr/local/bin/extDiff#!/bin/sh[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge \"$2\" \"$5\" 使 extMerge, extDiff 脚本拥有可执行权限。 12sudo chmod +x /usr/local/bin/extMergesudo chmod +x /usr/local/bin/extDiff 修改配置文件，自定义合并和比较文件。 12345git config --global merge.tool extMerge # 通知 Git 该使用哪个合并工具git config --global mergetool.extMerge.cmd \\ 'extMerge \\\"$BASE\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$MERGED\\\"' # 规定命令运行的方式git config --global mergetool.extMerge.trustExitCode false # 通知 Git 程序的返回值是否表示合并操作成功git config --global diff.external extDiff # 通知 Git 该用什么命令做比较 使用 git diff 命令，将自动唤起 P4Merge 图形化工具。 使用 git mergetool 命令，将自动唤起 P4Merge 图形化工具。 git 属性通过 .gitattributes 文件或 .git/info/attributes 文件设置属性，可用于识别二进制文件、比较二进制文件。 识别二进制文件只需配置 .gitattributes 文件。1*.pbxproj binary # 将 pbxproj 识别为二进制文件，git 将不会对其修改，如 CRLF 问题 比较 word 文件比较二进制 Microsoft Word 文件步骤： 下载 docx2txt。 编写可执行脚本，即 docx2txt 文件。 12#!/bin/bashdocx2txt.pl $1 - 编辑配置。 1git config diff.word.textconv docx2txt 配置 .gitattributes 文件。 1*.docx diff=word # 使用 “word” 过滤器，即借助 docx2txt 程序将 Word 文档转为可读文本文件 比较图像文件在比较时对图像文件运用一个过滤器(如 exiftool)，提炼出 EXIF 信息——这是在大部分图像格式中都有记录的一种元数据。 12echo '*.png diff=exif' &gt;&gt; .gitattributesgit config diff.exif.textconv exiftool 其他123test/ export-ignore # .gitattributes 文件中设置不必导出的文件或文件夹LAST_COMMIT export-subst # 设置 LAST_COMMIT 文件用于接受提交记录，git commit 提交后，执行 git archive 命令，将提交记录导出到 LAST_COMMIT 文件中。LAST_COMMIT 文件内容如 'Last commit date: $Format:%cd by %aN$'database.xml merge=ours # 设置合并策略，采用工作目录中的文件 git 钩子git 钩子放置在 .git/hooks 子目录中。git init 初始化项目时有示例，可以用 Ruby 或 Python 编程。 客户端钩子克隆远程仓库时不被复制。 pre-commit 钩子在键入提交信息前运行。使用 git commit –no-verify 来绕过这个环节。 prepare-commit-msg 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 commit-msg 钩子在编辑器退出后运行。 post-commit 钩子在整个提交过程完成后运行。 applypatch-msg 钩子在应用补丁之前运行，git am 命令执行。 pre-applypatch 钩子在应用补丁之后、产生提交之前运行，git am 命令执行。 post-applypatch 钩子在提交产生之后运行，git am 命令执行。 pre-rebase 钩子在变基之前运行。 post-rewrite 钩子被那些会替换提交记录的命令调用，比如 git commit –amend 和 git rebase 命令。 post-checkout 钩子在检出之后运行。 post-merge 钩子在合并之后运行。 pre-push 钩子在推送之前运行。 re-auto-gc 钩子会在垃圾回收开始之前被调用。git 的一些日常操作在运行时，偶尔会调用 git gc –auto 进行垃圾回收。 服务器端钩子 pre-receive 钩子在推送过程运行，同时向多个分支推送的情形下也只触发一次。 update 钩子在推送过程运行，同时向多个分支推送的情形下触发多次。 post-receive 钩子在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。 疑问 文件检出和暂存时设置过滤器，参考git 属性？ 使用钩子，参考使用强制策略的一个例子 Git Internals从根本上来讲 git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。 .git 目录包含：description 文件仅供 GitWeb 程序使用；config 文件包含项目特有的配置选项；info 目录包含一个全局性排除文件；hooks 目录包含客户端或服务端的钩子脚本；objects 目录存储所有数据内容；refs 目录存储指向数据（分支）的提交对象的指针；HEAD 文件指示目前被检出的分支；index 文件保存暂存区信息。 git 对象git 是一个内容寻址文件系统。这意味着，git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 通过底层命令 hash-object 可将任意数据保存于 .git 目录，并返回相应的键值。在 git 中，文件内容存储为数据对象/blob object，文件目录存储为树对象/tree object。一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 通常，Git 根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象。所以创建树对象时，先须把文件写入暂存区，以此获得树对象的校验和。但是，树对象的校验和不便于记忆，即不便于获取该树对象。在 git 中，使用提交对象定位树对象，以及该树对象的创建时间，即通过提交对象的校验和获取或存储树对象。提交对象的格式为，先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据 user.name 和 user.email 配置来设定，外加一个时间戳）；留空一行，最后是提交注释。 运行 git add 和 git commit 命令时，git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。数据对象、树对象和提交对象最初均以单独文件的形式保存在 .git/objects 目录下（首先转换为带有如 “blob #{content.length}\\0” 等头部信息的内存数据，其次计算校验和，最后再写入 .git/objects 目录下）。 在存储文件对象时，为避免同一文件的不同版本保存多份，git 使用包文件存储，即保存最新版本的完整数据，其他版本保存与最新版本的差异。使用 git gc 命令可执行打包过程；git verify-pack 命令查看打包的内容。自动打包过程发生在 push 命令触发或本地包含太多不同版本的文件，大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 git 启动一次真正的 gc 命令（可通过修改 gc.auto 与 gc.autopacklimit 的设置来改动这些数值）。打包后，.git/refs 目录将清空，相应创建 .git/packed-refs 目录；更新引用时，再相应创建 .git/refs 目录下文件；查找分支引用先从 .git/refs 目录找起，其次 .git/packed-refs 目录 123456789101112131415161718echo 'test content' | git hash-object -w --stdin # 写入数据。-w 选项指示 hash-object 命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值； --stdin 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。返回40位校验和，以前两位作为目录名，后38位作为文件名，存储在 .git/objects 目录中git hash-object -w test.txt # 写入数据git cat-file -p &lt;checksum&gt; # 读取数据find .git/objects -type f # 查看 .git/objects 目录下文件列表git cat-file -p &lt;checksum&gt; &gt; &lt;filepath&gt; # 将 .git/objects 目录下存储的某条数据导出到 filepath 文件中git cat-file -t &lt;checksum&gt; # 查看 git 存储数据的对象类型，如返回 blob 或 treegit cat-file -p master^&#123;tree&#125; # 查看树对象 master^&#123;tree&#125; 下的内容，可能包含 blob 或 tree 对象。master^&#123;tree&#125; 表示 master 分支上最新的提交所指向的树对象git cat-file -p &lt;checksum&gt; # 查看树对象、提交对象下的内容，将获取最新版本的文件内容git update-index --add --cacheinfo 100644 \\ 83baae61804e65cc73a7201a7252750c76066a30 test.txt # 通过 update-index 命令为 test.txt 文件创建暂存区，选项 --add 将文件存储到暂存区中；选项 --cacheinfo 将文件添加到 git 数据库，而非当前目录中；文件模式 100644 表示为普通文件，100755 为可执行文件，120000 为符号链接git update-index &lt;filepath&gt; # 更新暂存区中文件git update-index --add &lt;filepath&gt; # 添加暂存区中文件git write-tree # 将暂存区内容写入树对象，返回树对象的 SHA-1 值git read-tree &lt;checksum&gt; # 将树对象读入暂存区git read-tree --prefix=dirname &lt;checksum&gt; # 将树对象读入暂存区，--prefix 选项将其作为子树存储在 dirname 目录下echo 'first commit' | git commit-tree &lt;checksum&gt; # 以树对象 checksum 创建提交对象，返回提交对象的校验和。创建的提交对象可通过 git log 查看 git 引用git 通过 .git/refs 目录下的文件存储提交对象的引用，以分支形式分类存储，不同分支创建不同的文件，同一文件下包含该分支的提交记录历史。 HEAD 引用通过 .git/HEAD 文件存储，文件内容如 ref: refs/heads/master，指向其他分支引用。 标签对象（tag object）非常类似于一个提交对象——它包含标签创建者信息、日期、注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。它像是一个永不移动的分支引用——永远指向同一个提交对象，分支引用指向的提交对象可以改写。所以标签对象可用于发布。另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。标签对象存储在 .git/refs/tags 目录中，以标签名作为文件名。 .git/refs/remotes 目录下保存远程引用。远程引用和分支引用的主要区别在于，远程引用是只读的。虽然可以 git checkout 到某个远程引用，但是 git 并不会将 HEAD 引用指向该远程引用。因此，永远不能通过 commit 命令来更新远程引用，而只能通过 push 命令更新。 12345git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9 # 在 master 分支中添加提交对象的校验和，比直接编辑文件更安全git symbolic-ref HEAD # 查看 .git/HEAD 文件内容git symbolic-ref HEAD refs/heads/test # 修改 HEAD 引用的指向git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d # 创建轻量标签git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag' # -a 选项用于创建附注标签 引用规格引用规格/refspec 用于设定 fetch 命令的请求地址和拉取的分支，以小节形式存储在 .git/config 文件中。引用规格的格式由一个可选的 + 号和紧随其后的 : 组成，其中 是一个模式（pattern），代表远程版本库中的引用； 是那些远程引用在本地所对应的位置。 + 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。 执行 git remote add origin https://github.com/schacon/simplegit-progit 命令，.git/config 文件将添加引用规格如下：1234[remote \"origin\"] url = https://github.com/schacon/simplegit-progit fetch = +refs/heads/*:refs/remotes/origin/* # 当修改为 fetch = +refs/heads/master:refs/remotes/origin/master 时，将只抓取远程 master 分支（fetch 可以设置多个，以拉取不同分支的引用）；或者单次执行 git fetch origin master:refs/remotes/origin/mymaster 命令，将远程 master 分支拉到本地的 origin/mymaster 分支 # push = refs/heads/master:refs/heads/qa/master 用于设置推送，或执行 git push origin master:refs/heads/qa/master 命令 执行 git push origin :topic 命令可删除远程 topic 分支，因为 src 为空值，即代表删除。 数据恢复引用日志/reflog 记录每一次你改变 HEAD 时它的值。每一次提交或改变分支时，引用日志都会被更新。引用日志也可以通过 git update-ref 命令更新。git reflog 命令用于查看引用日志。引用日志存放在 .git/logs/ 目录中。 引用日志可用于找回丢失的提交，如 reset, rebase 命令导致丢失。通过 git branch 命令创建新分支指向丢失的提交。 当引用日志也同样丢失时，可以使用 git fsck –full 查看没有被引用的提交对象，即丢失的提交对象。 123git reflog # 查看引用日志git log -g # 以标准日志格式查看引用日志git count-objects -v # 查看内存占用，size-pack 指以 kb 为大小的包文件 疑问： git 的远程交互机制，参考传输协议 移除git 数据库中的历史文件，参考维护与数据恢复 git 环境变量，参考环境变量 参考：https://git-scm.com/book/zh/v2","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://xzfyu.com/categories/读书笔记/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"git","slug":"git","permalink":"http://xzfyu.com/tags/git/"}]},{"title":"mocha使用指南","slug":"frontend/guide/mocha使用指南","date":"2018-02-13T10:50:11.000Z","updated":"2020-03-08T10:59:32.312Z","comments":true,"path":"2018/02/13/frontend/guide/mocha使用指南/","link":"","permalink":"http://xzfyu.com/2018/02/13/frontend/guide/mocha使用指南/","excerpt":"","text":"概述mocha 是一款可运行在 node 环境或浏览器上的测试框架。 mocha 本身没有实现断言库，可使用 chai, should.js, expect.js, better-assert, unexpected 等断言库或 node 内置的 assert 模块。断言库错误输出需有 actual, expected 属性。 示例BDD123456789// BDD 风格，describe/context, it/specify, before, after, beforeEach, afterEachvar assert = require('assert');describe('Array', function() &#123;// 测试套件 describe('#indexOf()', function() &#123; it('should return -1 when the value is not present', function() &#123;// 测试单元 assert.equal([1,2,3].indexOf(4), -1); &#125;); &#125;);&#125;); TDD123456789101112// TDD 风格，suite, test, suiteSetup, suiteTeardown, setup, teardownsuite('Array', function() &#123; setup(function() &#123; // ... &#125;); suite('#indexOf()', function() &#123; test('should return -1 when not present', function() &#123; assert.equal(-1, [1,2,3].indexOf(4)); &#125;); &#125;);&#125;); EXPORTS1234567891011121314// EXPORTS 风格，before, after, beforeEach, afterEachmodule.exports = &#123; before: function() &#123; // ... &#125;, 'Array': &#123;// 对象作为测试套件 '#indexOf()': &#123; 'should return -1 when not present': function() &#123;// 函数为测试单元 [1,2,3].indexOf(4).should.equal(-1); &#125; &#125; &#125;&#125;; QUNIT123456789101112131415161718192021222324// QUNIT 风格，suite, test, before, after, beforeEach, afterEachfunction ok(expr, msg) &#123; if (!expr) throw new Error(msg);&#125;suite('Array');test('#length', function() &#123; var arr = [1,2,3]; ok(arr.length == 3);&#125;);test('#indexOf()', function() &#123; var arr = [1,2,3]; ok(arr.indexOf(1) == 0); ok(arr.indexOf(2) == 1); ok(arr.indexOf(3) == 2);&#125;);suite('String');test('#length', function() &#123; ok('foo'.length == 3);&#125;); REQUIRE1234567891011121314151617// REQUIRE 风格，使用 require 注入var testCase = require('mocha').describe;var pre = require('mocha').before;var assertions = require('mocha').it;var assert = require('chai').assert;testCase('Array', function() &#123; pre(function() &#123; // ... &#125;); testCase('#indexOf()', function() &#123; assertions('should return -1 when not present', function() &#123; assert.equal([1,2,3].indexOf(4), -1); &#125;); &#125;);&#125;) 配置mocha 后跟测试文件名（可使用通配符），或将测试脚本放在 test 目录里，执行 mocha 命令测试 test 目录下的测试脚本（默认只执行第一层）。浏览器端使用 mocha.setup 方法配置 mocha。 选项（可以将命令行参数放在 mocha.opts 文件里，也可以 mocha.opts 文件里指定测试目录）： -u, –ui 测试脚本编码风格，可选值 bdd|tdd|qunit|exports。 –recursive 使用 mocha 测试 test 目录下所有文件。 -g, –grep 只测试匹配正则的 it 。 -f, –fgrep 只测试包含字符串的 it。 -i, –invert 反转 grep, fgrep 选项。 –bail, -b 有一个测试脚本未通过时，就停止测试。 -d, –debug 启动 debug 模式。 –debug-brk enable node’s debugger breaking on the first line??? -gc, –expose-gc expose gc extension??? –harmony&lt;_classes,_generators,…&gt; all node –harmony* flags are available??? –es_staging 启用所有 staged 特征??? -S, –sort 排序测试文件。 –compilers :,… 指定测编译器，如 mocha –compilers js:babel-core/register。若需使用 Map、Set 等，须在测试脚本前 import ‘babel-polyfill’。 -r, –require 加载特定的模块，如 ‘babel-polyfill’。 –file 测试时加载指定文件。 –globals 以 ‘,’ 分割形式注入全局变量。 -A, –async-only 测试脚本只能使用异步编程，回调或 promise 形式。 -w, –watch 监视文件变动，自动运行测试脚本。 -t, –timeout 指定测试时的超时时间，默认为 2000 ms。 -s, –slow 高亮显示超过指定时间的测试报告，默认为 75 ms。 –check-leaks 检测全局变量泄漏。 –growl, -G 将报告显示在桌面。 -R, –reporter 指定报告打印形式，默认是 spec 格式，可选值 tap, dot, nyan, mochawesome 网页报告（须先安装 npm install –dev mochawesome）。 -O, –reporter-options &lt;k=v,k2=v2,…&gt;，打印选项。 –reporters 显示所有报告格式。 -c, –colors 显示颜色。 -C, –no-colors 不显示颜色。 –full-trace 显示完整的堆栈信息。 生成规格文件，如 mocha –recursive -R markdown &gt; spec.md 或 mocha –recursive -R doc &gt; spec.html。… 特性钩子函数 before，在测试用例之前执行 after，在测试用例之后执行 beforeEach，在每个单元测试前执行 afterEach，在每个单元测试后执行 12345678910111213141516171819202122// 钩子允许在 describe 外围，回调将在测试脚本之前或之后执行beforeEach(function() &#123; console.log('before every test in every file');&#125;);describe('hooks', function() &#123; // 钩子函数以匿名函数使用，允许携带描述；命名函数不能 before('some description', function() &#123; // runs before all tests in this block &#125;); // 钩子支持同步或异步编程 beforeEach(function(done) &#123; db.clear(function(err) &#123; if (err) return done(err); db.save([tobi, loki, jane], done); &#125;); &#125;); // test cases&#125;); 异步测试12345678910111213141516171819202122232425// 回调函数形式describe('User', function() &#123; describe('#save()', function() &#123; it('should save without error', function(done) &#123;// done 只能执行一次，两次及以上会报错 var user = new User('Luna'); user.save(done);// done 能自动识别并处理 err 错误 &#125;); &#125;);&#125;);// promise 形式describe('#find()', function() &#123; it('respond with matching records', function() &#123; // db.find(&#123; type: 'User' &#125;) 返回 promise return db.find(&#123; type: 'User' &#125;).should.eventually.have.length(3); &#125;);&#125;);// async 函数形式describe('#find()', function() &#123; it('responds with matching records', async function() &#123; const users = await db.find(&#123; type: 'User' &#125;); users.should.have.length(3); &#125;);&#125;); 延迟执行命令行选项 –delay 用于延迟，相应测试脚本使用 setTimeout 包裹。 123456789setTimeout(function() &#123; // do some setup describe('my suite', function() &#123; // ... &#125;); run();&#125;, 5000); 搁置测试使测试处于 pending 状态，仍然会打印报告。 123456describe('Array', function() &#123; describe('#indexOf()', function() &#123; // pending test below it('should return -1 when the value is not present'); &#125;);&#125;); 限制测试 describe, it 调用 only 方法将只运行指定测试脚本，添加的钩子仍会执行。 describe, it 调用 skip 方法将避免某些脚本的执行。skip 也可以在 mocha 运行过程中调用，或在钩子中调用，两者均使用 this.skip()。 12345678910111213141516171819202122232425262728293031323334353637383940414243// only 方法限制只执行某些测试脚本describe('Array', function() &#123; describe.only('#indexOf()', function() &#123; it.only('should return -1 unless present', function() &#123; // this test will be run &#125;); it('should return the index when present', function() &#123; // this test will not be run &#125;); &#125;);&#125;);// skip 方法跳过执行指定测试脚本describe('Array', function() &#123; describe('#indexOf()', function() &#123; it.skip('should return -1 unless present', function() &#123; // this test will not be run &#125;); it('should return the index when present', function() &#123; // this test will be run &#125;); &#125;);&#125;);// mocha 运行时 skipit('should only test in the correct environment', function() &#123; if (/* check test environment */) &#123; // make assertions &#125; else &#123; this.skip(); &#125;&#125;);// 钩子 skipbefore(function() &#123; if (/* check test environment */) &#123; // setup code &#125; else &#123; this.skip(); &#125;&#125;); 实例方法 retries(num)，指定重复执行测试脚本 num 次，不推荐在单元测试中使用。 slow(time)，高亮显示超过指定时间的测试报告，默认为 75 ms。 timeout(time)，设定超时时间，可在 describe, it 或钩子 中调用。 12345678910111213141516171819202122232425262728293031323334353637// retriesdescribe('retries', function() &#123; // Retry all tests in this suite up to 4 times this.retries(4); beforeEach(function () &#123; browser.get('http://www.yahoo.com'); &#125;); it('should succeed on the 3rd try', function () &#123; // Specify this test to only retry up to 2 times this.retries(2); expect($('.foo').isDisplayed()).to.eventually.be.true; &#125;);&#125;);// slowdescribe('something slow', function() &#123; this.slow(10000); it('should take long enough for me to go make a sandwich', function() &#123; // ... &#125;);&#125;);// timeoutdescribe('a suite of tests', function() &#123; this.timeout(500); it('should take less than 500ms', function(done)&#123; setTimeout(done, 300); &#125;); it('should take less than 500ms as well', function(done)&#123; setTimeout(done, 250); &#125;);&#125;)","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"guide","slug":"frontend/guide","permalink":"http://xzfyu.com/categories/frontend/guide/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"test","slug":"test","permalink":"http://xzfyu.com/tags/test/"}]},{"title":"chai使用指南","slug":"frontend/guide/chai使用指南","date":"2018-02-12T11:12:35.000Z","updated":"2020-03-08T10:59:26.525Z","comments":true,"path":"2018/02/12/frontend/guide/chai使用指南/","link":"","permalink":"http://xzfyu.com/2018/02/12/frontend/guide/chai使用指南/","excerpt":"","text":"概述chai 是一款辅助 TDD 测试驱动开发, BDD 行为驱动开发 的断言库。 有关 TDD 和 BDD，可参考：开发人员看测试之TDD和BDDTDD 已死？让我们再聊聊 TDDBDD敏捷开发入门与实战 chai 的 TDD 模块只包含 assert 一种， BDD 模块包含 except, should 两种。 配置 chai.config.includeStack = false，错误输出中是否包含堆栈信息 chai.config.showDiff = true，是否显示 diff chai.config.truncateThreshold = 40，错误输出中 actual, expexted 打印字符串上限??? api手册TDD测试assert类似 node 的同名模块。 123456789var assert = require('chai').assert , foo = 'bar' , beverages = &#123; tea: [ 'chai', 'matcha', 'oolong' ] &#125;;assert.typeOf(foo, 'string'); // without optional messageassert.typeOf(foo, 'string', 'foo is a string');assert.equal(foo, 'bar', 'foo equal `bar`');assert.lengthOf(foo, 3, 'foo`s value has a length of 3');assert.lengthOf(beverages.tea, 3, 'beverages has 3 types of tea'); apis assert(expression, message)，参数 expression 为待测试的语句 .fail(actual, expected, [message], [operator])，operator 为操作（默认为 !=） .ifError(object)，校验真值时抛出错误 .isOk/isNotOk/isTrue/isNotTrue/isFalse/isNotFalse/isNull/isNotNull/isNaN/isNotNaN/isUndefined/isDefined/isFunction/isNotFunction/isObject/isNotObject/isArray/isNotArray/isString/isNotString/isNumber/isNotNumber/isFinite/isBoolean/isNotBoolean(object, [message]) .exists/notExists(value, [message])，校验 value 不是 null 或 undefined .typeOf/notTypeOf(value, type, [message]) 类型校验 .instanceOf/notInstanceOf(object, constructor, [message]) .match/notMatch(value, regexp, [message]) .equal/notEqual/strictEqual/notStrictEqual/deepEqual/notDeepEqual(actual, expected, [message])，’==’, ‘===’ 或 深度相等 .isAbove/isAtLeast/isBelow/isAtMost(valueToCheck, valueToBeAbove, [message])，以操作符 ‘&gt;’, ‘&gt;=’, ‘&lt;’, ‘&lt;=’ 校验 .operator(val1, operator, val2, [message])，’&gt;’, ‘&lt;’ 操作符校验 .closeTo(actual, expected, delta, [message])，actual 在 expected - delta, expected + delta 之间 .approximately(actual, expected, delta, [message])，同上 .changes/doesNotChange/increases/doesNotIncrease/decreases/doesNotDecrease(function, object, property, [message])，校验函数执行时是否改变对象属性 .changesBy/changesButNotBy/ncreasesBy/increasesButNotBy/decreasesBy/doesNotDecreaseBy/decreasesButNotBy(function, object, property, delta, [message])，校验属性数值改变 + delta .lengthOf(object, length, [message])，校验字符串或数组的长度 .isExtensible/isNotExtensible/isSealed/isNotSealed/isFrozen/isNotFrozen(object) .isEmpty/isNotEmpty(target)，校验对象、数组、字符串、Map、Set非空 .oneOf(inList, list, [message]) .include/notInclude/deepInclude/notDeepInclude/nestedInclude/notNestedInclude/deepNestedInclude/notDeepNestedInclude/ownInclude/notOwnInclude/deepOwnInclude/notDeepOwnInclude(haystack, needle, [message])，校验是否包含数组项，子字符串，或者对象属性的截取。deep 为深度匹配，nest 以分隔符 . 或者 [] 校验嵌套属性，own 校验是否自有属性 sameMembers/notSameMembers/sameDeepMembers/notSameDeepMembers/sameOrderedMembers/notSameOrderedMembers/sameDeepOrderedMembers/notSameDeepOrderedMembers(set1, set2, [message])，校验 set 是否有相同的成员。orderd 顺序相同 .includeMembers/notIncludeMembers/includeDeepMembers/notIncludeDeepMembers/includeOrderedMembers/notIncludeOrderedMembers/includeDeepOrderedMembers/notIncludeDeepOrderedMembers(superset, subset, [message]) .property/notProperty/nestedProperty/notNestedProperty(object, property, [message]) .propertyVal/notPropertyVal/deepPropertyVal/notDeepPropertyVal/notNestedProperty/notNestedPropertyVal/deepNestedPropertyVal/notDeepNestedPropertyVal(object, property, value, [message]) .hasAnyKeys/hasAllKeys/containsAllKeys/doesNotHaveAnyKeys/doesNotHaveAllKeys/hasAnyDeepKeys/hasAllDeepKeys/containsAllDeepKeys/doesNotHaveAnyDeepKeys/doesNotHaveAllDeepKeys(object, [keys], [message]) .throws/doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])，校验函数 fn 将抛出指定类型及文案的错误 TDD测试 - except, shouldexcept提供链式调用。 12345678var expect = require('chai').expect , foo = 'bar' , beverages = &#123; tea: [ 'chai', 'matcha', 'oolong' ] &#125;;expect(foo).to.be.a('string');expect(foo).to.equal('bar');expect(foo).to.have.lengthOf(3);expect(beverages).to.have.property('tea').with.lengthOf(3); should增强了 Object.property 功能，因此需先显示调用 chai.should 函数。 12345678var should = require('chai').should() //actually call the function , foo = 'bar' , beverages = &#123; tea: [ 'chai', 'matcha', 'oolong' ] &#125;;foo.should.be.a('string');foo.should.equal('bar');foo.should.have.lengthOf(3);beverages.should.have.property('tea').with.lengthOf(3); 语言链修饰符语言链修饰符用于增强代码的可读性，包含 to, be, been, isthat, and, has, have, with, at, of, same apis not 将断言置否，即否值满足断言，如 expect(function () {}).to.not.throw(); deep 深比较，如 expect({a: 1}).to.deep.equal({a: 1}); nested 嵌套属性，以 . 或 [] 分割，如 expect({a: {b: [‘x’, ‘y’]}}).to.have.nested.property(‘a.b[1]’); own 如 expect({a: 1}).to.have.own.property(‘a’); ordered 顺序比较，如 expect([1, 2]).to.have.ordered.members([1, 2]).but.not.have.ordered.members([2, 1]); any/all 如 expect({a: 1, b: 2}).to.not.have.any.keys(‘c’, ‘d’); .a/an(type[, msg]) 如 expect({a: 1}).to.be.an(‘object’); .include(val[, msg]) 如 expect(‘foobar’).to.include(‘foo’); .ok/true/false/null/undefined/NaN/exist/empty/arguments/finite 如 expect(arguments).to.be.arguments; .eql(obj[, msg]) 如 expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1}); .above/least/below/most(n[, msg]) 如 expect(1).to.be.at.least(2); .within(start, finish[, msg]) 如 expect(2).to.be.within(1, 3); .instanceof(constructor[, msg]) 如 expect({a: 1}).to.not.be.an.instanceof(Array); .property(name[, val[, msg]]) 如 expect({x: {a: 1}}).to.have.deep.property(‘x’, {a: 1}); .ownPropertyDescriptor(name[, descriptor[, msg]]) 如 expect({a: 1}).to.have.ownPropertyDescriptor(‘a’); .lengthOf(n[, msg]) 如 expect([1, 2, 3]).to.have.lengthOf(3); .match(re[, msg]) 如 expect(‘foobar’).to.match(/^foo/); .string(str[, msg]) 包含子字符串，如 expect(‘foobar’).to.not.have.string(‘taco’); .keys(key1[, key2[, …]]) 如 expect({a: 1, b: 2}).to.have.all.keys(‘a’, ‘b’); .throw([errorLike], [errMsgMatcher], [msg]) 校验函数必须抛出错误，如 expect(badFn).to.throw(); .respondTo(method[, msg]) 校验对象是否有某方法，可以是继承的，如 expect(new Cat()).to.respondTo(‘meow’); .itself 自有属性，如 expect(Cat).itself.to.respondTo(‘hiss’).but.not.respondTo(‘meow’); .satisfy(matcher[, msg]) 校验是否匹配 matcher，如 expect(1).to.satisfy(function(num) { return num &gt; 0; }); .closeTo(expected, delta[, msg]) 校验值在 expected - delta ~ expected + delta 范围内，如 expect(1.5).to.be.closeTo(1, 0.5); .members(set[, msg]) 如 expect([1, 2, 3]).to.have.members([2, 1, 3]); .oneOf(list[, msg]) 如 expect(1).to.be.oneOf([1, 2, 3]); .change(subject[, prop[, msg]]) 执行函数后，引起对象或其属性改变，如 expect(addDot).to.change(myObj, ‘dots’); .increase(subject[, prop[, msg]]) 值增加 .decrease(subject[, prop[, msg]]) 值减少 .by(delta[, msg]) 如 expect(addTwo).to.increase(myObj, ‘val’).by(2); .extensible/sealed/frozen 对象可扩展性 .fail(actual, expected, [message], [operator])，operator 为操作（默认为 !=）","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"guide","slug":"frontend/guide","permalink":"http://xzfyu.com/categories/frontend/guide/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"test","slug":"test","permalink":"http://xzfyu.com/tags/test/"}]},{"title":"Enzyme使用指南","slug":"frontend/guide/Enzyme使用指南","date":"2018-02-10T16:00:00.000Z","updated":"2020-03-08T10:59:30.204Z","comments":true,"path":"2018/02/11/frontend/guide/Enzyme使用指南/","link":"","permalink":"http://xzfyu.com/2018/02/11/frontend/guide/Enzyme使用指南/","excerpt":"","text":"概述Enzyme 是一款 react 组件测试工具。 Enzyme 基于 cheerio 实现虚拟 dom 的查找和遍历；而 cheerio 号称为服务器端的 jquery 实现。 Enzyme 本身不实现测试和断言库，你可以选择使用 Mocha/chai, Jasmine, Jest 等测试或断言库。 使用 安装 npm i –save-dev enzyme。 针对项目中使用的 react 版本，安装 enzyme-adapter-react-16, enzyme-adapter-react-15（15.5.0 版本起）, enzyme-adapter-react-15.4（15.0.0 ~ 15.4.x）, enzyme-adapter-react-14, enzyme-adapter-react-13 适配器。 配置 enzyme 以使用适配器。 1234import Enzyme from 'enzyme';import Adapter from 'enzyme-adapter-react-16';Enzyme.configure(&#123; adapter: new Adapter() &#125;); 编写测试用例。 1234567891011121314151617181920212223242526272829303132333435import React from 'react';import &#123; expect &#125; from 'chai';import &#123; shallow &#125; from 'enzyme';import sinon from 'sinon';import MyComponent from './MyComponent';import Foo from './Foo';describe('&lt;MyComponent /&gt;', () =&gt; &#123; it('renders three &lt;Foo /&gt; components', () =&gt; &#123; const wrapper = shallow(&lt;MyComponent /&gt;); expect(wrapper.find(Foo)).to.have.length(3); &#125;); it('renders an `.icon-star`', () =&gt; &#123; const wrapper = shallow(&lt;MyComponent /&gt;); expect(wrapper.find('.icon-star')).to.have.length(1); &#125;); it('renders children when passed in', () =&gt; &#123; const wrapper = shallow(( &lt;MyComponent&gt; &lt;div className=\"unique\" /&gt; &lt;/MyComponent&gt; )); expect(wrapper.contains(&lt;div className=\"unique\" /&gt;)).to.equal(true); &#125;); it('simulates click events', () =&gt; &#123; const onButtonClick = sinon.spy(); const wrapper = shallow(&lt;Foo onButtonClick=&#123;onButtonClick&#125; /&gt;); wrapper.find('button').simulate('click'); expect(onButtonClick).to.have.property('callCount', 1); &#125;);&#125;); api 手册渲染模式 浅渲染：shallow(node[, options]) =&gt; ShallowWrapper。参数 node 为 ReactElement，options.context 传入组件的context，options.disableLifecycleMethods 生命周期方法是否有效。 完整渲染：mount(node[, options]) =&gt; ReactWrapper。options.context 传入组件的context，options.attachTo 生命周期方法是否有效。需要完整的 dom api，所以需要安装 jsdom 库。 静态渲染：render(node[, options]) =&gt; CheerioWrapper，渲染为 html，通过 cheerio 解析 html。 wrapper api .find(selector) =&gt; Wrapper .findWhere(predicate) =&gt; Wrapper .filter(selector) =&gt; Wrapper .filterWhere(predicate) =&gt; Wrapper .hostNodes() =&gt; Wrapper，事先存在于文档中 host 节点 .contains(nodeOrNodes) =&gt; Boolean .containsMatchingElement(node) =&gt; Boolean .containsAllMatchingElements(nodes) =&gt; Boolean .containsAnyMatchingElements(nodes) =&gt; Boolean .equals(node) =&gt; Boolean .matchesElement(node) =&gt; Boolean .hasClass(className) =&gt; Boolean .is(selector) =&gt; Boolean .exists() =&gt; Boolean .isEmpty() =&gt; Boolean .isEmptyRender() =&gt; Boolean .not(selector) =&gt; Wrapper .children() =&gt; Wrapper .childAt(index) =&gt; Wrapper .parents() =&gt; Wrapper .parent() =&gt; Wrapper .closest(selector) =&gt; Wrapper .shallow([options]) =&gt; Wrapper，ShallowWrapper 独有 .render() =&gt; CheerioWrapper .unmount() =&gt; Wrapper。ReactWrapper 独有 .mount() =&gt; Wrapper 方法 .text() =&gt; String .html() =&gt; String .get(index) =&gt; ReactElement .getElement() =&gt; ReactElement。ReactWrapper 中为 .getNode() =&gt; ReactElement 方法 .getElements() =&gt; Array。ReactWrapper 中为 .getNodes() =&gt; Array 方法。ReactWrapper 独有 .getDOMNode() =&gt; DOMComponent 方法。 .at(index) =&gt; Wrapper .first() =&gt; Wrapper .last() =&gt; Wrapper .state([key]) =&gt; Any .context([key]) =&gt; Any .props() =&gt; Object .prop(key) =&gt; Any .key() =&gt; String .simulate(event[, data]) =&gt; Wrapper，模拟点击事件等 .setState(nextState) =&gt; Wrapper .setProps(nextProps) =&gt; Wrapper .setContext(context) =&gt; Wrapper .instance() =&gt; ReactComponent .update() =&gt; Wrapper，调用 forceUpdate 方法强制更新组件实例。调用实例方法后，需要调用 .update 强制刷新 props。 .debug() =&gt; String，.children 返回已渲染的节点，.children().debug() 返回渲染实际配置格式 .type() =&gt; String|Function|null .name() =&gt; String .forEach(fn) =&gt; Wrapper .map(fn) =&gt; Array .reduce(fn[, initialValue]) =&gt; Any .reduceRight(fn[, initialValue]) =&gt; Any .slice([begin[, end]]) =&gt; Wrapper .tap(intercepter) =&gt; Self .some(selector) =&gt; Boolean .someWhere(predicate) =&gt; Boolean .every(selector) =&gt; Boolean .everyWhere(predicate) =&gt; Boolean .dive([options]) =&gt; Wrapper，ShallowWrapper 独有 .ref(refName) =&gt; Wrapper，ReactWrapper 独有 .detach() =&gt; void，ReactWrapper 独有","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"guide","slug":"frontend/guide","permalink":"http://xzfyu.com/categories/frontend/guide/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"test","slug":"test","permalink":"http://xzfyu.com/tags/test/"}]},{"title":"storybook使用指南","slug":"frontend/guide/storybook使用指南","date":"2018-02-10T12:44:57.000Z","updated":"2020-03-08T10:59:38.934Z","comments":true,"path":"2018/02/10/frontend/guide/storybook使用指南/","link":"","permalink":"http://xzfyu.com/2018/02/10/frontend/guide/storybook使用指南/","excerpt":"","text":"概述storybook 在应用之外，为 UI 组件提供了独立的开发、调试环境。react-transition-group 类库的测试工作即通过 storybook 实现。 storybook 支持调试 react, vue, angular, react-native 组件。storybook官网 操作指南 全局安装 @storybook/cli 项目目录安装依赖：react 项目为 @storybook/react，vue 项目为 @storybook/vue，angular 项目为 @storybook/angular。同时需要安装 babel-core。 package.json 添加 1234567891011// -h 选项 指定以 127.0.0.1 作为主机// -p 选项 指定以 9001 作为端口号// -s 选项 指定 public 作为为静态文件目录// -c 选项 指定以 .storybook 作为配置目录// -o 选项 指定以 .out 作为打包文件目录&#123; \"scripts\": &#123; \"storybook\": \"start-storybook -h 127.0.0.1 -p 9001 -s ./public -c .storybook\", \"build:storybook\": \"build-storybook -s ./public -c .storybook -o .out\" &#125;&#125; 创建配置文件 123456789// .storybook/config.jsimport &#123; configure &#125; from '@storybook/react';function loadStories() &#123; require('../stories/index.js'); // You can require as many stories as you need.&#125;configure(loadStories, module); 编写 story。 12345678910111213// stories/index.jsimport React from 'react';import &#123; storiesOf &#125; from '@storybook/react';import &#123; action &#125; from '@storybook/addon-actions';import Button from '../components/Button';// 来自于工程目录storiesOf('Button', module) .add('with text', () =&gt; ( &lt;Button onClick=&#123;action('clicked')&#125;&gt;Hello Button&lt;/Button&gt; )) .add('with some emoji', () =&gt; ( &lt;Button onClick=&#123;action('clicked')&#125;&gt;😀 😎 👍 💯&lt;/Button&gt; )); npm run storybook，将在 9001 端口启动服务，Button 按钮下有 with text, with some emoji 两个 story。 npm run build:storybook，打包输出静态文件。通过 storybook-deployer 工具可以将静态文件发布到 github 上，或者通过 build-storybook 命令将文件打包到 docs 目录中，作为 github pages 的根目录。 贴示 storybook 内部集成 webpack，通过 babel 编译 js，.babelrc 文件可替代 storybook 的默认配置；支持 css, json, 图片等静态文件的加载。自定义 webpack 配置通过在 .storybook 目录中添加 webpack.config.js 实现，如 1234567891011121314151617181920212223242526272829// 除了 babel-loader 外，默认配置中的其余加载器全部停用// 这种配置方式不能用于配置 babel-loader（第一个加载器）, entry, outputconst path = require('path');module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.scss$/, loaders: [\"style-loader\", \"css-loader\", \"sass-loader\"], include: path.resolve(__dirname, '../') &#125; ] &#125;&#125;// 或者// 这种配置方式不能用于替换 babel-loader（第一个加载器）, entry, output，所有已存在的插件const path = require('path');module.exports = (storybookBaseConfig, configType, defaultConfig) =&gt; &#123; storybookBaseConfig.module.rules.push(&#123; test: /\\.scss$/, loaders: [\"style-loader\", \"css-loader\", \"sass-loader\"], include: path.resolve(__dirname, '../') &#125;); return storybookBaseConfig;&#125;; html，head 头部添加标签。 12345// .storybook/preview-head.html 配置文件将如下标签注入到渲染导入组件的 iframe 中，不影响 storybook 主界面&lt;script src=\"https://use.typekit.net/xxxyyy.js\"&gt;&lt;/script&gt;&lt;script&gt;try&#123; Typekit.load(); &#125; catch(e)&#123; &#125;&lt;/script&gt;// .storybook/preview-head.html 配置文件，将影响 storybook 主界面 通过访问 http://localhost:9009/iframe.html?selectedKind=Button&amp;selectedStory=with+text&amp;dataId=0 可以访问 Button 下的 with text 这个 story，浏览器显示将不带左边栏。 辅助测试Structural TestingStructural Testing 结构测试的目的是判断页面元素是否异常，缺失或增加等。 在 storybook 中，借助 Jest’s snapshot testing 实现结构测试。针对 react，Jest 将为虚拟 DOM 拍摄快照，将其转化为 json 数据，在下一次运行时比对两张快照是否有偏差。 具体步骤为： 安装 @storybook/addon-storyshots 插件。 编写 storyshots.test.js 文件。 1234import initStoryshots from '@storybook/addon-storyshots';// getStorybook() 函数获取所有 storyinitStoryshots(&#123; /* configuration options */ &#125;); 执行 storyshots.test.js 脚本，可用于测试组件逻辑是否崩盘。 参考文档：ReactStorybook 的各种故事 interaction testing关于 interaction testing 交互测试，可以通过模拟用户输入，在 Enzyme 测试框架 Jest, Mocha 实现。 在 storybook 中，交互测试可通过 storybook-addon-specifications 插件实现。 具体步骤为： 安装 storybook-addon-specifications 插件。 编写 .storybook/addons.js 配置文件。 1import 'storybook-addon-specifications/register'; 添加测试文件。 123456789101112131415161718192021222324import &#123; storiesOf &#125; from '@kadira/storybook'import &#123; specs, describe, it &#125; from 'storybook-addon-specifications'import &#123;mount&#125; from \"enzyme\";import expect from \"expect\";const stories = storiesOf('Button', module);stories.add('Hello World', function () &#123; const story = &lt;button onClick=&#123;action('Hello World')&#125;&gt; Hello World &lt;/button&gt;; // describe 首参必须与 story 名字相同 specs(() =&gt; describe('Hello World', function () &#123; it('Should have the Hello World label', function () &#123; let output = mount(story); expect(output.text()).toContain('Hello World'); &#125;); &#125;)); return story;&#125;); 插件使用插件在 storybook 中，插件分为两类，装饰器 Decorator（通过封装 react 组件实现，如 storybook-router） 或 以面板形式注入的 Native Addon（如 addon-actions）。 添加 .storybook/addons.js 配置文件用于向页面添加右下方插件面板。如： 123import '@storybook/addon-actions/register';import '@storybook/addon-links/register';import '@storybook/addon-notes/register'; 编写 stroy 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import &#123; storiesOf &#125; from '@storybook/react';import &#123; action &#125; from '@storybook/addon-actions';import &#123; WithNotes &#125; from '@storybook/addon-notes';import Button from './Button';storiesOf('Button', module) .add('with some emoji', () =&gt; ( &lt;WithNotes notes=&#123;'Here we use some emoji as the Button text. Doesn&amp;apos;t it look nice?'&#125;&gt; &lt;Button onClick=&#123;action('clicked')&#125;&gt;😀 😎 👍 💯&lt;/Button&gt; &lt;/WithNotes&gt; ));// 使用装饰器 1import &#123; storiesOf &#125; from '@storybook/react';import &#123; action &#125; from '@storybook/addon-actions';import Button from './button';const styles = &#123; textAlign: 'center',&#125;;const CenterDecorator = (storyFn) =&gt; ( &lt;div style=&#123;styles&#125;&gt; &#123; storyFn() &#125; &lt;/div&gt;);storiesOf('Button', module) .addDecorator(CenterDecorator) .add('with text', () =&gt; ( &lt;Button onClick=&#123;action('clicked')&#125;&gt;Hello Button&lt;/Button&gt; )) .add('with some emojies', () =&gt; ( &lt;Button onClick=&#123;action('clicked')&#125;&gt;😀 😎 👍 💯&lt;/Button&gt; ));// 使用装饰器 2import &#123; storiesOf, addDecorator &#125; from '@storybook/react';import &#123; action &#125; from '@storybook/addon-actions';import &#123; linkTo &#125; from '@storybook/addon-links';import Button from './button';import Welcome from './welcome';const styles = &#123; textAlign: 'center',&#125;;const CenterDecorator = (storyFn) =&gt; ( &lt;div style=&#123;styles&#125;&gt; &#123; storyFn() &#125; &lt;/div&gt;);addDecorator(CenterDecorator);storiesOf('Welcome', module) .add('to Storybook', () =&gt; ( &lt;Welcome showApp=&#123;linkTo('Button')&#125;/&gt; ));storiesOf('Button', module) .add('with text', () =&gt; ( &lt;Button onClick=&#123;action('clicked')&#125;&gt;Hello Button&lt;/Button&gt; )) .add('with some emojies', () =&gt; ( &lt;Button onClick=&#123;action('clicked')&#125;&gt;😀 😎 👍 💯&lt;/Button&gt; )); 插件清单 Storyshots: 快照测试。 Specs: 交互测试。 Notes: 在 story 中添加备注。 Info: 用于创建 css 框架手册。 Readme: 将 markdown 导入为 story。 actions: 显示事件的 event 对象。 Intl: 添加 locales 面板，用于切换语言。 State: 添加 state 面板，展示或更新 state，重绘视图。 Props Combinations: 配置可能有的props，一次性绘出多个组件作对比。 Knobs: 页面上变更 props 重绘视图。 Links: 通过 linkTo 函数或 LinkTo 组件链接多个 story，支持点击跳转。 Story-router: 装饰器，支持 storybook 使用 react-router 等路由组件。 Backgrounds: 切换背景图或背景颜色。 i18n tools: 切换文字对齐方式，左对齐或右对齐。 Material-UI: 添加并切换自定义主题。 Host: 装饰器，在页面上以盒模式展示组件。 Chapters: 在同一个 story 中以章节形式展示多个组件。 Options: 调整 storybook 页面外观，切换为全屏等。 Console: 将浏览器控制台 console 信息输出到 storybook log 面板。 JSX preview: 展示及拷贝 JSX 代码。 Versions: 添加版本号，查看各版本的变化。 Apollo: 添加 Apollo client，模拟 GraphQL 查询。 Screenshot: 保存网页截图。 Styles: storybook 预览界面添加自定义样式。 Figma: 添加 Figma 设计面板。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"guide","slug":"frontend/guide","permalink":"http://xzfyu.com/categories/frontend/guide/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"tools","slug":"tools","permalink":"http://xzfyu.com/tags/tools/"}]},{"title":"浅析react-transition-group源码","slug":"frontend/library/浅析react-transition-group源码","date":"2018-02-07T15:19:17.000Z","updated":"2020-03-08T10:45:48.827Z","comments":true,"path":"2018/02/07/frontend/library/浅析react-transition-group源码/","link":"","permalink":"http://xzfyu.com/2018/02/07/frontend/library/浅析react-transition-group源码/","excerpt":"","text":"react-transition-group 1 版本回顾react-transition-group 1 版本在子组件创建、删除过程通过添加 class 控制 css 动效。 介于 css transition 动效在元素添加到页面过程就会执行，因此这个过程无需调控动效的执行。而当有元素被移除时，我们需要容器组件驻留被删除的子组件，等到动效执行完成后，才实际删除该子组件。 针对这一问题，react-transition-group 提供了 TransitionGroup 容器组件。其 state.children 属性为实际待绘制的组件，当组件更新时，通过比对 state.children, props.children，就可以获知新增了哪些组件、移除了哪些组件（用户配置的子组件通过 key 键存储成映射结构）。当子组件被移除时，触发 performLeave 方法，以调用子组件的 componentWillLeave 方法添加样式类、执行动效；再通过 componentWillLeave 方法的回调函数，更新 TransitionGroup 容器的 state.children，触发子组件的实际移除行为。 当采用上述逻辑处理子组件的移除动效时，为着处理逻辑的统一，react-transition-group 针对 componentDidMount 或 componentDidUpdate 时创建的子组件也采用相同的处理逻辑。子组件的钩子函数 componentWillAppear, componentDidAppear, componentWillEnter, componentDidEnter, componentWillLeave, componentDidLeave 将分别得到执行。当独立使用 TransitionGroup 容器时，我们可以借助这些钩子函数操控节点的样式以触发 css 动效，或者组织 js 动效，或者实现懒加载等等。 在 TransitionGroup 容器的基础上，CSSTransitionGroupChild 组件用于装饰子组件，在 componentWillAppear 等钩子函数添加样式类以执行 css 动效，通过 setTimeout 或 transitionEnd 事件更新 TransitionGroup 容器的 state.children 属性。CSSTransitionGroup 组件用于将 props 配置上提，而不是通过 CSSTransitionGroupChild 给每个子组件外加一个壳子。 react-transition-group 2 版本Transition相比于 1 版本通过判断子组件的有无添加动效，react-transition-group 2 版本可通过向子组件传递状态值（props.children 以函数形式配置；若为ReactElement，则无任何作用）控制子组件的创建和删除过程，这一点和 react-motion 类库相仿。关于 react-motion，笔者将在后续文章中加以分析。 上述思路的简单实现是通过容器组件向子组件传递 props.status，用于判断动效是在执行中 transitionExcute，还是执行完成 transitionEnd。若执行完成，将触发移除组件的操作。为此，react-transition-group 2 提供了 Transition 容器组件，props.status 状态分别在子组件创建和移除阶段添置了两个值，合计四种状态，即 ENTERING, ENTERED, EXITING, EXITED 。ENTERING, ENTERED 状态针对新创建的子组件，EXITING, EXITED 状态针对待移除的子组件。Transition 组件内部实现的主要业务逻辑就是协调 ENTERING 到 ENTERED，EXITING 到 EXITED 状态的自动变更。对于不需要动效的场景，状态将直接置为 ENTERED, EXITED；在 Transition 组件中，作为动效开关的是 props.appear, props.enter, props.exit 属性。 除此之外，有必要区分组件在创建过程 onEnter 还是在移除过程 onExit，以便于控制组件的挂载状态。然而 onEnter, onExit 两个状态值不适用于动效结束时仍保留组件的场景。为此，Transition 组件使用 props.in 属性表示组件的显示状态，结合 props.unmountOnExit 属性即表示在动效执行完成后，不必移除组件。子组件不能通过获得的 status 值控制自身的挂载状态，Transition 容器通过将 status 置为 UNMOUNTED，并在其 render 方法中输出 null，以控制子组件的显隐。这样的设计也满足了对子组件挂载时机的微调。像 1 版本中那样，通常情况下，子组件往往而在。不同的是，在组件初始化时通过将 props.mountOnEnter 属性置为真值，且 props.in 为否值，子组件将不在视图显示；当更新组件时，props.in 属性首次切换为真值时，才将 status 置为 EXITED，以便在实际视图中创建子组件，从而启动动效。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182constructor(props, context) &#123; super(props, context); let parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears let appear = parentGroup &amp;&amp; !parentGroup.isMounting ? props.enter : props.appear; let initialStatus; this.nextStatus = null; if (props.in) &#123;// in 为真值，创建并显示组件 if (appear) &#123;// appear 为真值，执行动效 initialStatus = EXITED;// updateStatus 方法中满足 initialStatus 非 null 校验，以执行 performEnter 方法 this.nextStatus = ENTERING; &#125; else &#123;// appear 为否值，不执行动效 initialStatus = ENTERED; &#125; &#125; else &#123; // mountOnEnter 为真值，意味着延迟挂载；unmountOnExit 为否值的情形，主要为着避过 updateStatus 中对 &#123; state: EXITED &#125; 的处理逻辑，即动效执行结束后移除组件 if (props.unmountOnExit || props.mountOnEnter) &#123; initialStatus = UNMOUNTED; &#125; else &#123; // 悬空 initialStatus = EXITED; &#125; &#125; this.state = &#123; status: initialStatus &#125;; this.nextCallback = null;&#125;componentDidMount() &#123; this.updateStatus(true);&#125;componentWillReceiveProps(nextProps) &#123; const &#123; status &#125; = this.pendingState || this.state; if (nextProps.in) &#123; // 子组件已被移除或初始化未被挂载，status 置为 EXITED，便于添加子组件 if (status === UNMOUNTED) &#123; this.setState(&#123; status: EXITED &#125;); &#125; // 子组件尚未在视图中，执行显示动效 if (status !== ENTERING &amp;&amp; status !== ENTERED) &#123; this.nextStatus = ENTERING; &#125; &#125; else &#123; // 子组件已在视图中，执行移除动效 if (status === ENTERING || status === ENTERED) &#123; this.nextStatus = EXITING; &#125; &#125;&#125;componentDidUpdate() &#123; this.updateStatus();&#125;updateStatus(mounting = false) &#123; let nextStatus = this.nextStatus;// 只有两种可能，ENTERING 或 EXITING if (nextStatus !== null) &#123; this.nextStatus = null; this.cancelNextCallback(); const node = ReactDOM.findDOMNode(this); if (nextStatus === ENTERING) &#123; this.performEnter(node, mounting); &#125; else &#123; this.performExit(node); &#125; &#125; else if (// 动效执行完成后 state 置为 EXITED 时，且 unmountOnExit 为真，移除子组件 this.props.unmountOnExit &amp;&amp; this.state.status === EXITED ) &#123; this.setState(&#123; status: UNMOUNTED &#125;); &#125;&#125; （当初始化时，props.in 置为否值，子组件将不予渲染或渲染后无动效；当更新时置为否值，子组件已在视图中，执行 performExit 方法，好启动 exit 动效。） 上述代码中，performEnter, performExit 方法用于操控容器组件在 props.timeout 时间后自动从 ENTERING 切换到 ENTERED 状态，或者从 EXITING 切换到 EXITED 状态。这两个方法均调用了 safeSetState 方法，该方法的意义是设置 pendingState 属性，以避免动效的多次执行；以及通过调用 onTransitionEnd 方法执行变更 status 的逻辑。onTransitionEnd 方法的延迟机制通过监听 transitionEnd 事件（借助于 props.addEventLinstener 配置）或者使用 setTimeout 执行回调实现，变更 status 状态的回调通过 setNextCallback 方法免于多次执行。 Transition 容器在根据 props.in, props.appear, props.enter, props.exit, props.mountOnEnter, props.unmountOnExit 属性自动处理 status 状态的同时，还设置了多个在适当时机执行的钩子函数，包含 props.onEnter, props.onEntering, props.onEntered, props.onExit, props.onExiting, props.onExited 配置项。 CSSTransition在 react-transition-group 2 版本内部，props.onEnter 等钩子在实现 CSSTransition 组件时极有意义。因为 Transition 容器传给 props.children 函数的 status 只包含 enter, exit 相关状态，没有 appear 状态。而 onEnter, onEntering, onEntered 钩子的次参即为是否在 appear 状态中（通过 context.transitionGroup.isMounting 或 mounting 获知），CSSTransition 组件即在此基础上实现，通过钩子更新 props.children 对应节点的 class（依次由 -appear, -appear-active, -enter, -enter-active, -enter-done, -exit, -exit-active, -exit-done 变更，* 通过 props.classNames 设置，该属性也设置为对象）。与 1 版本相同，2 版本在类名变更的同时，访问了 node.scrollTop 促使浏览器重绘；也可以在 props.children 中执行 onEnter 等方法阻止 js 动效或懒加载等逻辑。CSSTransition 组件同样向上抛出 props.onEnter, props.onEntering, props.onEntered, props.onExit, props.onExiting, props.onExited 钩子。 TransitionGroupTransitionGroup 的处理逻辑和 1 版本相同，即通过 state.children 控制待渲染的元素，以实现 exit 动效执行时仍驻留子组件的场景。不同的是，1 版本会用 CSSTransitionGroupChild 包装子组件，2 版本需要用户传入 Transition 组件作为 TransitionGroup 的子组件。当然，因为 2 版本中，Transition 组件动效执行时机和组件渲染状态的弱关联，促使 TransitionGroup 容器的 componentWillReceiveProps 方法中更新 state.children 的逻辑也不一样。 TransitionGroup 的一般适用场景为当子组件添加时，执行 enter 动效；当子组件移除时，执行 exit 动效。在这样的场景中，子组件的渲染状态不受 TransitionGroup 控制，也即 TransitionGroup 容器对子组件的 props.in 属性的调控必须与子组件的渲染状态向匹配。在 TransitionGroup 容器初始化阶段，传入子组件的 props.in 属性必然为真值，因为在这阶段，子组件都会得到渲染。在更新阶段，当子组件移除时，通过设置 props.in 为否值，触发 exit 动效；当子组件 exit 动效执行阶段，子组件又被添加，通过设置 props.in 为真值，使 enter, exit 动效得以执行；当子组件 exit 动效执行完成、且组件已移除后，处理逻辑同 exit 动效执行阶段；当子组件维持原样，传入子组件的 props.in 属性维持原值，props.oEnter, props.onExit 属性则同步为子组件最新的 props 值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364constructor(props, context) &#123; super(props, context); // Initial children should all be entering, dependent on appear this.state = &#123; children: getChildMapping(props.children, child =&gt; &#123; return cloneElement(child, &#123; onExited: this.handleExited.bind(this, child), in: true, appear: this.getProp(child, 'appear'), enter: this.getProp(child, 'enter'), exit: this.getProp(child, 'exit'), &#125;) &#125;), &#125;;&#125;componentWillReceiveProps(nextProps) &#123; let prevChildMapping = this.state.children; let nextChildMapping = getChildMapping(nextProps.children); let children = mergeChildMappings(prevChildMapping, nextChildMapping); Object.keys(children).forEach((key) =&gt; &#123; let child = children[key] if (!isValidElement(child)) return; const hasPrev = key in prevChildMapping; const hasNext = key in nextChildMapping; const prevChild = prevChildMapping[key]; // child 在移除过程中 const isLeaving = isValidElement(prevChild) &amp;&amp; !prevChild.props.in; // child 新添加或者移除动效尚未执行完成，执行 enter 动效 if (hasNext &amp;&amp; (!hasPrev || isLeaving)) &#123; // console.log('entering', key) children[key] = cloneElement(child, &#123; onExited: this.handleExited.bind(this, child), in: true, exit: this.getProp(child, 'exit', nextProps), enter: this.getProp(child, 'enter', nextProps), &#125;); &#125; // 组件已移除，执行 exit 动效 else if (!hasNext &amp;&amp; hasPrev &amp;&amp; !isLeaving) &#123; // console.log('leaving', key) children[key] = cloneElement(child, &#123; in: false &#125;); &#125; // 组件动效特性未作改变，保留原值 else if (hasNext &amp;&amp; hasPrev &amp;&amp; isValidElement(prevChild)) &#123; // console.log('unchanged', key) children[key] = cloneElement(child, &#123; onExited: this.handleExited.bind(this, child), in: prevChild.props.in, exit: this.getProp(child, 'exit', nextProps), enter: this.getProp(child, 'enter', nextProps), &#125;); &#125; &#125;) this.setState(&#123; children &#125;);&#125; handleExited 方法用于当子组件 exit 动效执行完成且移除后，更新 TransitionGroup 容器的 state.children 属性，附带调用原始传入子组件的 props.onExited 方法（实际传入子组件的 props.onExited 方法被改写为 handleExited 方法）。 在变更 state.children 的处理逻辑之外，TransitionGroup 向外提供 props.appear, props.enter, props.exit, props.component, props.childFactory 配置项。props.appear, props.enter, props.exit 为当子组件元素没有同名 props 属性时，使用 TransitionGroup 容器的 props 属性；props.component 为外层包裹元素（适配 react 中 props.children 不能置为数组的特性，react 16 可能不需要）；props.childFactory 用于装饰子元素。 2 版本没有提供 CSSTransitionGroup 组件，因为在 TransitionGroup 组件下挂载 CSSTransition 组件即能实现与 1 版本中 CSSTransitionGroup 相同的效果，通过调整节点的 class 实现动效。在这里，CSSTransition 组件作为特殊的 Transition 组件。除此而外，Transition, CSSTransition 组件都向外暴露 props.onEnter, props.onEntering, props.onEntered, props.onExit, props.onExiting, props.onExited 配置钩子，因此相较于 1 版本中通过 CSSTransitionGroup 自应用的 CSSTransitionGroupChild 组件，2 版本能对 css 动效实现更细微的控制。 此外，TransitionGroup 组件会通过 context 属性向 Transition 子组件传递 transitionGroup 属性，以使 Transition 子组件能够感知动效处于 appear 阶段还是 enter 阶段。Transition 组件又通过 getChildContext 方法，将其子孙组件的 transitionGroup 属性置为 null，其意义时，当父 Transition 嵌套子 Transition 时，子 Transition 不至于尝试通过 context.transitionGroup 属性判断动效在 appear 阶段还是 enter 阶段。 ReplaceTransition2 版本中，ReplaceTransition 用于通过控制 props.in 切换显示两个子组件中的一个。因此实际使用过程中，需要有容器包裹，通过容器更新传入 ReplaceTransition 组件中的props.in；循环切换需要在容器中设置定时器（循环切换过程中，不支持其中任意一个子组件 exit 动效，适用场景相对较小）。ReplaceTransition 组价向外提供 props.onEnter, props.onEntering, props.onEntered, props.onExit, props.onExiting, props.onExited 等配置属性，前三个为第一个子组件 enter 动效相关钩子，后三个为第二个子组件 enter 动效相关钩子。其 ReplaceTransition 组价支持在 enter 发生过程中调用子组件的 props.onEnter, props.onEntering, props.onEntered, props.onExit, props.onExiting, props.onExited，前三个钩子为第一个子组件独有，后三个为第二个子组件独有。源码不作赘述。 反思无论 1 版本的核心模块 TransitionGroup，还是 2 版本的核心模块 Transition，都通过容器管理子组件的动效执行过程。1 版本切入的视角在于通过判断子组件从列表中创建、移除的过程，触发调用子组件的 componentWillAppear 等方法，以管理动效。对于 css 动效，1 版本又通过包含特定 componentWillAppear 等实例方法的 CSSTransitionGroupChild 包装用户实际开发的子组件，从而对接上 TransitionGroup 容器，使子组件中的动效得到管理。2 版本在处理上更为细致，独立对待用户开发的动效组件，而不是视为列表形式。2 版本通过 Transition 容器将子组件可能包含的 enter, exit 动效抽象为 state.status，并传入子组件，由子组件自身通过 status 启用特定的动效；并且同样提供了以钩子方式（props.onEnter 等配置方法）管理动效的实现，2 版本自身的 CSSTransition 组件即通过钩子调节添加到节点上的 class。若说 1 版本还滞留于子组件从列表中移入移出的视点，2 版本的观察角度则从列表中脱离，实打实地介入了子组件动效执行周期的管理，will - excute - did，并向下注入执行状态。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"library","slug":"frontend/library","permalink":"http://xzfyu.com/categories/frontend/library/"}],"tags":[{"name":"react","slug":"react","permalink":"http://xzfyu.com/tags/react/"},{"name":"react-components","slug":"react-components","permalink":"http://xzfyu.com/tags/react-components/"}]},{"title":"webpack插件指南","slug":"frontend/工程化/webpack/webpack插件指南","date":"2018-02-06T15:38:53.000Z","updated":"2020-03-08T10:54:22.113Z","comments":true,"path":"2018/02/06/frontend/工程化/webpack/webpack插件指南/","link":"","permalink":"http://xzfyu.com/2018/02/06/frontend/工程化/webpack/webpack插件指南/","excerpt":"","text":"HotModuleReplacementPlugin内置为 webpack.HotModuleReplacementPlugin，热替换插件。 12345new webpack.HotModuleReplacementPlugin(&#123; multiStep: boolean,// 设置为 true 时，插件会分成两步构建文件。首先编译热加载 chunks，之后再编译剩余的通常的资源 fullBuildTimeout: number,// 当 multiStep 启用时，表示两步构建之间的延时 requestTimeout: number// 下载 manifest 的延时&#125;) DllPlugin, DLLReferencePlugin内置为 webpack.DllPlugin, webpack.DllReferencePlugin，用于提升编译速度。 DllPlugin 插件会生成一个 manifest.json 文件，该文件包含了从 require 和 import 的 request 到模块 id 的映射，用于让 DLLReferencePlugin 映射到相关的依赖上去。通过引用 manifest.json 文件来把依赖的名称映射到模块的 id 上，之后再在需要的时候通过内置的 webpack_require 函数来 require 他们。 12345678910111213141516// webpack.vendor.config.jsnew webpack.DllPlugin(&#123; context: __dirname,// manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context)) name: \"[name]_[hash]\",// 暴露出的 DLL 的函数名 path: path.join(__dirname, \"manifest.json\"),// manifest.json 文件的绝对路径&#125;)// webpack.app.config.jsnew webpack.DllReferencePlugin(&#123; context: __dirname,// 绝对路径， manifest.json (或者是内容属性)中请求的上下文 manifest: require(\"./manifest.json\"),// 包含 content 和 name 的对象 content: require(\"./manifest.json\").content,// 请求到模块 id 的映射 (默认值为 manifest.content) name: manifest.name,// dll 脚本的名称 (默认值为 manifest.name) scope: undefined,// 开启作用域模块，如 scope = \"xyz\"， dll 中的名为 abc 的文件可通过 require(\"xyz/abc\") 加载。默认为映射模式，即通过 require(\"abc\") 加载。且 dll 文件不会被打包到 bundle 中 sourceType: \"commonsjs2\"// dll 如何向外提供全局函数&#125;) DefinePlugin内置为 webpack.DefinePlugin，定义全局变量。使用场景如，由变量区分开发环境或生产环境，开发环境打印日志，生产环境不打印。变量的值将被转换为字符串，且以文本替换的形式传入代码中，所以需要包裹单双引号或使用 JSON.stringify，如 ‘“production”‘, JSON.stringify(‘production’)。 1234567891011121314new webpack.DefinePlugin(&#123; PRODUCTION: JSON.stringify(true),// 以文本形式传入 true VERSION: JSON.stringify(\"5fa3b9\"), BROWSER_SUPPORTS_HTML5: true, TWO: \"1+1\", \"typeof window\": JSON.stringify(\"object\"),// 替换 typeof window 文本 // 功能标记 'NICE_FEATURE': JSON.stringify(true), 'EXPERIMENTAL_FEATURE': JSON.stringify(false), // 服务 Url 'SERVICE_URL': JSON.stringify(\"http://dev.example.com\")&#125;) EnvironmentPlugin内置为 webpack.EnvironmentPlugin，使用 DefinePlugin 快捷设置 process.env 环境变量。 12345678910111213/**等同于 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV), 'process.env.DEBUG': JSON.stringify(process.env.DEBUG)&#125;) */new webpack.EnvironmentPlugin(['NODE_ENV', 'DEBUG'])// 使用默认值new webpack.EnvironmentPlugin(&#123; NODE_ENV: 'development', // 除非有定义 process.env.NODE_ENV，否则就使用 'development' DEBUG: false&#125;) ProvidePlugin内置为 webpack.ProvidePlugin，当某变量没有赋值时，自动 import 或 require 相应的模块，并导出其中的方法。 12345678910// 自动加载 jquerynew webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery'&#125;)// 注入 lodash.map 方法new webpack.ProvidePlugin(&#123; _map: ['lodash', 'map']&#125;) CommonsChunkPlugin内置为 webpack.optimize.CommonsChunkPlugin，提取公共代码，结合 entry 属性使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const webpack = require(\"webpack\");module.exports = &#123; entry: &#123; vendor: [\"jquery\", \"other-lib\"], app: \"./entry\" &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: string|string[],// 字符串或数组，若设为已经存在的打包文件 chunk 名称，将把该 chunk 提取到公共文件中。如果该选项被忽略，同时 `options.async` 或者 `options.children` 被设置，所有的 chunk 都会被使用，否则 `options.filename` 会用于作为 chunk 名 filename: string,// 公共文件名模板，使用和 output.filename 相同的占位符。不设置，将保留原 chunk 的名称 minChunks: number|Infinity|(module, count) =&gt; boolean,// 生成公共文件前，需要传入的 chunk 数量。设为 Infinity，会马上生成 公共chunk，但里面没有模块。默认是 chunk 的数量 chunks: string[],// 选择 chunk 的来源。如果被忽略，所有的入口 chunk 都会被选择 children: boolean,// 如果设置为 true，入口 chunk 的依赖都会被并入公共文件中，以避免 chunk 的依赖包含重复代码 async: boolean|string,// 如果设置为 true，与上面相同，入口 chunk 的依赖被并入公共文件中，且使用异步加载 minSize: number// 在 公共chunk 被创建立之前，所有公共模块的最少大小 &#125;) ]&#125;// 入口 chunk 依赖路径中包含 \"somelib\" 字样的脚本，这些脚本将被视为一个 chunk，chunk 的 keyname 是 \"my-single-lib-chunk\"，最终打包到 \"my-single-lib-chunk.js\" 中new webpack.optimize.CommonsChunkPlugin(&#123; name: \"vendor\", minChunks: ffunction(module, count) &#123; return module.resource &amp;&amp; (/somelib/).test(module.resource) &amp;&amp; count === 3; &#125;&#125;)// 避免提取 css, scss 文件，且公共文件只能在 node_modules 下new webpack.optimize.CommonsChunkPlugin(&#123; name: \"vendor\", minChunks: function (module) &#123; if(module.resource &amp;&amp; (/^.*\\.(css|scss)$/).test(module.resource)) &#123; return false; &#125; return module.context &amp;&amp; module.context.indexOf(\"node_modules\") !== -1; &#125;&#125;)// 将 webpack 注入页面的脚本提取到公共文件，文件名 \"manifest\" 不能和入口 chunk 重名new webpack.optimize.CommonsChunkPlugin(&#123; name: \"manifest\", minChunks: Infinity&#125;)// 或[ new webpack.optimize.CommonsChunkPlugin(&#123; name: \"vendor\", minChunks: function(module)&#123; return module.context &amp;&amp; module.context.indexOf(\"node_modules\") !== -1; &#125; &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: \"manifest\", minChunks: Infinity &#125;),] SourceMapDevToolPlugin内置为 webpack.SourceMapDevToolPlugin，对 webpackConfig.devtool 添加的 SourceMap 予以更细粒度的控制。 12345678910111213141516new webpack.SourceMapDevToolPlugin(&#123; test,// 指定资源，test 默认是 .js 和 .css 文件 include, exclude, filename: '[name].js.map',// SourceMap 的输出文件名。如果没有提供值，则 source map 是内联的 append,// 追加到原始资源。通常以 #sourceMappingURL 注释。[url] 替换为 source map 文件的 URL。false 禁止追加 moduleFilenameTemplate,// SourceMap 的输出文件名模板 fallbackModuleFilenameTemplate,// SourceMap 的输出文件名后备方案 module: true,// 为 false 时， loader 不再生成 source map，并且转换过的代码被用作源码 columns: true,// 为 false 时，source map 中的列映射(column mapping)被忽略，并且使用更快速的 source map 实现 lineToLine: &#123;// 匹配的模块使用简单快速的行到行 source map test, include, exclude &#125; &#125;) MinChunkSizePlugin内置为 webpack.optimize.MinChunkSizePlugin，通过合并小于 minChunkSize 大小的 chunk，将 chunk 体积保持在指定大小限制以上。 123new webpack.optimize.MinChunkSizePlugin(&#123; minChunkSize: 10000&#125;) BannerPlugin内置为 webpack.BannerPlugin，为每个 chunk 文件头部添加 banner。 1234567891011new webpack.BannerPlugin(banner)// 或new webpack.BannerPlugin(&#123; banner: \"hash:[hash], chunkhash:[chunkhash], name:[name], filebase:[filebase], query:[query], file:[file]\", raw: false,// 如果值为 true，将直出，不作为注释 entryOnly: false,// 如果值为 true，将只在入口 chunks 文件中添加 test: null, include: null, exclude: null&#125;) IgnorePlugin内置为 webpack.IgnorePlugin，打包时避过指定资源。 1234567new webpack.IgnorePlugin( requestRegExp,// 测试资源请求路径的正则表达式 [contextRegExp]// (可选) 测试资源上下文(目录)的正则表达式)// 示例，moment 类库中 locale 资源将不予打包new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) NormalModuleReplacementPlugin内置为 webpack.NormalModuleReplacementPlugin，替换指定资源，适用场景为生产环境下的某配置文件比开发环境的配置文件有更高优先级。高级用法是指定环境变量，通过环境变量指定待加载的资源。 1234567891011121314151617// 生产环境修改 webpack.config.js，加载 './config.production.js' 文件；开发环境不使用 NormalModuleReplacementPlugin 插件，加载 'some/path/config.development.js' 文件new webpack.NormalModuleReplacementPlugin( /some\\/path\\/config\\.development\\.js/, './config.production.js');// 高级用法，通过环境变量加载文件，开发环境默认加载带 VERSION_A 字样文件；生产环境设 env.APP_TARGET = 'VERSION_B'，加载 VERSION_B 文件module.exports = function(env) &#123; var appTarget = env.APP_TARGET || 'VERSION_A'; return &#123; plugins: [ new webpack.NormalModuleReplacementPlugin(/(.*)-APP_TARGET(\\.*)/, function(resource) &#123; resource.request = resource.request.replace(/-APP_TARGET/, `-$&#123;appTarget&#125;`); &#125;) ] &#125;&#125; ContextReplacementPlugin内置为 webpack.ContextReplacementPlugin，替换 webpack 文件查找规则。在 webpack 中，当 require(‘./locale/‘ + name + ‘.json’)，webpack 将查找目录 (‘./locale/‘) 下符合正则表达式 (/^.*.json$/)的文件，由于 name 在编译时(compile time)还是未知的，webpack 会将每个文件都作为模块引入到 bundle 中。 123456789101112131415161718192021222324252627282930313233343536373839new webpack.ContextReplacementPlugin，替换( resourceRegExp: RegExp,// 如果资源（或目录）符合 resourceRegExp 正则表达式，插件会替换默认资源为 newContentResource newContentResource?: string,// 如果 newContentResource 为相对路径，会相对于前一匹配资源路径去解析 newContentRecursive?: boolean,// 是否使用递归查找 newContentRegExp?: RegExp,// 用于筛选新上下文里的资源 newContentCallback?: data =&gt; void)// 示例new webpack.ContextReplacementPlugin(/moment[\\/\\\\]locale$/, /de|fr|hu/)// 或new webpack.ContextReplacementPlugin，替换( resourceRegExp: RegExp, newContentCallback?: data =&gt; void// 首参为为上下文模块工厂(ContextModuleFactory)的 data 对象，需要覆写该对象的 request 属性)// 示例new webpack.ContextReplacementPlugin(/^\\.\\/locale$/, (context) =&gt; &#123; if (!/\\/moment\\//.test(context.context)) &#123; return; &#125; Object.assign(context, &#123; regExp: /^\\.\\/\\w+/, request: '../../locale', // 相对路径 &#125;);&#125;)// 或new webpack.ContextReplacementPlugin( resourceRegExp: RegExp, newContentResource: string, newContentCreateContextMap: object // 将运行时请求(runtime-request)映射到编译时请求(compile-time request))// 示例new ContextReplacementPlugin(/selector/, './folder', &#123; './request': './request', './other-request': './new-request'&#125;) HtmlWebpackPluginhtml-webpack-plugin 插件，创建 html 文件，自动加载打包资源。 注入 html 模板的变量包含，htmlWebpackPlugin = { files, options }, webpack, webpackConfig。 支持的事件包含，html-webpack-plugin-before-html-generation, html-webpack-plugin-before-html-processing, html-webpack-plugin-alter-asset-tags, html-webpack-plugin-after-html-processing, html-webpack-plugin-after-emit, 同步事件 tml-webpack-plugin-alter-chunks。在自定义插件中使用。 参考文档：https://github.com/jantimon/html-webpack-plugin 123456789101112131415new HtmlWebpackPlugin(&#123; title: '',// 注入 html 的 title filename: 'index.html',// 影响加载资源的位置 template: '',// html, ejs, jade 模板的路径 inject: true | 'head' | 'body' | false,// 静态资源注入位置，默认在 body 底层 favicon: '',// 图标路径 minify: &#123;&#125;,// 传递给 html-minifier 的选项，用于优化输出 hash: true | false,// 设为真时，js, css 资源名将加上 hash 值，用于刷新缓存 cache: true,// 设为真时，只有文件变更时，才重新请求 showErrors: true,// 显示错误 chunks: [],// 添加 chunk，如用于单元测试的脚本 chunksSortMode: 'auto',// chunk 排序方式，可选值 'none' | 'auto' | 'dependency' |'manual' | &#123;function&#125; excludeChunks: [],// 避免引用某些 chunk xhtml: false&#125;) UglifyjsWebpackPluginuglifyjs-webpack-plugin 插件，压缩 js 脚本。 123456789101112131415161718192021new UglifyJSPlugin(&#123; test,// 定位资源 include, exclude, parallel: false,// 使用多进程并行运行和文件缓存来提高构建速度，如 &#123; cache: true, workers: 2 &#125;，parallel.workers 为 cpu 核数 sourceMap: false,// 生成 source map，会减慢编译的速度。cheap-source-map 选项不适用于此插件 uglifyOptions: &#123;// 压缩选项，供 uglifyJs 使用 ie8: false,// 支持 ie8 ecma: 8,// es 语法版本号，可选项 5, 6, 7, 8，影响 parse, compress, output 选项 parse: &#123;&#125;,// parse 选项 mangle: &#123;&#125;,// 名称矫正??? output: &#123;// 默认最佳压缩 comments: false, beautify: false &#125;, compress: &#123;&#125;,// parse 选项 warnings: false &#125;, extractComments: true,// 函数，提取注释 warningsFilter: undefined// 过滤警告，如 source =&gt; Boolean&#125;) ExtractTextWebpackPluginextract-text-webpack-plugin 插件，提取 css 文件。 ExtractTextPlugin.extract 在已经存在的 loader 中，创建一个提取 css 的 loader。 12345678910111213141516171819202122232425262728293031323334353637383940414243new ExtractTextWebpackPlugin(filename | &#123; id: string,// 此插件实例的唯一 ident（仅限高级用途，默认情况下自动生成） filename: string,// 生成文件的文件名，占位符包含 [name], [id], [contenthash]。ExtractTextPlugin 对 每个入口 chunk 都生成一个对应的文件 allChunks: false,// 默认情况下，从入口 chunk 提取 css。当使用 CommonsChunkPlugin，且使用 ExtractTextPlugin.extract 在公共 chunk 中有提取 css 时，allChunks 须置为真 disable: false,// 禁用插件 ignoreOrder: false,// 禁用检查 threshold: 0,// 大于该值的文件将被压缩 minRatio: 0.8,// 压缩比大于该值的将被压缩 deleteOriginalAssets: false// 是否删除原始资源&#125;)// ExtractTextPlugin.extractExtractTextPlugin.extract(&#123; loader: '[name]-loader', options: &#123; use: ['css-loader', 'sass-loader'],// 提取 css 文件，使用这些 loader 获得 css 模块 fallback: 'style-loader',// css 模块已取得，尚未提取前应用 publicPath: // 重写此 loader 的 publicPath 配置 &#125;&#125;)// 或者const ExtractTextPlugin = require('extract-text-webpack-plugin');const extractCSS = new ExtractTextPlugin('stylesheets/[name]-one.css');const extractLESS = new ExtractTextPlugin('stylesheets/[name]-two.css');module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: extractCSS.extract([ 'css-loader', 'postcss-loader' ]) &#125;, &#123; test: /\\.less$/i, use: extractLESS.extract([ 'css-loader', 'less-loader' ]) &#125;, ] &#125;, plugins: [ extractCSS, extractLESS ]&#125;; NpmInstallWebpackPluginnpm-install-webpack-plugin 插件，加载缺失的依赖。 123456new NpmInstallPlugin(&#123; dev: false,// 使用 --save 或者 --save-dev peerDependencies: true,// 安装缺少的 peerDependencies quiet: false,// 减少控制台日志记录的数量 npm: 'tnpm'// 包加载方式，默认 'npm'&#125;) I18nWebpackPlugini18n-webpack-plugin 插件，国际化??? 12345new I18nWebpackPlugin(&#123; functionName: '__',// 函数名 failOnMissing: false,// 找不到映射文件时给予警告 hideMessage: false// 隐藏警告/错误信息&#125;) BabiliWebpackPluginbabili-webpack-plugin 插件，使用 babel-minify 根据浏览器是否支持 es5 最新特性，优化压缩代码。也可以在 babel-loader 配置中使用 babel-preset-minify 。比起 babel-loader 配置，babili-webpack-plugin 插件能优化全文件，包含不通过 babel-loader 加载的文件，即 node_modules 下的文件，以及由 webpack 生成的文件。 1234567891011121314new BabiliPlugin( babiliOptions = &#123; plugins:[], presets:[] &#125;, overrides = &#123; test: /\\.js($|\\?)/i,// 待包含的文件 comments: /@preserve|@licen(s|c)e/,// 置为 false，将移除注释 sourceMap: webpackConfig.devtool, parserOpts: &#123;&#125;, babel: require(\"babel-core\"),// 用于替代 babel-core babili: require('babel-preset-minify') &#125;) CompressionWebpackPlugincompression-webpack-plugin 插件，压缩静态资源。 123456789101112new CompressionWebpackPlugin(&#123; test: '.', include: undefined, exclude: undefined, cache: false,// 开启文件缓存 asset: [path].gz[query],// 目标资源名称。[file] 会被替换成原始资源，[path] 会被替换成原始资源的路径，[query] 会被替换成查询字符串 filename: false,// 函数，如 (asset) =&gt; asset algorithm: 'gzip',// 压缩算法或算法名，如 (buffer, cb) =&gt; cb(buffer) threshold: 0,// 大于该值的文件将被压缩 minRatio: 0.8,// 压缩比大于该值的将被压缩 deleteOriginalAssets: false// 是否删除原始资源&#125;) ZopfliWebpackPluginzopfli-webpack-plugin 插件，压缩资源。 12345678new ZopfliWebpackPlugin(&#123; asset: [path].gz[query],// 目标资源名称。[file] 会被替换成原始资源，[path] 会被替换成原始资源的路径，[query] 会被替换成查询字符串 filename: false,// 函数，如 (asset) =&gt; asset algorithm: 'gzip',// 压缩算法或算法名，如 (buffer, cb) =&gt; cb(buffer) threshold: 0,// 大于该值的文件将被压缩 minRatio: 0.8,// 压缩比大于该值的将被压缩 deleteOriginalAssets: false// 是否删除原始资源&#125;) ComponentWebpackPlugin不详。。。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"webpack","slug":"frontend/webpack","permalink":"http://xzfyu.com/categories/frontend/webpack/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"webpack加载器指南","slug":"frontend/工程化/webpack/webpack加载器指南","date":"2018-02-03T16:00:00.000Z","updated":"2020-03-08T10:54:17.160Z","comments":true,"path":"2018/02/04/frontend/工程化/webpack/webpack加载器指南/","link":"","permalink":"http://xzfyu.com/2018/02/04/frontend/工程化/webpack/webpack加载器指南/","excerpt":"","text":"加载器在 webpack 编译前预处理文件，链式调用多个加载器。 babel-loaderbabel-loader将 es6 降级为 es5。 参考文档： Babel是如何编译JS代码的及理解抽象语法树(AST) options 选项参考文档： babel options。 123456789101112131415161718192021222324252627282930313233343536// 默认配置&#123; plugins:[],// 需要加载和使用的插件列表 presets: [],// 需要加载和使用的 presets (一组插件) 列表 generatorOpts: &#123;&#125;,// 包含要传递给 babel 代码生成器(babel-generator)的选项对象 parserOpts:&#123;&#125;,// 需要传递给 babel 解析器，babylon 的选项对象 only: null,// 待编译的文件，正则，字符串或数组形式 ignore: null,// 无需编译的文件 minified: false,// 保证输出最小化(不输出代码块最后一个分号，输出文字为字符串而不是转义字符串，安全情况下 new 后的 () 会被去除) babelrc: true,// 指定是否使用 .babelrc 和 babelignore 配置文件，命令行使用 --no-babelrc 代替 extends: null,// 扩展 .babelrc 文件的路径 sourceType: \"module\",// 设置 babel 解析代码的模式。可以设置为 “script” 或 “module” sourceRoot: (moduleRoot),// 所有 source 都是相对于 root 的 retainLines: false,// 保留行号。这将导致代码变得很古怪，适用于不能使用 source map 的场景 sourceMaps: false,// 如果为 true ，添加一个 map 属性在输出的返回值中。如果设置为 \"inline\" ，带有 sourceMappingURL 指令的注释被添加到返回代码的底部。如果设置为 \"both\" ，则会返回 map 属性并追加 source map 注释。命令行使用 --source-maps sourceMapTarget: (filenameRelative),// 在返回 souremap 时设置 file inputSourceMap: null,// 输出的 source map 将基于该 source map 对象 sourceFileName: (filenameRelative),// 在返回的 source map 上设置 sources[0] auxiliaryCommentAfter: null,// 在所有非用户编写代码后添加注释 auxiliaryCommentBefore: null,// 在所有非用户编写代码前添加注释 commets: true,// 是否在生成的代码中添加注释 shouldPrintComment: null,// 是否需要输出注释。具体调用为 shouldPrintComment(commentContents)。将覆盖 commets 选项 compact: 'auto',// 是否包含多余的空格符和换行符，当输入大于 500KB 时，compact 属性自动设置为真值 ast: true// 是否在返回对象包含 ast 抽象语法树 abstract syntax tree code: true,// 是否启用代码生成选项 env: &#123;&#125;,// 配置给不同环境的选项。环境配置的优先级依次为 BABEL_ENV, NODE_ENV，默认'development'环境。env 配置如 &#123; env: &#123; 'product': /* options */ &#125; &#125; filename: 'unknown',// 在错误信息是使用的文件名等 filenameRelative: (filename),// 相对于 sourceRoot 的文件名 moduleId: null,// 指定模块 ID 的自定义名称 moduleIds: false,// 是否为模块指定明确的 ID。默认情况下，所有模块都是匿名的(不适用于 common 模块) moduleRoot: (sourceRoot),// AMD 模块格式化程序的可选前缀，可以被预先添加到模块定义的文件名当中 getModuleId: null,// 指定回调函数 getModuleId(moduleName) 生成模块 ID。返回false，意味模块 ID 已被使用 highlightCode: true,// ANSI 错误语法高亮显示 resolveModuleSource: null,// 解析模块入口，例如 import \"SOURCE\"; 引入自定义值。具体调用为 resolveModuleSource(source, filename) wrapPluginVisitorMethod: null,// 可用于包装访问者模式的可选回调。注意: 这对于自我检查这样的事是有必要的，并且不需要实现任何方法。具体调用为 wrapPluginVisitorMethod(pluginAlias, visitorType, callback)&#125; plugins presets 插件参考文档： babel plugins。 plugins 为编译时调用的插件，presets 为官方封装的插件集合。编译时，plugin 运行在 preset 前，plugin 顺序执行，preset 反序执行。配置时，’babel-plugin-‘, ‘babel-preset-‘ 前缀可以忽略，babel 将自动拼接，并在 node_modules 目录中查找。当 babel 插件不在工程目录中时，可以通过插件的绝对路径加以配置，如 “plugins”: [“./node_modules/asdf/plugin”]。插件选项配置通过将插件名称和选项对象放置在同一个数组中实现。 1234567891011121314151617181920212223242526// 执行顺序为 \"transform-decorators-legacy\", \"transform-class-properties\"&#123; \"plugins\": [ \"transform-decorators-legacy\", \"transform-class-properties\" ]&#125;// 执行顺序为 \"stage-2\", \"react\", \"es2015\"&#123; \"presets\": [ \"es2015\", \"react\", \"stage-2\" ]&#125;// 配置选项&#123; \"plugins\": [ [\"transform-async-to-module-method\", &#123; \"module\": \"bluebird\", \"method\": \"coroutine\" &#125;] ]&#125; presets 官方插件集合12345678910111213141516171819202122232425262728293031323334353637383940[ // env 包含es2015, es2016, es2017 及最新版本 // 参考文档：[](https://babeljs.cn/docs/plugins/preset-env/) [\"babel-preset-env\",&#123; \"targets\": &#123;&#125;,// 设定适配环境，如 &#123; node: \"6.10\" &#125;。支持的环境有 browsers, chrome, opera, edge, firefox, safari, ie, ios, android, node, electron。浏览器端清单 https://github.com/ai/browserslist，如 &#123; \"chrome\": 52, \"browsers\": [\"last 2 versions\", \"safari 7\"] &#125;。uglify 属性设置为 true，uglify-js 压缩脚本时已编译为 es5 语法 \"spec\": false,// 是否允许插件启用 \"spec\" 转换，更符合规范，编译较慢 \"loose\": false,// 是否允许插件启用 \"loose\" 转换 \"modules\": \"commonjs\",// 将es6模块语法转换为另一个模块类型。可选值为 \"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | false。false 将不会转换任何模块 \"include\": [],// 包含的插件。include 与 exclude 选项仅仅适用于 preset 中包含的插件。可配置为 [\"transform-es2015-arrow-functions\", \"es6.map\"]。\"es6.map\" 为 [Built-ins](https://github.com/babel/babel-preset-env/blob/master/data/built-in-features.js) \"exclude\": [],// 移除的插件 \"useBuiltIns\": false// 是否在 env 中引入 babel-ployfill，以避免在模块中调用 import \"babel-polyfill\"。npm &gt; 3，babel 6 &#125;], [\"babel-preset-es2015\",&#123; \"loose\": false, \"spec\": false, \"modules\": \"commonjs\" &#125;], [\"babel-preset-es2016\",&#123; &#125;], [\"babel-preset-es2017\",&#123; &#125;], [\"babel-preset-react\",&#123; &#125;], [\"babel-preset-flow\",&#123; &#125;], // stage 3 候选：完成规范和浏览器初步实现。Stage 4 将到下一年度发行 [\"babel-preset-stage-3\",&#123; &#125;], // stage 2 初稿: 完成初步规范。包含 preset-stage-3 所有插件 [\"babel-preset-stage-2\",&#123; &#125;], // stage 1 提案: 初步尝试。包含 preset-stage-2, preset-stage-3 所有插件 [\"babel-preset-stage-1\",&#123; &#125;], // stage 0 稻草人: 只是一个想法。包含 preset-stage-1, preset-stage-2, preset-stage-3 所有插件 [\"babel-preset-stage-0\",&#123; &#125;],] plugin 插件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180[ // es3 [\"babel-plugin-transform-es3-property-literals\",&#123; &#125;],// 定义对象属性时包裹上双引号 [\"babel-plugin-transform-es3-member-expression-literals\",&#123; &#125;],// 使用对象属性时包裹上双引号 // es5 [\"abel-plugin-transform-es5-property-mutators\",&#123; &#125;],// 对象访问器属性 get, set 方法 // es2015 [\"check-es2015-constants\",&#123; &#125;],// 常量只读检查 [\"transform-es2015-block-scoped-functions\",&#123; &#125;],// 在块中声明的函数只在块中可用 [\"transform-es2015-block-scoping\",&#123;// let 块级作用域 \"throwIfClosureRequired\": false// for() 语句中定义的 let 在 &#123;&#125; 中使用，是否直接报错 &#125;], [\"transform-es2015-arrow-functions\",&#123; \"spec\": false &#125;],// 箭头函数转换 [\"transform-es2015-classes\",&#123;// 类转换 \"loose\": false// loose 模式下，原型方法可枚举，且不能在子类中重复定义 &#125;], [\"transform-es2015-computed-properties\",&#123; &#125;],// 对象计算属性转换，如 [x + 'foo'] 属性 [\"transform-es2015-destructuring\",&#123; &#125;],// 解构 [\"transform-es2015-duplicate-keys\",&#123; &#125;],// 将同名属性转换为计算属性，再由 transform-es2015-computed-properties 插件处理 [\"transform-es2015-for-of\",&#123; &#125;],// for of 语法 [\"transform-es2015-function-name\",&#123; &#125;],// function.name [\"transform-es2015-literals\",&#123; &#125;],// 二进制、八进制整数，unicode 字面量 [\"transform-es2015-modules-commonjs\",&#123; &#125;],// 转换成 commonjs 模块。使用 babel-plugin-add-module-exports 插件，避免使用 require(\"your-module\").default 调用模块，可直接使用 require(\"your-module\") [\"transform-es2015-object-super\",&#123; &#125;],// super 父类转换??? [\"transform-es2015-parameters\",&#123; &#125;],// 解构函数参数，设置默认值，...arr支持。默认使用 let 处理参数，需要配合使用 transform-es2015-block-scoping 插件 [\"transform-es2015-shorthand-properties\",&#123; &#125;],// 允许 &#123; a &#125; 方式赋值对象，转换为 &#123; a: a &#125; [\"transform-es2015-spread\",&#123;// ...a \"loose\": false &#125;], [\"transform-es2015-sticky-regex\",&#123; &#125;],// 正则表达式转换为正则构造函数形式 [\"transform-es2015-template-literals\",&#123; \"loose\": false,// 设置为true时，模板字符串对象不会被 frozen \"spec\": false// 是否用 String 函数包裹模板字符串内变量 &#125;],// 模板字符串 [\"transform-es2015-typeof-symbol\",&#123; &#125;],// typeof Symbol() === \"symbol\" 语法支持 [\"transform-es2015-unicode-regex\",&#123; &#125;],// unicode 正则??? [\"transform-regenerator\",&#123;// 生成器函数，页面需要引入 babel-ployfill 或 regenerator-runtime 运行时脚本。使用 async 函数，需要添加 syntax-async-functions 插件 \"asyncGenerators\": true, \"generators\": true, \"async\": true &#125;], // es2016 [\"transform-exponentiation-operator\",&#123; &#125;],// ** 求幂 // es2017 [\"syntax-trailing-function-commas\",&#123; &#125;],// 函数参数后加','，添加参数时只有一行改变，方便git diff [\"transform-async-to-generator\",&#123; &#125;],// 将 acync 函数转化为生成器函数 // react 包含 preset-flow, babel-plugin-syntax-jsx, babel-plugin-transform-react-jsx, babel-plugin-transform-react-display-name // preset-flow 包含 transform-flow-strip-types 插件，其余均为插件 [\"transform-flow-strip-types\",&#123; &#125;],// 移除 flow 类型，但不作类型校验，类型校验需要使用 flow 或另外的插件。如 function foo(one: any, two: number, three?): string &#123;&#125; 将转换为 function foo(one, two, three) &#123;&#125; [\"babel-plugin-syntax-jsx\",&#123; &#125;],// 解析 JSX [\"babel-plugin-transform-react-jsx\",&#123; &#125;],// 将 JSX 转换为 react 函数 [\"babel-plugin-transform-react-display-name\",&#123; &#125;],// 调用 React.createClass 或 createReactClass 函数时自动添加 displayName，如 var bar = createReactClass(&#123;&#125;) 将转换为 var bar = createReactClass(&#123; displayName: \"bar\" &#125;) // flow [\"transform-flow-strip-types\",&#123; &#125;],// react preset 包含 // stage 3 [\"transform-object-rest-spread\",&#123; &#125;],// ...a 语法支持 [\"transform-async-generator-functions\",&#123; &#125;],// async 函数转换为生成器函数 // stage 2 [\"syntax-dynamic-import\",&#123; &#125;],// import() 支持变量 [\"transform-class-properties\",&#123; &#125;],// 类静态属性，实例属性、方法等 // stage 1 [\"transform-class-constructor-call\",&#123; &#125;],// 类作为普通函数使用 [\"transform-export-extensions\",&#123; &#125;],// export * as ns from 'mod'; export v from 'mod'; 语法支持 // stage 0 [\"transform-do-expressions\",&#123; &#125;],// do &#123;&#125; 语法支持，构造块级作用域，最终执行语句作为返回值 [\"transform-function-bind\",&#123; &#125;],// obj::func 转换为 func.bind(obj)；::obj.func 转换为 obj.func.bind(obj)；obj::func(val) 转换为 func.call(obj, val)；::obj.func(val) 转换为 obj.func.call(obj, val) // 模块 [\"es2015-modules-amd\",&#123; &#125;],// 将模块导出为 amd 模块 [\"es2015-modules-commonjs\",&#123;// 将模块导出为 commonjs 模块 \"loose\": false,// loose 模式下，import, export 可在全局使用；非 loose 模式下，只能在外层使用。非 loose 模式下，通过 defineProperty 语句注入不可枚举的 __esModule 属性；loose 模式下，通过赋值注入 __esModule 属性 \"strict\": false,// strict 属性置为真，将阻止导出 __esModule 属性 \"noInterop\": false// 加载模块时，是否不使用 function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;，适用于不需要 default 属性的场景 &#125;], [\"es2015-modules-systemjs\",&#123;// 将模块导出为 SystemJS 模块 \"systemGlobal\": \"SystemJS\" &#125;], [\"es2015-modules-umd\",&#123;// 依据 define, exports 变量有无，分别导出 amd, commonjs 等模块 \"globals\": &#123;&#125;,// 用于设置导出变量名，如 \"globals\": &#123; \"es6-promise\": \"Promise\" &#125; \"exactGlobals\": true// 规范化注入的全局变量??? &#125;], // 实验阶段 [\"async-generator-functions\",&#123; &#125;],// stage 3 包含 [\"transform-async-to-module-method\",&#123; &#125;],// 将 async 函数转换为 Bluebird coroutine [\"class-properties\",&#123; &#125;],// stage 2 包含 [\"transform-decorators-legacy\",&#123; &#125;],// 装饰器，babel 7 包含在 stage 0 中。平常开发时，需要通过 plugins 配置注入 [\"do-expressions\",&#123; &#125;],// stage 0 包含 [\"export-extensions\",&#123; &#125;],// stage 1 包含 [\"function-bind\",&#123; &#125;],// stage 0 包含 [\"object-rest-spread\",&#123; &#125;],// stage 3 包含 // Minification [\"transform-inline-environment-variables\",&#123;// 将环境变量以字符串形式注入模块 \"include\": [],// 注入的环境变量，如 \"include\": [ \"NODE_ENV\" ] \"exclude\": []// 移除的环境变量 &#125;], [\"transform-inline-consecutive-adds\",&#123; &#125;],// 将对象属性的赋值和数组 push 方法调用过程移入声明中，前提赋值和 push 紧跟在声明后 [\"member-expression-literals\",&#123;&#125;],// 对象属性名含关键字，以计算属性 [''] 表示；不含，采用 . 分割形式 [\"transform-minify-booleans\",&#123;&#125;],// 以 !0 代替 true，!1 代替 false [\"minify-dead-code-elimination\",&#123;// 精简无用代码 \"keepFnName\": true,// 防止插件删除函数名 \"keepFnArgs\": true,// 防止插件删除函数参数 \"keepClassName\": true,// 防止插件删除类名 &#125;], [\"minify-flip-comparisons\",&#123;&#125;],// 精简翻转输出，基于重复的内容进行压缩算法优化，例如 gzip。bar !== null 转换为 null !== bar [\"minify-guarded-expressions\",&#123;&#125;],// 精简守护表达式，针对 &amp;&amp;, ||，0 &amp;&amp; new Foo() 转换为 0 [\"minify-infinity\",&#123;&#125;],// 精简无穷大，Infinity 转换为 1/0 [\"minify-mangle-names\",&#123;&#125;],// 根据作用域精简一次性使用的变量名 [\"minify-numeric-literals\",&#123;&#125;],// 通过科学计数法精简数值字面量 [\"minify-replace\",&#123;// 用给定节点替换变量 \"identifierName\": null,// 待替换的变量名，如 __DEV__ \"replacement\": &#123;&#125;// 替换规则，如 &#123; type: \"numericLiteral\", value: 0, &#125;，效果是将 __DEV__ 转换为 0 &#125;], [\"minify-simplify\",&#123;&#125;],// 简化，if (x) a(); 将转换为 x &amp;&amp; a()，Number(foo) 将转换为 +foo [\"minify-type-constructors\",&#123;// 将构造函数转化为字面量，不推荐在 IE8 中使用 \"array\": true,// 是否启用 Array 构造函数 \"boolean\": true,// 是否启用 Boolean 构造函数 \"number\": true,// 是否启用 Number 构造函数 \"object\": true,// 是否启用 Object 构造函数 \"string\": true// 是否启用 String 构造函数 &#125;], [\"transform-node-env-inline\",&#123;&#125;],// 将 process.env.NODE_ENV === \"development\"; 转换为 true | false [\"transform-property-literals\",&#123;&#125;],// 对非关键字属性取出双引号 [\"transform-regexp-constructors\",&#123;&#125;],// 正则构造函数转换为正则表达式 [\"transform-remove-console\",&#123;&#125;],// 移除console [\"transform-remove-debugger\",&#123;&#125;],// 移除debugger [\"simplify-comparison-operators\",&#123;&#125;],// 当比较类型相同时，将 ===, !== 转换为 ==, != [\"transform-undefined-to-void\",&#123;&#125;],// 将 undefined 转换为 void 0 // react [\"transform-react-constant-elements\",&#123;&#125;],// 将常量元素(作为返回值)提取到最外层，如 const Hr = () =&gt; &#123; return &lt;hr className=\"hr\" /&gt;; &#125;; 将转换为 const _ref = &lt;hr className=\"hr\" /&gt;; const Hr = () =&gt; &#123; return _ref; &#125;; 若元素包含 ...props 或 ref 属性，将不予转换 [\"transform-react-display-name\",&#123;&#125;],// react preset 包含 [\"transform-react-inline-elements\",&#123;&#125;],// 将 React.createElement 转换为 babelHelpers.jsx，如 &lt;Baz foo=\"bar\" key=\"1\"&gt;&lt;/Baz&gt;; 将转换为 babelHelpers.jsx(Baz, &#123; foo: \"bar\" &#125;, \"1\"); 若元素包含 ...props 或 ref 属性，将不予转换 [\"transform-react-jsx\",&#123;&#125;],// react preset 包含 [\"transform-react-jsx-compat\",&#123;&#125;],// 将 JSX 转换为 React Pre-0.12 函数，如 var profile = &lt;div&gt;&lt;img src=\"avatar.png\" class=\"profile\" /&gt;&lt;/div&gt;; 将转换为 var profile = React.DOM.div(null, React.DOM.img(&#123; src: \"avatar.png\", \"class\": \"profile\" &#125;) ); [\"transform-react-jsx-self\",&#123;&#125;],// JSX 元素中添加 __self 属性为 this，以便于 react 运行时报错 [\"transform-react-jsx-source\",&#123;&#125;],// JSX 元素中添加 __source 属性为 &#123; fileName: 'this/file.js', lineNumber: 10 &#125; 等，以便于 react 运行时报错 // 其他 [\"transform-eval\",&#123;&#125;],// eval(\"(() =&gt; 'foo')\"); 将转换为 eval(\"(function () &#123; return 'foo'; &#125;)\"); [\"transform-flow-comments\",&#123;&#125;],// 将 flow 类型说明转换为注释??? [\"transform-flow-strip-types\",&#123;&#125;],// react, flow preset 包含 [\"transform-jscript\",&#123;&#125;],// 将函数表达式通过自调用匿名函数赋值 [\"transform-object-assign\",&#123;&#125;],// 将 Object.assign 函数转换为 ... 语句，不适用于 const &#123; assign &#125; = Object场景 [\"transform-object-set-prototype-of-to-assign\",&#123;&#125;],// 将 Object.setPrototypeOf 转换为 ... 语句 [\"transform-proto-to-assign\",&#123;&#125;],// 对象 __proto__ 赋值转换为 ... 语句 [\"transform-regenerator\",&#123;&#125;],// es2015 包含 [\"transform-runtime\",&#123;// 无需通过污染全局对象调用最新的 api，模块需要注入 babel-runtime。参考文档：[tranform-runtime](https://babeljs.cn/docs/plugins/transform-runtime/) \"helpers\": true,// 是否内置 classCallCheck, extends 等。模块为 babel-runtime/helpers \"polyfill\": true,// 是否内置 Promise, Set, Map, Symbol 等。模块为 babel-runtime/core-js \"regenerator\": true,// 是否内置生成器函数，async 函数。模块为 babel-runtime/regenerator \"moduleName\": \"babel-runtime\"// 改变模块名，import 相应作改变 &#125;],// JSX 元素中添加 __self 属性为 this，以便于 react 运行时报错 [\"transform-strict-mode\",&#123;&#125;],// 转换为严格模式 [\"external-helpers\",&#123;&#125;],// 将 babel 中的 helpers 通过 babel-cli 导出为独立文件，然后在页面直接加载 // ant-design [\"babel-plugin-import\",&#123; \"libraryName\": \"antd\", \"style\": true &#125;], [\"babel-plugin-import\",&#123; \"libraryName\": \"antd-mobile\", \"style\": \"css\" &#125;],] awesome-typescript-loader编译 typescript。 1234567891011121314151617181920212223242526&#123; module: &#123; rules: [&#123; test: /\\.tsx?$/, loader: 'awesome-typescript-loader', options: &#123; silent: false,// 是否打印日志 compiler: 'typescript',// 选择编译器 useTranspileModule: false,// 启用 transpileModule 模式??? instance: 'at-loader',// 使用多个编译器??? configFileName: 'tsconfig.json',// 配置文件名 transpileOnly: false,// 置为真，跳过类型校验 errorsAsWarnings: false,// 以警告方式对待错误 forceIsolatedModules: false,// 模块不能包含依赖 ignoreDiagnostics: [],// 跳过错误，如 [8014] 将跳过 stage-1 错误 useBabel: false,// 使用 babel-loader babelOptions: &#123;&#125;,// 配置 babel-loader 选项 babelCore: undefined,// @babel/core 路径。@babel/core 不在 node_modules 中需要配置；babel 7 需要配置为 \"@babel/core\" useCache: false,// 使用缓存，提升速度，供 babel-loader 使用 usePrecompiledFiles: false,// 启用预编译文件 cacheDirectory: '.awcache',// 缓存目录 reportFiles: []// 诊断报道???，如 [ \"src/**/*.&#123;ts,tsx&#125;\" ] &#125; &#125;] &#125;&#125; vue-loader编译 vue 组件。 123456789101112131415161718192021222324252627&#123; module: &#123; rules: [&#123; test: /\\.vue?$/, loader: 'awesome-typescript-loader', options: &#123; loaders: &#123;// 组件各部分加载器 js: 'babel-loader!eslint-loader', template: 'html-loader', css: 'style-loader!css-loader!less-loader' &#125;, preLoaders: &#123;&#125;,// 在 loaders 之前处理 postLoaders: &#123;&#125;, postcss: [],// 指定要应用于 .vue 文件中 CSS 的自定义 PostCSS 插件。在 11.0.0+ 版本中，推荐使用 PostCSS 配置文件代替。也可使用对象配置，如 &#123; plugins: [...], options: &#123; parser: 'sugarss' &#125;, config: &#123; path: path.resolve('./src') &#125;, useConfigFile: false &#125;，config.path 指定加载 PostCSS 配置文件的路径或目录，config.ctx 指定为 PostCSS 插件提供的上下文，useConfigFile 是否禁用配置文件 cssSourceMap: false,// 是否开启 CSS 的 source maps，关闭可提升编译速度，避免 css-loader 的 some relative path related bugs。webpack 配置中没有 devtool 的情况下自动设置为 false esModule: false,// 是否导出兼容 esModule 的代码。默认导出 commonjs 格式，像 module.exports = ....。esModule 为真时，导出 exports.__esModule = true; exports = ...，适用于与 Babel 以外的 transpiler 互操作，比如 TypeScript preserveWhitespace: true,// 置为否值，模版中 HTML 标签之间的空格将会被忽略 compilerModules: [],// 为 vue-template-compiler 配置 modules 选项 compilerDirectives: [],// 为 vue-template-compiler 配置 directives 选项 transformToRequire: &#123; img: 'src', image: 'xlink:href' &#125;,// 在模版编译过程中，编译器可以将某些属性，如 src 路径，转换为 require 调用。供 html-loader 使用 buble: &#123;&#125;,// 配置 buble-loader 的选项 (如果存在)，并且 buble 编译传递模板渲染函数??? extractCSS: true,// 使用 extract-text-webpack-plugin 自动提取 CSS。值可以为真，或 ExtractTextPlugin 插件的一个实例 optimizeSSR: false// 渲染函数将会把返回的 vdom 树的一部分编译为字符串，适用于服务器端渲染 &#125; &#125;] &#125;&#125; style-loader配合 css-loader 一起使用。style-loader 用于将样式以 style 标签注入到页面中，同时 import 时将生成类名的 hash 值(标识符)对象；style-loader/url 模块将以 link 注入到页面中。style-loader/useable 模块将延迟注入页面，直到 import style from ‘./file.css’; style.use();// =style.ref() 中 use, ref 方法被调用时，才注入到页面中。当调用unuse, unref 方法时，将从页面上删除。 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\", options: &#123; base: true,// 设置模块 ID 基础，生成 ID 大于该值。当使用 DllPlugin 编译 css 时，用于避免多个编译结果的 ID 冲突，实现是 多个编译配置设置不同的 ID 范围值 attrs: &#123;&#125;,// 添加自定义属性到注入页面的 style, link 标签中 transform: false,// 转换/条件加载 CSS，通过传递转换/条件函数。用于载入页面前修改 css，函数返回 false 将不会加载 css 。配置如 css =&gt; css.replace('.classNameA', '.classNameB')。transform 也可配置为脚本的路径 insertAt: \"bottom\",// 在给定位置插入 style 节点，可选值 \"bottom\", \"top\" insertInto: \"&lt;head&gt;\",// 在给定标签处插入 style 节点，值可以是 css 选择器，或 ShadowRoot??? singleton: true,// 重用 style 标签插入 css 脚本，否则每个样式文件插入一个 style 标签 sourceMap: false,// 是否启用 SourceMap，css 脚本将生成 Blob，相对路径将无法正常工作。解决方法是设置 publicPath 属性或将 convertToAbsoluteUrls 置为真??? convertToAbsoluteUrls: false// 启用 SourceMap 后，将相对 url 转换为绝对 url &#125; &#125;, &#123; loader: \"css-loader\" &#125;, ], &#125;, &#123; test: /\\.url\\.css$/, use: [ &#123; loader: \"style-loader/url\" &#125;, &#123; loader: \"css-loader\" &#125;, ], &#125;, &#123; test: /\\.useable\\.css$/, use: [ &#123; loader: \"style-loader/useable\" &#125;, &#123; loader: \"css-loader\" &#125;, ], &#125;, ], &#125;,&#125; css-loader用于解析 css 脚本中的 @import, url() 语句，附加的资源文件调用 import, require 加载并解析。import, url() 语句解析时，根据 webpack 配置将调用对应的 file-loader, url-loader 加载器。因此 css-loader 基于 file-loader, url-loader 加载器。 可以直接将 css-loader 的结果作为字符串使用，例如 Angular 的组件样式???。如果有 SourceMap，它们也将包含在字符串结果中。 对使用 extract-text-webpack-plugin 预渲染的场景，应使用 css-loader/locals，而不是 style-loader!css-loader。它不会嵌入 CSS，但只导出标识符映射；由 extract-text-webpack-plugin 提取 css 后，再通过 link 标签嵌入页面。 12345678910111213141516171819202122232425262728293031323334353637383940// 'css-loader' 导入资源转化为字符串，由开发者在页面中添加 link 标签后使用&#123; test: /\\.css$/, use: [ 'to-string-loader', 'css-loader' ]&#125;// 或const css = require('./test.css').toString();// 或&#123; test: /\\.css$/, use: [ 'file-loader?name=[name].[ext]' 'handlebars-loader', // handlebars loader expects raw resource string 'extract-loader',// 将 html, css 提取为纯粹的字符串，通过 handlebars 处理，由 file 注入页面 &#123; loader: 'css-loader', options: &#123; root: \"/\",// 以 / 开头的 URL 默认不会被转译，设置 root 为 \".\"，将 /image.png 转换为 ./image.png url: true,// 是否编译 css 文件中 url() 语句 alias: &#123;&#125;,// 别名，便于 import 导入 import: true,// 是否编译 css 文件中 @import 语句 modules: false,// 是否启用 css-modules minimize: false,// 是否启用压缩，压缩通过 cssnano 实现。[cssnano 文档](http://cssnano.co/guides/) sourceMap: false,// 是否启用SourceMap camelCase: false,// 以驼峰化式类名导出类名。可选值有 true 类名将被驼峰化，'dashes' 只有破折号被驼峰化，'only' 类名将被驼峰化，初始类名从映射中移除，'dashesOnly' 只有破折号被驼峰化，初始类名从映射中移除 importLoaders: 0,// 在 css-loader 前应用的加载器数量。css-loader 前有 postcss-loader 时，设置为 1；css-loader 前有 postcss-loader, sass-loader，设置为 2 localIdentName: [hash:base64],// 配置生成的标识符，import style from 'a.css' 加载时，作为style 属性的值，如 '[path][name]__[local]--[hash:base64:5]' getLocalIdent: false,// 指定生成标识符的函数，如 (context, localIdentName, localName, options) =&gt; &#123; return 'whatever_random_class_name' &#125; &#125; &#125; ]&#125;// 或const css = require('./test.css').toString(); css-modules启用启用 css-modules 时，会产生局部作用域 CSS，使用 :global(…) 或 :global 设置为全局作用域，类名将不会转换为标识符；使用 :local(…) 或 :locale 设置为局部，类名将转换为标识符。局部作用域的类名建议使用驼峰式书写。 样式属性中可使用 composes 属性，用于向一个类注入另一个类(该类可以是另一个 css 文件中的类)的样式。一个类下，composes 属性可设置多个。 1234567891011121314// :local 为局部作用域，类名将转换为标识符，import 加载时生成映射形式；:global为全局作用域，类名保持不变:local(.className) &#123; composes: edit hightlight from './edit.css'; composes: button from 'module/button.css'; composes: classFromThisModule; background: red;&#125;:local(.subClass) &#123; composes: className; background: blue;&#125;:local .className .subClass :global(.global-class-name) &#123; color: blue; &#125; postcss-loader对 css 文件自动拼接浏览器兼容性前缀等。参考文档：https://github.com/postcss/postcss-loader。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; module: &#123; rules: [&#123; test: /\\.style.js$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; parser: undefined,// 设置 PostCSS 解析器，可选值 'sugarss'，可配置为函数 syntax: undefined,// 设置 PostCSS 语法解析器，可选值 'sugarss'，可配置为函数 stringifier: undefined,// 设置 PostCSS 字符串化，可选值 'midas'，可配置为函数 exec: true,// 将 css-in-js 编译为 css config: &#123; path: undefined,// postcss.config.js 文件路径，默认自动从 css 文件目录向上查找 ctx: &#123;// postcss 配置的上下文，传入 postcss.config.js env: 'development',// process.env.NODE_ENV file: loader.resourcePath,// 包含 extname扩展名, dirname目录名, basename文件名 options: &#123;&#125;// 选项 ...// 其余参数 &#125; &#125;, plugins: [],// 可配置为函数形式，如(loader) =&gt; [ require('postcss-import')(&#123; root: loader.resourcePath &#125;), require('postcss-cssnext')(), require('autoprefixer')(), require('cssnano')() ] sourceMap: false// 是否启用 SourceMap，可选值 true, \"inline\" &#125; &#125; ] &#125;,&#123; &#125;] &#125;&#125;// postcss.config.js 依旧生成 postcss-loader 选项module.exports = (&#123; file, options, env &#125;) =&gt; (&#123; parser: file.extname === '.sss' ? 'sugarss' : false, plugins: &#123; 'postcss-import': &#123; root: file.dirname &#125;, 'postcss-cssnext': options.cssnext ? options.cssnext : false, 'autoprefixer': env == 'production' ? options.autoprefixer : false, 'cssnano': env === 'production' ? options.cssnano : false &#125;&#125;)// style.jsimport colors from './styles/colors'export default &#123; '.menu': &#123; color: colors.main, height: 25, '&amp;_link': &#123; color: 'white' &#125; &#125;&#125; less-loader将 less 文件编译成 css 文件。less 插件会作为 less-loader 的 peerDependency，因此安装 less-loader 的时候会自动安装 less 插件。 less-loader 4 起，查询文件可通过 webpack resolver 或 less 内置的 resolver。less-loader 应用一个 Less 插件，并且将所有查询参数传递给 webpack resolver。需要从 node_modules 导入 less 模块时，只要加一个 ~ 前缀，如 @import “~bootstrap/less/bootstrap”; 。使用 webpack resolver，可以引入任何导出 less 的文件，如 “js-to-less-loader” 导出的文件，与此同时，需要使用 issuer 属性约定请求资源的脚本文件名，如 issuer: /.less$/。 当 options 配置 paths 属性时，将使用 less 内置的 resolver 去查询文件。paths 属性以数组形式配置绝对路径。 options 配置参考 less options。 1234567891011121314151617181920212223242526272829303132333435&#123; module: &#123; rules: [&#123; test: /\\.less$/, use: [&#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\" &#125;, &#123; loader: \"less-loader\", options: &#123; strictMath: false,// 是否直接输出数学计算值 strictUnits: false,// 是否支持 1px * 2px 运算，单位通过猜测获得 globalVar: &#123;&#125;,// 全局变量 modifyVar: &#123;&#125;,// 在 less 文件可改变的变量 paths: [],// less 文件查找路径，如 [ path.resolve(__dirname, \"node_modules\") ] plugins: [],// 设置插件，如 [ new CleanCSSPlugin(&#123; advanced: true &#125;) ] sourceMap: false// 是否启用 SourceMap，可选值 true, \"inline\" &#125; &#125;] &#125;]&#125;// 或&#123; module: &#123; rules: [&#123; test: /\\.js$/, issuer: /\\.less$/, use: [&#123; loader: \"js-to-less-loader\" &#125;] &#125;] &#125;&#125;; sass-loader将 scss 文件编译成 css 文件。node-sass 插件会作为 sass-loader 的 peerDependency，因此安装 sass-loader 的时候会自动安装 node-sass 插件。 options 配置参考 node-sass。 sass-loader 中，url(…) 语法将相对于网站的根目录查找(没有 css-loader)，或相对 scss 文件查找(有 css-loader)。有 css-loader 场景，可通过 resolve-url-loader 加载器获得相对 scss 文件的 url。 1234567891011121314151617&#123; module: &#123; rules: [&#123; test: /\\.scss$/, use: [&#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\" &#125;, &#123; loader: \"sass-loader\", options: &#123; includePaths: [],// 文件路径，如 [\"absolute/path/a\", \"absolute/path/b\"] &#125; &#125;] &#125;] &#125;&#125; dynamic-css-loader对 css 文件中的 import 语句，采用动态加载的方式。结合 extract-text-webpack-plugin, file-loader, extract-loader 使用。 1234567891011&#123; test: /.../, use: ExtractTextPlugin.extract(&#123; use: [ ... ], fallback: [ 'dynamic-css-loader', 'file-loader', 'extract-loader', ], &#125;),&#125;, file-loader支持 import, require 加载文件，返回文件的 url。 1234567891011121314151617181920module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123; name: [hash].[ext],// 文件名，模板字符串，支持占位符 ext 扩展名，name 文件名，path 相对于 context 的路径，hash 哈希值，N 当前文件名按照查询参数 regExp 匹配后获得到第 N 个匹配结果，等 context: this.options.context,// 文件查找的基本路径，默认为 webpack 配置项的 context publicPath: __webpack_public_path__,// 文件的 public path，默认为 webpack 配置项的 publicPath outputPath: undefined,// 文件导出目录 useRelativePath: false,// 设置为真值时，生成 url 相对于 context emitFile: true// 为真值时处理文件，为否值只获取 url &#125; &#125; ] &#125; ]&#125; url-loader基本功能同 file-loader，但当文件不大时，以 DataUrl 形式嵌入 html 页面中，避免请求服务器资源。DataUrl 主要实现为，将图片编码为 base64，存储在 url 中，并冠以 mime-type。base64 编码的数据体积通常是原数据的体积 4/3，且不会被浏览器缓存。缓存问题可通过 css 背景图片解决，图片资源嵌入 url(…) 语句，随 css 文件一同缓存在浏览器端。 12345678910111213141516171819&#123; module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: undefined,// 文件大于 limit 值，使用 file-loader 加载；小于，使用 url-loader，如 limit: 8192 mimetype: \"extname\",// 设置文件的 mime-type，默认通过扩展名获取 prefix: false// 提供给 file-loader 使用 &#125; &#125; ] &#125; ] &#125;&#125; html-loader处理 html 文件中的图片链接 img:src 等属性，需要结合 url-loader, file-loader 使用。 html-loader 只作字符处理，如 ‘Text Text’ 将转换为 ‘module.exports = “Text &lt;img src=\\“” + require(“./image.png”) + “\\“&gt;&lt;img src=\\“” + require(“bootstrap-img”) + “\\“&gt; Text”;’ 因此，若要导出 html 页面，需要配合 file-loader, extract-loader 使用。extract-loader 将 js 转换为 html，file-loader 输出 html 文件。 123456789101112131415161718192021222324252627// html-loader 加载器选项，也可以设置在 webpackConfig 的 htmlLoader, otherHtmlLoaderConfig 属性中，加载时指定 config，如 html-loader?config=otherHtmlLoaderConfig&#123; test: /\\.(html)$/, use: &#123; loader: 'html-loader', options: &#123; attrs: ['img:src'],// 待处理的标签，如 ':data-src'。设置为 false，禁用对标签属性的处理。设置为 'img:src'，url-loader, file-loader 导出的链接赋值给 src 属性；设置为 ':data-src'，url-loader, file-loader 导出的链接赋值给 data-src 属性 minimize: false,// 最小化输出 removeComments: false,// 最小化选项 removeCommentsFromCDATA: false, removeCDATASectionsFromCDATA: false, collapseWhitespace: false, conservativeCollapse: false, removeAttributeQuotes: false, useShortDoctype: false, keepClosingSlash: false, minifyJS: false, minifyCSS: false, removeScriptTypeAttributes: false, removeStyleTypeAttributes: false, root: false,// 设置为 true 时，&lt;img src=\"/image.jpg\"&gt; 中 src 属性将自动拼接网站根目录 interpolate: false,// 设置为 true 时，自动转换 es6 模板字符串 $&#123;&#125;；设置为 'require'，只能在模板内使用 require。如 &lt;#list list as list&gt;&lt;a href=\"$&#123;list.href!&#125;\" /&gt;$&#123;list.name&#125;&lt;/a&gt;&lt;/#list&gt; exportAsDefault: false,// 以 es5 格式导出 exports.default = \"Hello world\"; 默认导出格式为 module.exports = \"Hello world\"; exportAsEs6Default: false,// 以 es6 格式导出 export default \"Hello world\"; &#125; &#125;&#125; raw-loader将文件导入为字符串。 1234&#123; test: /\\.txt$/, loader: 'raw-loader'&#125; i18n-loader将所有语言包加载到一个对象中，并根据 window.navigator.userLanguage 或 window.navigator.language 区分语言包。i18n/choose 模块用于选择正确的语言包，i18n/concat 模块将拼接所有合适的地区，i18n/merge 将所有语言包合并到对象中， 1234567var locale = require(\"./colors.i18.json\");// 等待准备就绪，在一个 web 项目中所有地区只需要一次// 因为所有地区的语言被合并到一个块中locale(function() &#123; console.log(locale);// 打印语言包&#125;); 123456789101112&#123; test: /\\.i18$/, use: [&#123; loader: 'i18n-loader', options: &#123; locales: [],// 将所有语言包打包到一个对象中，如 [ \"de\", \"de-de\", \"fr\" ]，同时开启同步加载模式 bundleTogether: false// 是否禁止所有语言包打包在一起 &#125; &#125;,&#123; loader: 'json-loader' &#125;]&#125; json-loaderwebpack 2 起，将自动导入json。若使用不同的扩展名，仍可使用 json-loader 导入 json 数据。 json5-loader用于导入 json5 文件。 1234&#123; test: /\\.json5$/, loader: 'json5-loader'&#125; svg-inline-loader用于导入 svg。 12345678910111213141516&#123; test: /\\.svg$/, use: [&#123; loader: 'svg-inline-loader', options: &#123; removeTags: false,// 删除指定的标签和它的子元素，布尔型 removingTags: [],// 待删除的标签，需要 removeTags 属性置为真，如 ['title', 'desc', 'defs', 'style'] warnTags: [],// 警告标签 removeSVGTagAttrs: true,// 是否删除 &lt;svg /&gt; 的 width 和 height 属性 removingTagAttrs: [],// 删除内部的 &lt;svg /&gt;的属性 warnTagAttrs: [],// 在console发出关于内部 &lt;svg /&gt; 属性的警告 classPrefix: false,// svg 标签 class 添加前缀，避免命名冲突，可选值 true 或 字符串 idPrefix: false// svg 标签 id 添加前缀，避免命名冲突，可选值 true 或 字符串 &#125; &#125;]&#125; null-loader使打包文件不包含部分类库额外引入的依赖。 1234&#123; test: path.resolve(__dirname, 'node_modules/library/polyfill.js'), loader: 'null-loader'&#125; bundle-loader通过 require.ensure 方法实现文件的异步加载，设置回调对文件作处理，回调可设置多个。当文件加载完成后，执行回调；当回调在文件加载完成后添加，立即执行回调。为了同其他脚本作区分，配置时 test 属性可设置为 /.bundle.js$/。效果如下： 123import load from 'test.bundle.js';load(file =&gt; &#123;&#125;);// 首次调用文件后加载回调 coffee-loader编译 CoffeeScript。选项包含 literate = false 编译在 Markdown 中书写的 CoffeeScript 脚本，sourceMap = false 是否启用 source-map，transpile = false 配置 babel-preset 及 babel-plugin。 coffee-redux-loader编译 CoffeeScript。终极版??? jshint-loaderjshint 语法检查。jshint-loader 选项配置参考：http://jshint.com/docs/options/。 123456789101112131415161718&#123; module: &#123; rules: [&#123; test: /\\.js$/, enforce: \"pre\", // 预先加载 jshint loader exclude: /node_modules/, use: [&#123; loader: \"jshint-loader\", options: &#123; camelcase: true, emitErrors: false,// jshint 默认显示警告类信息，emitErrors设为 true 将置为错误类信息 failOnHint: false,// 设置为真值时，jshint 报错将打断 webpack 函数 reporter: function(errors) &#123; &#125;// 自定义报告函数，errors 为数组形式 [&#123; id, code, reason, evidence, line, character, scope &#125;]; 其中，reason 为错误消息，evidence 为错误编码，scope 为消息作用域。函数中，调用 this.emitWarning(...) 或 this.emitError(...) 显示消息。由 webpack 提供上下文 this &#125; &#125;] &#125;] &#125;&#125; mocha-loader加载时运行 mocha 测试。 1234567&#123; rules: [&#123; test: /test\\.js$/, use: 'mocha-loader', exclude: /node_modules/, &#125;]&#125; istanbul-instrumenter-loader加载时运行 karam 测试。 参考文档：karma-webpackkarma-coverage-istanbul-reporter 123456789101112131415161718&#123; test: /\\.js$|\\.jsx$/, use: &#123; loader: 'istanbul-instrumenter-loader', options: &#123; debug: false,// 开启 debug 模式 compact: true,// 生成压缩后代码 autoWrap: false,// 函数外是否允许返回语句 esModules: false,// ES2015 书写代码 coverageVariable: '__coverage__',// 全局覆盖率变量名 preserveComments: false,// 输出中保留注释 produceSourceMap: false,// 生成 source-map sourceMapUrlCallback: null// source-map url 查询后的回调 &#125; &#125;, enforce: 'post', exclude: /node_modules|\\.spec\\.js$/,&#125; coverjs-loader用于测试??? 123456// cover-my-client-tests.jsrequire(\"./my-client-tests\");after(function() &#123; require(\"cover-loader\").reportHtml();&#125;); exports-loaderexports 插入属性，或者赋值 module.exports。 123456789101112require(\"exports-loader?file,parse=helpers.parse!./file.js\");// adds below code to the file's source:// exports[\"file\"] = file;// exports[\"parse\"] = helpers.parse;require(\"exports-loader?file!./file.js\");// adds below code to the file's source:// module.exports = file;require(\"exports-loader?[name]!./file.js\");// adds below code to the file's source:// module.exports = file; expose-loader暴露全局变量，注入到 global 对象中。 123456789101112131415require(\"expose-loader?$!jquery\");// 或module: &#123; rules: [&#123; test: require.resolve('jquery'), use: [&#123; loader: 'expose-loader', options: 'jQuery' &#125;,&#123; loader: 'expose-loader', options: '$' &#125;] &#125;]&#125; imports-loader自动为文件注入局部变量。 123456789module: &#123; rules: [&#123; test: /test\\/.js/ use: [&#123; loader: 'imports-loader', options: &#123;&#125;// 注入变量，如 &#123; angular: true &#125; 将注入 angular 类库；&#123; $: 'jquery' &#125; 将注入 jquery；&#123; config: '&gt;&#123; size: 50 &#125;' &#125; 将赋值 config = &#123; size: 50 &#125; 等 &#125;] &#125;]&#125; gzip-loader加载 gzip 压缩资源。 1234567891011&#123; module: &#123; rules: [ &#123; test: /\\.gz$/, enforce: 'pre', use: 'gzip-loader' &#125; ] &#125;&#125; yaml-frontmatter-loader将 yaml 转化为 json。 react-proxy-loader通过 require.ensure 按需加载文件组件。组件实例 mixins 属性注入代理组件 require(‘react-proxy-loader!./a.js’).Mixin，在当前组件中调用loadComponent 即可获取 a.js 导出的组件，a.js 文件尚未加载完成，调用开发者配置的 renderUnavailable 方法进行渲染。或者，直接将 require(‘react-proxy-loader!./a.js’) 作为组件使用，a.js 文件尚未加载完成，render 方法返回 null。 123456789var Component = require(\"react-proxy-loader!./Component\");var ComponentProxyMixin = require(\"react-proxy-loader!./Component\").Mixin;var ComponentProxy = React.createClass(&#123; mixins: [ComponentProxyMixin], renderUnavailable: function() &#123; return &lt;p&gt;Loading...&lt;/p&gt;; &#125;&#125;); script-loader在全局上下文中执行一次 js 脚本，加载时即执行。 source-map-loader从 js 入口文件中提取 source-map 文件(该文件的内容由 webpackConfig devtool 配置项限定)。可设置 include, exclude 选项。 cache-loader在性能开销较大的 loader 前加载 cache-loader，可以将编译结果缓存到磁盘中，如 babel-loader 前。options 有 cacheDirectory 缓存目录，默认为 path.resolve(‘.cache-loader’)。 worker-loader将 js 转化为 webworker，父子线程间通信??? webworker 参考文档：https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API。 1234567891011121314151617181920// file.jsvar _ = require('lodash')var o = &#123;foo: 'foo'&#125;_.has(o, 'foo') // true// 将数据发送到父线程(parent thread)self.postMessage(&#123;foo: 'foo'&#125;)// 响应来自父线程(parent thread)的消息self.addEventListener('message', function(event)&#123; console.log(event); &#125;);// main.jsvar MyWorker = require(\"worker-loader!./file.js\");var worker = new MyWorker();worker.postMessage(&#123;a: 1&#125;);worker.onmessage = function(event) &#123;...&#125;;worker.addEventListener(\"message\", function(event) &#123;...&#125;); multi-loader控制多个加载器。 123456789101112var multi = require(\"multi-loader\");&#123; module: &#123; loaders: [&#123; test: /\\.css$/, loader: multi(// multi 参数中 loader 顺序执行，即先解析 css，再以字符串输出 \"style-loader!css-loader!autoprefixer-loader\", \"raw-loader\" ) &#125;] &#125;&#125; thread-loader作为前置 loader，将使之后的 loader 运行在独立的线程池中。但这些后置的 loader 不能产生新的文件，不能使用定制的 loader API，无法获取 webpack 的选项设置??? 123456789101112131415161718192021222324&#123; use: [ &#123; loader: \"thread-loader\", options: &#123;// 有同样配置的 loader 会共享一个 worker 池(worker pool) workers: 2,// 产生的 worker 的数量，默认是 cpu 的核心数 workerParallelJobs: 50,// 一个 worker 进程中并行执行工作的数量，默认为 20 workerNodeArgs: ['--max-old-space-size', '1024'],// 额外的 node.js 参数 poolTimeout: 2000,// 闲置时定时删除 worker 进程，默认为 500ms。可以设置为无穷大， 这样在监视模式(--watch)下可以保持 worker 持续存在 poolParallelJobs: 50,// 池(pool)分配给 worker 的工作数量，默认为 200。降低这个数值会降低总体的效率，但是会提升工作分布更均一 name: \"my-pool\"// 池(pool)的名称，可以修改名称来创建其余选项都一样的池(pool) &#125; &#125;, \"expensive-loader\" ]&#125;// 预热 worker 池(worker pool)来防止启动 worker 时的高延时。这会启动池(pool)内最大数量的 worker 并把指定的模块载入 node.js 的模块缓存中const threadLoader = require('thread-loader');threadLoader.warmup(options, [ 'babel-loader', 'babel-preset-es2015', 'sass-loader',]); transform-loader应用 browserify transforms??? browserify transforms 参考文档：https://github.com/browserify/browserify/wiki/list-of-transforms val-loader根据输入加载不同文件，交由下一个中间件??? 1234567891011121314151617181920212223242526272829303132333435const ask = require('./ask.js');const generateResult = require('./generateResult.js');function findAnswer(options) &#123; return ask(options.question) .then(generateResult) .then(result =&gt; (&#123; code: result.code, sourceMap: result.sourceMap, ast: result.abstractSyntaxTree,// 下一个 loader 使用相同的 ast，可以提升编译速度 dependencies: [// 默认为 []，需要监听这些文件的变更 require.resolve('./ask.js'), require.resolve('./generateResult.js') ],. cacheable: true// 依赖没有变更时，使用缓存 &#125;));&#125;module.exports = findAnswer;// webpack.config.jsmodule.exports = &#123; ... module: &#123; rules: [&#123; test: require.resolve('path/to/findAnswer.js'), use: [&#123; loader: 'val-loader', options: &#123; question: 'What is the meaning of life?' &#125; &#125;] &#125;] &#125;&#125;;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"webpack","slug":"frontend/webpack","permalink":"http://xzfyu.com/categories/frontend/webpack/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"浅析webpack-merge源码","slug":"frontend/工程化/浅析webpack-merge源码","date":"2018-02-03T06:48:30.000Z","updated":"2020-03-08T10:57:17.803Z","comments":true,"path":"2018/02/03/frontend/工程化/浅析webpack-merge源码/","link":"","permalink":"http://xzfyu.com/2018/02/03/frontend/工程化/浅析webpack-merge源码/","excerpt":"","text":"merge方法webpack-merge 类库的 merge 方法基于 lodash 类库的 mergeWith 方法实现。 mergeWith 方法用于遍历数组项或对象属性，通过尾参 customizer 定制化数据处理函数，获得新的数组项或对象属性。customizer 函数的参数为 (objValue, srcValue, key, object, source, stack)。 webpack-merge 通过 join-arrays 模块导出的 joinArrays 函数将用户配置项 { customizeArray, customizeObject } 对象构建为 customizer 函数生成器。customizer 函数的处理逻辑为：当 objValue, srcValue 为函数时，该函数的返回值由 customizer 函数再次处理。当 objValue, srcValue 为数组时，通过 customizeArray 函数处理，参数为（objValue, srcValue, key）；若 customizeArray 函数未定义，合并数组项。当 objValue, srcValue 为对象时，通过 customizeObject 函数处理，若无返回值或 customizeObject 函数未定义，构建新的key值，调用 joinArrays 函数将 { customizeArray, customizeObject } 配置项转化成内层数据处理函数，并对 objValue, srcValue 的子孙属性深度处理。除此而外，深拷贝 source 或者将 source 作为返回值。特别的，当 customizeArray, customizeObject 函数均未作配置时，customizer 函数作深拷贝处理。 1234567891011121314151617181920212223242526272829303132333435export default function joinArrays(&#123; customizeArray, customizeObject, key&#125; = &#123;&#125;) &#123; return function _joinArrays(a, b, k) &#123; const newKey = key ? `$&#123;key&#125;.$&#123;k&#125;` : k; if (isFunction(a) &amp;&amp; isFunction(b)) &#123; return (...args) =&gt; _joinArrays(a(...args), b(...args), k); &#125; if (isArray(a) &amp;&amp; isArray(b)) &#123; const customResult = customizeArray &amp;&amp; customizeArray(a, b, newKey); return customResult || [...a, ...b]; &#125; if (isPlainObject(a) &amp;&amp; isPlainObject(b)) &#123; const customResult = customizeObject &amp;&amp; customizeObject(a, b, newKey); // 第二层以同样的逻辑处理，如 'module.rules'等 return customResult || mergeWith(&#123;&#125;, a, b, joinArrays(&#123; customizeArray, customizeObject, key: newKey &#125;)); &#125; if (isPlainObject(b)) &#123; return cloneDeep(b); &#125; return b; &#125;;&#125; 在此基础上，webpack-merge 实现了 merge 方法。该方法支持单参数，通过接受{ customizeArray, customizeObject } 对象，返回值用于对数据（格式可以是数组，或多参数）做处理；也支持多参数，数据处理模式即为深拷贝。 multiple 方法multiple 方法在 merge 方法的基础上构建，首先通过 merge 方法将配置数据复合为一，然后通过 lodash.values 方法以数组形式返回复合对象各属性的值。 12345678910111213141516171819202122232425262728293031323334353637383940var path = require('path');var baseConfig = &#123; server: &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; &#125;, client: &#123; output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; &#125; &#125;;// specialized configurationvar production = &#123; client: &#123; output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash].js' &#125; &#125; &#125;// output[&#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125;&#125;,&#123; output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash].js' &#125;&#125;] unique 方法unique 方法通过 lodash 类库的 differenceWith 方法实现。differenceWith 方法接受参数为 (array, values, comparator)，通过遍历 array 数组项，并调用 comparator 函数将数组项和 values 数组比较，将返回否值的数组项构建成新的数组。unique 方法用于构建 customizeArray 配置函数，且其接受参数为 (key, uniques, getter)，key 即属性名，uniques, getter 参数用于构建 differenceWith 方法中的参数 comparator。若getter返回值已存在 uniques 中，comparator 返回真值；否则返回否值，即该数组项拷贝到新数组中。 1234567891011// unique 方法源码function mergeUnique(key, uniques, getter = a =&gt; a) &#123; return (a, b, k) =&gt; ( k === key &amp;&amp; [ ...a, ...differenceWith( b, a, item =&gt; uniques.indexOf(getter(item)) &gt;= 0 ) ] );&#125; 123456789101112131415161718// unique 方法使用// 需要注意的是，若首个 plugins 中没有 HotModuleReplacementPlugin 构造函数// 第二个 plugins 中的HotModuleReplacementPlugin 也不会拷贝到新数组中const output = merge(&#123; customizeArray: merge.unique( 'plugins', ['HotModuleReplacementPlugin'], plugin =&gt; plugin.constructor &amp;&amp; plugin.constructor.name )&#125;)(&#123; plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;, &#123; plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125;); strategy 方法strategy 方法在 merge 方法基础上实现，通过配置项 rules 构建 { customizeArray, customizeObject } 对象，最终生成 customizer 数据处理函数。rules 以对象形式配置，定义了数据处理策略，其中，’prepend’ 为反向深拷贝，’replace’ 替换，默认为 ‘append’ 即正向深拷贝。与 merge 方法相同，rules 可以设置深度嵌套属性的处理规则，如 ‘module.rules’: ‘prepend’。 123456789101112131415161718192021222324252627282930const mergeStrategy = (rules = &#123;&#125;) =&gt; merge(&#123; customizeArray: customizeArray(rules), customizeObject: customizeObject(rules)&#125;);function customizeArray(rules) &#123; return (a, b, key) =&gt; &#123; switch (rules[key]) &#123; case 'prepend': return [...b, ...a]; case 'replace': return b; default: // append return false; &#125; &#125;;&#125;function customizeObject(rules) &#123; return (a, b, key) =&gt; &#123; switch (rules[key]) &#123; case 'prepend': return mergeWith(&#123;&#125;, b, a, joinArrays()); case 'replace': return b; default: // append return false; &#125; &#125;;&#125; smart 方法smart 方法为处理 module.rules 配置项而设计。首先提取 module.rules 数组，交由 lodash 模块的 unionWith 方法处理。unionWith 方法接受参数为 (…array, compator)，comparator(arrVal, othVal) 函数返回 false 时保留两个数组项，返回真值只保留 arrVal。特别的，comparator 执行过程中，可对引用对象 arrVal 进行再度插值操作，使其具有 othVal 的特性。为此，webpack-merge 类库构造了 uniteRules 函数对 module.rules 数组项进行处理。 123456789const mergeSmart = merge(&#123; customizeArray: (a, b, key) =&gt; &#123; if (isRule(key.split('.').slice(-1)[0])) &#123; return unionWith(a, b, uniteRules.bind(null, &#123;&#125;, key)); &#125; return null; &#125;&#125;); uniteRules 函数接受参数为 {rules, key, newRule, rule}，其中 rules 用于配置 module.rules 合并策略，如 { rules.use: ‘prepend’ | ‘append’ | ‘replace’ }，key 即 ‘rules’，newRule, rule 为待合并的两个加载器配置项。uniteRules 函数的处理逻辑为：首先比较 newRule, rule 的 test, include, exclude, enforce, query 查询字符串，是否跳过合并；其次，将 newRule.loader 配置项赋给rule，作为返回值，因为无论 ‘prepend’ | ‘append’ | ‘replace’ 策略，都将返回 newRule.loader；其次将 rule.loader 转换为 [{ loader }]数组，同时newRule.use, rule.use 也转换为 [{ loader }] 数组，该数组同名 loader 将会被合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106function uniteRules(rules, key, newRule, rule) &#123; if (String(rule.test) !== String(newRule.test) || ((newRule.enforce || rule.enforce) &amp;&amp; rule.enforce !== newRule.enforce) || (newRule.include &amp;&amp; !isSameValue(rule.include, newRule.include)) || (newRule.exclude &amp;&amp; !isSameValue(rule.exclude, newRule.exclude))) &#123; return false; &#125; else if (!rule.test &amp;&amp; !rule.include &amp;&amp; !rule.exclude &amp;&amp; (rule.loader &amp;&amp; rule.loader.split('?')[0]) !== (newRule.loader &amp;&amp; newRule.loader.split('?')[0])) &#123; // Don't merge the rule if there isn't any identifying fields and the loaders don't match return false; &#125; else if ((rule.include || rule.exclude) &amp;&amp; (!newRule.include &amp;&amp; !newRule.exclude)) &#123; // Don't merge child without include/exclude to parent that has either return false; &#125; // newRule.loader should always override if (newRule.loader) &#123; const optionsKey = newRule.options ? 'options' : newRule.query &amp;&amp; 'query'; delete rule.use; delete rule.loaders; rule.loader = newRule.loader; if (optionsKey) &#123; rule[optionsKey] = newRule[optionsKey]; &#125; &#125; else if ((rule.use || rule.loaders || rule.loader) &amp;&amp; (newRule.use || newRule.loaders)) &#123; const expandEntry = loader =&gt; ( typeof loader === 'string' ? &#123; loader &#125; : loader ); // this is only here to avoid breaking existing tests const unwrapEntry = entry =&gt; ( !entry.options &amp;&amp; !entry.query ? entry.loader : entry ); let entries; // 将 &#123; loader &#125; 转化成 [&#123; loader, option?, query? &#125;]数组 if (rule.loader) &#123; const optionsKey = rule.options ? 'options' : rule.query &amp;&amp; 'query'; entries = [&#123; loader: rule.loader &#125;]; if (optionsKey) &#123; entries[0][optionsKey] = rule[optionsKey]; &#125; delete rule.loader; if (optionsKey) &#123; delete rule[optionsKey]; &#125; &#125; else &#123; // rule.use, rule.loaders 数组项若为字符串，转化为 &#123; loader &#125; 对象 entries = [].concat(rule.use || rule.loaders).map(expandEntry); &#125; const newEntries = [].concat(newRule.use || newRule.loaders).map(expandEntry); const loadersKey = rule.use || newRule.use ? 'use' : 'loaders'; const resolvedKey = `$&#123;key&#125;.$&#123;loadersKey&#125;`; switch (rules[resolvedKey]) &#123; case 'prepend': rule[loadersKey] = [ ...differenceWith(newEntries, entries, uniteEntries), ...entries ].map(unwrapEntry); break; case 'replace': rule[loadersKey] = newRule.use || newRule.loaders; break; default: rule[loadersKey] = unionWith( // Remove existing entries so that we can respect the order of the new // entries differenceWith(entries, newEntries, isEqual), newEntries, uniteEntries ).map(unwrapEntry); &#125; &#125; if (newRule.include) &#123; rule.include = newRule.include; &#125; if (newRule.exclude) &#123; rule.exclude = newRule.exclude; &#125; return true;&#125;function uniteEntries(newEntry, entry) &#123; const loaderNameRe = /^([^?]+)/ig; const [loaderName] = entry.loader.match(loaderNameRe); const [newLoaderName] = newEntry.loader.match(loaderNameRe); if (loaderName !== newLoaderName) &#123; return false; &#125; // Replace query values with newer ones mergeWith(entry, newEntry); return true;&#125; smartStrategy 方法smartStrategy 方法不同于 smart 方法只处理 module.rules 配置项，smartStrategy 方法对整个 webpack 配置进行处理。其中，对 module.rules 配置项，smartStrategy 方法处理逻辑雷同 smart 方法，其他配置项则同 strategy 方法。针对 module.rules 配置项，合并规则 rules 须配置为 { ‘module.rules’: ‘prepend’ | ‘replace’ | ‘append’, ‘module.rules.use’: ‘prepend’ | ‘replace’ | ‘append’ } 形式。’module.rules’ 属性设定 module.rules 合并策略，’module.rules.use’ 属性设定 rule.use 合并策略。 123456789101112131415161718192021222324const mergeSmartStrategy = (rules = &#123;&#125;) =&gt; merge(&#123; customizeArray: (a, b, key) =&gt; &#123; const topKey = key.split('.').slice(-1)[0]; if (isRule(topKey)) &#123; switch (rules[key]) &#123; case 'prepend': return [ ...differenceWith(b, a, (newRule, seenRule) =&gt; ( uniteRules(rules, key, newRule, seenRule, 'prepend')) ), ...a ]; case 'replace': return b; default: // append return unionWith(a, b, uniteRules.bind(null, rules, key)); &#125; &#125; return customizeArray(rules)(a, b, key); &#125;, customizeObject: customizeObject(rules)&#125;); 备注：webpack-merge类库主要应用于webpack配置，对于roadhog等类库需要注入babelPlugins、babelPresets配置的，稍显鞭长莫及。 参考文档lodash官方文档 webpack-merge仓库","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"前端工程化","slug":"frontend/前端工程化","permalink":"http://xzfyu.com/categories/frontend/前端工程化/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"webpack配置指南","slug":"frontend/工程化/webpack/webpack配置指南","date":"2018-02-01T15:14:26.000Z","updated":"2020-03-08T10:54:28.446Z","comments":true,"path":"2018/02/01/frontend/工程化/webpack/webpack配置指南/","link":"","permalink":"http://xzfyu.com/2018/02/01/frontend/工程化/webpack/webpack配置指南/","excerpt":"","text":"3.10.0参考文档：webpack 3.10.0 官方文档webpack 3.5.5 中文文档 content 上下文配置用于定位入口文件、loader的绝对路径，默认为工程目录。在基于webpack开发的打包工具中，content属性可设置为该类库的目录路径，以便于查找该类库加载的loader，入口文件采用绝对路径的方式引入。 context: path.resolve(__dirname, &quot;app&quot;) entry 入口配置入口文件，字符串、数组或对象形式（对象属性可以是数组形式）。 12345678910111213141516171819202122// 字符串形式entry: './src/app.js'// 对象形式entry: &#123; home: \"./home.js\", about: \"./about.js\", contact: \"./contact.js\"&#125;// orentry: &#123; app: './src/app.js', vendors: [ 'react', 'react-dom', 'react-router', 'redux', 'react-redux' ]// 配置第三方库&#125;// 函数形式，动态入口entry: () =&gt; './demo'// orentry: () =&gt; new Promise((resolve) =&gt; resolve(['./demo', './demo2'])) output 输出path输出目录的绝对路径，如 path: path.resolve(__dirname, ‘/dist’)。 pathinfo打包文件是否添加包含模块的注释，默认为false。生产环境需置为false。 publicPath浏览器端访问资源时的公开路径，作为前缀。绝对或相对路径形式，如 publicPath: ‘/assets/‘（相对服务器检索资源），页面访问资源为’/assets/spinner.gif’。 123456publicPath: \"https://cdn.example.com/assets/\", // CDN（总是 HTTPS 协议）publicPath: \"//cdn.example.com/assets/\", // CDN (协议相同)publicPath: \"/assets/\", // 相对于服务(server-relative)publicPath: \"assets/\", // 相对于 HTML 页面publicPath: \"../assets/\", // 相对于 HTML 页面publicPath: \"\", // 相对于 HTML 页面（目录相同） filename输出文件名，如 filename: ‘bundle.js’ 或 ‘[name].js’。其中，name占位符会自动填充为待打包脚本的文件名。占位符包含 name 文件名，id 模块标识符，hash 模块标识符的hash值，chunkhash chunk内容的hash值，query 文件名?后面的字符串，下同。 chunkFilename按需加载的非入口文件，包含require.ensure异步加载的脚本，如 chunkFilename: ‘[name].async.js’。 chunkLoadTimeout访问按需加载资源的超时时间，默认为120000。 jsonpFunction按需加载资源的jsonp函数名，默认值为’webpackJsonp’。有多个编译过程需要修改，避免同名冲突。 jsonpScriptType以jsonp形式按需加载资源时，注入页面的script节点的type值，默认为’text/Javascript’。可配置为’module’，即以es6语法形式加载脚本。 crossOriginLoading启用jsonp跨域加载脚本，默认值为false，即不允许；可配置为’anonymous’（允许跨域，发送不带凭据的请求）或’use-credentials’（允许跨域，发送待凭据的请求）。 library开发类库时配置，配置为 libaryName 类库名。参考 创建库 (Library)。 libraryTarget类库导出格式，默认值为’var’。可选值包含’var’（导出为变量），’this’（导出为this的属性），’commonjs’（导出为exports的属性，即node脚本的方法），’commonjs2’（通过module.exports导出，即node的一个模块），’amd’（requirejs模块化规范导出模块），’umd’（以AMD，CommonJS2 形式导出或者导出为 root 的属性）。 libraryExport配置导出的内容，默认值为 _entry_return_ ，即将完全导出模块。若配置为 _entry_return_.default ，只导出 default 属性。若配置为 _entry_return_.methodName ，只导出 methodName 方法。 auxiliaryComment在导出类库时，用于在导出容器中添加注释，配合 library, libraryTarget 属性一起使用。如 auxiliaryComment: ‘Test Comment’。 12345678910111213141516(function webpackUniversalModuleDefinition(root, factory) &#123; // Test Comment if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory(require(\"lodash\")); // Test Comment else if(typeof define === 'function' &amp;&amp; define.amd) define([\"lodash\"], factory); // Test Comment else if(typeof exports === 'object') exports[\"someLibName\"] = factory(require(\"lodash\")); // Test Comment else root[\"someLibName\"] = factory(root[\"_\"]);&#125;)(this, function(__WEBPACK_EXTERNAL_MODULE_1__) &#123; // ...&#125;); umdNamedDefine当 libraryTarget 属性 配置为 ‘umd’ 时，设置 umdNamedDefine 为真，将对 UMD 构建过程中的 AMD 模块进行命名，否则就使用匿名的 define。 sourceMapFilenamesource map文件名，默认值为’[file].map’。占位符除包含entry的所有占位符外，还包含 file 模块文件名，filebase 模块的basename，带扩展名。 devtoolModuleFilenameTemplate定义每个 source map 的 sources 数组项的名称，模板字符串或函数。模板占位符包含 absolute-resource-path 绝对路径文件名，id 模块标识符，hash 模块标识符的hash值，all-loaders 自动和显式的loader，参数取决于第一个loader的名称，loaders 显式的loader，参数取决于第一个loader的名称，resource 文件路径加首个loader的查询参数，resource-path 文件路径。 123456devtoolModuleFilenameTemplate: \"webpack:///[resource-path]?[loaders]\"// 或devtoolModuleFilenameTemplate: info =&gt; &#123; return `webpack:///$&#123;info.resourcePath&#125;?$&#123;info.loaders&#125;`&#125; devtoolFallbackModuleFilenameTemplate使用devtoolModuleFilenameTemplate使多个模块产生相同的名称时，devtoolFallbackModuleFilenameTemplate属性是备用的解决方案，配置同上。 hotUpdateChunkFilename配置热更新文件名，默认为’[id].[hash].hot-update.js’，没必要修改。 hotUpdateFunction热更新加载的jsonp函数名，默认为’webpackHotUpdate’，只在浏览器端使用。 hotUpdateMainFilename热更新的主文件名 ，默认值为’[hash].hot-update.json’，没必要修改。占位符只有 hash。 hashDigest生成 hash 时的编码方式，默认为 ‘hex’。 hashDigestLength散列摘要的前缀长度。 hashFunction散列算法。 hashSalt可选的加盐值。 strictModuleExceptionHandling默认为否值。如为真值，模块报错后，再次引用，将重复报错，因此无需配置。 sourcePrefix配置打包文件每行的前缀，默认使用空字符串，没必要配置。 module 模块noParse无需webpack解析的文件名，正则或函数形式，如 module.noParse: /jquery|lodash/ 或 module.noParse: function(content) { return /jquery|lodash/.test(content); }。 rules用于配置加载器，如 module.rules: [{ test: /.ts$/, use: ‘ts-loader’ }]。 rule.test，资源文件名须匹配的条件，可以是正则，或正则数组，或字符串，或函数（返回真值匹配），或对象（匹配所有属性），下同。与rule.resource属性相冲。 rule.include，资源文件所在目录。 rule.exclude，资源文件排除的目录。 rule.and，资源文件名须匹配所有条件。 rule.or，资源文件名须匹配其中一条条件。 rule.not，资源文件名须排除的条件。 rule.resourceQuery，加载文件时须匹配的查询字符串，如 rule.resourceQuery : /inline/，可使用 import Foo from ‘./foo.css?inline’。 rule.resource，资源文件匹配的规则，可以用rule.test, rule.include, rule.exclude替代配置。 rule.issuer，请求资源的脚本文件名。 rule.use，指定加载器，数组形式。加载器执行顺序为从右到左。 rule.use.loader，指定加载器，如 use: [ { loader: “style-loader “} ]，简写形式为use: [ “style-loader” ]。 rule.use.options | rule.use.query，传入loader的配置项，如 use: [{ loader: “css-loader”, options: { modules: true } }。 rule.parser，配置解析选项，约定模块可以使用的模块化加载语法，默认值为 12345678910111213parser: &#123; amd: false, // 禁用 AMD commonjs: false, // 禁用 CommonJS system: false, // 禁用 SystemJS harmony: false, // 禁用 ES2015 Harmony import/export requireInclude: false, // 禁用 require.include requireEnsure: false, // 禁用 require.ensure requireContext: false, // 禁用 require.context browserify: false, // 禁用特殊处理的 browserify bundle requireJs: false, // 禁用 requirejs.* node: false, // 禁用 __dirname, __filename, module, require.extensions, require.main 等。 node: &#123;...&#125; // 在模块级别(module level)上重新配置 [node](/configuration/node) 层(layer)&#125; rule.rules，配置嵌套规则。 rule.oneOf，以数组顺序优先选用嵌套规则，如 12345678910111213use: [&#123; test: /.css$/, oneOf: [ &#123; resourceQuery: /inline/, // foo.css?inline use: 'url-loader' &#125;, &#123; resourceQuery: /external/, // foo.css?external use: 'file-loader' &#125; ]&#125;] rule.enforce，指定 loader 调用顺序，可选值为’pre’（前置）, ‘inline’（行内）, ‘normal’（普通）, ‘post’（后置），留空即为默认值’normal’。 resolve 解析alias配置资源文件的别名，影响 webpack 查找资源的方式。 enforceExtension是否允许加载无扩展名的文件，默认为 false。 extensions自动解析的文件扩展名，默认值为 extensions: [“.js”, “.json”]。 mainFields决定类库导入的方式，默认值为 mainFields: [“browser”, “module”, “main”]，即优先以类库 package.json 文件中’browser’属性导入模块，其次’module’，其次’main’。 mainFiles解析目录时使用的文件名，默认值为 mainFiles: [“index”]。 modules告诉 webpack 在哪个目录中查找模块，如 modules: [path.resolve(__dirname, “src”), “node_modules”]。 unsafeCache指定需要缓存的模块，默认为 unsafeCache: true。unsafeCache: /src\\/utilities/配置只缓存utilities模块。 plugins额外使用的解析插件列表，如 plugins: [new DirectoryNamedWebpackPlugin()]。 cachePredicate指定异步加载脚本是否需要被缓存，函数形式，默认值为 cachePredicate: function() { return true }。 resolveLoader指定 webpack 查找loader的方式，如resolveLoader: { modules: [“node_modules”], extensions: [“.js”, “.json”], mainFields: [“loader”, “main”] }。 moduleExtensionsrule.use配置loader时待添加的后缀。 plugins 插件12345678910111213141516171819202122232425262728293031var webpack = require('webpack')// 导入非 webpack 默认自带插件var ExtractTextPlugin = require('extract-text-webpack-plugin');var DashboardPlugin = require('webpack-dashboard/plugin');// 在配置中添加插件plugins: [ // 构建优化插件 new webpack.optimize.CommonsChunkPlugin(&#123;// 提取公共资源 name: 'vendor', filename: 'vendor-[hash].min.js', &#125;), new webpack.optimize.UglifyJsPlugin(&#123;// 压缩代码 compress: &#123; warnings: false, drop_console: false, &#125; &#125;), new ExtractTextPlugin(&#123;// 提取并压缩css filename: 'build.min.css', allChunks: true, &#125;), new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/), // 编译时(compile time)插件 new webpack.DefinePlugin(&#123;// 定义全局变量 'process.env.NODE_ENV': '\"production\"', &#125;), // webpack-dev-server 强化插件 new DashboardPlugin(), new webpack.HotModuleReplacementPlugin(),] devServer 开发服务器使用 webpack-dev-server 启动本地开发环境的服务器。由 webpack-dev-server 启动的服务，访问 /webpack-dev-server 路径可查看加载的资源。 inlinedev server 使用内联模式启动，将处理实时重载的脚本注入到打包文件中，开发者可在浏览器控制台查看构建信息。当配置为 inline: false 时，将启用 iframe 模式，处理实时重载的脚本将注入到 iframe 标签中。 lazydev server 使用惰性模式，在请求资源时重新编译脚本，webpack 不会监听任何文件的变动。 hot是否启用 webpack 模块热替换特性，可通过命令行 –hot 启动。 hotOnly启用热替换特性时，编译失败时，是否避免刷新页面，可通过命令行 –hot 启动。 open是否自动打开浏览器，可通过命令行 –open 配置。 openPage打开浏览器时指定页面，如 openPage: ‘/different/page’，可通过命令行 –open-page “/different/page” 配置。 overlay浏览器端显示构建失败和警告信息，配置为 overlay: true 只提示构建失败信息，overlay: { warnings: true, errors: true } 同时显示失败和警告信息。 useLocalIp浏览器端以 ip 打开网页，可通过命令行 –useLocalIp 配置。 historyApiFallback通过 html5 histroy api 控制路由，设置为真值，404 错误页面将重定向到 index.html。rewrites 选项开启更细粒度的重定向；disableDotRule 选项用于在路径中使用’.’（常见于 Angular）。 1234567historyApiFallback: &#123; rewrites: [ &#123; from: /^\\/$/, to: '/views/landing.html' &#125;, &#123; from: /^\\/subpage/, to: '/views/subpage.html' &#125;, &#123; from: /./, to: '/views/404.html' &#125; ]&#125; proxy通过代理服务器转发请求。 12345678910111213141516171819proxy: &#123; \"/api\": &#123; target: \"http://localhost:3000\",// 代理服务器转发到的目标服务器地址 secure: true,// 是否接受 https 服务，且使用无效证书的目标服务器 pathRewrite: &#123;\"^/api\" : \"\"&#125;,// 重写请求路径 bypass: function(req, res, proxyOptions) &#123;// 请求 html 页面资源时，跳过代理 if (req.headers.accept.indexOf(\"html\") !== -1) &#123; console.log(\"Skipping proxy for browser request.\"); return \"/index.html\"; &#125; &#125; &#125;&#125;// 或者proxy: [&#123;// 设置多个代理 context: [\"/auth\", \"/api\"], target: \"http://localhost:3000\",&#125;] setup访问 dev server 服务器实例，添加钩子或中间件。 12345setup(app)&#123; app.get('/some/path', function(req, res) &#123; res.json(&#123; custom: 'response' &#125;); &#125;);&#125; quiet配置为真值时，将隐藏构建信息，包含错误和警告提示。 info该配置项只能通过命令行配置，默认为true，是否输出日志，如 –info=false。 noInfo是否隐藏构建信息，错误和警告除外。 clientLogLevel控制台打印日志级别，默认为 info。可选项 none, error, warning 或 info。 color是否带颜色输出日志，可通过命令行 –color 启动。 stats细粒度控制台打印的信息，同 webapckConfig.stats。 filenamelazy 属性为true，惰性模式启动服务器时，配置 filename 可使资源被请求时才启动打包，如 filename: “bundle.js”。 host配置主机ip，如 host: “0.0.0.0”，可通过命令行 –host 0.0.0.0 配置。 port配置端口号，如 port: 8080，可通过命令行 –port 8080 配置。 public使用内联模式，且通过 ngnix 代理 dev server 时，设置 public 主机url，如public: “myapp.test:80”。可通过命令行 –public myapp.test:80 配置。 publicPath浏览器端访问打包文件的路径，默认为’/‘，可配置为相对路径或完整url，如 publicPath: “http://localhost:8080/assets/&quot;，此时访问资源 bundle.js 的地址为 http://localhost:8080/assets/bundle.js。 contentBase指定服务器从哪里获取静态资源，默认为工程目录，可配置为字符串或数组，false表示禁用。publicPath 指定打包文件加载路径，优先级较高。可通过命令行 –content-base /path/to/content/dir 配置。 watchContentBase监听 contentBase 静态资源改动，可通过命令行 –watch-content-base 配置。 staticOptions配置通过 contentBase 访问的静态资源选项，如 staticOptions: { redirect: false }。 headers在所有响应中添加头部配置，如 headers: { “X-Custom-Foo”: “bar” }。 disableHostCheck是否禁用请求头 host 检查，可通过命令行 –disable-host-check 配置。 allowedHostsallowedHosts配置将校验请求头中的 host 主机，匹配的予以访问权限，如 allowedHosts: [ ‘.host.com’, ‘host2.com’ ]，以’.’起始的配置项可以作为子域名。该配置项可以通过命令行 –allowed-hosts .host.com,host2.com 配置。 bonjour是否通过零配置网络服务规范自动生成ip地址，可通过命令行 –bonjour 启动。 compress服务是否通过 gzip 压缩，可通过命令行 –compress 启动。 https启动 https 服务，默认启动 http 服务。可通过命令行 –https –key /path/to/server.key –cert /path/to/server.crt –cacert /path/to/ca.pem 配置。 12345https: &#123;// 配置自签名证书 key: fs.readFileSync(\"/path/to/server.key\"), cert: fs.readFileSync(\"/path/to/server.crt\"), ca: fs.readFileSync(\"/path/to/ca.pem\"),&#125; socket使用Unix socket通信，如 socket: ‘socket’，可通过命令行 –socket socket 配置。 pfx配置数字证书ssl pfx的路径，如 pfx: ‘/path/to/file.pfx’，可通过命令行 –pfx /path/to/file.pfx 配置。 pfxPassphrase访问数字证书ssl pfx的密码，如 pfxPassphrase: ‘passphrase’，可通过命令行 –pfx-passphrase passphrase 配置。 progress将运行进度输出到控制台，只能使用命令行 –progress 配置。 stdin标准输入停止时关闭 dev server，只能通过命令行 –stdin 配置。 watchOptions监听配置。 devtool 开发工具devtool配置影响生成source map的方式，默认不配置，即不生成source map。打包脚本可通过SourceMap查找实际的报错行号。开发环境可配置为’cheap-module-eval-source-map’；生产环境可配置为’nosources-source-map’。 devtool配置性能： target 构建目标指定构建目标，即打包文件适配的环境，字符串或函数。字符串可选值为 web 浏览器环境（默认值），node 类node环境，使用require加载文件，async-node 类node环境，使用fs和vm异步加载文件，electron-main 编译为Electron主进程，electron-renderer 编译为Electron渲染进程，node-webkit 编译为Webkit可用，使用jsonp加载，webworker 编译成WebWorker。 1234// 返回undefined，避免使用插件构建；返回 'web'，指定 'web' 插件构建const options = &#123; target: () =&gt; undefined&#125;; 1234567891011// 指定 'web' 插件构建const webpack = require(\"webpack\");const options = &#123; target: (compiler) =&gt; &#123; compiler.apply( new webpack.JsonpTemplatePlugin(options.output), new webpack.LoaderTargetPlugin(\"web\") ); &#125;&#125;; Watch 监听 watch 是否启用 Watch 模式监听文件改动，以重启编译过程。webpack 默认为 false，webpack-dev-server 和 webpack-dev-middleware 默认为 true。 watchOptions 定义 watch 监听模式的选项。12345watchOptions: &#123; aggregateTimeout: 300,// 以毫秒值为单位，该时间段内的文件改动将一次性影响 webpack 的编译过程，默认为 300 ignored: /node_modules/,// 避免监听某些文件的改动，节省内存开销，可以配置为 \"files/**/*.js\" poll: 1000// 布尔值或数值，真值开启轮询，监听文件变动；数值时，以该时间间隔检查文件变动&#125; externals 外部扩展用于将第三方类库打包到输出文件中，而是通过运行时由外部注入，如externals: { jquery: ‘jQuery’ }。 1234567891011121314151617181920212223242526272829// 字符串externals: 'jQuery'// 数组externals: &#123; subtract: ['./math', 'subtract']// './math' 模块下的子模块 subtract 由外部注入&#125;// 对象externals : &#123; lodash : &#123; commonjs: \"lodash\",// commonjs 或 amd 模块系统下，通过 lodash 访问 amd: \"lodash\", root: \"_\" // 全局变量下，通过 _ 访问 &#125;&#125;// 函数externals: [ function(context, request, callback) &#123; if (/^yourregex$/.test(request))&#123; return callback(null, 'commonjs ' + request);// 'commonjs ' + request 由外部注入 &#125; callback(); &#125;],// 正则externals: /^(jquery|\\$)$/i node 注入node全局注入 node 变量，提供类 node 环境的功能，由 NodeStuffPlugin 插件为’web’ 或 ‘webworker’ 环境提供ployfill。对象形式，属性的值可以是 true 提供plyfill，”mock” 提供mock，功能很少或没有，”empty” 供空对象，false 什么都不提供。 1234567891011121314151617181920// 默认值node: &#123; console: false, global: true, process: true, __filename: true,// 入口文件的文件名，相对于webpackConfig.context __dirname: true,// 入口文件的目录名，相对于webpackConfig.context Buffer: true, setImmediate: true // 更多选项，请查看“其他 Node.js 核心库”&#125;// 其他node: &#123; dns: &quot;mock&quot;, fs: &quot;empty&quot;, path: true, url: false&#125; performance 性能hints资源过大时，打开/关闭提示，默认为”warning”，可选值为 false | “error” | “warning”。开发环境推荐使用”warning”，生产环境推荐使用”error”。 maxEntrypointSize限制入口文件打包时的最大体积，默认为 250000 (bytes)。 maxAssetSize限制所有单个资源的最大体积，默认为 250000 (bytes)。 assetFilter配置需要计算最大体积以节省性能的文件。 1234567891011// 默认function(assetFilename) &#123; return !(/\\.map$/.test(assetFilename))&#125;;// 其他performance: &#123; assetFilter: function(assetFilename) &#123; return assetFilename.endsWith('.js'); &#125;&#125; stats 统计细粒度地控制输出日志，字符串或对象形式。字符串可选项包含”errors-only” 只包含错误，”minimal” 包含错误和新的编译信息，”none” 没有输出，”normal” 标准输出，”detailed” 详细输出，”verbose” 全部输出。也可配置为对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677stats: &#123; // 增加资源信息 assets: true, // 对资源按指定的项进行排序 assetsSort: \"field\", // 增加缓存了的（但没构建）模块的信息 cached: true, // Show cached assets (setting this to `false` only shows emitted files) cachedAssets: true, // 增加子级的信息 children: true, // 增加包信息（设置为 `false` 能允许较少的冗长输出） chunks: true, // 将内置模块信息增加到包信息 chunkModules: true, // 增加包 和 包合并 的来源信息 chunkOrigins: true, // 对包按指定的项进行排序 chunksSort: \"field\", // 用于缩短请求的上下文目录 context: \"../src/\", // `webpack --colors` 等同于 colors: true, // Display the distance from the entry point for each module depth: false, // Display the entry points with the corresponding bundles entrypoints: false, // 增加错误信息 errors: true, // 增加错误的详细信息（就像解析日志一样） errorDetails: true, // Exclude assets from being displayed in stats // This can be done with a String, a RegExp, a Function getting the assets name // and returning a boolean or an Array of the above. excludeAssets: \"filter\" | /filter/ | (assetName) =&gt; ... return true|false | [\"filter\"] | [/filter/] | [(assetName) =&gt; ... return true|false], // Exclude modules from being displayed in stats // This can be done with a String, a RegExp, a Function getting the modules source // and returning a boolean or an Array of the above. excludeModules: \"filter\" | /filter/ | (moduleSource) =&gt; ... return true|false | [\"filter\"] | [/filter/] | [(moduleSource) =&gt; ... return true|false], // See excludeModules exclude: \"filter\" | /filter/ | (moduleSource) =&gt; ... return true|false | [\"filter\"] | [/filter/] | [(moduleSource) =&gt; ... return true|false], // 增加编译的哈希值 hash: true, // Set the maximum number of modules to be shown maxModules: 15, // 增加内置的模块信息 modules: true, // 对模块按指定的项进行排序 modulesSort: \"field\", // Show dependencies and origin of warnings/errors (since webpack 2.5.0) moduleTrace: true, // Show performance hint when file size exceeds `performance.maxAssetSize` performance: true, // Show the exports of the modules providedExports: false, // 增加 public path 的信息 publicPath: true, // 增加模块被引入的原因 reasons: true, // 增加模块的源码 source: true, // 增加时间信息 timings: true, // Show which exports of a module are used usedExports: false, // 增加 webpack 版本信息 version: true, // 增加提示 warnings: true, // Filter warnings to be shown (since webpack 2.4.0), // can be a String, Regexp, a function getting the warning and returning a boolean // or an Array of a combination of the above. First match wins. warningsFilter: \"filter\" | /filter/ | [\"filter\", /filter/] | (warning) =&gt; ... return true|false&#125;;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"webpack","slug":"frontend/webpack","permalink":"http://xzfyu.com/categories/frontend/webpack/"}],"tags":[{"name":"carrier","slug":"carrier","permalink":"http://xzfyu.com/tags/carrier/"},{"name":"webpack","slug":"webpack","permalink":"http://xzfyu.com/tags/webpack/"}]},{"title":"浅析async-validator源码","slug":"frontend/antd/浅析async-validator源码","date":"2018-01-24T12:56:01.000Z","updated":"2020-03-08T10:28:33.657Z","comments":true,"path":"2018/01/24/frontend/antd/浅析async-validator源码/","link":"","permalink":"http://xzfyu.com/2018/01/24/frontend/antd/浅析async-validator源码/","excerpt":"","text":"这篇文章旨在于分析async-validator数据校验模块(1.8.1版本)的实现。如果这篇文章也能给读者带去裨益，那是笔者的荣幸。 基本校验在async-validator源码中，src/rule文件夹下各代码文件实现了最基础的数据校验能力，因此也可以被称为基础校验规则。 类型校验要分析async-validator模块的实现，容笔者先从类型校验说起。 在async-validator模块中，单个校验器被定义为validator函数。该validator函数接受rule、value、callback、source、options作为参数。source、options这两个参数姑且按下不论。参数rule是以对象形式配置的校验规则，value是待校验的数据，callback是由开发者手动执行的回调函数。 容易猜想的是，在实现类型校验的过程中，async-validator模块采用了{ type: ‘array’ }的形式配置rule。其中type可接受的值包含’integer’, ‘float’, ‘array’, ‘regexp’, ‘object’, ‘method’, ‘email’, ‘number’, ‘date’, ‘url’, ‘hex’这几种类型。在其背后的实现机制中，async-validator模块没有采用switch语句在单一的函数中完成类型判断，而是通过types对象设定每种类型的校验方法，接着通过调用typestype方法实现类型校验，这样能使代码的结构变得清晰。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// src/rule/type.jsconst types = &#123; integer(value) &#123; return types.number(value) &amp;&amp; parseInt(value, 10) === value; &#125;, float(value) &#123; return types.number(value) &amp;&amp; !types.integer(value); &#125;, array(value) &#123; return Array.isArray(value); &#125;, regexp(value) &#123; if (value instanceof RegExp) &#123; return true; &#125; try &#123; return !!new RegExp(value); &#125; catch (e) &#123; return false; &#125; &#125;, date(value) &#123; return typeof value.getTime === 'function' &amp;&amp; typeof value.getMonth === 'function' &amp;&amp; typeof value.getYear === 'function'; &#125;, number(value) &#123; if (isNaN(value)) &#123; return false; &#125; return typeof (value) === 'number'; &#125;, object(value) &#123; return typeof (value) === 'object' &amp;&amp; !types.array(value); &#125;, method(value) &#123; return typeof (value) === 'function'; &#125;, email(value) &#123; return typeof (value) === 'string' &amp;&amp; !!value.match(pattern.email) &amp;&amp; value.length &lt; 255; &#125;, url(value) &#123; return typeof (value) === 'string' &amp;&amp; !!value.match(pattern.url); &#125;, hex(value) &#123; return typeof (value) === 'string' &amp;&amp; !!value.match(pattern.hex); &#125;,&#125;; 从上面的代码中，可以发现types并不包含’boolean’, ‘string’，那么是不是async-validator模块遗漏了这两种数据类型呢？不是的。async-validator通过if-else if语句校验了这两种数据类型（没有else语句，意味着不满足条件的视为校验通过）。 123456789101112// src/rule/type.jsconst custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];const ruleType = rule.type;if (custom.indexOf(ruleType) &gt; -1) &#123; if (!types[ruleType](value)) &#123; errors.push(util.format(options.messages.types[ruleType], rule.fullField, rule.type)); &#125; // straight typeof check&#125; else if (ruleType &amp;&amp; typeof (value) !== rule.type) &#123; errors.push(util.format(options.messages.types[ruleType], rule.fullField, rule.type));&#125; 奇怪的是，在async-validator模块中，既然type的种类包含了’email’(邮箱), ‘url’(网址)，为什么没有包含’phone’(手机号)呢？或者，为什么async-validator模块不对开发者开放注册type的方法呢？那样开发者可以在types对象中添加方法，使得类型校验更为多样，不是吗？实际上，在async-validator模块的设计中，这个type只是单条校验规则，还不是校验器。作为不可变动的底层，它没有提供向types对象注入新类型的方法。关于可注册的校验器类型，将在下文予以分析。 其他基本校验在async-validator模块中，其他基本校验包含’required’(非空校验), ‘whitespace’(空白字符校验), ‘range’(范围校验), ‘enum’(枚举校验), ‘pattern’(正则校验)。’required’, ‘whitespace’校验自不必多说，笔者将着重介绍’range’, ‘enum’, ‘pattern’校验。 关于’range’校验，其能力包含校验数值的大小、字符串或数组的长度，因此rule对象相应添加了min、max、len属性，其中len属性的优先级高于min、max属性。在async-validator源码的实现中，通过先将字符串和数组形式的value转换成待校验的value.length，再通过if语句协调len与min、max校验规则的优先级。具体可参详src/rule/range.js文件的源码。 关于’enum’校验，其能力为校验数据value是否某个枚举数组的一份子，相应rule对象添加了enum属性。若value在rule.enum中，则校验通过；否则校验失败。 关于’pattern’校验，其能力为校验数据value是否匹配正则字符串或正则表达式，相应rule对象添加了pattern属性。该pattern属性可配置为正则字符串或正则表达式。 介绍完了前述校验规则，笔者再度提问，为什么’range’校验中并不包含日期对象的起止时间校验，’enum’校验也不包含数组value尽在rule.enum配置数据中的校验？若说前一条会使’range’校验的实现过于复杂，后一条针对checkbox、select元素却较为常见。实际上，日期对象的range校验在date校验器中实现，笔者将在下文予以描述。 校验器内置校验器在async-validator源码中，src/validator文件夹下各代码文件将基础校验规则整合成单个校验器（字面上是单个校验器，实际是多个基础校验规则构成的组合校验器）。下面将予以简单的介绍，源码不再赘述。 array校验器校验rule为{ type: ‘array’, required: true, min: 1 }的数据value非空、且为数组类型、且长度匹配校验条件。required为false时，跳过非空校验，后同。 boolean校验器校验rule为{ type: ‘boolean’, required: true }的数据value非空、且为布尔类型。 date校验器校验rule为{ type: ‘date’, required: true, min: new Date(‘2017 12 10’).getTime() }的数据value非空、且为date日期对象，且该日期对象匹配起止时间校验。在date校验器的实现中，通过value.getTime()方法将其转化为毫秒数，然后再作range基础校验。 enum校验器校验rule为{ type: ‘enum’, required: true, enum: [‘male’, ‘female’] }的数据value非空，且其值为rule.enum中的一个。 float校验器校验rule为{ type: ‘float’, required: true, min: 1 }的数据value非空、且为浮点型数值、且长度匹配校验条件。 integer校验器校验rule为{ type: ‘integer’, required: true, min: 1 }的数据value非空、且为整型数值、且长度匹配校验条件。 method校验器校验rule为{ type: ‘method’, required: true }的数据value非空、且为函数。 number校验器校验rule为{ type: ‘number’, required: true, min: 1 }的数据value非空、且为数值、且长度匹配校验条件。 object校验器校验rule为{ type: ‘object’, required: true }的数据value非空、且为对象。 pattern校验器校验rule为{ pattern: /\\s/, required: true }的数据value非空、且匹配正则表达式或正则字符串。 regexp校验器校验rule为{ type: ‘regexp’, required: true }的数据value非空、且为正则表达式或正则字符串。 required校验器校验rule为{ required: true }的数据value非空。 string校验器校验rule为{ type: ‘string’, pattern: /\\s/, required: true, min: 1, whitespace: true }的数据value非空、且为字符串、且其长度匹配校验条件、且匹配正则表达式或正则字符串、且不是空字符串。 type校验器校验rule为{ type: ‘email | url | hex’, required: true }的数据value非空、且是’email’或’url’或’hex’中的一种。 自定义校验前述内置校验器无法满足丰富的业务需求，为此，在async-validator模块的实现中，可以通过配置rule = { validator: function(rule, value, callback, source, options){} }或rule = function(rule, value, callback, source, options){}的方式设置自定义校验器。 上文未提及到的是，错误文案可作为callback回调函数的参数传入。并且，该callback函数必须得到调用，其中的因由，将在下文予以描述。 与此同时，在自定义校验器函数中，可以通过首参获得开发者配置的rule对象，或者说，开发者可以通过rule向自定义校验器传入额外的参数。比如，在async-validator模块结合react使用的场景中，笔者在组件内部定义了一个validateId的方法，可以通过配置rule = { vaidator: this.validateId, ctx: this }的校验规则，从而在validateId方法的内部，通过rule.ctx就可以获得该组件实例。虽然，当需要访问组件实例时，常规的配置方式是{ validator: this.validateId.bind(this) }。这个例子旨在说明，跟随外部环境变动的数据可以通过rule对象传入自定义校验器函数内部，不必通过bind方法实现。 假使多个字段共用同一个自定义校验器时，要怎样才能区分当前的校验字段是哪一个呢？在async-validator源码的实现中，开发者配置的rule数据会添加field、fullField属性，其中field就是当前校验的字段名。fullField是当前校验字段的全名，这在深度校验的时候用到。 值得说明的是，参数source是整个待校验的数据，value也是source的一个属性。这样，async-validator模块就为开发者提供了关联校验的能力。假使有字段min、max需要校验，对min字段，需要校验其数值不大于max字段的值，开发者就可以通过source[max]属性获取到max字段的值，从而实现关联校验。 关于参数options，笔者将在后文予以分析。 注册校验器前文已经提到，async-validator模块并未提供注入基础校验规则的方法，相应的，它提供了注册单个校验器的能力。通过调用AsyncValidator.register(type, validator)静态方法，开发者即可以注册一个类型为type的validator校验器。 1234567891011121314151617181920212223242526272829303132333435// src/index.jsSchema.property = &#123; //... getType(rule) &#123; if (rule.type === undefined &amp;&amp; (rule.pattern instanceof RegExp)) &#123; rule.type = 'pattern'; &#125; if (typeof (rule.validator) !== 'function' &amp;&amp; (rule.type &amp;&amp; !validators.hasOwnProperty(rule.type))) &#123; throw new Error(format('Unknown rule type %s', rule.type)); &#125; return rule.type || 'string'; &#125;, getValidationMethod(rule) &#123; if (typeof rule.validator === 'function') &#123; return rule.validator; &#125; const keys = Object.keys(rule); const messageIndex = keys.indexOf('message'); if (messageIndex !== -1) &#123; keys.splice(messageIndex, 1); &#125; if (keys.length === 1 &amp;&amp; keys[0] === 'required') &#123; return validators.required; &#125; return validators[this.getType(rule)] || false; &#125;,&#125;;Schema.register = function register(type, validator) &#123; if (typeof validator !== 'function') &#123; throw new Error('Cannot register a validator by type, validator is not a function'); &#125; validators[type] = validator;&#125;; 通过源码，我们也可以看到该校验器和内置校验器如array、boolean校验器平级。 因此我们也可以实现一个type类型为’remote’远程校验器。 123456789101112131415161718function remoteValidator = (rule, value, callback, source, options)&#123; const &#123; field, action, queryData = &#123;&#125;, format &#125; = rule; if ( !action )&#123; console.warn('action is required'); return; &#125;; let data = &#123; ...queryData, [field]: value &#125;; data = format &amp;&amp; typeof format === 'function' ? format(data, source, options) : data; fetch(action,queryData).then(res =&gt; &#123; if ( res.model === true ) callback(); else callback('error'); &#125;); &#125;; 如上的’remote’远程校验器用到了validator函数能够访问rule对象的能力。相应的rule对象也需要{ type: ‘remote’, action: url, queryData: {} }之类的数据格式。需要说明的是，format函数也可以通过async-validator模块内置的transform配置函数实现，该transform函数只接受value作为其参数，虽然完整的待校验数据source需要由外部注入transform函数体内。在async-validator模块中，rule对象中可配置的transform属性即提供了预制校验数据转化的能力。 校验组合通常，单个校验器无法满足实际的开发需求，async-validator模块使用校验规则数组[ rule ]校验source数据的某个属性。因此在校验某个数据的时候，可以设置多个校验器如[{ type: ‘array’, required: true, min: 1 }, { validator: function(rule, value, callback){} }]。 深度校验对于复杂的对象，async-validator模块提供了深度校验的能力。当rule.type为’object’或’object’时，通过设置rule.defaultField或rule.fields属性(其值为{ key: [rule] }结构)，async-validator模块将会以rule.defaultField与rule.fields合并对象作为校验规则，并校验source内的深层属性。特别的，rule.defaultField可以用来校验数据结构相同的数组项；rule.fields只作用于某个对象属性或某个数组项。该深层属性可以是数组或对象，通过for…in获得数组项或对象属性，并作相应校验。关于这一点，笔者也将在校验流程那一段落加以描述。 校验流程整体校验流程为： 创建Schema实例，let schema = new Schema(descriptor)，其中descriptor即校验规则rules； 调用schema.define(rules)方法，注册校验规则rules； 调用schema.validate(source, options, callback)方法，校验数据source。 笔者将深入讨论第3步schema.validate方法的内部机理，即async-validator模块的校验过程。 在schema.validate方法，主要的工作流程为： 参数转换。若options参数不存在，callback回调取次参。 检查校验规则是否存在。若不存在，执行callback回调。 设置内部回调complete函数，为callback回调传入参数errors = [{ field, message }]和参数fields = { [fieldName] }。 获取校验文案，并写入options.messages。 校验规则转换。将参数rules复合为series数组，其中，series数组的每一项为{ rule, value, source, field }形式。其中，value值由rule.transform(value)方法转换后获得；rule的数据格式为{ type, validator, fullField, field, … }诸如此类，rule.type通过schema.getType(rule)方法获得，rule.validator通过schema.getValidationMethod(rule)获得。 调用asyncMap(series, options, singleValidator, completeCallback)函数校验数据。其中，参数singleValidator接受用于执行单个校验器，并操控下一个校验器的执行；completeCallback为最终回调函数，用于执行内部回调complete函数。singleValidator函数接受参数data和doIt，data即遍历着的series数组项；doIt函数等同koa模块的next函数，用于执行下一个校验器或者最终回调。且，若校验为平行校验，doIt函数负责传递参数错误对象数组，由utils.js文件中的asyncParallelArray函数将所有校验器的错误对象数组构建成单一数组，供completeCallback回调处理。若校验为有序校验，且options.first为真值，doIt函数接收到参数错误对象数组、并交由utils.js文件中的asyncSerialArray函数处理的时候，将直接调用completeCallback回调，中断后续校验器的执行；当options.first为否值，对错误对象的处理与平行校验相同。 通过rule.type、rule.fields、rule.defaultField判断是否深度校验。若是，内部变量deep置为真。 定义addFullfield函数，用于获取深度校验时嵌套对象属性的fullField。 定义单次校验后执行的回调函数cb。cb的实现机制中，包含将错误对象加工为[{ field, message }]数据格式；通过rule.defaultField、rule.fields构建深度校验Schema实例，并在该Schema实例的回调中启动后续校验器。 执行rule.validator(rule, value, cb, source, options)作校验。若返回Promise实例，cb将在该Promise实例的then方法中执行。 制作成简易的流程图为： 平行、有序校验逻辑再梳理在async-validator源码中，平行、有序校验逻辑由util.js文件中asyncMap、asyncSerialArray、asyncParallelArray这三个函数支撑，其实现原理类似于async模块。其中，asyncParallelArray函数用于实现平行校验，在某个异步校验器执行过程中，平行调用下一个校验器；asyncSerialArray用于实现有序校验，在异步校验器执行完成后，再启用下一个校验器。 关于asyncParallelArray(arr, func, callback)函数，其工作流即遍历数组arr，对数组项分别调用func函数加以处理，并通过手动执行的次参收集错误对象或调用callback回调。当遍历完成时，callback回调将被执行。 123456789101112131415161718// src/util.jsfunction asyncParallelArray(arr, func, callback) &#123; const results = []; let total = 0; const arrLength = arr.length; function count(errors) &#123; results.push.apply(results, errors); total++; if (total === arrLength) &#123; callback(results); &#125; &#125; arr.forEach((a) =&gt; &#123; func(a, count); &#125;);&#125; 关于asyncSerialArray(arr, func, callback)函数，其工作流是在内部构建一个next函数，通过该next函数调用func，并将arr数组项及next函数本身作为func的参数，由此有序遍历arr。 123456789101112131415161718192021// src/util.jsfunction asyncSerialArray(arr, func, callback) &#123; let index = 0; const arrLength = arr.length; function next(errors) &#123; if (errors &amp;&amp; errors.length) &#123; callback(errors); return; &#125; const original = index; index = index + 1; if (original &lt; arrLength) &#123; func(arr[original], next); &#125; else &#123; callback([]); &#125; &#125; next([]);&#125; 关于asyncMap函数，首先它判断options.first是否为真值，若为真值，调用asyncSerialArray处理series数组，当某一规则校验失败时，即终止校验，执行callback回调。若options.first为否值，构建next函数包装callback，目的是将所有校验器的失败文案合二为一，在传入callback回调中；再根据options.firstFields是否为真值，分别执行asyncSerialArray、asyncParallelArray函数。 123456789101112131415161718192021222324252627282930// src/util.jsexport function asyncMap(objArr, option, func, callback) &#123; if (option.first) &#123; const flattenArr = flattenObjArr(objArr); return asyncSerialArray(flattenArr, func, callback); &#125; let firstFields = option.firstFields || []; if (firstFields === true) &#123; firstFields = Object.keys(objArr); &#125; const objArrKeys = Object.keys(objArr); const objArrLength = objArrKeys.length; let total = 0; const results = []; const next = (errors) =&gt; &#123; results.push.apply(results, errors); total++; if (total === objArrLength) &#123; callback(results); &#125; &#125;; objArrKeys.forEach((key) =&gt; &#123; const arr = objArr[key]; if (firstFields.indexOf(key) !== -1) &#123; asyncSerialArray(arr, func, next); &#125; else &#123; asyncParallelArray(arr, func, next); &#125; &#125;);&#125; 反思校验流程首先笔者需要介绍的是怎样在自定义校验器中应用promise。代码见下。 1234567891011121314151617181920function covertErrToPromise(err) &#123; let promise = new Promise(function(resolve, reject)&#123; if ( err ) reject(err); else resolve(); &#125;)); return promise;&#125;;function ValidatorDecorator(validator)&#123; return function(rule, value, cb, source, options)&#123; let result = validator(rule, value, cb, source, options); return covertErrToPromise(result); &#125;;&#125;@ValidatorDecoratorfunction customValidator(rule, value, cb, source, options)&#123; // ...validate &#125;; 不得不说，async-validator模块有个缺点，即需要调用者自行构建Promise实例，而不能直接使用unjq-ajax、react-resource、fetch之类模块返回的Promise实例。与此同时，返回的Promise实例将阻塞后续的校验器。 因此笔者有个疑问，为什么async-validator模块在组织异步逻辑的时候，没有采用Promise的写法？ 如果async-validator模块在实现中率先判断rule.validator的返回值是否为Promise实例（通过instanceof判断是否Promise实例，或者通过thenable之类的函数判断返回值是否包含then方法），对于同步校验校验器，将其转化为Promise实例，再将cb回调挂载到该Promise的then方法上；对于异步校验器，不作任何处理。这样可以简化自定义校验器的书写流程，校验通过返回错误文案，成功返回null或不返回；异步校验可以采用async函数书写，也不需要构建Promise实例。 在性能方面，仍旧参数options的first、firstFields属性判断是否该启用有序校验；默认使用平行校验。 错误文案在async-validator模块中，错误文案通过Schema实例的messages方法添加。在内置或自定义校验器中，通过options参数的messages方法获得，再由util.js文件里的format函数格式化。介于async-validator模块不对外提供format方法，对于使用者注册的type校验器，需要自行构建format函数，手动格式化。 此外，async-validator模块不提供国际化的能力。因此，在切换语言时，需要使用者自行调用Schema实例的messages方法切换加载的语言包。关于async-validator模块的设计，完全可以为Schema实例添加一个setLanguage方法，用以切换语言，随后再调用messages添加当前项目实际需要的错误文案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647schema.messages(&#123; default: '字段 %s 校验失败', required: '%s 必填', enum: '%s 必须是 %s 中的一个', whitespace: '%s 不能为空', date: &#123; format: '%s 日期对象 %s 无效，当转换 %s时', parse: '%s 日期对象不能被解析, %s 无效', invalid: '%s 日期对象 %s 无效', &#125;, types: &#123; string: '%s 不是一个 %s', method: '%s 不是一个 %s (function)', array: '%s 不是一个 %s', object: '%s 不是一个 %s', number: '%s 不是一个 %s', date: '%s 不是一个 %s', boolean: '%s 不是一个 %s', integer: '%s 不是一个 %s', float: '%s 不是一个 %s', regexp: '%s 不是一个有效的 %s', email: '%s 不是一个有效的 %s', url: '%s 不是一个有效的 %s', hex: '%s 不是一个有效的 %s', &#125;, string: &#123; len: '字段 %s 须包含 %s 个字符', min: '字段 %s 须大于 %s 个字符', max: '字段 %s 须小于 %s 个字符', range: '字段 %s 须小于 %s 到 %s 个字符', &#125;, number: &#123; len: '字段 %s 须等于 %s', min: '字段 %s 须大于 %s', max: '字段 %s 须小于 %s', range: '字段 %s 须介于 %s 、 %s 之间', &#125;, array: &#123; len: '字段 %s 的长度须等于 %s', min: '字段 %s 的长度须大于 %s', max: '字段 %s 的长度须小于 %s', range: '字段 %s 的长度须介于 %s 、 %s 之间', &#125;, pattern: &#123; mismatch: '字段 %s 的值 %s 不匹配正则 %s', &#125;,&#125;) 应用async-validator在rc-form组件中的应用rc-form组件是ant-design组件库中表单组件的底层实现。关于该表单组件的实现，笔者将在以后的文章中探讨。在这篇文章中，笔者只截取rc-form组件(2.1.6版本)对async-validator模块的使用。 在业务上，一则当表单元素失去焦点时需要校验该表单项，另一方面整张表单在提交时需要校验所有未隐藏的表单项。以上两点，rc-form组件都基于validateFieldsInternal方法创建新的AsyncValidator实例实现。参数action用于过滤校验条件，适用于第一种情形。参数options.force为真时，在事件过程中已被校验的表单项仍需再度校验；options.firstFields需要执行阻塞式校验的字段；其他属性同async-validator模块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// rc-form/src/createBaseField.jsvalidateFieldsInternal(fields, &#123; fieldNames, action, options = &#123;&#125;,&#125;, callback) &#123; const allRules = &#123;&#125;; const allValues = &#123;&#125;; const allFields = &#123;&#125;; const alreadyErrors = &#123;&#125;; fields.forEach((field) =&gt; &#123; const name = field.name; // 表单项在事件过程中已被校验，将不予再次校验 if (options.force !== true &amp;&amp; field.dirty === false) &#123; if (field.errors) &#123; set(alreadyErrors, name, &#123; errors: field.errors &#125;); &#125; return; &#125; const fieldMeta = this.fieldsStore.getFieldMeta(name); const newField = &#123; ...field, &#125;; newField.errors = undefined; newField.validating = true; newField.dirty = true; allRules[name] = this.getRules(fieldMeta, action); allValues[name] = newField.value; allFields[name] = newField; &#125;); this.setFields(allFields); // in case normalize Object.keys(allValues).forEach((f) =&gt; &#123; allValues[f] = this.fieldsStore.getFieldValue(f); &#125;); if (callback &amp;&amp; isEmptyObject(allFields)) &#123; callback(isEmptyObject(alreadyErrors) ? null : alreadyErrors, this.fieldsStore.getFieldsValue(fieldNames)); return; &#125; const validator = new AsyncValidator(allRules); if (validateMessages) &#123; validator.messages(validateMessages); &#125; validator.validate(allValues, options, (errors) =&gt; &#123; const errorsGroup = &#123; ...alreadyErrors, &#125;; if (errors &amp;&amp; errors.length) &#123; errors.forEach((e) =&gt; &#123; const fieldName = e.field; if (!has(errorsGroup, fieldName)) &#123; set(errorsGroup, fieldName, &#123; errors: [] &#125;); &#125; const fieldErrors = get(errorsGroup, fieldName.concat('.errors')); fieldErrors.push(e); &#125;); &#125; const expired = []; const nowAllFields = &#123;&#125;; Object.keys(allRules).forEach((name) =&gt; &#123; const fieldErrors = get(errorsGroup, name); const nowField = this.fieldsStore.getField(name); // avoid concurrency problems // 校验过程中数据变更，提醒需要再次校验 if (nowField.value !== allValues[name]) &#123; expired.push(&#123; name, &#125;); &#125; else &#123; nowField.errors = fieldErrors &amp;&amp; fieldErrors.errors; nowField.value = allValues[name]; nowField.validating = false; nowField.dirty = false; nowAllFields[name] = nowField; &#125; &#125;); this.setFields(nowAllFields); if (callback) &#123; if (expired.length) &#123; expired.forEach((&#123; name &#125;) =&gt; &#123; const fieldErrors = [&#123; message: `$&#123;name&#125; need to revalidate`, field: name, &#125;]; set(errorsGroup, name, &#123; expired: true, errors: fieldErrors, &#125;); &#125;); &#125; callback(isEmptyObject(errorsGroup) ? null : errorsGroup, this.fieldsStore.getFieldsValue(fieldNames)); &#125; &#125;);&#125;,getRules(fieldMeta, action) &#123; const actionRules = fieldMeta.validate.filter((item) =&gt; &#123; return !action || item.trigger.indexOf(action) &gt;= 0; &#125;).map((item) =&gt; item.rules); return flattenArray(actionRules);&#125;, 表单项校验针对第一点，rc-form组件的实现策略是通过getFieldProps方法生成传入表单元素的事件绑定函数props如{ onChange: () =&gt; {} }。绑定函数内部将调用validateFieldsInternal方法对当前的表单项进行校验。 123456789101112131415// rc-form/src/createBaseField.jsgetFieldProps(name, usersFieldOption = &#123;&#125;) &#123; // ... const validateRules = normalizeValidateRules(validate, rules, validateTrigger); const validateTriggers = getValidateTriggers(validateRules); validateTriggers.forEach((action) =&gt; &#123; if (inputProps[action]) return; inputProps[action] = this.getCacheBind(name, action, this.onCollectValidate); &#125;); // ... return inputProps;&#125;, 其中，参数validate = [{ rules, trigger }]、rules、validateTrigger均为usersFieldOption的属性。validate可以设置多组校验规则的不同触发方式，如失去焦点(‘onBlur’)或数据改变(‘onChange’)。参数validateTrigger即usersFieldOption.rules校验规则的触发方式，默认为’onChange’。this.getCacheBind方法用于以this.cachedBind = { name: { action: () =&gt; {} } }缓存校验函数。 123456789101112131415// rc-form/src/createBaseField.jsonCollectValidate(name_, action, ...args) &#123; // this.onCollectCommon方法用于执行onChange等副作用函数，并获取表单项的值 const &#123; field, fieldMeta &#125; = this.onCollectCommon(name_, action, args); const newField = &#123; ...field, dirty: true, &#125;; this.validateFieldsInternal([newField], &#123; action, options: &#123; firstFields: !!fieldMeta.validateFirst, &#125;, &#125;);&#125;, 可以看到，inputProps注入表单项的绑定函数this.onCollectValidate方法将调用this.validateFieldsInternal校验表单项。特别需要指明的是，fieldMeta为{ name, trigger, valuePropName, …usersFieldOption, validate }数据格式。其中，usersFieldOption.validateFirst决定当前校验字段是否执行阻塞式校验；usersFieldOption.getValueFromEvent用于将事件参数event等转化成表单项额值。usersFieldOption.onChange等方法当同名事件发生时将被调用。 表单校验rc-form组件中，校验整张表单通过显式调用this.validateFields方法实现。在该方法内部，也将调用this.validateFieldsInternal校验所有表单项。 123456789101112131415161718192021222324252627282930313233// rc-form/src/createBaseField.jsvalidateFields(ns, opt, cb) &#123; // getParams用于参数转化 const &#123; names, callback, options &#125; = getParams(ns, opt, cb); const fieldNames = names ? this.fieldsStore.getValidFieldsFullName(names) : this.fieldsStore.getValidFieldsName(); const fields = fieldNames .filter(name =&gt; &#123; const fieldMeta = this.fieldsStore.getFieldMeta(name); return hasRules(fieldMeta.validate); &#125;).map((name) =&gt; &#123; const field = this.fieldsStore.getField(name); field.value = this.fieldsStore.getFieldValue(name); return field; &#125;); if (!fields.length) &#123; if (callback) &#123; callback(null, this.fieldsStore.getFieldsValue(fieldNames)); &#125; return; &#125; if (!('firstFields' in options)) &#123; options.firstFields = fieldNames.filter((name) =&gt; &#123; const fieldMeta = this.fieldsStore.getFieldMeta(name); return !!fieldMeta.validateFirst; &#125;); &#125; this.validateFieldsInternal(fields, &#123; fieldNames, options, &#125;, callback);&#125;, 后台校验笔者将探讨的是async-validator模块在koa框架中的使用。 因为AsyncValidator实例的validate方法采用回调的方式组织异步逻辑，所以需要将其转化为Promise实例，这个过程又可以通过在中间件中提供ctx.validate方法实现。 123456789101112131415161718192021const asyncValidatorMiddleware = async function(ctx, next)&#123; ctx.validate = (rules, values, opts) =&gt; &#123; let options = Object.assign(opts); let validator = new AsyncValidator(rules); let promise = new Promise(resolve =&gt; &#123; validator.validate(values, options, errs =&gt; &#123; if ( errs )&#123; resolve(); &#125; else &#123; let msgs = errs.map(err=&gt;err.message).join('; '); ctx.throw(400, msgs); &#125;; &#125;); &#125;)); return promise; &#125;; next();&#125;; 制作校验器图形界面在本小节，笔者将结合实际的项目经验，概要地设计一个可订制校验规则的图形界面。 首先，我们需要一个面板预设单组校验器的校验模式，比如限制某字段必须介于1到10之间，我们就可以在这块面板中限定该字段的值只能为数值，且开启’range’范围校验；接着，在另一块面板配置实际的校验数据，如min = 1, max = 10，由此生成实际的校验规则。 在第一块面板中，预设的校验模式最终将会吐出{ validatorCode, validatorName, validatorDescription, validatorRules }形式的数据结构。其中validatorCode为校验器code，validatorName为校验器名称，validatorDesription为校验器描述，validatorRules = [ rule ]以数组形式存储各字段的校验规则。rule对象的数据结构譬如{ fieldCode, fieldName, fieldDecription, type, validateStrategy, renderType }。在rule对象中，fieldCode为校验字段code；fieldName为校验字段名称；fieldDecription为校验字段描述；type为类型，可选’number’, ‘string’, ‘date’, ‘enum’, ‘array’, ‘object’, ‘custom’（当type为’array’或’object’时，嵌套设置其下属数组项或属性的校验规则；当type为’custom’时，校验方式由程序约定，通过fieldCode查找）；validateStrategy为校验策略，当type为’string’时，可选的校验策略包含’regexp’（正则匹配）, ‘expired’（严格相等）, ‘url’等，余略；renderType为渲染形式，当type为’string’时，renderType自然为输入框形式，这意味着在第二块面板中需要渲染一个输入框以配置正则或期望值，余略。 关于校验类型type和校验策略validateStrategy、渲染形式renderType的关系，笔者用下图简要说明： 特别的，枚举类型额外需要输入框，以配置枚举值key-value键值对。 第一块面板用原型图展示，即为： 至于弹窗形式的单字段校验规则配置，笔者不再赘述。 需要说明的是，针对type类型为’array’或’object’类型的校验规则，因其配置繁琐，完全可以使用type = ‘custom’类型予以校验，通过validatorCode与fieldCode获取后台写死的校验器，这样既对用户透明，也不容易出错。 有了第一块面板，我们再设计第二块面板，即实际校验数据配置面板。这里我们引入校验组合的概念，即单个校验组合下可配置多个校验器，校验组合之间有序排列，逐个校验，其中一个出错，即为校验失败。至于校验器配置弹窗，其渲染方式完全由第一块面板填充的数据决定，如我们配置了validateRules = [{ fieldCode: ‘field1’, fieldName: ‘field1’, type: ‘string’, validateStragery: ‘expired’, renderType: ‘input’ }, { fieldCode: ‘field2’, fieldName: ‘field2’, type: ‘enum’, validateStragery: ‘multiple’, renderType: ‘select’ }]，校验器的配置弹窗即显示一个输入框和一个多选下拉框，前者用于决定第一个字段的期望值，后者用于决定第二个字段须为下拉框选中项中的一个。在这里，笔者只给出校验组合的原型图，至于校验器的配置弹窗，不再赘述。 有了以上两块面板及其输入数据，我们就可以拼装实际的校验规则。笔者依然以前述的validatorRules为例，当用户配置了如下的校验组合，validatorCombinations = [[{ field1: ‘aaa’, field2: [‘1’, ‘2’, ‘3’] }]]。生成的实际校验器即为{ type: ‘expired’, expired: ‘aaa’ }及{ type: ‘enum’, enum: [‘1’, ‘2’, ‘3’] }。针对type值为’expired’的校验规则，预先需要在AsyncValidator构造函数中注册expiredValidator校验器如let expiredValidator = (val, rule) =&gt; { if ( val === rule.expired ) cb(); else cb(util.format(‘value %s is not valid, %s expired’, val, rule.expired)) }。 值得反思的是，以上的图形界面，并没有提供关联校验的能力。 比较jquery-validate相比async-validator模块专司于数据校验，jquery-validate模块还承担着视图层的工作。因此数据在流入流出校验器时，都可能需要判断数据所属节点的标签名。在这里，笔者只概要地介绍该插件数据校验方面的流程。 内置校验器在jquery-validate模块源码中，校验方法注册在$.validator.prototype.methods（后文将用methods代替）属性中。校验方法的函数形式均为function(value, element, param)，参数value为待校验的值，element为待校验的元素，param为相应校验规则的值。校验方法又包含required非空检验，email校验，url校验，date校验，dateISO年-月-日校验，number数值（包含小数）校验，digits正整数校验，creditcard信用卡号校验，minlength最小长度校验，maxlength最大长度校验，rangelength长度范围校验，min最小值校验，max最大值校验，range范围校验，equalTo关联元素等值校验，remote远程校验。 挂载在元素上的校验规则通过let rules = { fieldName:{ required: true, min: 1 } }; $(“#form”).validate({ rules })形式设定。因此各校验方法获得的param参数也在于配置项rules.filedName对象，如methods.required校验方法获得的param为true，methods.min方法获得的param为1。特别的，在methods.required校验方法中，预先调用this.depend方法判断先决条件是否成立（前提是将required校验方法作为预先设置的最基础的校验器，其他校验方法都调用this.optional方法校验元素的值非空后，才进行特定的数据校验。该先决条件的成立与否都不影响校验显示结果），当param为字符串时，需要相应元素在页面中存在，这在联动显示隐藏的业务场景特别有用；当param为函数时，需要函数返回真值，这可用在关联校验等业务场景中；当param为布尔值时，无须判断先决条件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169$.validator.prototype.methods = &#123; // ... elementValue: function (element) &#123; var val, $element = $(element), type = element.type; if (type === \"radio\" || type === \"checkbox\") &#123; return this.findByName(element.name).filter(\":checked\").val(); &#125; else if (type === \"number\" &amp;&amp; typeof element.validity !== \"undefined\") &#123; return element.validity.badInput ? false : $element.val(); &#125; val = $element.val(); if (typeof val === \"string\") &#123; return val.replace(/\\r/g, \"\"); &#125; return val; &#125;, checkable: function (element) &#123; return (/radio|checkbox/i).test(element.type); &#125;, getLength: function (value, element) &#123; switch (element.nodeName.toLowerCase()) &#123; case \"select\": return $(\"option:selected\", element).length; case \"input\": if (this.checkable(element)) &#123; return this.findByName(element.name).filter(\":checked\").length; &#125; &#125; return value.length; &#125;, depend: function (param, element) &#123; return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true; &#125;, dependTypes: &#123; \"boolean\": function (param) &#123; return param; &#125;, \"string\": function (param, element) &#123; return !!$(param, element.form).length; &#125;, \"function\": function (param, element) &#123; return param(element); &#125; &#125;, optional: function (element) &#123; var val = this.elementValue(element); return !$.validator.methods.required.call(this, val, element) &amp;&amp; \"dependency-mismatch\"; &#125;, methods: &#123; // &#123;required:true&#125;、&#123;required:function()&#123;return $(anotherEle).val()&lt;12&#125;&#125;依赖条件 required: function(value, element, param) &#123; if (!this.depend(param, element)) &#123; return \"dependency-mismatch\"; &#125; if (element.nodeName.toLowerCase() === \"select\") &#123; // could be an array for select-multiple or a string, both are fine this way var val = $(element).val(); return val &amp;&amp; val.length &gt; 0; &#125; if (this.checkable(element)) &#123; return this.getLength(value, element) &gt; 0; &#125; return value.length &gt; 0; &#125;, email: function(value, element) &#123; return this.optional(element) || /^[a-zA-Z0-9.!#$%&amp;'*+\\/=?^_`&#123;|&#125;~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]&#123;0,61&#125;[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]&#123;0,61&#125;[a-zA-Z0-9])?)*$/.test(value); &#125;, url: function(value, element) &#123; return this.optional(element) || /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d&#123;1,3&#125;)&#123;3&#125;)(?!(?:169\\.254|192\\.168)(?:\\.\\d&#123;1,3&#125;)&#123;2&#125;)(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d&#123;1,3&#125;)&#123;2&#125;)(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d&#123;1,2&#125;|2[0-4]\\d|25[0-5]))&#123;2&#125;(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]&#123;2,&#125;)).?)(?::\\d&#123;2,5&#125;)?(?:[/?#]\\S*)?$/i.test(value); &#125;, date: function(value, element) &#123; return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString()); &#125;, dateISO: function(value, element) &#123; return this.optional(element) || /^\\d&#123;4&#125;[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])$/.test(value); &#125;, number: function(value, element) &#123; return this.optional(element) || /^(?:-?\\d+|-?\\d&#123;1,3&#125;(?:,\\d&#123;3&#125;)+)?(?:\\.\\d+)?$/.test(value); &#125;, digits: function(value, element) &#123; return this.optional(element) || /^\\d+$/.test(value); &#125;, // http://jqueryvalidation.org/creditcard-method/ // based on http://en.wikipedia.org/wiki/Luhn_algorithm creditcard: function(value, element) &#123; if (this.optional(element)) &#123; return \"dependency-mismatch\"; &#125; if (/[^0-9 \\-]+/.test(value)) &#123; return false; &#125; var nCheck = 0, nDigit = 0, bEven = false, n, cDigit; value = value.replace(/\\D/g, \"\"); // http://developer.ean.com/general_info/Valid_Credit_Card_Types if (value.length &lt; 13 || value.length &gt; 19) &#123; return false; &#125; for (n = value.length - 1; n &gt;= 0; n--) &#123; cDigit = value.charAt(n); nDigit = parseInt(cDigit, 10); if (bEven) &#123; if ((nDigit *= 2) &gt; 9) &#123; nDigit -= 9; &#125; &#125; nCheck += nDigit; bEven = !bEven; &#125; return (nCheck % 10) === 0; &#125;, minlength: function(value, element, param) &#123; var length = $.isArray(value) ? value.length : this.getLength(value, element); return this.optional(element) || length &gt;= param; &#125;, maxlength: function(value, element, param) &#123; var length = $.isArray(value) ? value.length : this.getLength(value, element); return this.optional(element) || length &lt;= param; &#125;, rangelength: function(value, element, param) &#123; var length = $.isArray(value) ? value.length : this.getLength(value, element); return this.optional(element) || (length &gt;= param[0] &amp;&amp; length &lt;= param[1]); &#125;, min: function(value, element, param) &#123; return this.optional(element) || value &gt;= param; &#125;, max: function(value, element, param) &#123; return this.optional(element) || value &lt;= param; &#125;, range: function(value, element, param) &#123; return this.optional(element) || (value &gt;= param[0] &amp;&amp; value &lt;= param[1]); &#125;, equalTo: function(value, element, param) &#123; // bind to the blur event of the target in order to revalidate whenever the target field is updated // TODO find a way to bind the event just once, avoiding the unbind-rebind overhead var target = $(param); if (this.settings.onfocusout) &#123; target.off(\".validate-equalTo\").on(\"blur.validate-equalTo\", function () &#123; $(element).valid();// 执行验证 &#125;); &#125; return value === target.val(); &#125;, // ... &#125;&#125; 远程校验关于methods.remote远程校验。与async-validadtor模块不同的是，首先async-validadtor模块并没有提供远程校验方法，其次async-validadtor模块有异步流程控制，jquery-validate模块没有，而是通过远程校验起始时自增1、结束时自减1的标识符this.pendingRequest，以及远程校验中元素的集合this.pending来感知远程校验的状态，随后才能提交表单。 在jquery-validate模块中，远程校验的校验规则配置形式为rule = { remote: url }或rule = { url, …params }。参数url为请求地址，其余参数params以深拷贝的形式改变$.ajax方法的参数，可以包含data属性改变请求数据（默认值为表单项name值和表单项数据组成的键值对），success改变成功时的回调函数。默认的成功回调success中，当响应为真值，即为校验成功；为否值，即为校验失败。改写这个成功回调，需要调用者对jquery-validate模块的机制比较理解。 在性能方面，jquery-validate模块会在校验元素的’data-previousValue’属性中缓存上次的校验数据及结果。当元素的当前值和缓存数据相同时，直接使用缓存中的校验结果。为避免同一个校验元素连续发送多次请求，jquery-validate模块通过扩展$.ajax实现，当有新一轮请求时，将前一轮请求abort终结掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124$.validator.prototype = &#123; // ... previousValue: function (element) &#123; return $.data(element, \"previousValue\") || $.data(element, \"previousValue\", &#123; old: null, valid: true, message: this.defaultMessage(element, \"remote\") &#125;); &#125;, startRequest: function (element) &#123; if (!this.pending[element.name]) &#123; this.pendingRequest++; this.pending[element.name] = true; &#125; &#125;, stopRequest: function (element, valid) &#123; this.pendingRequest--; // sometimes synchronization fails, make sure pendingRequest is never &lt; 0 if (this.pendingRequest &lt; 0) &#123; this.pendingRequest = 0; &#125; delete this.pending[element.name]; if (valid &amp;&amp; this.pendingRequest === 0 &amp;&amp; this.formSubmitted &amp;&amp; this.form()) &#123; $(this.currentForm).submit(); this.formSubmitted = false; &#125; else if (!valid &amp;&amp; this.pendingRequest === 0 &amp;&amp; this.formSubmitted) &#123; $(this.currentForm).triggerHandler(\"invalid-form\", [this]); this.formSubmitted = false; &#125; &#125;,&#125;// http://jqueryvalidation.org/remote-method/$.validator.prototype.methods.remote = function(value, element, param) &#123; if (this.optional(element)) &#123; return \"dependency-mismatch\"; &#125; var previous = this.previousValue(element),// 获取上一次的验证结果、值。提示文本 validator, data; if (!this.settings.messages[element.name]) &#123; this.settings.messages[element.name] = &#123;&#125;; &#125; previous.originalMessage = this.settings.messages[element.name].remote; this.settings.messages[element.name].remote = previous.message; param = typeof param === \"string\" &amp;&amp; &#123; url: param &#125; || param; // 当前验证与上一次情形相同，返回前一次验证结果 if (previous.old === value) &#123; return previous.valid; &#125; previous.old = value; validator = this; this.startRequest(element); data = &#123;&#125;; data[element.name] = value; $.ajax($.extend(true, &#123; mode: \"abort\", port: \"validate\" + element.name,// port和元素name相关，发送ajax后pendingRequests[port]标记为有值，阻止同一个元素发送两次ajax dataType: \"json\", data: data, context: validator.currentForm, success: function (response) &#123; var valid = response === true || response === \"true\", errors, message, submitted; validator.settings.messages[element.name].remote = previous.originalMessage; if (valid) &#123; submitted = validator.formSubmitted; validator.prepareElement(element); validator.formSubmitted = submitted; validator.successList.push(element); delete validator.invalid[element.name]; validator.showErrors(); &#125; else &#123; errors = &#123;&#125;; message = response || validator.defaultMessage(element, \"remote\"); errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message; validator.invalid[element.name] = true; validator.showErrors(errors); &#125; previous.valid = valid; validator.stopRequest(element, valid); &#125; &#125;, param)); return \"pending\"; &#125;var pendingRequests = &#123;&#125;, ajax;// Use a prefilter if available (1.5+) // 为ajax方法添加abort、port标志，阻止同一验证元素在前一次ajax未完成时，再度发起ajax请求if ($.ajaxPrefilter) &#123; // ajaxPrefilter发送前的预处理，setting请求的所有参数，xhr经过jquery封装的XMLHttpRequest对象 $.ajaxPrefilter(function (settings, _, xhr) &#123; var port = settings.port; if (settings.mode === \"abort\") &#123; if (pendingRequests[port]) &#123; pendingRequests[port].abort(); &#125; pendingRequests[port] = xhr; &#125; &#125;);&#125; else &#123; ajax = $.ajax; $.ajax = function (settings) &#123; var mode = (\"mode\" in settings ? settings : $.ajaxSettings).mode, port = (\"port\" in settings ? settings : $.ajaxSettings).port; if (mode === \"abort\") &#123; if (pendingRequests[port]) &#123; pendingRequests[port].abort();// abort()用来终止ajax请求，还是会执行success回调，返回值为空 &#125; pendingRequests[port] = ajax.apply(this, arguments); return pendingRequests[port]; &#125; return ajax.apply(this, arguments); &#125;;&#125; 注册校验器在jquery-validate模块中，注册校验方法通过调用addMethod实现。与async-validadtor模块相比较，jquery-validate模块稍显得不够灵活，只能将自定义校验器注册为methods下属的方法，而不能直接使用外部函数。 $.validator = { // … addMethod: function (name, method, message) { $.validator.methods[name] = method; $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name]; if (method.length &lt; 3) { $.validator.addClassRules(name, $.validator.normalizeRule(name)); } },} 校验在jquery-validate模块中，实际的校验过程通过调用this.check方法执行，无论是整张表单校验，还是单个表单项校验。在check方法内部，也即遍历校验规则，调用methods下属的方法完成校验。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$.validator.prototype = &#123; // ... check: function (element) &#123; element = this.validationTargetFor(this.clean(element));// 获取当前验证元素 var rules = $(element).rules(),// 获取元素的验证规则 rulesCount = $.map(rules, function (n, i) &#123; return i; &#125;).length, dependencyMismatch = false, val = this.elementValue(element), result, method, rule; for (method in rules) &#123; rule = &#123; method: method, parameters: rules[method] &#125;; try &#123; result = $.validator.methods[method].call(this, val, element, rule.parameters); // 依赖条件不成立，跳过验证 if (result === \"dependency-mismatch\" &amp;&amp; rulesCount === 1) &#123; dependencyMismatch = true; continue; &#125; dependencyMismatch = false; if (result === \"pending\") &#123; this.toHide = this.toHide.not(this.errorsFor(element)); return; &#125; if (!result) &#123; this.formatAndAdd(element, rule);// 获取错误文案，并向this.errorList塞值 return false; &#125; &#125; catch (e) &#123; if (this.settings.debug &amp;&amp; window.console) &#123; console.log(\"Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\", e); &#125; if (e instanceof TypeError) &#123; e.message += \". Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\"; &#125; throw e; &#125; &#125; if (dependencyMismatch) &#123; return; &#125; if (this.objectLength(rules)) &#123; this.successList.push(element); &#125; return true; &#125;,&#125; 错误文案在jquery-validate模块中，错误文案的实现与async-validator模块基本相同。因为jquery-validate模块没有灵活的自定义校验器概念，错误文案都通过配置项注入，可以用通用的format方法对其格式化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778$.validator = &#123; // ... format: function (source, params) &#123; if (arguments.length === 1) &#123; return function () &#123; var args = $.makeArray(arguments); args.unshift(source); return $.validator.format.apply(this, args); &#125;; &#125; if (arguments.length &gt; 2 &amp;&amp; params.constructor !== Array) &#123; params = $.makeArray(arguments).slice(1); &#125; if (params.constructor !== Array) &#123; params = [params]; &#125; $.each(params, function (i, n) &#123; source = source.replace(new RegExp(\"\\\\&#123;\" + i + \"\\\\&#125;\", \"g\"), function () &#123; return n; &#125;); &#125;); return source; &#125;, messages: &#123; required: \"This field is required.\", remote: \"Please fix this field.\", email: \"Please enter a valid email address.\", url: \"Please enter a valid URL.\", date: \"Please enter a valid date.\", dateISO: \"Please enter a valid date ( ISO ).\", number: \"Please enter a valid number.\", digits: \"Please enter only digits.\", creditcard: \"Please enter a valid credit card number.\", equalTo: \"Please enter the same value again.\", maxlength: $.validator.format(\"Please enter no more than &#123;0&#125; characters.\"), minlength: $.validator.format(\"Please enter at least &#123;0&#125; characters.\"), rangelength: $.validator.format(\"Please enter a value between &#123;0&#125; and &#123;1&#125; characters long.\"), range: $.validator.format(\"Please enter a value between &#123;0&#125; and &#123;1&#125;.\"), max: $.validator.format(\"Please enter a value less than or equal to &#123;0&#125;.\"), min: $.validator.format(\"Please enter a value greater than or equal to &#123;0&#125;.\") &#125;,&#125;$.validator.prototype = &#123; // ... defaultMessage: function (element, method) &#123; return this.findDefined(// this.findDefined输出首个真值的参数 this.customMessage(element.name, method),// html设置的错误文案，字符串 this.customDataMessage(element, method),// js代码设置的错误文案，字符串或函数 // title is never undefined, so handle empty string as undefined !this.settings.ignoreTitle &amp;&amp; element.title || undefined, $.validator.messages[method], \"&lt;strong&gt;Warning: No message defined for \" + element.name + \"&lt;/strong&gt;\" ); &#125;, formatAndAdd: function (element, rule) &#123; var message = this.defaultMessage(element, rule.method),// 获取错误文案 theregex = /\\$?\\&#123;(\\d+)\\&#125;/g; if (typeof message === \"function\") &#123; message = message.call(this, rule.parameters, element); &#125; else if (theregex.test(message)) &#123; message = $.validator.format(message.replace(theregex, \"&#123;$1&#125;\"), rule.parameters); &#125; this.errorList.push(&#123; message: message, element: element, method: rule.method &#125;); this.errorMap[element.name] = message; this.submitted[element.name] = message; &#125;,&#125; jquery-validationjquery-validation模块的校验流程完全仿照jquery-validate，只是增加了额外的校验方法和语言包。笔者扼要说明一下部分校验方法的功能，代码不再赘述。 require_from_group方法校验指定相关元素(name值查找)选中项的个数不小于指定值时，予以校验通过skip_or_fill_minimum方法校验相关元素(name值查找)未赋值或选中项个数不小于指定值时，予以校验通过。pattern方法正则匹配。notEqualTo方法校验不等于指定值。integer方法校验整数，可以时负整数。maxWords、minWords、rangeWords方法校验字符数量，剔除html标签和标点符号后。strippedminlength方法校验文本长度不能小于指定值。nowhitespace方法校验非空字符串。lettersonly方法校验字符串。letterswithbasicpunc方法校验带基本标点符号的字符串，通过正则表达式 /^[a-z-.,()’”\\s]+$/i 。alphanumeric方法校验值是否为字符串、下划线、数值中的一种，通过正则表达式 /^\\w+$/i 。url2方法校验网址。dateFA、dateITA、dateNL校验日期。time、time12h校验时分，24小时制或12小时制。accept方法校验上传文件的类型。extension方法校验文件的扩展名。ipv4方法校验IP v4地址。ipv6方法校验IP v6地址。currency方法校验货币金额，可带有币种标识。mobileNL、mobileUK方法校验特定地区或国家的手机号。phoneNL、phonesUK、phoneUK、phoneUS方法校验特定地区或国家的移动电话号码。postalcodeBR、postalCodeCA、postalcodeNL、postcodeUK、zipcodeUS、ziprange方法校验特定地区或国家的邮政编码。bankaccountNL方法校验是否银行账号。giroaccountNL方法校验是否转账账号。bankorgiroaccountNL方法校验是否银行账号或者转账账号。iban方法校验国际银行账号。bic方法校验是否商业识别码。cifES方法校验是否西班牙纳税识别号。cpfBR方法校验是否巴西纳税识别号。creditcardtypes方法校验信用卡号是否为特定类型。vinUS方法校验汽车编号。stateUS方法校验美国的州或地区。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://xzfyu.com/categories/frontend/"},{"name":"antd","slug":"frontend/antd","permalink":"http://xzfyu.com/categories/frontend/antd/"}],"tags":[{"name":"analyst","slug":"analyst","permalink":"http://xzfyu.com/tags/analyst/"},{"name":"validate","slug":"validate","permalink":"http://xzfyu.com/tags/validate/"}]}]}