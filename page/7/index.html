<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="人苦不知足，既得陇，复望蜀">
<meta property="og:type" content="website">
<meta property="og:title" content="修子范语">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="修子范语">
<meta property="og:description" content="人苦不知足，既得陇，复望蜀">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="修子范语">
<meta name="twitter:description" content="人苦不知足，既得陇，复望蜀">






  <link rel="canonical" href="http://yoursite.com/page/7/">


  <title>修子范语</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">修子范语</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Alfredo's Notes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/antd/react-component/rc-trigger/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/antd/react-component/rc-trigger/" itemprop="url">rc-trigger</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/antd-组件库/" itemprop="url" rel="index"><span itemprop="name">antd 组件库</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/25/antd/react-component/rc-trigger/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/25/antd/react-component/rc-trigger/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>rc-trigger 集成了弹层显示隐藏的处理逻辑，以便在操作挂载元素时显示和隐藏弹层。简单的使用场景如：当鼠标移入帮助符号时，显示文本提示；当鼠标移出时，隐藏文本提示。rc-trigger 的组件层级如下：</p>
<img src="/2019/02/25/antd/react-component/rc-trigger/层级结构.png">
<p>为适配弹层的多种处理逻辑，rc-trigger 统一在弹层触发元素外围以虚拟组件 Trigger 的形式组织弹层显示隐藏的处理逻辑。为使弹层不受触发元素位置及大小的影响，rc-trigger 统一将弹层插入到 document 根节点中：Popup 组件既用于绘制蒙层，又用于组织弹层的动效以及调整弹层的位置；PopupInner 对接 Trigger，弹层实际内容外围挂载鼠标移入移出事件对弹层的影响；LazyRenderBox 根据 props.visible 等属性，决定是否需要绘制弹层实际内容，还是绘制空的 div 元素；popup 用于渲染弹层的实际内容。</p>
<p>作为对外交互组件，Trigger 实现了系列方法管理着弹层的显示隐藏状态 state.popupVisible，该值即作为 LazyRenderBox 组件获得的 props.visible 属性。rc-trigger 针对弹层的显示隐藏状态，有两种事件处理逻辑：以指定的事件操纵触发元素时显示弹层；或者如鼠标移出弹层时隐藏弹层。因为这两种事件处理逻辑都与弹层的显示隐藏状态有关，所以都在 Trigger 组件内实现。Trigger 组件向下对接 PopupInner 组件，为其注入 props.onMouseLeave 等方法以操纵弹层的显隐。Trigger 组件内部实现 onClick 等方法，这样就可以在点击触发元素时显示弹层。最终，Trigger 组件对外透出可配置的 props 属性，以满足开发者的特定处理逻辑。同样的，为使 Popup 组件中实现的弹层动效处理逻辑、弹层调整方式可配置，Trigger 组件的 props 属性覆盖了弹层动效、位置相关的配置项。</p>
<p>这样的处理机制有其一般性，即在构造抽象组件时，在父组件中实现抽象组件层级的视图状态和状态管理方法，并将子组件中使用的状态管理方法透传到子组件中，以使透传的状态管理方法和子组件的渲染内容相互绑定；再由父组件对外提供可配置项，既可以定制父组件的处理逻辑，也可以定制子组件的处理逻辑，从而满足开发者的特定需求。</p>
<p>对于 Trigger 组件的处理逻辑，小结如下：</p>
<ol>
<li>渲染时将弹层插入 document 根节点。</li>
<li>通过 props.action, props.showAction, props.hideAction 指定切换弹层显示隐藏状态的事件；在 Trigger 组件中实现诸如 onClick 等方法以切换弹层的显示隐藏状态。</li>
<li>在 Trigger 组件中实现 onPopupMouseLeave 等方法，透传到 PopupInner 组件中，以使鼠标移出弹层时隐藏弹层。</li>
<li>Trigger 将弹层动效、位置调整相关属性传入 Popup 组件中。</li>
</ol>
<h2 id="弹层渲染"><a href="#弹层渲染" class="headerlink" title="弹层渲染"></a>弹层渲染</h2><p>当使用 react16 框架，弹层渲染实际借助于 ReactDOM.createPortal 方法，由 rc-utils 提供 Protal 组件；当没有使用 react16 框架，弹层渲染通过 rc-utils 提供的 ContainerRender 组件完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有指定 props.getPopupContainer 时，弹层在根节点中创建 div 元素并完成渲染</span></span><br><span class="line">getContainer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; props &#125; = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> popupContainer = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="comment">// Make sure default popup container will never cause scrollbar appearing</span></span><br><span class="line">  <span class="comment">// https://github.com/react-component/trigger/issues/41</span></span><br><span class="line">  popupContainer.style.position = <span class="string">'absolute'</span>;</span><br><span class="line">  popupContainer.style.top = <span class="string">'0'</span>;</span><br><span class="line">  popupContainer.style.left = <span class="string">'0'</span>;</span><br><span class="line">  popupContainer.style.width = <span class="string">'100%'</span>;</span><br><span class="line">  <span class="keyword">const</span> mountNode = props.getPopupContainer ?</span><br><span class="line">    props.getPopupContainer(findDOMNode(<span class="keyword">this</span>)) : props.getDocument().body;</span><br><span class="line">  mountNode.appendChild(popupContainer);</span><br><span class="line">  <span class="keyword">return</span> popupContainer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// getComponent 渲染 Popup 等弹层组件</span></span><br><span class="line">  <span class="keyword">if</span> (!IS_REACT_16) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ContainerRender</span><br><span class="line">        parent=&#123;<span class="keyword">this</span>&#125;</span><br><span class="line">        visible=&#123;popupVisible&#125;</span><br><span class="line">        autoMount=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">        forceRender=&#123;forceRender&#125;</span><br><span class="line">        getComponent=&#123;<span class="keyword">this</span>.getComponent&#125;</span><br><span class="line">        getContainer=&#123;<span class="keyword">this</span>.getContainer&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;(&#123; renderComponent &#125;) =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.renderComponent = renderComponent;</span><br><span class="line">          <span class="keyword">return</span> trigger;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/ContainerRender&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  let portal;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ prevent unmounting after it's rendered</span></span><br><span class="line"><span class="regexp">  if (popupVisible || this._component || forceRender) &#123;</span></span><br><span class="line"><span class="regexp">    portal = (</span></span><br><span class="line"><span class="regexp">      &lt;Portal</span></span><br><span class="line"><span class="regexp">        key="portal"</span></span><br><span class="line"><span class="regexp">        getContainer=&#123;this.getContainer&#125;</span></span><br><span class="line"><span class="regexp">        didUpdate=&#123;this.handlePortalUpdate&#125;</span></span><br><span class="line"><span class="regexp">      &gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.getComponent()&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Portal&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    trigger,</span><br><span class="line">    portal,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="触发元素的绑定事件"><a href="#触发元素的绑定事件" class="headerlink" title="触发元素的绑定事件"></a>触发元素的绑定事件</h2><p>触发元素上可绑定的事件包含 ‘onClick’, ‘onMouseDown’, ‘onTouchStart’, ‘onMouseEnter’, ‘onMouseLeave’, ‘onFocus’, ‘onBlur’, ‘onContextMenu’。props.action, props.showAction, props.hideAction 就允许开发者以数组形式指定触发元素上绑定的事件。同时，Trigger 组件中实现了 isClickToShow 等方法用于判断开发者指定在触发元素的绑定事件。若 isClickToShow 方法返回真值时，那么触发元素上绑定的 onClick 方法就可以调用 Trigger 组件的内置处理逻辑，以显示或隐藏弹层；否则，触发元素上绑定的 onClick 方法就只能调用开发者传给 Trigger 组件或触发元素 children 的 props.onClick。其他事件的处理机制与此类同。</p>
<p>在实现上，rc-trigger 有两层处理逻辑：若所处理的事件不影响弹层的显示隐藏状态，将 createTwoChains 创建的兜底函数作为绑定函数，直接调用外层 Trigger 元素或 children 触发元素的 props 同名方法；若影响，使用内置的 onClick 方法作为事件的绑定函数，以切换弹层的显示隐藏状态。下面就是兜底函数和内置绑定函数的实现，内置绑定函数仅以 onClick 作为示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 事件的兜底处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', </span></span><br><span class="line"><span class="comment">// 'onMouseLeave', 'onFocus', 'onBlur', 'onContextMenu'];</span></span><br><span class="line">componentWillMount() &#123;</span><br><span class="line">  ALL_HANDLERS.forEach(<span class="function">(<span class="params">h</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="string">`fire<span class="subst">$&#123;h&#125;</span>`</span>] = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.fireEvents(h, e);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先调用触发元素 children 的 props 方法，再调用 Trigger 元素的 props 方法</span></span><br><span class="line">fireEvents(type, e) &#123;</span><br><span class="line">  <span class="keyword">const</span> childCallback = <span class="keyword">this</span>.props.children.props[type];</span><br><span class="line">  <span class="keyword">if</span> (childCallback) &#123;</span><br><span class="line">    childCallback(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> callback = <span class="keyword">this</span>.props[type];</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    callback(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 render 时作为触发元素 children 实际绑定的方法</span></span><br><span class="line">createTwoChains(event) &#123;</span><br><span class="line">  <span class="keyword">const</span> childPros = <span class="keyword">this</span>.props.children.props;</span><br><span class="line">  <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">if</span> (childPros[event] &amp;&amp; props[event]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="string">`fire<span class="subst">$&#123;event&#125;</span>`</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> childPros[event] || props[event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过事件显隐弹层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时或延迟显隐弹窗</span></span><br><span class="line">delaySetPopupVisible(visible, delayS, event) &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = delayS * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">this</span>.clearDelayTimer();</span><br><span class="line">  <span class="keyword">if</span> (delay) &#123;</span><br><span class="line">    <span class="keyword">const</span> point = event ? &#123; <span class="attr">pageX</span>: event.pageX, <span class="attr">pageY</span>: event.pageY &#125; : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.delayTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setPopupVisible(visible, point);</span><br><span class="line">      <span class="keyword">this</span>.clearDelayTimer();</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setPopupVisible(visible, event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.fireEvents(<span class="string">'onClick'</span>, event);</span><br><span class="line">  <span class="comment">// focus will trigger click</span></span><br><span class="line">  <span class="comment">// 聚焦时快速点击，不必隐藏弹层</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.focusTime) &#123;</span><br><span class="line">    <span class="keyword">let</span> preTime;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.preClickTime &amp;&amp; <span class="keyword">this</span>.preTouchTime) &#123;</span><br><span class="line">      preTime = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.preClickTime, <span class="keyword">this</span>.preTouchTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.preClickTime) &#123;</span><br><span class="line">      preTime = <span class="keyword">this</span>.preClickTime;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.preTouchTime) &#123;</span><br><span class="line">      preTime = <span class="keyword">this</span>.preTouchTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(preTime - <span class="keyword">this</span>.focusTime) &lt; <span class="number">20</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.focusTime = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.preClickTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.preTouchTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (event &amp;&amp; event.preventDefault) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextVisible = !<span class="keyword">this</span>.state.popupVisible;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isClickToHide() &amp;&amp; !nextVisible || nextVisible &amp;&amp; <span class="keyword">this</span>.isClickToShow()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setPopupVisible(!<span class="keyword">this</span>.state.popupVisible, event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onMouseDown = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.fireEvents(<span class="string">'onMouseDown'</span>, e);</span><br><span class="line">  <span class="keyword">this</span>.preClickTime = <span class="built_in">Date</span>.now();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onTouchStart = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.fireEvents(<span class="string">'onTouchStart'</span>, e);</span><br><span class="line">  <span class="keyword">this</span>.preTouchTime = <span class="built_in">Date</span>.now();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onFocus = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.fireEvents(<span class="string">'onFocus'</span>, e);</span><br><span class="line">  <span class="comment">// incase focusin and focusout</span></span><br><span class="line">  <span class="keyword">this</span>.clearDelayTimer();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isFocusToShow()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.focusTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">this</span>.delaySetPopupVisible(<span class="literal">true</span>, <span class="keyword">this</span>.props.focusDelay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弹层的绑定事件"><a href="#弹层的绑定事件" class="headerlink" title="弹层的绑定事件"></a>弹层的绑定事件</h2><p>当弹层已经显示时，rc-trigger 既支持在文档被点击时隐藏弹层，又支持在鼠标移出弹层时隐藏弹层。因此，Trigger 组件中有两种相关的处理逻辑：对于文档中挂载的事件，Trigger 组件在 componentDidUpdate 生命周期中对 document 节点绑定事件，所绑定的事件不限于点击，还包含文档滚动、窗口失焦；对于弹层挂载的事件，Trigger 组件实现了 onPopupMouseEnter, onPopupMouseLeave, onPopupMouseDown 方法，并透传给 PopupInner 组件，作为该组件渲染内容的绑定函数。其实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 文档绑定事件处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据可操控弹层显隐的事件，对 document 或 window 绑定事件处理函数</span></span><br><span class="line">componentDidUpdate(_, prevState) &#123;</span><br><span class="line">  <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">this</span>.state;</span><br><span class="line">  <span class="keyword">const</span> triggerAfterPopupVisibleChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevState.popupVisible !== state.popupVisible) &#123;</span><br><span class="line">      props.afterPopupVisibleChange(state.popupVisible);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (!IS_REACT_16) &#123;</span><br><span class="line">    <span class="keyword">this</span>.renderComponent(<span class="literal">null</span>, triggerAfterPopupVisibleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.prevPopupVisible = prevState.popupVisible;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We must listen to `mousedown` or `touchstart`, edge case:</span></span><br><span class="line">  <span class="comment">// https://github.com/ant-design/ant-design/issues/5804</span></span><br><span class="line">  <span class="comment">// https://github.com/react-component/calendar/issues/250</span></span><br><span class="line">  <span class="comment">// https://github.com/react-component/trigger/issues/50</span></span><br><span class="line">  <span class="keyword">if</span> (state.popupVisible) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentDocument;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.clickOutsideHandler &amp;&amp; (<span class="keyword">this</span>.isClickToHide() || <span class="keyword">this</span>.isContextMenuToShow())) &#123;</span><br><span class="line">      currentDocument = props.getDocument();</span><br><span class="line">      <span class="keyword">this</span>.clickOutsideHandler = addEventListener(currentDocument,</span><br><span class="line">        <span class="string">'mousedown'</span>, <span class="keyword">this</span>.onDocumentClick);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// always hide on mobile</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.touchOutsideHandler) &#123;</span><br><span class="line">      currentDocument = currentDocument || props.getDocument();</span><br><span class="line">      <span class="keyword">this</span>.touchOutsideHandler = addEventListener(currentDocument,</span><br><span class="line">        <span class="string">'touchstart'</span>, <span class="keyword">this</span>.onDocumentClick);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close popup when trigger type contains 'onContextMenu' and document is scrolling.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.contextMenuOutsideHandler1 &amp;&amp; <span class="keyword">this</span>.isContextMenuToShow()) &#123;</span><br><span class="line">      currentDocument = currentDocument || props.getDocument();</span><br><span class="line">      <span class="keyword">this</span>.contextMenuOutsideHandler1 = addEventListener(currentDocument,</span><br><span class="line">        <span class="string">'scroll'</span>, <span class="keyword">this</span>.onContextMenuClose);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close popup when trigger type contains 'onContextMenu' and window is blur.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.contextMenuOutsideHandler2 &amp;&amp; <span class="keyword">this</span>.isContextMenuToShow()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.contextMenuOutsideHandler2 = addEventListener(<span class="built_in">window</span>,</span><br><span class="line">        <span class="string">'blur'</span>, <span class="keyword">this</span>.onContextMenuClose);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.clearOutsideHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当蒙层可关闭时，点击文档关闭弹层</span></span><br><span class="line">onDocumentClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.mask &amp;&amp; !<span class="keyword">this</span>.props.maskClosable) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> target = event.target;</span><br><span class="line">  <span class="keyword">const</span> root = findDOMNode(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (!contains(root, target) &amp;&amp; !<span class="keyword">this</span>.hasPopupMouseDown) &#123;</span><br><span class="line">    <span class="keyword">this</span>.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标右键可显示弹层时，通过文档滚动、窗口失焦可隐藏弹层</span></span><br><span class="line">onContextMenuClose = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isContextMenuToShow()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setPopupVisible(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 弹层绑定事件处理函数</span></span><br><span class="line"></span><br><span class="line">onPopupMouseEnter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.clearDelayTimer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当鼠标移出弹层时，隐藏弹层</span></span><br><span class="line"><span class="comment">// this._component 即 Popup 组件实例</span></span><br><span class="line"><span class="comment">// this._component.getPopupDomNode 用于获取 PopupInner 组件绘制的节点内容</span></span><br><span class="line">onPopupMouseLeave = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// https://github.com/react-component/trigger/pull/13</span></span><br><span class="line">  <span class="comment">// react bug?</span></span><br><span class="line">  <span class="keyword">if</span> (e.relatedTarget &amp;&amp; !e.relatedTarget.setTimeout &amp;&amp;</span><br><span class="line">    <span class="keyword">this</span>._component &amp;&amp;</span><br><span class="line">    <span class="keyword">this</span>._component.getPopupDomNode &amp;&amp;</span><br><span class="line">    contains(<span class="keyword">this</span>._component.getPopupDomNode(), e.relatedTarget)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.delaySetPopupVisible(<span class="literal">false</span>, <span class="keyword">this</span>.props.mouseLeaveDelay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击弹层变更 Trigger 实例的 hasPopupMouseDown 属性，以指定文档点击区域不是弹层内部</span></span><br><span class="line"><span class="comment">// 当弹层相互嵌套时，向上递归调用 onPopupMouseDown 方法也用于阻止祖先弹层的隐藏</span></span><br><span class="line">onPopupMouseDown = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; rcTrigger = &#123;&#125; &#125; = <span class="keyword">this</span>.context;</span><br><span class="line">  <span class="keyword">this</span>.hasPopupMouseDown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  clearTimeout(<span class="keyword">this</span>.mouseDownTimeout);</span><br><span class="line">  <span class="keyword">this</span>.mouseDownTimeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasPopupMouseDown = <span class="literal">false</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rcTrigger.onPopupMouseDown) &#123;</span><br><span class="line">    rcTrigger.onPopupMouseDown(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="弹层位置调整及动效"><a href="#弹层位置调整及动效" class="headerlink" title="弹层位置调整及动效"></a>弹层位置调整及动效</h2><h3 id="位置调整"><a href="#位置调整" class="headerlink" title="位置调整"></a>位置调整</h3><p>弹层的位置调整基于 rc-align 类库。在实现上，通过将 props.alignPoint 置为真值，弹层位置即可根据鼠标移动情况进行调整；默认情况下，弹层位置取决于触发元素的显示位置。Trigger 将动态计算鼠标的位置 state.point，随后将 props.align 注入到 Popup 组件。若 Popup 组件接受的 props.align 为否值，弹层位置即取决于触发元素的显示位置；否则，由鼠标位置决定。在位置调整过程中，Trigger 组件接受的 props.onPopupAlign 可用于监听弹层位置的调整状况，以便于动态微调。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取实际注入 dom-align 类库的 alignConfig 配置，用于调整弹层位置</span></span><br><span class="line"><span class="comment">// 参见 https://github.com/yiminghe/dom-align</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlignFromPlacement</span>(<span class="params">builtinPlacements, placementStr, align</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> baseAlign = builtinPlacements[placementStr] || &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...baseAlign,</span><br><span class="line">    ...align,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trigger</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// props.builtinPlacements 内置多种弹层放置策略，实际使用 props.popupPlacement 放置策略</span></span><br><span class="line">  <span class="comment">// props.popupAlign 作为 dom-align 库获得的 alignConfig 配置，用于调整位置</span></span><br><span class="line">  getPopupAlign() &#123;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; popupPlacement, popupAlign, builtinPlacements &#125; = props;</span><br><span class="line">    <span class="keyword">if</span> (popupPlacement &amp;&amp; builtinPlacements) &#123;</span><br><span class="line">      <span class="keyword">return</span> getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> popupAlign;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 props.alignPoint 为真值，Popup 组件获得的 props.align 即为 state.point</span></span><br><span class="line">  <span class="comment">// 意义是弹层的定位位置将根据鼠标位置进行调整</span></span><br><span class="line">  setPoint = <span class="function">(<span class="params">point</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; alignPoint &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">if</span> (!alignPoint || !point) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      point: &#123;</span><br><span class="line">        pageX: point.pageX,</span><br><span class="line">        pageY: point.pageY,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Popup</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 位置调整时调用</span></span><br><span class="line">  onAlign = <span class="function">(<span class="params">popupDomNode, align</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> currentAlignClassName = props.getClassNameFromAlign(align);</span><br><span class="line">    <span class="comment">// FIX: https://github.com/react-component/trigger/issues/56</span></span><br><span class="line">    <span class="comment">// FIX: https://github.com/react-component/tooltip/issues/79</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentAlignClassName !== currentAlignClassName) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentAlignClassName = currentAlignClassName;</span><br><span class="line">      popupDomNode.className = <span class="keyword">this</span>.getClassName(currentAlignClassName);</span><br><span class="line">    &#125;</span><br><span class="line">    props.onAlign(popupDomNode, align);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取弹层的定位位置，有两种可能：根据鼠标调整，或者触发元素的位置</span></span><br><span class="line">  getAlignTarget = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; point &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">if</span> (point) &#123;</span><br><span class="line">      <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getTargetElement 方法由 Trigger 注入，用于获取 Trigger 元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getTargetElement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 Align 虚拟组件包裹实际渲染内容，调整弹层的显示位置</span></span><br><span class="line">  getPopupElement() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &lt;Align target=&#123;<span class="keyword">this</span>.getAlignTarget()&#125; key=<span class="string">"popup"</span> ref=&#123;<span class="keyword">this</span>.saveAlignRef&#125;</span><br><span class="line">      monitorWindowResize align=&#123;align&#125; onAlign=&#123;<span class="keyword">this</span>.onAlign&#125;&gt;</span><br><span class="line">      &lt;PopupInner visible &#123;...popupInnerProps&#125;&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;<span class="regexp">/PopupInner&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Align&gt;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态伸缩"><a href="#动态伸缩" class="headerlink" title="动态伸缩"></a>动态伸缩</h3><p>当指定 props.stretch 为真时，弹层大小可根据触发元素动态伸缩。这一机制在 Popup 组件中实现，即通过 setStretchSize 方法计算触发元素的宽高，在 render 阶段（getPopupElement 方法执行过程中）影响弹层的 style。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.rootNode = <span class="keyword">this</span>.getPopupDomNode();</span><br><span class="line">  <span class="keyword">this</span>.setStretchSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setStretchSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setStretchSize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; stretch, getRootDomNode, visible &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">const</span> &#123; stretchChecked, targetHeight, targetWidth &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!stretch || !visible) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stretchChecked) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">stretchChecked</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> $ele = getRootDomNode();</span><br><span class="line">  <span class="keyword">if</span> (!$ele) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> height = $ele.offsetHeight;</span><br><span class="line">  <span class="keyword">const</span> width = $ele.offsetWidth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (targetHeight !== height || targetWidth !== width || !stretchChecked) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      stretchChecked: <span class="literal">true</span>,</span><br><span class="line">      targetHeight: height,</span><br><span class="line">      targetWidth: width,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="弹层动效"><a href="#弹层动效" class="headerlink" title="弹层动效"></a>弹层动效</h3><p>弹层的动效基于 rc-animate 类库实现：包含蒙层和弹层实际内容的动效。动效可配置项都通过 Trigger 组件的 props.popupAnimation, props.popupTransitionName, props.maskAnimation, props.maskTransitionName 属性向外对接，又通过 Popup 组件的 getMaskTransitionName, getTransitionName 方法转化，然后完成渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rc-trigger 不支持 js 动效，将 animation 转化成 transitionName</span></span><br><span class="line"><span class="comment">// 以影响 rc-animate 类库输出的 Animate 组件</span></span><br><span class="line">getMaskTransitionName() &#123;</span><br><span class="line">  <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">let</span> transitionName = props.maskTransitionName;</span><br><span class="line">  <span class="keyword">const</span> animation = props.maskAnimation;</span><br><span class="line">  <span class="keyword">if</span> (!transitionName &amp;&amp; animation) &#123;</span><br><span class="line">    transitionName = <span class="string">`<span class="subst">$&#123;props.prefixCls&#125;</span>-<span class="subst">$&#123;animation&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> transitionName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getTransitionName() &#123;</span><br><span class="line">  <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">let</span> transitionName = props.transitionName;</span><br><span class="line">  <span class="keyword">if</span> (!transitionName &amp;&amp; props.animation) &#123;</span><br><span class="line">    transitionName = <span class="string">`<span class="subst">$&#123;props.prefixCls&#125;</span>-<span class="subst">$&#123;props.animation&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> transitionName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染弹层内容</span></span><br><span class="line">getPopupElement() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (destroyPopupOnHide) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Animate component=<span class="string">""</span> exclusive transitionAppear</span><br><span class="line">        transitionName=&#123;<span class="keyword">this</span>.getTransitionName()&#125;&gt;</span><br><span class="line">        &#123;visible ? (</span><br><span class="line">          &lt;Align target=&#123;<span class="keyword">this</span>.getAlignTarget()&#125; key=<span class="string">"popup"</span> ref=&#123;<span class="keyword">this</span>.saveAlignRef&#125;</span><br><span class="line">            monitorWindowResize align=&#123;align&#125; onAlign=&#123;<span class="keyword">this</span>.onAlign&#125;&gt;</span><br><span class="line">            &lt;PopupInner visible &#123;...popupInnerProps&#125;&gt;</span><br><span class="line">              &#123;children&#125;</span><br><span class="line">            &lt;<span class="regexp">/PopupInner&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>Align&gt;</span><br><span class="line">        ) : <span class="literal">null</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/Animate&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Animate component="" exclusive transitionAppear</span></span><br><span class="line"><span class="regexp">      transitionName=&#123;this.getTransitionName()&#125; showProp="xVisible"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Align target=&#123;this.getAlignTarget()&#125; key="popup" ref=&#123;this.saveAlignRef&#125;</span></span><br><span class="line"><span class="regexp">        monitorWindowResize xVisible=&#123;visible&#125; childrenProps=&#123;&#123; visible: 'xVisible' &#125;&#125;</span></span><br><span class="line"><span class="regexp">        disabled=&#123;!visible&#125; align=&#123;align&#125; onAlign=&#123;this.onAlign&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;PopupInner hiddenClassName=&#123;hiddenClassName&#125; &#123;...popupInnerProps&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &#123;children&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>PopupInner&gt;</span><br><span class="line">      &lt;<span class="regexp">/Align&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Animate&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染弹层内容</span></span><br><span class="line">getMaskElement() &#123;</span><br><span class="line">  <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">let</span> maskElement;</span><br><span class="line">  <span class="keyword">if</span> (props.mask) &#123;</span><br><span class="line">    <span class="keyword">const</span> maskTransition = <span class="keyword">this</span>.getMaskTransitionName();</span><br><span class="line">    <span class="comment">// getZIndexStyle 方法用于获取用户配置的 zIndex</span></span><br><span class="line">    maskElement = (</span><br><span class="line">      &lt;LazyRenderBox style=&#123;<span class="keyword">this</span>.getZIndexStyle()&#125; key=<span class="string">"mask"</span></span><br><span class="line">        className=&#123;<span class="string">`<span class="subst">$&#123;props.prefixCls&#125;</span>-mask`</span>&#125;</span><br><span class="line">        hiddenClassName=&#123;<span class="string">`<span class="subst">$&#123;props.prefixCls&#125;</span>-mask-hidden`</span>&#125;</span><br><span class="line">        visible=&#123;props.visible&#125;/&gt;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (maskTransition) &#123;</span><br><span class="line">      maskElement = (</span><br><span class="line">        &lt;Animate key=<span class="string">"mask"</span> showProp=<span class="string">"visible"</span> transitionAppear</span><br><span class="line">          component=<span class="string">""</span> transitionName=&#123;maskTransition&#125;&gt;</span><br><span class="line">          &#123;maskElement&#125;</span><br><span class="line">        &lt;<span class="regexp">/Animate&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return maskElement;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/24/随笔/换种角度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/24/随笔/换种角度/" itemprop="url">换种角度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-24T00:00:00+08:00">2019-02-24</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/24/随笔/换种角度/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/24/随笔/换种角度/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>视图层有两种要素：页面元素和用户行为。作为可见的实体，页面元素根据用户行为施加的影响，变化着形态。假使把页面元素比作我们自学生时代就接触的弹簧，按照实验数据抽象的弹性系数就是页面元素自有的属性，施加的外力就是用户针对该节点的操作，click 或 change 之流。我们可以仿照胡克定律的方式，使用数学函数阐述视图层的变化，如 view = handler(action)。与自然现象那种冥冥中的物理机制不同的是，在人为的视图层机制中，handler 是可控的。我们既可以在 node.onClick 中看见 handler 的影子，又可以在 node.addEventListener(‘onClick’, handler) 看见 handler 的影子。当我们以弹性系数是弹簧固有的物理特征这种方式思忖这两种实现时，我们就能意识到：前一种方式是较为直观的，施加哪种影响，产生哪种变化，比如先作力的合成，再计算力的影响；后一种是可量化的、轻耦合的，不限于物质实体而抽象物理机制，再使用这套物理机制演绎物质实体的表现，比如先作力的分解，再叠加力的影响。这样我们就可以认为，作为平台的浏览器提供了力学定律，前端开发者定义了物质实体的物理特征，用户施加了作用力，继而使物质实体发生了变化。以这种方式理解浏览器的事件机制既是我个人的一种癖好，又可以拉近与浏览器实现的亲近感。在延伸面上，我们还可以把事件委托看成是”隔山打牛“这种武侠招式的浏览器表现，不是很有趣吗？</p>
<p>有什么在妨碍我们看清浏览器的实现机制就是 view = handler(action) 呢？在浏览器中，页面元素被抽象成了具有样式属性且富有层次结构的节点。在内存中驻留的节点属性就像实时变化的运动量那样，让我们不能直观地感受到输入输出模型，而是更容易只看到等式的右半部分：在 handler(action) 执行过程中，node 节点的形态发生着变化。让我们再聚焦于脚蹬自行车这种”隔山打牛“的情景，我们想必会直观地认为在 handler(action) 执行过程中，脚踏板、链条、轮轴、车轮都在运动，而不能定位到输入输出模型。一个 handler(action) 过程中的多节点变化不正是这样的吗？我们书写的代码不也正是这样的吗？因此而论，就像我们基于力学定律阐释脚蹬自行车这一物理过程一样，view = handler(action) 就是我们的力学定律，节点的种种变化就是我们的物理过程。也因此，在单输入单输出模型下，基于操作节点的前端编码方式就退化成了学生时代的解题，或者我们找到了学生时代解题的意义。以下就是单输入输出模型中常见的任务流处理方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x1 = f1(x0);</span><br><span class="line">x2 = f2(x1);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>当我们再把眼光投向多输入多输出模型，或者整体构造比自行车复杂得多的现代汽车，面向过程的思考方式势必会让我们遭遇分岔的支路。这时候，面向对象的方式就隆重登场了。在面向对象的思维方式中，实体的状态变更可以归结为实体自有的特征，如前文提到的弹性系数。环绕弹性系数，弹簧拉伸长度和受力的机制都可以内化为实体的状态及方法。如果实体的特征仅止于此，以面向对象的方式对实体进行建模看似是不必要的。我们可以感知到面向过程的方式在这样一种单输入单输出模型上的便利性和清晰性。当然，当实体并不止于单方面的特征，面向对象的方式就会优于面向过程的方式。在这方面，我们以自带搜索表单和编辑弹窗的列表组件加以说明。如果我们以面向对象的方式封装每个组件的状态和行为，每个组件即构成交互网络中的一个节点，其所缺的就是上下游节点的通信方式。作为上游的列表组件，既可以集成弹窗的显示隐藏状态以及操纵弹窗显示隐藏的方法；又可以直接调用弹窗组件的显示隐藏方法。列表组件和搜索表单的交互方式也是一样的。因此，面向对象的方式更像一个节点网络，每个节点都各自组织节点内部的状态和行为，节点之间又通过交互接口完成通信。这和面向过程的方式有着着眼点上的不同：面向过程聚焦于输入输出流的传递和变更，更适合在单任务流串联各实体变化的脉络轨线；面向对象在于对单实体的丰富特征进行抽象，然后在节点网络中组织上下游的通信，更适合机制复杂的系统。</p>
<img src="/2019/02/24/随笔/换种角度/节点网络.png">
<p>在面向对象的编码方式中，除了 uml 类图之外，通过节点网络阐述各节点的组织关系以及各节点的内在特征也许是可行的。我们知道，以类实现的实体之间可以有依赖、聚合、继承关系，比如列表组件聚合了搜索表单和编辑弹窗，这三个组件可能都依赖了状态管理类、继承自实现生命周期管理方法的基类组件。状态管理类可视为 mobx 等类库在组件状态管理上提供的解决方案；基类组件可视为 react 等框架在视图层提供的抽象。当我们在业务层面在进一步抽象，就可以针对列表组件分别抽象两个类去封装其与搜索表单和编辑弹窗的状态管理和交互逻辑，以避免代码的重复书写。为此，typescript 像 java 那样提供了抽象类、接口、多重继承、私有属性等，为我们以面向对象的方式编写前端代码提供了许多弹药。正如这篇文章旨在于换种角度思考编程、盘活思路，这里不对具体的编码实现作深入，遗留下来的可探讨、可推敲空间仍在于展开问题，或者寻找提升编程技术的切入点。当然，这样会显得虎头蛇尾、泛泛而谈，也是笔者编程造诣不够精深的佐证吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/08/css/css 总汇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/08/css/css 总汇/" itemprop="url">css 总汇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-08T00:00:00+08:00">2019-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/css/" itemprop="url" rel="index"><span itemprop="name">css</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/08/css/css 总汇/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/08/css/css 总汇/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>意义</th>
<th>版本</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>通用选择器</td>
<td>2.1</td>
<td>*</td>
</tr>
<tr>
<td>E</td>
<td>标签选择器</td>
<td>1</td>
<td>p</td>
</tr>
<tr>
<td>.class</td>
<td>类选择器</td>
<td>1</td>
<td>.nav</td>
</tr>
<tr>
<td>#id</td>
<td>ID选择器</td>
<td>1</td>
<td>#wrapper</td>
</tr>
<tr>
<td>E[attr]</td>
<td>属性选择器，匹配带 ‘data-url’ 属性的 a 元素</td>
<td>2.1</td>
<td>a[data-url]</td>
</tr>
<tr>
<td>E[attr=val]</td>
<td>属性选择器，匹配 type 属性为 ‘text’ 的 input 元素</td>
<td>2.1</td>
<td>input[type=’text’]</td>
</tr>
<tr>
<td>E[attr~=val]</td>
<td>属性选择器，匹配 keywords 属性包含 ‘round’ 的 div 元素</td>
<td>2.1</td>
<td>div[keywords~=’round’]</td>
</tr>
<tr>
<td>E[attr=val]</td>
<td>属性选择器，匹配 lang 属性以 ‘zh’ 开始的 label 元素</td>
<td>2.1</td>
<td>label[lang=’zh’]</td>
</tr>
<tr>
<td>E[attr^=val]</td>
<td>属性选择器，匹配 href 属性以 ‘http://‘ 开始的 a 元素</td>
<td>3</td>
<td>a[href^=’http://‘]</td>
</tr>
<tr>
<td>E[attr$=val]</td>
<td>属性选择器，匹配 src 属性以 ‘.png’ 结尾的 img 元素</td>
<td>3</td>
<td>img[src$=’.png’]</td>
</tr>
<tr>
<td>E[attr*=val]</td>
<td>属性选择器，匹配 href 属性中包含 ‘baidu.com’ 的 a 元素</td>
<td>3</td>
<td>a[href*=’baidu.com’]</td>
</tr>
<tr>
<td>E F</td>
<td>后代选择器</td>
<td>1</td>
<td>.blog p</td>
</tr>
<tr>
<td>E&gt;F</td>
<td>子选择器</td>
<td>2.1</td>
<td>.nav &gt; button</td>
</tr>
<tr>
<td>E+F</td>
<td>相邻兄弟选择器</td>
<td>2.1</td>
<td>label + input</td>
</tr>
<tr>
<td>E~F</td>
<td>兄弟选择器</td>
<td>3</td>
<td>header ~ div</td>
</tr>
<tr>
<td>S1, S2</td>
<td>选择器分组</td>
<td>1</td>
<td>input, select, textarea</td>
</tr>
</tbody>
</table>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>意义</th>
<th>版本</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>:link</td>
<td>动态伪类，匹配未访问过的链接</td>
<td>1</td>
<td>a:link</td>
</tr>
<tr>
<td>:visited</td>
<td>动态伪类，匹配被访问过的链接</td>
<td>1</td>
<td>a:visited</td>
</tr>
<tr>
<td>:hover</td>
<td>动态伪类，匹配鼠标悬浮的元素</td>
<td>1</td>
<td>div:hover</td>
</tr>
<tr>
<td>:active</td>
<td>动态伪类，匹配鼠标按下的元素</td>
<td>1</td>
<td>a:active</td>
</tr>
<tr>
<td>:focus</td>
<td>动态伪类，匹配获得焦点的元素</td>
<td>2.1</td>
<td>input:focus</td>
</tr>
<tr>
<td>:target</td>
<td>目标伪类，匹配活动的锚</td>
<td>2.1</td>
<td>#tab1:target</td>
</tr>
<tr>
<td>:lang(val)</td>
<td>语言伪类，匹配指定 lang 属性的元素</td>
<td>2.1</td>
<td>p:lang(zh)</td>
</tr>
<tr>
<td>:enabled</td>
<td>状态伪类，匹配启用的元素</td>
<td>3</td>
<td>input:enabled</td>
</tr>
<tr>
<td>:disabled</td>
<td>状态伪类，匹配禁用的元素</td>
<td>3</td>
<td>input:disabled</td>
</tr>
<tr>
<td>:checked</td>
<td>状态伪类，匹配选中的元素</td>
<td>3</td>
<td>input:checked</td>
</tr>
<tr>
<td>:root</td>
<td>结构性伪类，文档根元素</td>
<td>3</td>
<td>:root</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>结构性伪类，匹配父元素的第 n 个子元素</td>
<td>3</td>
<td>:nth-child</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>结构性伪类，匹配父元素的倒数第 n 个子元素</td>
<td>3</td>
<td>:nth-last-child</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>结构性伪类，匹配父元素的第 n 个相同子元素</td>
<td>3</td>
<td>:nth-of-type</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>结构性伪类，匹配父元素的倒数第 n 个相同子元素</td>
<td>3</td>
<td>:nth-last-of-type</td>
</tr>
<tr>
<td>:first-child</td>
<td>结构性伪类，匹配父元素的第一个子元素</td>
<td>3</td>
<td>:first-child</td>
</tr>
<tr>
<td>:last-child</td>
<td>结构性伪类，匹配父元素的最后一个子元素</td>
<td>3</td>
<td>:last-child</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>结构性伪类，匹配父元素的第一个相同子元素</td>
<td>3</td>
<td>:first-of-type</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>结构性伪类，匹配父元素的最后一个相同子元素</td>
<td>3</td>
<td>:last-of-type</td>
</tr>
<tr>
<td>:only-child</td>
<td>结构性伪类，匹配父元素的唯一一个子元素</td>
<td>3</td>
<td>:only-child</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>结构性伪类，匹配父元素的唯一一个相同子元素</td>
<td>3</td>
<td>:only-of-type</td>
</tr>
<tr>
<td>:empty</td>
<td>结构性伪类，匹配没有子元素的元素</td>
<td>3</td>
<td>:empty</td>
</tr>
<tr>
<td>::first-line</td>
<td>伪元素，匹配元素文本内容的首行</td>
<td>1</td>
<td>p::first-line</td>
</tr>
<tr>
<td>::first-letter</td>
<td>伪元素，匹配元素文本内容的首字母</td>
<td>1</td>
<td>p::first-letter</td>
</tr>
<tr>
<td>::before</td>
<td>伪元素，匹配元素之前的内容</td>
<td>2.1</td>
<td>div::before</td>
</tr>
<tr>
<td>::after</td>
<td>伪元素，匹配元素之后的内容</td>
<td>2.1</td>
<td>div::after</td>
</tr>
</tbody>
</table>
<h3 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h3><p>选择器分为 4 个优先级，分别是：内联样式；ID 选择器；类、伪类，属性选择器；元素，伪元素。其权重通常是 1000, 100, 10, 1。需要注明的是，11 个类选择器的权重并不会超过 1 个 ID 选择器。除此之外，!important 可将对应规则的权重提升到最高。</p>
<h2 id="响应式开发"><a href="#响应式开发" class="headerlink" title="响应式开发"></a>响应式开发</h2><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p>在介绍响应式开发前，先须理清如下三个概念，各设备的物理像素和设备像素比也见于下表：</p>
<ul>
<li>物理像素：屏幕实际的像素点。</li>
<li>设备独立像素：逻辑像素，用于定义应用的 UI。</li>
<li>屏幕像素比：物理像素和设备独立像素的比值。</li>
</ul>
<table>
<thead>
<tr>
<th>设备名称</th>
<th>物理像素</th>
<th>设备独立像素</th>
<th>屏幕像素比</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPhone 7, 6, 6S</td>
<td>750*1334</td>
<td>373*667</td>
<td>2</td>
</tr>
<tr>
<td>iPhone 7 plus, 6S plus, 6 plus</td>
<td>1080*1920</td>
<td>414*736</td>
<td>3</td>
</tr>
<tr>
<td>iPhone 5, 5S, 5C, 5E</td>
<td>640*1136</td>
<td>320*568</td>
<td>2</td>
</tr>
<tr>
<td>iPhone 4</td>
<td>640*960</td>
<td>320*480</td>
<td>2</td>
</tr>
<tr>
<td>iPod Touch</td>
<td>640*1136</td>
<td>320*568</td>
<td>2</td>
</tr>
<tr>
<td>Galaxy S7, S7 edge, S6</td>
<td>1440*2560</td>
<td>360*640</td>
<td>4</td>
</tr>
<tr>
<td>Galaxy S5, S4</td>
<td>1080*1920</td>
<td>360*640</td>
<td>3</td>
</tr>
<tr>
<td>Galaxy S4 mini</td>
<td>540*960</td>
<td>360*640</td>
<td>1.5</td>
</tr>
<tr>
<td>Galaxy S3</td>
<td>720*1280</td>
<td>360*640</td>
<td>2</td>
</tr>
<tr>
<td>Galaxy Note 4</td>
<td>1440*2560</td>
<td>360*640</td>
<td>4</td>
</tr>
<tr>
<td>Galaxy Note 3</td>
<td>1080*1920</td>
<td>360*640</td>
<td>3</td>
</tr>
<tr>
<td>Galaxy Note 2</td>
<td>720*1280</td>
<td>360*640</td>
<td>2</td>
</tr>
<tr>
<td>Mi 4, 3</td>
<td>1080*1920</td>
<td>360*640</td>
<td>3</td>
</tr>
<tr>
<td>HTC One</td>
<td>1080*1920</td>
<td>360*640</td>
<td>3</td>
</tr>
<tr>
<td>Sony Xperia 23</td>
<td>1080*1920</td>
<td>360*640</td>
<td>3</td>
</tr>
<tr>
<td>Lenovo K900</td>
<td>1080*1920</td>
<td>360*640</td>
<td>3</td>
</tr>
<tr>
<td>ZTE Grand S</td>
<td>1080*1920</td>
<td>360*640</td>
<td>3</td>
</tr>
<tr>
<td>iPad Pro</td>
<td>2048*2732</td>
<td>1024*1366</td>
<td>2</td>
</tr>
<tr>
<td>iPad 3, 4, Air, Air2</td>
<td>1536*2048</td>
<td>768*1024</td>
<td>2</td>
</tr>
<tr>
<td>iPad mini 2, 3</td>
<td>1536*2048</td>
<td>768*1024</td>
<td>2</td>
</tr>
<tr>
<td>iPad mini</td>
<td>768*1024</td>
<td>768*1024</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>大多数设备的视口宽度都为 980 px，通过设置 <meta name="viewport" content="width=device-width, initial-scale=1"> 可调整视口（viewport）的宽度。关于视口的概念，可参考 <a href="https://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="noopener">移动前端开发之viewport的深入理解</a>。其中，meta 标签包含的属性含义如下：</p>
<ul>
<li>width：设置 viewport 宽度。</li>
<li>initial-scale：设置 viewport 初始缩放值。</li>
<li>minimum-scale：设置 viewport 最小缩放值。</li>
<li>maximum-scale：设置 viewport 最大缩放值。</li>
<li>height：设置 viewport 高度。</li>
<li>user-scalable：是否允许用户缩放。</li>
</ul>
<h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3><p>flex 弹性布局示意图：</p>

<p>在 flex 容器内，水平轴称为交叉轴，垂直轴称为主轴；容器内分布 flex 项目。flex 容器包含以下属性：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>意义</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-direction</td>
<td>决定 item 排列方向</td>
<td>row 从左至右；column 从上到下；row-reverse；column-reverse</td>
</tr>
<tr>
<td>flex-wrap</td>
<td>决定 item 换行方式</td>
<td>nowrap 不换行；wrap；wrap-reverse 第一行在下面</td>
</tr>
<tr>
<td>justify-content</td>
<td>决定 item 在主轴上的对齐方式</td>
<td>flex-start；flex-end；center；space-between 两端对齐；space-around 沿轴线均匀分布</td>
</tr>
<tr>
<td>align-items</td>
<td>决定 item 在交叉轴上的对齐方式</td>
<td>flex-start；flex-end；center；baseline；stretch 当 item 未设置高度时，item 将与容器等高度</td>
</tr>
<tr>
<td>align-content</td>
<td>决定多行 item 的对齐方式</td>
<td>flex-start；flex-end；center；space-between；space-around；stretch</td>
</tr>
</tbody>
</table>
<p>flex 项目包含如下属性：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>意义</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>order</td>
<td>决定 item 排列顺序，默认值为 0</td>
<td>-</td>
</tr>
<tr>
<td>flex-grow</td>
<td>决定 item 放大比例，默认值为 0</td>
<td>-</td>
</tr>
<tr>
<td>flex-shrink</td>
<td>决定 item 缩小比例，默认值为 1</td>
<td>-</td>
</tr>
<tr>
<td>flex-basis</td>
<td>决定 item 在主轴上占据的空间，默认值为 auto</td>
<td>-</td>
</tr>
<tr>
<td>align-self</td>
<td>决定 item 在交叉轴上的对齐方式</td>
<td>auto；flex-start；flex-end；center；baseline；stretch</td>
</tr>
</tbody>
</table>
<p>关于 flex 布局，可参考 <a href="https://www.cnblogs.com/nuannuan7362/p/5823381.html" target="_blank" rel="noopener">flex弹性布局学习总结</a>。</p>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询可以定义在 css 中，也可以定义在 link 元素的 media 属性内。后一种方法始终会加载 css 样式，通过 media 属性决定是否应用 css 样式。</p>
<p>媒体查询可使用如下属性，并可加以 min- 或 max- 前缀：</p>
<ul>
<li>width：视口的宽度。</li>
<li>height：视口的高度。</li>
<li>aspect-ratio：视口的宽高比。</li>
<li>orientation：设备横竖屏，值为 portrait 或 landscape。</li>
<li>resolution：设备分辨率，值可以是每英寸 dpi 或每厘米 dpcm。</li>
</ul>
<p>媒体查询以 @media 起始；以 not 为逻辑非，’,’ 号为逻辑或。@media 后可使用不同的媒体类型或媒体属性。媒体类型包含：all 所有媒体类型；print 打印设备；screen 显示器；speech 辅助设备。</p>
<h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>css 中的计量单位有 px, pt, em, rem 等。em 相对当前元素的字体大小；rem 相对根元素的字体大小。使用 rem 制作响应式页面，先须根据屏幕大小调整切换根元素的字体大小。关于如何动态调整根元素的字体大小，可参考 <a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">lib-flexible</a>。</p>
<h3 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h3><p>在 css3 中，文本可采用多列布局，其中施以影响的样式有：</p>
<ul>
<li>column-count：设定列数。</li>
<li>column-width：设定列宽度。</li>
<li>column-gap：设定列间距。</li>
<li>column-rule：设定列间距的样式规则。</li>
</ul>
<h2 id="动效"><a href="#动效" class="headerlink" title="动效"></a>动效</h2><h3 id="transform-转换"><a href="#transform-转换" class="headerlink" title="transform 转换"></a>transform 转换</h3><ul>
<li>translate(x, y)：平移。</li>
<li>translate3d(x, y, z)：平移。</li>
<li>translateX(x)：平移。</li>
<li>translateY(y)：平移。</li>
<li>translateZ(z)：平移。</li>
<li>scale(x, y)：缩放。</li>
<li>scale3d(x, y, z)：缩放。</li>
<li>scaleX(x)：缩放。</li>
<li>scaleY(y)：缩放。</li>
<li>scaleZ(z)：缩放。</li>
<li>rotate(angle)：旋转。</li>
<li>rotate3d(x, y, z, angle)：旋转。</li>
<li>rotateX(angle)：旋转。</li>
<li>rotateY(angle)：旋转。</li>
<li>rotateZ(angle)：旋转。</li>
<li>skew(x-angle, y-angle)：倾斜变形。</li>
<li>skewX(angle)：倾斜变形。</li>
<li>skewY(angle)：倾斜变形。</li>
<li>matrix(n, n, n, n, n, n)：自定义转换。</li>
<li>matrix3d(n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n)：自定义转换。</li>
<li>prespective(n)：透视图。</li>
</ul>
<h3 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition 过渡"></a>transition 过渡</h3><p>transition 在指定 css 属性发生变化时，开始执行动效。它的格式以及包含的属性如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">transition-property</span> <span class="selector-tag">transition-duration</span> <span class="selector-tag">transition-timing-function</span> <span class="selector-tag">transition-delay</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>transition-property：指定将发生变化的 css 属性。</li>
<li>transition-duration：指定动效执行的时长。</li>
<li>transition-timing-function：指定动效的速度曲线。可能的值包含：linea 以相同的速度执行动效，等同于贝济埃曲线（0.0, 0.0, 1.0, 1.0）；ease 以逐渐变慢的速度执行动效，等同于贝济埃曲线（0.25, 1.0, 0.25, 1.0）；ease-in 以慢速开始执行动效，等同于贝济埃曲线（0.42, 0.0, 1.0, 1.0）；ease-out 以慢速结束执行动效，等同于贝济埃曲线（0.0, 0.0, 0.58, 1.0）；ease-in-out 以慢速开始并结束执行动效，等同于贝济埃曲线（0.42, 0.0, 0.58, 1.0）；cubic-bezier(n, n, n, n) 自定义时间曲线，即自定义贝济埃曲线。</li>
<li>transition-delay：指定动效的延迟时间。</li>
</ul>
<h3 id="animation-动画"><a href="#animation-动画" class="headerlink" title="animation 动画"></a>animation 动画</h3><p>animation 适用于块状和内联元素。它的格式以及包含的属性如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">animation-name</span> <span class="selector-tag">animation-duration</span> <span class="selector-tag">animation-timing-function</span> <span class="selector-tag">animation-delay</span> <span class="selector-tag">animation-iteration-count</span> <span class="selector-tag">animation-direction</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>animation-name：值可以为 @keyframes 创建的动画名称，默认值为 none，即不会有任何动画效果。</li>
<li>animation-duration：动画播放时长。</li>
<li>animation-timing-function：指定动画的速度曲线，值可以是 linea, ease, ease-in, ease-out, ease-in-out, cubic-bezier(n, n, n, n)。</li>
<li>animation-delay：动画的延迟时间。</li>
<li>animation-iteration-count：动画的播放次数。</li>
<li>animation-direction：动画的播放方向，默认值为 normal。当指定为 alternate 时，偶数次向前播放，奇数次向后播放。</li>
</ul>
<h2 id="常用特性"><a href="#常用特性" class="headerlink" title="常用特性"></a>常用特性</h2><h3 id="开放字体格式-WOFF"><a href="#开放字体格式-WOFF" class="headerlink" title="开放字体格式 WOFF"></a>开放字体格式 WOFF</h3><p>通过 css3 中的 @font-face 可使用开放字体格式（Web Open Font Format，简称 WOFF）。@font-face 规则如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: &lt;开放字体格式名&gt;;</span><br><span class="line">  <span class="attribute">src</span>: &lt;字体路径&gt; [&lt;字体格式&gt;] [,&lt;字体路径&gt; [&lt;字体格式&gt;]] *;</span><br><span class="line">  [font-weight: &lt;字体粗细&gt;]; </span><br><span class="line">  <span class="selector-attr">[font-style: &lt;字体样式&gt;]</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'fontello'</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'./font/fontello.eot?69798120'</span>);</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'./font/fontello.eot?69798120#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-open-type'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'./font/fontello.woff?69798120'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'./font/fontello.tff?69798120'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">'./font/fontello.svg?69798120#fontello'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>);</span><br><span class="line">  <span class="attribute">font-weight</span>: normal; </span><br><span class="line">  <span class="attribute">font-style</span>: normal; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字体格式包含如下值：</p>
<ul>
<li>.tff：TrueType 格式，是 windows, mac 上常见的字体。</li>
<li>.otf: OpenType 格式，一种原始的字体。</li>
<li>.woff: Web Open Font Format 格式，Web 字体中最佳格式，TrueType/OpenType 格式的压缩版。</li>
<li>.eot：Embedded Open Type 格式，可以从 TrueType 创建此格式的字体，IE 专用格式，支持此字体的浏览器有 IE4+。</li>
<li>.svg：SVG 格式。</li>
</ul>
<p>@font-face 可用于加载字体图标 IconFont。字体图标可参考 <a href="https://www.cnblogs.com/hjvsdr/p/6639649.html" target="_blank" rel="noopener">iconfont字体图标的使用方法–超简单!</a>。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>background-color：指定背景色。</li>
<li>background-position：指定背景图像的位置。</li>
<li>background-size：指定背景图像的尺寸，值可以指定背景的宽度和高度，也可以是 cover 使背景图像覆盖背景区域，超出部分将会裁剪, contain 使背景图像适应背景区域。</li>
<li>background-repeat：指定是否重复背景图像。</li>
<li>background-origin：指定背景的定位区域，值可以是 padding, padding-box, border, border-box, content, content-box，即从内边距或外边距开始。</li>
<li>background-clip：指定背景的绘制区域，指定区域将被裁剪，值可以是 border-box, padding-box, content-box。</li>
<li>background-attachment：指定背景图像是否固定或者随着页面的其余部分滚动。</li>
<li>background-image：指定背景图像。</li>
</ul>
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>颜色取值可以指定颜色名称，如 black；或 HEX 以十六进制表示颜色，如 #000000；或 RGB 记法，如 rgb(0, 0, 0)；或 RGBA 记法，alpha 为透明度，如 rgba(0, 0, 0, 0.5)；或 HSL 记法，如 hsl(360, 50%, 50%)；或 HSLA 记法，如 hsla(360, 50%, 50%, 0.5)；或 transparent 全透明色彩；或 currentcolor 当前标签继承的文字颜色。</p>
<p>颜色也可以设置渐变。linear-gradient 线性渐变，如 linear-gradient(direction, color-stop1, color-stop2, …)；或 radial-gradient 径向渐变，如 radial-gradient(position, shape size, start-color, …, last-color)。</p>
<p>也可以使用 opacity 指定透明度。</p>
<h3 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h3><ul>
<li>text-shadow：字体阴影，格式如 text-shadow: h-shadow v-shadow blur color。其中，h-shadow 为水平阴影的位置；v-shadow 为垂直阴影的位置；blur 模糊的距离；color 阴影的颜色。</li>
<li>text-overflow：指定文本溢出的处理方式。值可以是 clip 裁剪；ellipsis 省略号显示；string 指定字符串替代被裁剪的文本。</li>
<li>word-wrap：指定长单词或 url 地址是否自动换行，值可以是 normal, break-word。normal 在允许的断字点换行；break-word 在长单词或 url 地址内部进行换行。</li>
<li>word-break：指定自动换行的处理方式，值可以是 normal, break-all, keep-all。normal 默认的换行方式；break-all 允许在单次内换行；keep-all 只能在半角空格或连字符处换行。</li>
</ul>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul>
<li>border-width：指定边框的宽度。</li>
<li>border-style：指定边框样式。</li>
<li>border-color：指定边框颜色。</li>
<li>border-radius：指定圆角边框。</li>
<li>border-image：指定边框背景图像。</li>
<li>box-shadow：指定边框阴影。格式如 box-shadow: h-shadow v-shadow blur spread color inset。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>box-sizing：盒模式。<br>calc：函数计算样式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/读书笔记/移动Web高效开发实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/读书笔记/移动Web高效开发实践/" itemprop="url">移动Web高效开发实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T00:00:00+08:00">2019-02-03</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/03/读书笔记/移动Web高效开发实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/03/读书笔记/移动Web高效开发实践/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文档主要用于汇总待整理的问题点，后续将以文章形式逐条剖析。</p>
<h2 id="开发环境或工具"><a href="#开发环境或工具" class="headerlink" title="开发环境或工具"></a>开发环境或工具</h2><ul>
<li>NProxy：web 代理工具，参考 <a href="http://www.cnblogs.com/wenber/p/3893308.html" target="_blank" rel="noopener">前端调试利器—nproxy</a>。</li>
<li>http-server：搭建 http 服务器，参考 <a href="https://www.cnblogs.com/Janejxt/p/9394989.html" target="_blank" rel="noopener">本地搭建http-server服务器</a>。</li>
<li>caniuse：查询浏览器对样式的支持度。</li>
<li>modernizr：嵌入脚本，检测浏览器对样式或特征的支持度。</li>
</ul>
<h2 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h2><ul>
<li>布局元素：Header, Nav, Article, Section, Aside, Footer。</li>
<li>input[type=?]：search, tel, url, email, date, color, number, range, datetime, month, week。</li>
<li>input[?=]：required, pattern, autofocus, form, placeholder。</li>
<li>新元素：progress 进度条, meter 标尺。</li>
<li>新属性：contenteditable 使元素可编辑。</li>
<li>audio 音频、video 视频：包含 controls 展示默认控件, autoplay, loop 循环播放, preload 预加载, volumn 音量属性，通过 source 元素加载音频、视频；可以用 api 形式操作音频。</li>
<li>navigator.geolocation.getCurrentPosition(success, error, options)：获取当前地理位置。</li>
<li>navigator.mediaDevices.getUserMedia(contraints).then(success).catch(error)：调用摄像头拍照，success 回调的参数 stream 可通过 window.URL.createObjectURL(stream) 赋值给 video 元素的 src 属性。</li>
<li>deviceorientation 事件：可监听设备旋转角度的变化，绕上下坐标旋转称为 alpha 弧度，绕左右坐标称为 beta，绕前后坐标旋转称为 gamma。</li>
<li>devicemotion 事件：可监听设备移动的距离以及旋转角度的变化。</li>
<li>离线存储：以 ‘.mainfest’ 或 ‘.appcache’ 描述文件设定待存储的资源目录，html 指定 mainfest 属性关联该描述文件，这样可以在断网状态下加载本地缓存的资源。结合 LocalStorage，可以缓存本地用户填写的数据。除此之外，service worker 可以用指定的方式加载本地缓存。关于 service worker，可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service Worker API</a>, <a href="https://www.jianshu.com/p/0e2dee4c77bc" target="_blank" rel="noopener">构建 Web 应用之 Service Worker 初探</a>, <a href="https://www.cnblogs.com/dojo-lzz/p/8047336.html" target="_blank" rel="noopener">Web离线应用解决方案——ServiceWorker</a>。</li>
<li>LocalStorage, SessionStorage：本地存储。</li>
<li>IndexedDB：浏览器本地的结构化数据库，使用 new LocalDB(dbName, tableName) 创建。</li>
<li>Canvas 画布。</li>
<li>SVG 矢量图。</li>
<li>WebGL 三维图像。渲染引擎可参考 <a href="https://github.com/pixijs/pixi.js" target="_blank" rel="noopener">pixi.js</a>。</li>
<li>window.postMessage(message, target, [transfer])：跨域传送。</li>
<li>xhr2：添加 ontimeout, onprogress 方法，可传送 FormData 数据。</li>
<li>EventSource：创建 EventSource 对象接受服务端主动推送的消息。</li>
<li>WebSocket 全双工通信。</li>
<li>WebRTC 实时通信。</li>
<li>drag, drop 拖拽。</li>
<li><a href="http://xzfyu.com/2019/01/27/history%E6%BA%90%E7%A0%81/" target="_blank" rel="noopener">history api</a>。</li>
<li>web workers 多线程。</li>
<li>performance api 网站性能。</li>
<li>microdata：参考 <a href="https://lepture.com/zh/2015/fe-microdata" target="_blank" rel="noopener">前端的基礎修養：Microdata</a>。</li>
</ul>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>参考 <a href="http://xzfyu.com/2019/02/08/css/css%20%E6%80%BB%E6%B1%87/" target="_blank" rel="noopener">css 总汇</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/01/antd/react-component/dom-align/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/antd/react-component/dom-align/" itemprop="url">dom-align</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T00:00:00+08:00">2019-02-01</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/antd-组件库/" itemprop="url" rel="index"><span itemprop="name">antd 组件库</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/01/antd/react-component/dom-align/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/01/antd/react-component/dom-align/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><ul>
<li>utils.getWindow(node): 获取 node 节点所属的 window 对象。</li>
<li>utils.getDocument(node): 获取 node 节点所属的 document 对象。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/01/antd/react-component/rc-align/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/antd/react-component/rc-align/" itemprop="url">rc-align</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T00:00:00+08:00">2019-02-01</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/antd-组件库/" itemprop="url" rel="index"><span itemprop="name">antd 组件库</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/01/antd/react-component/rc-align/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/01/antd/react-component/rc-align/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="dom-align"><a href="#dom-align" class="headerlink" title="dom-align"></a>dom-align</h2><h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><ul>
<li>utils.getWindow(node): 获取 node 节点所属的 window 对象。</li>
<li><p>utils.getDocument(node): 获取 node 节点所属的 document 对象。</p>
</li>
<li><p>isAncestorFixed(element): 判断祖先元素是否固定定位。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/31/react/react相关/react-router源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/31/react/react相关/react-router源码分析/" itemprop="url">react-router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-31T00:00:00+08:00">2019-01-31</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端路由/" itemprop="url" rel="index"><span itemprop="name">前端路由</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/31/react/react相关/react-router源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/31/react/react相关/react-router源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h2><p>基于 <a href="http://xzfyu.com/2019/01/27/history%E6%BA%90%E7%A0%81/" target="_blank" rel="noopener">history</a> 创建的 history 对象、以及 <a href="https://github.com/jamiebuilds/create-react-context" target="_blank" rel="noopener">create-react-context</a> 为上下游组件传递 context 数据，上游的 Router 组件用于监听地址栏的变更，随后将 history 对象以及当前的 state.location 信息写入 context；下游的 Route 组件通过工具函数 matchPath 判断 location.pathname 是否匹配 props.path，以此渲染出内容。</p>
<p>在这种机制下，存在两个问题：如果 location.pathname 与多个 Route 匹配时，react-router 将会渲染出这几个 Route 的内容；如果嵌套使用的 Route 元素均需要与 location.pathname 当前的地址栏信息加以比较的话，那么这个 Route 元素的 props.path 属性也需要感知父 Route 元素的 props.path 信息。针对第一个问题，react-router 提供了 Switch 组件。借助 Switch 组件，react-router 将只渲染首个匹配的 Route 元素，且为子组件注入 props.computedMatch 属性（以避免 matchPath 的多次调用）。针对第二个问题，react-router 通过 Switch 组件或父 Route 组件向子组件注入 props.match 属性，再通过 match.path 设置子 Route 的 props.path 属性（参见 <a href="https://reacttraining.com/react-router/web/example/basic" target="_blank" rel="noopener">basic 示例</a>）。</p>
<p>除了改变子组件的 props.match 属性外，Switch 和 Route 组件均能改变子组件的 props.location 属性。react-router 以 <a href="https://reacttraining.com/react-router/web/example/animated-transitions" target="_blank" rel="noopener">Animated Transitions 示例</a> 指出 props.location 属性可应用于动效渲染场景。在示例中，react-router 使用指定 location 属性的 Switch 组件包裹前后两个页面级渲染内容，再经由指定 key 键为 location.key 的 CSSTransition 组件包裹（指定 key 键是为了在 CSSTransition 组件重绘期间，使该组件一前一后、卸载再挂载的机制切合视图上的移入移出动效），而后统一由 TransitionGroup 组件管理 CSSTransition 组件的动效切换过程。这样就可以实现：在地址栏变更过程中，前一个 CSSTransition 组件同步驻留，执行完隐藏动效后再移出；后一个 CSSTransition 组件执行完显示动效后再移入。</p>
<p>顺带指出的是，因为 Route 或 Switch 组件都可以指定动态的 props.location 属性，那就可以设想如下的黑魔法：自定义的、且与历史堆栈无甚关联的动态 location 属性将主导子 Route 的渲染状态。当然，这一黑魔法并不规范，理应避免使用。</p>
<p>在 Router 之外，react-router 还提供 MemoryRouter, StaticRouter 组件。MemoryRouter 组件可根据虚拟的缓存历史堆栈控制子 Route 的渲染状态，适用于测试或 native 环境。StaticRouter 组件适用于服务端渲染：react-router 会根据地址栏渲染出指定的内容，因此可以在 node 端设定 controller 对不同的前端路由统一发送 html 内容（通过 ReactDOMServer.renderToString 获得指定路由的 html 内容）；但是当地址栏与前端路由不匹配时，我们需要跳转到 404 页面，react-router 就会通过 StaticRouter 组件的机制在 ReactDOMServer.renderToString 方法执行期间，使用 content 引用对象收集待 404 页面地址，然后在 node 端进行重定向。引用对象 content 收集数据的方式有两种：第一种在虚拟跳转页面环节（为此，react-router 为 StaticRouter 组件提供了特定的 push, replace 方法实现）；第二种在待渲染页面 render 期间对 content 属性进行赋值。当然，这两种收集方式都在 ReactDOMServer.renderToString 方法执行期间完成。以上机制，可参考官方的 <a href="https://reacttraining.com/react-router/web/guides/server-rendering" target="_blank" rel="noopener">Server Rendering 示例</a>。</p>
<p>上一个段落的 ReactDOMServer.renderToString 方法执行期间，前端代码会虚拟地重定向到 404 页面；node 端再通过 context 感知到这一虚拟重定向过程，然后再发起真实的重定向。在这个过程中，虚拟重定向是由 Redirect 组件完成的。在 react-router4 中，Redirect 组件的机制就是在组件的生命周期中跳转页面、或者在渲染期间改变 context 的属性（服务端渲染时，将待跳转页面上报给 node 服务器），并无其他内容。因此，如果不需要重定向，就需要条件语句控制 Redirect 组件的渲染。参考 <a href="https://reacttraining.com/react-router/web/example/auth-workflow" target="_blank" rel="noopener">Redirects (Auth) 示例</a>。</p>
<p>在 Redirect 组件之外，借助 history 库封装的 block 方法，Prompt 组件用于拦截地址栏的变更，如默认会使用 window.confirm 提醒用户是否要进行跳转。Prompt 组件按两种条件决定是否需要对用户进行提示，其一是 props.when 属性，当其为真值进入条件二（因此可以将 state 状态赋值给 props.when 以设定条件）；其二是 props.message 属性，即 history 库中的 prompt，该值可以为函数，允许开发者根据待变更地址的 location, action 动态加以判断，是否需要提示用户。</p>
<p>我们用下图表示上文中组件的层级关系（虚线表示可有无可）：<br><img src="/2019/01/31/react/react相关/react-router源码分析/react-router层级关系.png"></p>
<p>以下列表简要概括各组价的输出能力和特点：</p>
<ul>
<li>StaticRouter: 服务器端渲染时，配合收集跳转页面地址并完成服务器端重定向。</li>
<li>MemoryRouter: native 环境使用虚拟历史堆栈实现前端路由。</li>
<li>Router: 将真实或虚拟的路由信息注入到子组件中，以控制 Route 内容的渲染。</li>
<li>Switch: 控制渲染首个匹配路由信息的 Route 内容。</li>
<li>Route: 设定单个路由规则，匹配时渲染内容。渲染内容可以是 children, Component, render 懒加载。其中，children 可以 React 元素，或 render props 形式。</li>
<li>Render: 作为 Route 下的渲染内容。</li>
<li>Redirect: 渲染时即重定向。</li>
<li>Prompt: 拦截地址栏变更。</li>
</ul>
<h3 id="RouterContext"><a href="#RouterContext" class="headerlink" title="__RouterContext"></a>__RouterContext</h3><p>基于 <a href="https://github.com/jamiebuilds/create-react-context" target="_blank" rel="noopener">create-react-context</a>，__RouterContext 用于为上下游组件传递 context。</p>
<h3 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h3><p>withRouter 装饰器将构造 HOC 组件，用于将 context 内容注入到子组件的 props 中。并且，HOC 组件基于 <a href="https://github.com/mridgway/hoist-non-react-statics" target="_blank" rel="noopener">hoist-non-react-statics</a>，拷贝了原始组件的非 react 类静态属性或方法。</p>
<h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><ul>
<li>Lifecycle: 生命周期方法管理组件。</li>
<li>generatePath(path, params): 基于 <a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a>，将路径规则 path 和路由参数 params 解析为实际的路径。实现上，根据路径规则的解析函数会以对象形式缓存在内存中。</li>
<li>matchPath(pathname, { path, exact, strict, sensitive }): 基于 <a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a>，将实际路径 pathname 解析为 { path, url, isExact, params } 形式。其中，path 为路径规则；url 为匹配的路径内容；isExact 指实际路径 path 和路径规则 pathname 是否相等；params 为路由参数。</li>
</ul>
<h2 id="react-router-config"><a href="#react-router-config" class="headerlink" title="react-router-config"></a>react-router-config</h2><p>react-router-config 输出如下两个工具函数：</p>
<ul>
<li>matchRoutes(routes, pathname): 从类树形结构的路由中获取当前匹配的路由节点分叉。主要针对 react-router4 没有在全局层面缓存全量的路由配置信息，路由配置散落在 Route 组件中。</li>
<li>renderRoutes(routes, extraProps, switchProps): 使用 Switch, Route 组件渲染单层结构的数组路由 routes。</li>
</ul>
<h2 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h2><p>基于 react-router 包，react-router-dom 针对浏览器环境提供了如下组件：</p>
<ul>
<li>BrowserRouter: 使用 history 库输出的 createBrowserHistory，构建前端路由。</li>
<li>HashRouter: 使用 history 库输出的 createBrowserHistory, 构建 hash 路由。</li>
<li>Link: 基于 __RouterContext，绘制 a 标签跳转链接。在配置 props.onClick 方法的情景中，可以采用采用浏览器机制跳转。</li>
<li>NavLink: 根据路由匹配情况，为 Link 元素设置特殊的样式。</li>
</ul>
<h2 id="react-router-native"><a href="#react-router-native" class="headerlink" title="react-router-native"></a>react-router-native</h2><p>基于 react-router 包，react-router-dom 针对 native 环境提供了如下组件：</p>
<ul>
<li>NativeRouter: 基于 MemoryRouter 组件，构建前端路由。默认的 props.getUserConfirmation 方法通过 react-native 输出的 Alert 实现。</li>
<li>BackButton: 基于 react-native 输出的 BackHandler 绑定 hardwareBackPress 事件，实现点击 back 按钮回退页面的功能。</li>
<li>Link: 通过为 props.Component 组件绑定 onPress 事件并渲染，实现页面跳转。</li>
<li>DeepLinking: 基于 react-native 输出的 Linking 绑定 url 事件，以使 Linking.openURL 调用过程中移除参数 url 中 ‘://‘ 及其前的内容。关于深度链接，可参看 <a href="https://www.jianshu.com/p/117a2cd510a6" target="_blank" rel="noopener">浅析移动应用深度链接 (Deeplinking)</a>， <a href="https://facebook.github.io/react-native/docs/linking.html" target="_blank" rel="noopener">Linking</a>。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的写作基于反向演绎，缺少遇到问题时正向推理的顺畅感，又介于笔者水平有限，文中难免谬误，仍望海涵。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/27/react/react相关/history源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/react/react相关/history源码/" itemprop="url">history</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T00:00:00+08:00">2019-01-27</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端路由/" itemprop="url" rel="index"><span itemprop="name">前端路由</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/27/react/react相关/history源码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/27/react/react相关/history源码/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>history 库基于 html5 的 history 接口，用于操控和观察浏览器地址栏的变更。本文分为两部分：介绍 html5 的 history 接口；再介绍 history 库的实现。</p>
<h2 id="history-接口"><a href="#history-接口" class="headerlink" title="history 接口"></a>history 接口</h2><p>为实现浏览器地址栏变更，又不至使页面刷新，html 提供了 history.pushState(state, title, url) 方法。该方法结合 ajax 请求一起使用，就可以实现地址栏变更时的局部刷新。实现详情可参阅 <a href="http://diveintohtml5.info/history.html" target="_blank" rel="noopener">MANIPULATING HISTORY FOR FUN &amp; PROFIT</a> 这篇文章。同时，这篇文章也指出，若想保证回退按钮也实现局部刷新，须监听 popstate 事件。以下整理的是 mozilla 开列的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">history 文档</a>。</p>
<ul>
<li>history.length: 存储在回话历史堆栈中的元素数量。</li>
<li>history.state: 获取栈顶——历史堆栈入口的状态值。</li>
<li>history.back(): 前往上一页，浏览器的回退按钮可以模拟此方法。</li>
<li>history.forward(): 前往下一页，浏览器的前进按钮可以模拟此方法。</li>
<li>history.go(num): 前往历史堆栈中的指定页面。</li>
<li>history.pushState(state, title, url): 将数据压入历史堆栈中。state 数据量须小于 640kb，firefox 会将其保存到本地磁盘中。firefox 也会忽略 title 参数。这一过程将触发 popstate 事件，但不会触发 hashchange 事件。</li>
<li>history.replaceState(state, title, url): 替换历史堆栈入口的数据。</li>
<li>popstate: 当历史堆栈入口数据变更时，均会触发 popstate 事件，包含调用 history.back, history.forward, history.go 方法，以及点击前进、回退按钮。history.pushState, history.replaceState 方法不会触发 popstate 事件。</li>
<li>window.onpopstate = (event) =&gt; {}; window.addEventListener(‘popstate’, (event) =&gt; {}): 监听 popstate 事件。</li>
<li>hashchange: hash 路径变更，将会触发 hashchange 事件。</li>
<li>window.onhashchange = (event) =&gt; {}; window.addEventListener(‘hashchange’, (event) =&gt; {}): 监听 hashchange 事件。</li>
</ul>
<h2 id="history-库"><a href="#history-库" class="headerlink" title="history 库"></a>history 库</h2><p>history 库创建了一个虚拟的 history 对象，以操纵浏览器地址栏的变更（createBrowserHistory）、或者操纵 hash 路径的变更（createHashHistory）、或者管理内存中的虚拟历史堆栈（createMemoryHistory）。各 history 对象均含有如下属性或方法：</p>
<ul>
<li>push(path, state): 往历史堆栈中压入数据。</li>
<li>replace(path, state): 变更历史堆栈入口数据。</li>
<li>go, goBack, goForward: 根据历史堆栈信息进行跳页。</li>
<li>block(prompt): 根据条件 prompt 阻断地址栏变更。</li>
<li>listen((location, action) =&gt; {}): 监听地址栏变更。</li>
<li>length: 历史堆栈中的数据量。</li>
<li>action: history 前次执行的方法名，值包含 ‘POP’, ‘PUSH’, ‘REPLACE’。</li>
<li>location: 历史堆栈入口的数据内容，数据结构为 { pathname, search, hash, key, state }，通过 LocationUtils.createLocation 创建。</li>
</ul>
<p>监听函数 listener 会在地址栏变更后予以执行。实现上，history 先收集历史堆栈入口的变更数据，并写入虚拟的 history 对象中，然后再执行 listener。这一过程表现为 createBrowserHistory, createHashHistory, createMemoryHistory 模块中的 setState 函数。因此，通过 pushState, replaceState, go 方法，或者通过对 location 对象赋值变更地址栏后，就可以调用 setState 执行监听函数了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">nextState</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(history, nextState);</span><br><span class="line">  history.length = globalHistory.length;</span><br><span class="line">  transitionManager.notifyListeners(history.location, history.action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>history 有两种阻断地址栏变更的方法：在变更前拦截；在变更后回滚。相对于变更地址栏的三种方式：对 location 对象直接赋值，或者调用 pushState, replaceState 方法，或者调用 go 方法。前两种方法，我们都知道地址栏将要变更为何值，因此 history 选择在变更前拦截；后一种方法，我们不知道地址栏将会变更为何值，因此 history 选择在变更后回滚。实现上，history 使用 transitionManager.confirmTransitionTo 包裹前两种方法的调用过程；通过监听 popstate, hashchange 事件获得变更后的 location 数据，同样使用 transitionManager.confirmTransitionTo 判断是否需要回滚，还是维持现状。回滚机制的典型实现如 createBrowserHistory, createHashHistory 模块中的 handlePop 函数等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回滚到前几页时，跳过回滚机制</span></span><br><span class="line"><span class="keyword">let</span> forceNextPop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlePop</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (forceNextPop) &#123;</span><br><span class="line">    forceNextPop = <span class="literal">false</span>;</span><br><span class="line">    setState();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="string">'POP'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 prompt 判断是否需要回滚</span></span><br><span class="line">    transitionManager.confirmTransitionTo(</span><br><span class="line">      location,</span><br><span class="line">      action,</span><br><span class="line">      getUserConfirmation,</span><br><span class="line">      ok =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">          <span class="comment">// 维持现状</span></span><br><span class="line">          setState(&#123; action, location &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 回滚</span></span><br><span class="line">          revertPop(location);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revertPop</span>(<span class="params">fromLocation</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> toLocation = history.location;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We could probably make this more reliable by</span></span><br><span class="line">  <span class="comment">// keeping a list of keys we've seen in sessionStorage.</span></span><br><span class="line">  <span class="comment">// Instead, we just default to 0 for keys we don't know.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// allKeys 缓存历史堆栈中的数据标识</span></span><br><span class="line">  <span class="keyword">let</span> toIndex = allKeys.indexOf(toLocation.key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (toIndex === <span class="number">-1</span>) toIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> fromIndex = allKeys.indexOf(fromLocation.key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fromIndex === <span class="number">-1</span>) fromIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> delta = toIndex - fromIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">    forceNextPop = <span class="literal">true</span>;</span><br><span class="line">    go(delta);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transitionManager 由 createTransitionManager 模块创建，提供了如下四种方法：</p>
<ul>
<li>appendListener(fn)：添加 fn 监听函数，返回函数可用于移除添加的监听函数。</li>
<li>notifyListeners(…args)：执行所有已添加的监听函数。</li>
<li>setPrompt(nextPrompt)：字符串时为提示；函数形式 (location, action) =&gt; {} 既可用于判断变更条件是否达成，或者输出提示文案；布尔值作为变更条件判断的结果。</li>
<li>confirmTransitionTo(location, action, getUserConfirmation, callback)：变更地址栏时，通过 prompt 判断变更条件是否达成或者获取提示文案；若取得提示文案，由 getUserConfirmation = (prompt, callback) =&gt; {} 设定 callback 的调用机制，否则以变更条件达成与否的状态值作为 callback 的参数，并执行 callback 回调。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">confirmTransitionTo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  location,</span></span></span><br><span class="line"><span class="function"><span class="params">  action,</span></span></span><br><span class="line"><span class="function"><span class="params">  getUserConfirmation,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> If another transition starts while we're still confirming</span></span><br><span class="line">  <span class="comment">// the previous one, we may end up in a weird state. Figure out the</span></span><br><span class="line">  <span class="comment">// best way to handle this.</span></span><br><span class="line">  <span class="keyword">if</span> (prompt != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result =</span><br><span class="line">      <span class="keyword">typeof</span> prompt === <span class="string">'function'</span> ? prompt(location, action) : prompt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> getUserConfirmation === <span class="string">'function'</span>) &#123;</span><br><span class="line">        getUserConfirmation(result, callback);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warning(</span><br><span class="line">          <span class="literal">false</span>,</span><br><span class="line">          <span class="string">'A history needs a getUserConfirmation function in order to use a prompt message'</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        callback(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Return false from a transition hook to cancel the transition.</span></span><br><span class="line">      callback(result !== <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    callback(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于以上触发监听函数、阻断地址栏变更的机制，下面我们一一揭开 createBrowserHistory, createHashHistory, createMemoryHistory 模块的面纱。</p>
<h3 id="createBrowserHistory"><a href="#createBrowserHistory" class="headerlink" title="createBrowserHistory"></a>createBrowserHistory</h3><p>createBrowserHistory 基于 html5 中的 pushState, replaceState 变更地址栏。地址栏变更内容不限于 hash 路径。当浏览器不支持 html5 的 history 接口时，createBrowserHistory 将直接变更 location.href 或者调用 location.replace 方法实现地址栏变更。</p>
<p>首先，createBrowserHistory 接受 props 参数。其中，props.forceRefresh 设定以刷新页面的形式变更地址栏；getUserConfirmation 配合 browserHistory.block 方法，可根据地址栏变更信息决定是否允许本次变更；props.keyLength 决定每条历史数据标识符 key 键的长度；props.basename 设置地址栏变更的基本路径。</p>
<p>其次，实现 push, replace 方法，用于变更历史入口。在支持 html5 history 接口的浏览器中，createBrowserHistory 将调用 setState 方法监听函数的执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">  warning(</span><br><span class="line">    !(</span><br><span class="line">      <span class="keyword">typeof</span> path === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      path.state !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">      state !== <span class="literal">undefined</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'You should avoid providing a 2nd state argument to push when the 1st '</span> +</span><br><span class="line">      <span class="string">'argument is a location-like object that already has state; it is ignored'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'PUSH'</span>;</span><br><span class="line">  <span class="keyword">const</span> location = createLocation(path, state, createKey(), history.location);</span><br><span class="line"></span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> href = createHref(location);</span><br><span class="line">      <span class="keyword">const</span> &#123; key, state &#125; = location;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (canUseHistory) &#123;</span><br><span class="line">        globalHistory.pushState(&#123; key, state &#125;, <span class="literal">null</span>, href);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceRefresh) &#123;</span><br><span class="line">          <span class="built_in">window</span>.location.href = href;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> prevIndex = allKeys.indexOf(history.location.key);</span><br><span class="line">          <span class="keyword">const</span> nextKeys = allKeys.slice(</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            prevIndex === <span class="number">-1</span> ? <span class="number">0</span> : prevIndex + <span class="number">1</span></span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          nextKeys.push(location.key);</span><br><span class="line">          allKeys = nextKeys;</span><br><span class="line"></span><br><span class="line">          setState(&#123; action, location &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warning(</span><br><span class="line">          state === <span class="literal">undefined</span>,</span><br><span class="line">          <span class="string">'Browser history cannot push state in browsers that do not support HTML5 history'</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.location.href = href;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">path, state</span>) </span>&#123;</span><br><span class="line">  warning(</span><br><span class="line">    !(</span><br><span class="line">      <span class="keyword">typeof</span> path === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      path.state !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">      state !== <span class="literal">undefined</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'You should avoid providing a 2nd state argument to replace when the 1st '</span> +</span><br><span class="line">      <span class="string">'argument is a location-like object that already has state; it is ignored'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = <span class="string">'REPLACE'</span>;</span><br><span class="line">  <span class="keyword">const</span> location = createLocation(path, state, createKey(), history.location);</span><br><span class="line"></span><br><span class="line">  transitionManager.confirmTransitionTo(</span><br><span class="line">    location,</span><br><span class="line">    action,</span><br><span class="line">    getUserConfirmation,</span><br><span class="line">    ok =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> href = createHref(location);</span><br><span class="line">      <span class="keyword">const</span> &#123; key, state &#125; = location;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (canUseHistory) &#123;</span><br><span class="line">        globalHistory.replaceState(&#123; key, state &#125;, <span class="literal">null</span>, href);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceRefresh) &#123;</span><br><span class="line">          <span class="built_in">window</span>.location.replace(href);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> prevIndex = allKeys.indexOf(history.location.key);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (prevIndex !== <span class="number">-1</span>) allKeys[prevIndex] = location.key;</span><br><span class="line"></span><br><span class="line">          setState(&#123; action, location &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warning(</span><br><span class="line">          state === <span class="literal">undefined</span>,</span><br><span class="line">          <span class="string">'Browser history cannot replace state in browsers that do not support HTML5 history'</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.location.replace(href);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，基于原生的 history 对象实现 go, goBack, goForward 方法。此种变更地址栏的方式可以触发 popstate 或 hashchange 事件。</p>
<p>最后，实现 block 方法阻断地址栏变更；listen 方法监听地址栏变更。两者都会绑定 popstate 或 hashchange 事件的回调函数。通过这两个事件判断本次变更是否需要回滚、以及触发 listener 监听函数的执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为事件的绑定函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlePopState</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Ignore extraneous popstate events in WebKit.</span></span><br><span class="line">  <span class="keyword">if</span> (isExtraneousPopstateEvent(event)) <span class="keyword">return</span>;</span><br><span class="line">  handlePop(getDOMLocation(event.state));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleHashChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  handlePop(getDOMLocation(getHistoryState()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定或清理事件的处理函数</span></span><br><span class="line"><span class="keyword">let</span> listenerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkDOMListeners</span>(<span class="params">delta</span>) </span>&#123;</span><br><span class="line">  listenerCount += delta;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (listenerCount === <span class="number">1</span> &amp;&amp; delta === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(PopStateEvent, handlePopState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHashChangeListener)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(HashChangeEvent, handleHashChange);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenerCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(PopStateEvent, handlePopState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHashChangeListener)</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(HashChangeEvent, handleHashChange);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻断地址栏变更</span></span><br><span class="line"><span class="keyword">let</span> isBlocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params">prompt = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unblock = transitionManager.setPrompt(prompt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isBlocked) &#123;</span><br><span class="line">    checkDOMListeners(<span class="number">1</span>);</span><br><span class="line">    isBlocked = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlocked) &#123;</span><br><span class="line">      isBlocked = <span class="literal">false</span>;</span><br><span class="line">      checkDOMListeners(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unblock();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听地址栏变更</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unlisten = transitionManager.appendListener(listener);</span><br><span class="line">  checkDOMListeners(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    checkDOMListeners(<span class="number">-1</span>);</span><br><span class="line">    unlisten();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="createHashHistory"><a href="#createHashHistory" class="headerlink" title="createHashHistory"></a>createHashHistory</h3><p>createHashHistory 的处理逻辑与 createBrowserHistory 相同，只不过 createHashHistory 着眼于 hash 路径的变更。</p>
<p>createHashHistory 的参数 props 仅接受 basename, getUserConfirmation, hashType 三个属性。createHashHistory 专有的 hashType 用于设置 hash 路径的编码解码策略，默认为 ‘slash’。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash 路径的编码解码策略集合</span></span><br><span class="line"><span class="keyword">const</span> HashPathCoders = &#123;</span><br><span class="line">  hashbang: &#123;</span><br><span class="line">    encodePath: <span class="function"><span class="params">path</span> =&gt;</span></span><br><span class="line">      path.charAt(<span class="number">0</span>) === <span class="string">'!'</span> ? path : <span class="string">'!/'</span> + stripLeadingSlash(path),</span><br><span class="line">    decodePath: <span class="function"><span class="params">path</span> =&gt;</span> (path.charAt(<span class="number">0</span>) === <span class="string">'!'</span> ? path.substr(<span class="number">1</span>) : path)</span><br><span class="line">  &#125;,</span><br><span class="line">  noslash: &#123;</span><br><span class="line">    encodePath: stripLeadingSlash,</span><br><span class="line">    decodePath: addLeadingSlash</span><br><span class="line">  &#125;,</span><br><span class="line">  slash: &#123;</span><br><span class="line">    encodePath: addLeadingSlash,</span><br><span class="line">    decodePath: addLeadingSlash</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 createHashHistory 模块中，变更 hash 路径基于 location.hash 赋值和 location.replace 方法。同时，createHashHistory 借助 hashchange 事件实现回滚，而上述两者变更 hash 路径的方式均会触发 hashchange 事件。因此，在 push, replace 方法的实现中，待变更的地址将会写入 ignorePath 缓存中，以在 handleHashChange 绑定函数对此变更不作回滚操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleHashChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = getHashPath();</span><br><span class="line">  <span class="keyword">const</span> encodedPath = encodePath(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (path !== encodedPath) &#123;</span><br><span class="line">    <span class="comment">// Ensure we always have a properly-encoded hash.</span></span><br><span class="line">    replaceHashPath(encodedPath);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> location = getDOMLocation();</span><br><span class="line">    <span class="keyword">const</span> prevLocation = history.location;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!forceNextPop &amp;&amp; locationsAreEqual(prevLocation, location)) <span class="keyword">return</span>; <span class="comment">// A hashchange doesn't always == location change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignorePath === createPath(location)) <span class="keyword">return</span>; <span class="comment">// Ignore this change; we already setState in push/replace.</span></span><br><span class="line"></span><br><span class="line">    ignorePath = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    handlePop(location);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="createMemoryHistory"><a href="#createMemoryHistory" class="headerlink" title="createMemoryHistory"></a>createMemoryHistory</h3><p>createMemoryHistory 用于在内存中创建完全虚拟的历史堆栈，只缓存历史记录，但与真实的地址栏无关（不会引起地址栏变更，不会和原生的 history 对象保持同步），也与 popstate, hashchange 事件无关。</p>
<p>createMemoryHistory 的参数 props 接受 getUserConfirmation, initialEntries, initialIndex, keyLength 属性。其中，props.initialEntries 指定最初的历史堆栈内容 history.entries；props.initialIndex 指定最初的索引值 history.index。push, replace 方法均将改变 history.entries 历史堆栈内容；go, goBack, goForward 均基于  history.entries 历史堆栈内容，以改变 history.index 及 history.location。实现参见源码。</p>
<h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><h4 id="PathUtils"><a href="#PathUtils" class="headerlink" title="PathUtils"></a>PathUtils</h4><p>路径相关操作。</p>
<ul>
<li>addLeadingSlash(path)：酌情为 path 路径添加前缀 ‘/‘。</li>
<li>stripLeadingSlash(path)：酌情为 path 路径剔除前缀 ‘/‘。</li>
<li>hasBasename(path, prefix)：判断路径 path 是否包含前缀 prefix。</li>
<li>stripBasename(path, prefix)：酌情为 path 路径剔除前缀 prefix。</li>
<li>stripTrailingSlash(path)：酌情为 path 路径剔除后缀 ‘/‘。</li>
<li>parsePath(path)：将字符串路径 path 转换为 { pathname, search, hash } 对象。</li>
<li>createPath(location)：将 { pathname, search, hash } 对象转换为字符串路径 path。</li>
</ul>
<h4 id="LocationUtils"><a href="#LocationUtils" class="headerlink" title="LocationUtils"></a>LocationUtils</h4><p>location 对象相关操作，基于 resolve-pathname, value-equal。</p>
<ul>
<li>createLocation(path, state, key, currentLocation) 构建 location = { pathname, search, hash, key, state } 对象，pathname 将根据 currentLocation 参数进行调整。</li>
<li>locationsAreEqual(a, b) 判断两个 location 对象是否相等。</li>
</ul>
<h4 id="DOMUtils"><a href="#DOMUtils" class="headerlink" title="DOMUtils"></a>DOMUtils</h4><p>DOM 环境判断。</p>
<ul>
<li>canUseDOM 是否可以操作节点。</li>
<li>getConfirmation(message, callback) 使用 window.confirm 弹出确认框，callback 的参数可用于判断用户是否点击确认按键。</li>
<li>supportsHistory 判断浏览器平台是否支持 HTML5 history API。</li>
<li>supportsPopStateOnHashChange 判断浏览器平台是否会在 hash 路径变更时触发 popstate 事件。</li>
<li>supportsGoWithoutReloadUsingHash 使用 go(n) 变更 hash 路径时是否不会页面刷新。</li>
<li>isExtraneousPopstateEvent 判断 popstate 事件是否由无关的操作引起。iOS 平台 chrome 浏览器点击回退按钮会触发 state 为 undefined 的 popstate 事件。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/15/react/react16源码/scheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/15/react/react16源码/scheduler/" itemprop="url">scheduler 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-15T00:00:00+08:00">2019-01-15</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/react/" itemprop="url" rel="index"><span itemprop="name">react</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/15/react/react16源码/scheduler/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/15/react/react16源码/scheduler/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>scheduler 模块用于管理重绘完成后回调的执行逻辑。在 scheduler 中，requestHostCallback 函数用于实现在重绘完成后、视线程的空闲程度以及任务预设的超时时间，以在特定的时机执行任务。在 requestHostCallback 的基础上，scheduler 使用双向链表构建含有优先级的原子任务节点，再输出添加并执行任务节点、打断任务节点执行的 api。</p>
<h2 id="requestHostCallback"><a href="#requestHostCallback" class="headerlink" title="requestHostCallback"></a>requestHostCallback</h2><p>scheduler 模块支持三种方式实现 requestHostCallback, cancelHostCallback, shouldYieldToHost, getCurrentTime 函数：一、通过 window._schedMock 或 global._schedMock 数组注入；二、通过 setTimeout 实现（实现上当 requestHostCallback 的首参 —— 任务函数尚在执行过程中，scheduler 将 requestHostCallback 作为 setTimeout 的回调函数，以使在新添加任务函数间接添加到 macrotasks 队列中，可参看源码）；三、基于 MessageChannel, requestAnimationFrame 实现（MessageChannel 用于探知线程是否空闲，requestAnimationFrame 用于与重绘机制契合）。本文着重介绍第三种方式，并用 rAF 指代 requestAnimationFrame。</p>
<p>基于 MessageChannel, requestAnimationFrame 实现的上述四种函数的功能点为：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>requestHostCallback(callback, absoluteTimeout)</td>
<td>在重绘完成后执行任务，并与线程的空闲程度相契合，详情见下文</td>
</tr>
<tr>
<td>cancelHostCallback</td>
<td>用于取消任务</td>
</tr>
<tr>
<td>shouldYieldToHost</td>
<td>用于判断任务是否超时、需要被打断</td>
</tr>
<tr>
<td>getCurrentTime</td>
<td>使用 performance 或 Date 对象获取当前时间</td>
</tr>
</tbody>
</table>
<p>requestHostCallback 执行的流程图为：</p>
<img src="/2019/01/15/react/react16源码/scheduler/requestHostCallback流程图.png">
<p>上图中所用的缓存值有：</p>
<table>
<thead>
<tr>
<th>缓存</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>scheduledHostCallback</td>
<td>待执行的回调，即上图中的任务，会被刷新</td>
</tr>
<tr>
<td>timeoutTime</td>
<td>任务允许的超时时间点</td>
</tr>
<tr>
<td>isAnimationFrameScheduled</td>
<td>rAF 轮询启动状态</td>
</tr>
<tr>
<td>isMessageEventScheduled</td>
<td>消息发送中标识</td>
</tr>
<tr>
<td>isFlushingHostCallback</td>
<td>任务执行中标识</td>
</tr>
<tr>
<td>activeFrameTime</td>
<td>任务允许的超时时间点</td>
</tr>
<tr>
<td>timeoutTime</td>
<td>一帧的期望执行时长，预设为 33 ms，在视图刷新过快时会更新，值将变小</td>
</tr>
<tr>
<td>previousFrameTime</td>
<td>前一帧执行时长</td>
</tr>
<tr>
<td>frameDeadline</td>
<td>下一帧期望完成时间点，用于判断重绘后 js 线程是否空闲，还是长期占用</td>
</tr>
</tbody>
</table>
<p>实现机制上，scheduler 首先实现 requestAnimationFrameWithTimeout 函数。该函数封装 requestAnimationFrame 函数，以使任务在重绘完后才予执行；但如果一些视图操作在后台执行，requestAnimationFrame 的回调将得不到执行，因此 scheduler 使用 setTimeout 兜底。流程图中启动 rAF 轮询就是指调用 requestAnimationFrameWithTimeout； animateTick 作为 requestAnimationFrameWithTimeout 回调。在 animateTick 的实现中，若 scheduledHostCallback 非 null，scheduler 将持续调用 requestAnimationFrameWithTimeout。因此本文将这一过程称为 rAF 轮询。</p>
<p>scheduler 考虑了重绘完成后、线程可能处于紧张的场景，因此所添加的任务并没有直接作为 requestAnimationFrameWithTimeout 的回调。scheduler 使用 MessageChannel 添加 macrotasks 队列作桥接，等待线程空闲，然后再执行任务。在 animateTick 中，scheduler 将计算下一帧期望完成时间点 previousFrameTime，然后通过 port.postMessage 方法发送消息。等到 port1 接受到消息时，schdulear 将 previousFrameTime 与 currentTime 作比较：当 previousFrameTime 小于等于 currentTime 时，scheduler 认为线程不是空闲的，对于超时的任务将立即执行，对于未超时的任务将在下次重绘后予以处理；当 previousFrameTime 大于 currentTime 时，线程就是空闲的，scheduler 将立即执行。这一处理机制在 port1.onMessage 监听函数中实现（作为 macrotasks，port1 接受消息的时机将随着线程的空闲程度起变化）。</p>
<p>有了上述的处理逻辑，scheduler 在外围制作 requestHostCallback(callback, absoluteTimeout) 接口：当前如果有任务正在执行中（意为当前没有重绘任务，重绘线程是空闲的）或者所添加的任务需要立即执行，scheduler 直接调用 port.postMessage 发送消息，跳过 rAF 轮询，以使任务得到即时执行；否则，如果 rAF 轮询未启动，调用 requestAnimationFrameWithTimeout(animationTick) 启动轮询。</p>
<p>在 requestHostCallback 接口之外，cancelHostCallback 通过 scheduledHostCallback 置为 null，以中断任务的执行；shouldYieldToHost 用于比较 frameDeadline 是否小于等于 currentTime（在一帧时间外），以此推断线程是否空闲，好添加并处理新任务。以下是 requestHostCallback 函数实现的源码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestAnimationFrameWithTimeout = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// schedule rAF and also a setTimeout</span></span><br><span class="line">  rAFID = localRequestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// cancel the setTimeout</span></span><br><span class="line">    localClearTimeout(rAFTimeoutID);</span><br><span class="line">    callback(timestamp);</span><br><span class="line">  &#125;);</span><br><span class="line">  rAFTimeoutID = localSetTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// cancel the requestAnimationFrame</span></span><br><span class="line">    localCancelAnimationFrame(rAFID);</span><br><span class="line">    callback(getCurrentTime());</span><br><span class="line">  &#125;, ANIMATION_FRAME_TIMEOUT);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">var</span> port = channel.port2;</span><br><span class="line">channel.port1.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> prevScheduledCallback = scheduledHostCallback;</span><br><span class="line">  <span class="keyword">var</span> prevTimeoutTime = timeoutTime;</span><br><span class="line">  scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">  timeoutTime = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> didTimeout = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程不空闲</span></span><br><span class="line">  <span class="keyword">if</span> (frameDeadline - currentTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// There's no time left in this idle period. Check if the callback has</span></span><br><span class="line">    <span class="comment">// a timeout and whether it's been exceeded.</span></span><br><span class="line">    <span class="keyword">if</span> (prevTimeoutTime !== <span class="number">-1</span> &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// Exceeded the timeout. Invoke the callback even though there's no</span></span><br><span class="line">      <span class="comment">// time left.</span></span><br><span class="line">      didTimeout = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No timeout.</span></span><br><span class="line">      <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">        <span class="comment">// Schedule another animation callback so we retry later.</span></span><br><span class="line">        isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">        requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Exit without invoking the callback.</span></span><br><span class="line">      scheduledHostCallback = prevScheduledCallback;</span><br><span class="line">      timeoutTime = prevTimeoutTime;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevScheduledCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    isFlushingHostCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      prevScheduledCallback(didTimeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animationTick = <span class="function"><span class="keyword">function</span>(<span class="params">rafTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (scheduledHostCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Eagerly schedule the next animation callback at the beginning of the</span></span><br><span class="line">    <span class="comment">// frame. If the scheduler queue is not empty at the end of the frame, it</span></span><br><span class="line">    <span class="comment">// will continue flushing inside that callback. If the queue *is* empty,</span></span><br><span class="line">    <span class="comment">// then it will exit immediately. Posting the callback at the start of the</span></span><br><span class="line">    <span class="comment">// frame ensures it's fired within the earliest possible frame. If we</span></span><br><span class="line">    <span class="comment">// waited until the end of the frame to post the callback, we risk the</span></span><br><span class="line">    <span class="comment">// browser skipping a frame and not firing the callback until the frame</span></span><br><span class="line">    <span class="comment">// after that.</span></span><br><span class="line">    requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No pending work. Exit.</span></span><br><span class="line">    isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nextFrameTime = rafTime - frameDeadline + activeFrameTime;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    nextFrameTime &lt; activeFrameTime &amp;&amp;</span><br><span class="line">    previousFrameTime &lt; activeFrameTime</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFrameTime &lt; <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="comment">// Defensive coding. We don't support higher frame rates than 120hz.</span></span><br><span class="line">      <span class="comment">// If the calculated frame time gets lower than 8, it is probably a bug.</span></span><br><span class="line">      nextFrameTime = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If one frame goes long, then the next one can be short to catch up.</span></span><br><span class="line">    <span class="comment">// If two frames are short in a row, then that's an indication that we</span></span><br><span class="line">    <span class="comment">// actually have a higher frame rate than what we're currently optimizing.</span></span><br><span class="line">    <span class="comment">// We adjust our heuristic dynamically accordingly. For example, if we're</span></span><br><span class="line">    <span class="comment">// running on 120hz display or 90hz VR display.</span></span><br><span class="line">    <span class="comment">// Take the max of the two in case one of them was an anomaly due to</span></span><br><span class="line">    <span class="comment">// missed frame deadlines.</span></span><br><span class="line">    activeFrameTime =</span><br><span class="line">      nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    previousFrameTime = nextFrameTime;</span><br><span class="line">  &#125;</span><br><span class="line">  frameDeadline = rafTime + activeFrameTime;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageEventScheduled) &#123;</span><br><span class="line">    isMessageEventScheduled = <span class="literal">true</span>;</span><br><span class="line">    port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span>(<span class="params">callback, absoluteTimeout</span>) </span>&#123;</span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  timeoutTime = absoluteTimeout;</span><br><span class="line">  <span class="keyword">if</span> (isFlushingHostCallback || absoluteTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Don't wait for the next frame. Continue working ASAP, in a new event.</span></span><br><span class="line">    port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">    <span class="comment">// If rAF didn't already schedule one, we need to schedule a frame.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> If this rAF doesn't materialize because the browser throttles, we</span></span><br><span class="line">    <span class="comment">// might want to still have setTimeout trigger rIC as a backup to ensure</span></span><br><span class="line">    <span class="comment">// that we keep performing work.</span></span><br><span class="line">    isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">    requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><h3 id="callbackNode-及其执行机制"><a href="#callbackNode-及其执行机制" class="headerlink" title="callbackNode 及其执行机制"></a>callbackNode 及其执行机制</h3><p>scheduler 以首尾相连的双向链表缓存 callbackNode，每个任务节点的 previous 属性指向上一个任务节点（firstCallbackNode 的 previous 属性指向 lastCallbackNode），next 属性指向下一个任务节点（lastCallbackNode 的 next 属性指向 firstCallbackNode）。链表中的 callbackNode 以优先级（以超时时间 expirationTime 属性表示）进行排序。以双向链表构建的数据，只需要缓存 firstCallbackNode 首任务节点。</p>
<p>scheduler 针对 callbackNode 设定五种优先级，分别是 ImmediatePriority, UserBlockingPriority, NormalPriority, LowPriority, IdlePriority。优先级会影响超时时间，以上五个优先级的超时时间分别为 -1, 250, 5000, 10000, 1073741823。因此对于 ImmediatePriority 优先级的任务节点，在使用 requestHostCallback 函数处理的过程中，该任务节点就不需要经过 rAF 回调机制，而是会经由 MessageChannel 直接被处理。</p>
<p>在 callbackNode 任务节点中，callback 属性为待执行的函数，priorityLevel 为执行优先级，expirationTime 为允许的超时时间点（以当前时间 + 超时时间的方式计算）。因为 requestHostCallback 每次调用时都会刷新 scheduledHostCallback 缓存，callbackNode.callback 并不能直接作为 requestHostCallback 的参数，那样会在两次调用过程中，造成前一个任务丢失。scheduler 实际使用 flushWork 函数作为 requestHostCallback 的参数（在 ensureHostCallbackIsScheduled 函数中处理），便于批量执行双向链表中的 callbackNode.callback 函数，也不至使任务丢失。</p>
<p>flushWork 函数基于 flushFirstCallback, flushImmediateWork，以下是这三个函数的实现机制：</p>
<p>flushFirstCallback 从双向链表中取出首个任务节点并执行。若首个任务节点的 callback 返回函数，使用该函数构建新的 callbackNode 任务节点，并将该任务节点插入双向链表中：若该任务节点的优先级最高、且不只包含一个任务节点，调用 ensureHostCallbackIsScheduled，在下一次重绘后酌情执行双向链表中的任务节点；否则只将新创建的任务节点添加到双向链表中。</p>
<p>基于 flushFirstCallback，flushImmediateWork 函数用于执行双向链表中所有优先级为 ImmediatePriority 的任务节点。如果双向链表不只包含优先级为 ImmediatePriority 的任务节点，flushImmediateWork 将调用 ensureHostCallbackIsScheduled 等待下次重绘后执行剩余的任务节点。</p>
<p>flushWork 作为 requestHostCallback 函数的参数，获得的首个实参 didTimeout 为是否超时的标识。如果超时，flushWork 通过调用 flushFirstCallback 批量执行所有未超时的任务节点；若果没有超时，flushWork 将在下一帧未完成前（通过 shouldYieldToHost 函数判断）尽可能地执行任务节点。等上述条件逻辑执行完成后，如果双向链表非空，调用 ensureHostCallbackIsScheduled 等待下次重绘后执行剩余的任务节点。特别的，当双向链表中还存在 ImmediatePriority 优先级的任务节点，flushWork 将调用 flushImmediateWork 批量执行这些任务节点。</p>
<p>因为 scheduler 使用首个任务节点的超时时间点作为 requestHostCallback 函数的次参（在 ensureHostCallbackIsScheduled 函数中处理）。因此，如果首个任务节点的优先级为 ImmediatePriority，flushWork 所获得参数 didTimeout 也将是否值，其执行逻辑将是执行所有优先级为 ImmediatePriority 的任务节点，再调用 ensureHostCallbackIsScheduled 等待下一次重绘时执行其余任务节点。如果首个任务节点的优先级为 UserBlockingPriority 等，flushWork 将执行同优先级的任务节点，再调用 ensureHostCallbackIsScheduled 等待下一次重绘时执行其余任务节点。所有对不同优先级的任务节点，scheduler 采用分段执行的策略。</p>
<table>
<thead>
<tr>
<th>缓存</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>currentPriorityLevel</td>
<td>执行中任务节点的优先级，默认为 NormalPriority</td>
</tr>
<tr>
<td>currentExpirationTime</td>
<td>执行中任务节点的超时时间点</td>
</tr>
<tr>
<td>enableSchedulerDebugging</td>
<td>debug 模式？</td>
</tr>
<tr>
<td>isExecutingCallback</td>
<td>任务节点正在批量执行中标识</td>
</tr>
<tr>
<td>isHostCallbackScheduled</td>
<td>requestHostCallback 已执行并开启 rAF 轮询标识</td>
</tr>
<tr>
<td>isSchedulerPaused</td>
<td>scheduler 是否被打断，将不会执行任务节点，由接口层更新该值</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureHostCallbackIsScheduled</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isExecutingCallback) &#123;</span><br><span class="line">    <span class="comment">// Don't schedule work yet; wait until the next time we yield.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Schedule the host callback using the earliest expiration in the list.</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = firstCallbackNode.expirationTime;</span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Cancel the existing host callback.</span></span><br><span class="line">    cancelHostCallback();</span><br><span class="line">  &#125;</span><br><span class="line">  requestHostCallback(flushWork, expirationTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushFirstCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flushedNode = firstCallbackNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the node from the list before calling the callback. That way the</span></span><br><span class="line">  <span class="comment">// list is in a consistent state even if the callback throws.</span></span><br><span class="line">  <span class="keyword">var</span> next = firstCallbackNode.next;</span><br><span class="line">  <span class="keyword">if</span> (firstCallbackNode === next) &#123;</span><br><span class="line">    <span class="comment">// This is the last callback in the list.</span></span><br><span class="line">    firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lastCallbackNode = firstCallbackNode.previous;</span><br><span class="line">    firstCallbackNode = lastCallbackNode.next = next;</span><br><span class="line">    next.previous = lastCallbackNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flushedNode.next = flushedNode.previous = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now it's safe to call the callback.</span></span><br><span class="line">  <span class="keyword">var</span> callback = flushedNode.callback;</span><br><span class="line">  <span class="keyword">var</span> expirationTime = flushedNode.expirationTime;</span><br><span class="line">  <span class="keyword">var</span> priorityLevel = flushedNode.priorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousExpirationTime = currentExpirationTime;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line">  currentExpirationTime = expirationTime;</span><br><span class="line">  <span class="keyword">var</span> continuationCallback;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    continuationCallback = callback();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    currentExpirationTime = previousExpirationTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A callback may return a continuation. The continuation should be scheduled</span></span><br><span class="line">  <span class="comment">// with the same priority and expiration as the just-finished callback.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> continuationNode: CallbackNode = &#123;</span><br><span class="line">      callback: continuationCallback,</span><br><span class="line">      priorityLevel,</span><br><span class="line">      expirationTime,</span><br><span class="line">      next: <span class="literal">null</span>,</span><br><span class="line">      previous: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert the new callback into the list, sorted by its expiration. This is</span></span><br><span class="line">    <span class="comment">// almost the same as the code in `scheduleCallback`, except the callback</span></span><br><span class="line">    <span class="comment">// is inserted into the list *before* callbacks of equal expiration instead</span></span><br><span class="line">    <span class="comment">// of after.</span></span><br><span class="line">    <span class="keyword">if</span> (firstCallbackNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first callback in the list.</span></span><br><span class="line">      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> nextAfterContinuation = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">var</span> node = firstCallbackNode;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.expirationTime &gt;= expirationTime) &#123;</span><br><span class="line">          <span class="comment">// This callback expires at or after the continuation. We will insert</span></span><br><span class="line">          <span class="comment">// the continuation *before* this callback.</span></span><br><span class="line">          nextAfterContinuation = node;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">      &#125; <span class="keyword">while</span> (node !== firstCallbackNode);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextAfterContinuation === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No equal or lower priority callback was found, which means the new</span></span><br><span class="line">        <span class="comment">// callback is the lowest priority callback in the list.</span></span><br><span class="line">        nextAfterContinuation = firstCallbackNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextAfterContinuation === firstCallbackNode) &#123;</span><br><span class="line">        <span class="comment">// The new callback is the highest priority callback in the list.</span></span><br><span class="line">        firstCallbackNode = continuationNode;</span><br><span class="line">        ensureHostCallbackIsScheduled();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> previous = nextAfterContinuation.previous;</span><br><span class="line">      previous.next = nextAfterContinuation.previous = continuationNode;</span><br><span class="line">      continuationNode.next = nextAfterContinuation;</span><br><span class="line">      continuationNode.previous = previous;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushImmediateWork</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// Confirm we've exited the outer most event handler</span></span><br><span class="line">    currentEventStartTime === <span class="number">-1</span> &amp;&amp;</span><br><span class="line">    firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    firstCallbackNode.priorityLevel === ImmediatePriority</span><br><span class="line">  ) &#123;</span><br><span class="line">    isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        flushFirstCallback();</span><br><span class="line">      &#125; <span class="keyword">while</span> (</span><br><span class="line">        <span class="comment">// Keep flushing until there are no more immediate callbacks</span></span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        firstCallbackNode.priorityLevel === ImmediatePriority</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// There's still work remaining. Request another callback.</span></span><br><span class="line">        ensureHostCallbackIsScheduled();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushWork</span>(<span class="params">didTimeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Exit right away if we're currently paused</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> previousDidTimeout = currentDidTimeout;</span><br><span class="line">  currentDidTimeout = didTimeout;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (didTimeout) &#123;</span><br><span class="line">      <span class="comment">// Flush all the expired callbacks without yielding.</span></span><br><span class="line">      <span class="keyword">while</span> (</span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// TODO Wrap i nfeature flag</span></span><br><span class="line">        <span class="comment">// Read the current time. Flush all the callbacks that expire at or</span></span><br><span class="line">        <span class="comment">// earlier than that time. Then read the current time again and repeat.</span></span><br><span class="line">        <span class="comment">// This optimizes for as few performance.now calls as possible.</span></span><br><span class="line">        <span class="keyword">var</span> currentTime = getCurrentTime();</span><br><span class="line">        <span class="keyword">if</span> (firstCallbackNode.expirationTime &lt;= currentTime) &#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            flushFirstCallback();</span><br><span class="line">          &#125; <span class="keyword">while</span> (</span><br><span class="line">            firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            firstCallbackNode.expirationTime &lt;= currentTime &amp;&amp;</span><br><span class="line">            !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Keep flushing callbacks until we run out of time in the frame.</span></span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          flushFirstCallback();</span><br><span class="line">        &#125; <span class="keyword">while</span> (firstCallbackNode !== <span class="literal">null</span> &amp;&amp; !shouldYieldToHost());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">    currentDidTimeout = previousDidTimeout;</span><br><span class="line">    <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// There's still work remaining. Request another callback.</span></span><br><span class="line">      ensureHostCallbackIsScheduled();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">    flushImmediateWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="apis"><a href="#apis" class="headerlink" title="apis"></a>apis</h3><h4 id="unstable-scheduleCallback"><a href="#unstable-scheduleCallback" class="headerlink" title="unstable_scheduleCallback"></a>unstable_scheduleCallback</h4><p>unstable_scheduleCallback(callback, deprecated_options) 基于 currentPriorityLevel 优先级计算超时时间点，将 callback 构建为一个 callbackNode 任务节点，并将该节点插入双向链表，启用 ensureHostCallbackIsScheduled 等待重绘后执行任务节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params">callback, deprecated_options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime =</span><br><span class="line">    currentEventStartTime !== <span class="number">-1</span> ? currentEventStartTime : getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> expirationTime;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    deprecated_options !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options.timeout === <span class="string">'number'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Remove this branch once we lift expiration times out of React.</span></span><br><span class="line">    expirationTime = startTime + deprecated_options.timeout;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPriorityLevel) &#123;</span><br><span class="line">      <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">        expirationTime = startTime + USER_BLOCKING_PRIORITY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IdlePriority:</span><br><span class="line">        expirationTime = startTime + IDLE_PRIORITY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LowPriority:</span><br><span class="line">        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NormalPriority:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newNode = &#123;</span><br><span class="line">    callback,</span><br><span class="line">    priorityLevel: currentPriorityLevel,</span><br><span class="line">    expirationTime,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">    previous: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert the new callback into the list, ordered first by expiration, then</span></span><br><span class="line">  <span class="comment">// by insertion. So the new callback is inserted any other callback with</span></span><br><span class="line">  <span class="comment">// equal expiration.</span></span><br><span class="line">  <span class="keyword">if</span> (firstCallbackNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is the first callback in the list.</span></span><br><span class="line">    firstCallbackNode = newNode.next = newNode.previous = newNode;</span><br><span class="line">    ensureHostCallbackIsScheduled();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> node = firstCallbackNode;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.expirationTime &gt; expirationTime) &#123;</span><br><span class="line">        <span class="comment">// The new callback expires before this one.</span></span><br><span class="line">        next = node;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node !== firstCallbackNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No callback with a later expiration was found, which means the new</span></span><br><span class="line">      <span class="comment">// callback has the latest expiration in the list.</span></span><br><span class="line">      next = firstCallbackNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next === firstCallbackNode) &#123;</span><br><span class="line">      <span class="comment">// The new callback has the earliest expiration in the entire list.</span></span><br><span class="line">      firstCallbackNode = newNode;</span><br><span class="line">      ensureHostCallbackIsScheduled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> previous = next.previous;</span><br><span class="line">    previous.next = next.previous = newNode;</span><br><span class="line">    newNode.next = next;</span><br><span class="line">    newNode.previous = previous;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unstable-runWithPriority"><a href="#unstable-runWithPriority" class="headerlink" title="unstable_runWithPriority"></a>unstable_runWithPriority</h4><p>unstable_runWithPriority(priorityLevel, eventHandler) 将 currentPriorityLevel 缓存设置为 priorityLevel，随后再执行 eventHandler，最后调用 flushImmediateWork 函数执行所有优先级为 ImmediatePriority 的任务节点，其余任务节点等待下次重绘后再执行。可以设想，当 eventHandler 为 unstable_scheduleCallback 函数时，将影响所添加任务节点的优先级，并立即执行 ImmediatePriority 优先级的任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_runWithPriority</span>(<span class="params">priorityLevel, eventHandler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      priorityLevel = NormalPriority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousEventStartTime = currentEventStartTime;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line">  currentEventStartTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> eventHandler();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    currentEventStartTime = previousEventStartTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">    flushImmediateWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unstable-wrapCallback"><a href="#unstable-wrapCallback" class="headerlink" title="unstable_wrapCallback"></a>unstable_wrapCallback</h4><p>unstable_wrapCallback(callback) 记录当前的优先级 currentPriorityLevel，返回函数处理效果如 unstable_runWithPriority，对于 callback 中新添加的任务节点将使用所记录的 currentPriorityLevel 作为优先级。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_wrapCallback</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parentPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// This is a fork of runWithPriority, inlined for performance.</span></span><br><span class="line">    <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">    <span class="keyword">var</span> previousEventStartTime = currentEventStartTime;</span><br><span class="line">    currentPriorityLevel = parentPriorityLevel;</span><br><span class="line">    currentEventStartTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">      currentEventStartTime = previousEventStartTime;</span><br><span class="line">      flushImmediateWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>unstable_pauseExecution 通过将 isSchedulerPaused 置为 true，打断 scheduler 处理任务节点。</li>
<li>unstable_continueExecution 取消打断状态，使 scheduler 恢复处理任务节点。</li>
<li>unstable_getFirstCallbackNode 获取双向链表中的首个任务节点。</li>
<li>unstable_cancelCallback(callbackNode) 从双向链表中移除指定任务节点。</li>
<li>unstable_getCurrentPriorityLevel 获取当前优先级 currentPriorityLevel 缓存。</li>
<li>unstable_shouldYield 是否需要被打断。</li>
<li>unstable_now 获取当前时间。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_shouldYield</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    !currentDidTimeout &amp;&amp;</span><br><span class="line">    ((firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      firstCallbackNode.expirationTime &lt; currentExpirationTime) ||</span><br><span class="line">      shouldYieldToHost())</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>scheduler 模块代码简短，逻辑复杂，在这篇文章中，难免有理解不当的地方。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/react/react16源码/React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/react/react16源码/React/" itemprop="url">react api 整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T00:00:00+08:00">2019-01-14</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/react/" itemprop="url" rel="index"><span itemprop="name">react</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/14/react/react16源码/React/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/14/react/react16源码/React/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文档意在整理 react 顶层 api 的内容和实现，可参阅<a href="https://reactjs.org/docs/react-api.html" target="_blank" rel="noopener">react 官方文档</a>。React 包主要提供 api 接口，功能上的核心逻辑点通常由 react-dom 等包实现。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>React 组件可将视图内容拆分为独立的、可复用的单元，以便在组件的模块制作过程中独立实现视图逻辑和业务逻辑。在 es6 语法背景下，React 组件可基于 React.Component, React.PureComponent 类加以制作。如果没有使用 es6 语法，可以使用 <a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="noopener">create-react-class</a> 库。除此以外，也可以编写函数式组件。该函数式组件能用 React.memo 加以包裹。</p>
<p>在源码中，React.Component, React.PureComponent 类由 ReactBaseClasses 模块提供。</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>Component(props, context, updater) 基类在构造函数中初始化 props, context, refs, updater 实例属性，并包含 isReactComponent, setState, forceUpdate 原型方法。其中，updater 属性在实例化阶段将赋值为默认的 ReactNoopUpdateQueue，渲染阶段在注入实际的 updater。setState, forceUpdate 原型方法基于 updater.enqueueSetState, updater.enqueueForceUpdate 构建。</p>
<h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>PureComponent(props, context, updater) 与 Component 基类拥有相同的实例属性，其原型对象也通过桥接函数赋值的形式重新构造、且混入了 Component 基类的原型方法，除此之外，PureComponent 还具有 isPureReactComponent 原型方法。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>可参考 <a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">React 组件生命周期</a></p>
<ol>
<li>挂载阶段：<ul>
<li>constructor(props): 实例化。</li>
<li>static getDeriverdStateFromProps 从 props 中获取 state。</li>
<li>render 渲染。</li>
<li>componentDidMount: 完成挂载。</li>
</ul>
</li>
<li>更新阶段：<ul>
<li>static getDeriverdStateFromProps 从 props 中获取 state。</li>
<li>shouldComponentUpdate 判断是否需要重绘。</li>
<li>rendere 渲染。</li>
<li>getShapshotBeforeUpdate 获取快照。</li>
<li>componentDidUpdate 渲染完成后回调。</li>
</ul>
</li>
<li>卸载阶段：<ul>
<li>componentWillUnmount 即将卸载。</li>
</ul>
</li>
<li>错误处理：<ul>
<li>static getDerivedStateFromError 从错误中获取 state。</li>
<li>componentDidCatch 捕获错误并进行处理。</li>
</ul>
</li>
</ol>
<h3 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h3><p>React.memo(funcComponent, compare) 用于创建高阶组件，使函数式组件具有如 PureComponent 的效果。在默认情况下，它会浅比较接受到的 props，当然，在提供 compare(prevProps, nextProps) 参数的场景中，你也可以定制重绘时机。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure>
<p>实现上，memo 函数会构建类 React 元素数据如 { $$typeof, type, compare }。其中，$$typeof 为来自 shared/ReactSymbols 包下的常量 REACT_MEMO_TYPE；type 为首参函数式组件；compare 即次参对比函数。</p>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><p>React 元素可使用 JSX 语法书写，也可以使用 createElement, createFactory 方法构建。<a href="https://github.com/mlmorg/react-hyperscript" target="_blank" rel="noopener">react-hyperscript</a>, <a href="https://github.com/ohanhi/hyperscript-helpers" target="_blank" rel="noopener">hyperscript-helpers</a> 这两个类库也提供了创建 React 元素的便捷语法糖。</p>
<p>除了 createElement, createFactory 方法以外，React 还提供 cloneElementAndReplaceKey, cloneElement, isValidElement 用于克隆元素或者校验元素。这些方法均由 ReactElement 模块输出。而 React.children 用于处理对子元素的操作。</p>
<h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><p>ReactElement(type, key, ref, self, source, owner, props) 作为创建元素的工厂函数，将构建 element 常量并返回。其中，element 包含可枚举可赋值的 $$typeof, type, key, ref, props, _owner 属性，$$typeof 属性为特定常量 REACT_ELEMENT_TYPE。在开发环境中，element 又包含 _store 存储校验标识（_store.validated），不可枚举不可赋值的 _self, _source 属性；且 element, element.props 均使用 Object.freeze 冻结。</p>
<p>createElement(type, config, children) 使用特定的自定义或内置组件 type 创建元素。参数 config 通过 key, ref, <strong>self, </strong>source 配置元素的 key, ref, self, source 属性，其余属性将作为元素的 props。children 用于配置元素下割的子元素。在创建元素时，ReactCurrentOwner.current 将作为元素的 _owner 属性。ReactCurrentOwner.current 值为渲染过程中的 Fiber 实例。</p>
<p>createFactory(type) 为特定的组件创建工厂函数。</p>
<p>cloneAndReplaceKey(oldElement, newKey) 使用 oldElement 组件构造器 oldElement.type 以及 ref, props, _owner, _self, _source 属性构建新的元素，该元素的 key 属性指定为 newKey。</p>
<p>cloneElement(element, config, children) 与 cloneAndReplaceKey 不同的是，该方法在克隆元素时可以重新配置 key, ref, props, children 属性。如果重置 ref 属性时，克隆元素的 _owner 属性也将同步更新为渲染过程中的 ReactCurrentOwner.current。</p>
<p>isValidElement(object) 通过校验参数 object 是否为对象且其 $$typeof 属性为 REACT_ELEMENT_TYPE，以判断是否 React 元素。</p>
<h3 id="Children"><a href="#Children" class="headerlink" title="Children"></a>Children</h3><p>forEach(children, forEachFunc, forEachContext) 遍历子元素，执行 forEachFunc 函数。</p>
<p>map(children, func, context) 遍历子元素，执行 func 函数。功能点同 forEach 方法，但是返回数组。</p>
<p>toArray(children) 将子元素转化为数组。</p>
<p>count(children) 计算子元素的数目。</p>
<p>only((children)) 校验参数 children 是否单一的 React 元素，并返回。</p>
<p>实现上，React 以 traverseAllChildren(children, callback, traverseContext) 函数作为遍历子元素的 api。traverseAllChildren 函数通过递归调用 traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) 遍历子元素，并校验子元素集合不能由 Map, Object 对象构建。对于回调的执行机制，React 会先使用 getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) 将 forEach 方法的参数 forEachFunc, forEachContext 或者 map 方法的参数 func, context 组装成 traverseContext 对象（该对象还包含用于收集子元素的数组 mapResult 和元素 key 键的公共前缀 keyPrefix 属性）。在 traverseContext 对象的基础上，React 对 forEach, map 构建了单独的回调包装函数 forEachSingleChild, mapSingleChildIntoContext，以处理特定的逻辑。具体实现可参阅源码。</p>
<p>多个元素在渲染时可使用 React.Fragment 组件包裹，那样就不必创建额外的 dom 节点。React 输出的 Fragment 组件直接来自于 shared/ReactSymbols 包下的常量 REACT_FRAGMENT_TYPE。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;React.Fragment&gt;</span><br><span class="line">  Some text.</span><br><span class="line">  &lt;h2&gt;A heading&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>React.Fragment&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><h3 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h3><p>React.createRef 创建 refObject 对象，该对象可以作为 React 元素的 ref 属性，以此引用指定的 React 元素。React 包下只创建 refObject 对象并使用 Object.seal 加以密封，核心逻辑由其他包提供。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.input = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.input.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">ref</span>=<span class="string">&#123;this.input&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><p>React.forwardRef 通过创建组件的方式将其所接受的 ref 引用配置长传给其子孙组件。forwardRef 有两个应用场景：为函数式组件指定引用；为高阶组件指定引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cosnt FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">'FancyButton'</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const ref = React.createRef();</span></span><br><span class="line"><span class="regexp">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/</span>FancyButton&gt;;</span><br></pre></td></tr></table></figure>
<p>上述代码可将创建的 refObject 对象通过 forwardRef 的次参传入函数式组件，以便引用原生 dom 组件。虽然这样创建 ref 引用会增加 FancyButton 与其父元素的层级关联，造成一定的复杂度，但是当 FancyButton 组件被多个应用级组件所使用时，且这些应用级组件都要细微地操作 button 节点，通过 forwardRef 长传 ref 引用就必不可少了。</p>
<p>在制作高阶组件时，同样可以使用 React.forwardRef 将 ref 引用转变为特定的 props 属性并传入高阶组件中，那样被包裹的组件就可以使用该 props 属性设置 ref 引用了。代码实现如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">Component</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'old props:'</span>, prevProps);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'new props:'</span>, <span class="keyword">this</span>.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return React.forwardRef((props, ref) =&gt; &#123;</span></span><br><span class="line">    return &lt;LogProps &#123;...props&#125; forwaredRef=&#123;ref&#125; /&gt;;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现中，forwardRef 将校验参数是否为函数且包含两个参数（通过 length 属性校验）等，最终返回类 React 元素结构如 { $$typeof, render }。其中，$$typeof 为常量 REACT_FORWARD_REF_TYPE，render 即 forwardRef 的参数。</p>
<h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><p>React.Suspense 支持在某事件执行完成后渲染组件。目前只支持一种应用场景：通过 React.lazy 动态加载组件，在组件加载完成后，再行渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LazyComponent  = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent.js'</span>));</span><br><span class="line"></span><br><span class="line">&lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">  &lt;LazyComponent&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Suspense&gt;</span><br></pre></td></tr></table></figure>
<p>在 OtherComponent 组件加载过程中，React 将使用 fallback 渲染元素；当 OtherComponent 加载完成后，视图将显示 OtherComponent 组件。Suspense 组件内允许渲染多个懒加载组件。在组件加载失败的场景中，可以构建实现了 getDerivedStateFromError(error) 静态方法以及 componentDidCatch(error, info) 生命周期方法的 ErrorBoundary 组件捕获错误并加以处理。</p>
<p>使用 React.lazy 动态加载的组件，不止可以作为 Suspense 组件的子元素，还可以作为 Route 组件的 component，以在路由层面实现动态加载。</p>
<p>在实现上，React.lazy 方法将构建类 React 元素的数据结构如 { $$typeof, _ctor, _status, _result }。其中，$$typeof 为常量 REACT_LAZY_TYPE，_ctor 为 React.lazy 接受的参数。React 输出的 Suspense 组件直接来自于 shared/ReactSymbols 包下的常量 REACT_SUSPENSE_TYPE。 </p>
<h2 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h2><p>Context 可视为 React 组件树的全局数据（比如验权后的用户信息、网页的主题风格、显示的语言），用于向子孙组件透传数据，而不必通过 props 属性逐层传递、或者将在顶层组件中将实际消费数据的子组件作为 children 传入中介组件。</p>
<p>Context 使用的方式为：</p>
<ol>
<li>使用 React.createContext(defaultValue) 创建 Context 对象。当 React 组件订阅了该 Context 对象时，该组件将从就近且匹配的 Provider 中读取 Context 对象。如果没有匹配的 Provider，那就会使用 defaultValue。</li>
<li>Context.Provider 以父组件的形式作为 Context 对象的提供者，当其重绘时，将迫使订阅数据的组件相应重绘。</li>
<li>在自定义组件中添加 contextType 静态属性，当其值为 Context 对象时，就可以通过组件实例的 context.value 访问实际透传的数据。</li>
<li>第 3 步也可以替代为第 4 步，使用 Context.Consumer 作为数据的消费者，其下可以用 value =&gt; ReactNode 的形式编写函数式组件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"><span class="keyword">const</span> UserContext = React.createContext(&#123; <span class="attr">name</span>: <span class="string">'Guest'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; signedInUser, theme &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;</span><br><span class="line">        &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt;</span><br><span class="line">          &lt;Layout /&gt;</span><br><span class="line">        &lt;<span class="regexp">/UserContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Sidebar /&gt;</span><br><span class="line">      &lt;Context /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Context()&#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">      &#123;theme =&gt; (</span></span><br><span class="line"><span class="regexp">        &lt;UserContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">          &#123;user =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /</span>&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">        &lt;<span class="regexp">/UserContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现上，createContext(defaultValue, calculateChangeBits) 方法会创建类 React 元素数据如 { $$typeof, _calculateChangedBits, _currentValue, _currentValue2, _threadCount, Provider, Consumer }。其中，$$typeof 为常量 REACT_CONTEXT_TYPE。Context.Provider 创建类 React 元素数据如 { $$typeof, _context }。其中，$$typeof 为常量 REACT_PROVIDER_TYPE；_context 即引用 Context 对象。Context.Consumer 在生产环境中就是Context 引用对象，开发环境将校验不能使用嵌套形式编码如 Context.Consumer.Provider, Context.Consumer.Consumer。</p>
<h2 id="ReactHooks"><a href="#ReactHooks" class="headerlink" title="ReactHooks"></a>ReactHooks</h2><p>借助于 <a href="https://reactjs.org/docs/high-order-components.html" target="_blank" rel="noopener">HOC</a> 或者 <a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">render props</a>，你可以整合组件内的可重用逻辑。比如当弹窗 Modal 组件内包含多个可切换的表单组件时，可以使用 render props 将表单的渲染函数传入 Modal 中。但是这样处理却会破坏组件的结构，容易造成 wrapper 装饰器层叠套用较深，在层叠组件中维护组件的状态。使用 ReactHooks 后，我们可以提取状态处理逻辑，这样可以对状态处理逻辑进行独立测试和复用，且不会改变组件的层级。在多个组件中，共用钩子也是较为方便的。</p>
<p>在编写组件时，随着项目的逐步发展，组件的逻辑将变得极为复杂，比如 componentDidMount 方法内既会包含数据获取的操作，又会包含事件绑定，同时，相同功能点的处理逻辑（事件绑定和解绑）会散落在多个生命周期中。这样就会包含多个执行逻辑，也使代码不易测试、容易出错。借助状态管理器，我们可以将部分执行逻辑写入 store 中，然而这样会引入过多的抽象，执行逻辑也分散在多个模块中，也使组件不便于重用。使用 ReactHooks 后，我们可以基于功能点将彼此相关的处理逻辑拆分为多个小函数，而不是割裂性地分布在组件的多个生命周期中。</p>
<p>如同 Svelte, Angular, Glimer 所展示的，提前预编译组件在未来拥有极高的潜力。React 最近在尝试使用 <a href="https://prepack.io" target="_blank" rel="noopener">Prepack</a> 在编译时预处理组件，并且已经看见了一些眉目。然而类组件会使这些优化进展缓慢，同时，类也不能很好的压缩，并使热加载变得不可靠。使用 ReactHooks 后，我们可以使用更多的 React 特性，且不必借助类组件的形式。</p>
<p>从效果上看，ReactHooks 为函数式组件提供状态管理以及相关生命周期特性。</p>
<p>在 React 包中，除却必要的校验外，ReactHooks 提供的 api 都将间接调用 ReactCurrentOwner.currentDispatcher 的同名方法。</p>
<h3 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>useState 将声明一个状态变量，作为返回数组的首项，该状态变量受到 React 机制的保护，只能通过第二个数组项 setCount 进行修改（其功能点一如类组件中使用的 setState 方法）。useState 的参数为状态的初始值，不限于对象形式。如果要使用两个状态，可调用 useState 两次达成。如前所述，useState 以数组形式返回一对值，前一个是当前的状态，后一个是用于变更状态的函数。</p>
<p>useState 的首参也可以是函数，初始状态由函数的返回值提供。</p>
<h3 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h3><p>Effect Hook 用于组织副作用逻辑，包含远程数据获取、事件绑定、节点操作、日志打印等。假设有针对组件状态的处理逻辑，在类组件的编程形式中，我们需要在 componentDidMount, componentDidUpdate 生命周期中两次组织同一个处理逻辑。当使用 Effect Hook 时，我们只需要组织一次这个处理逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果上，useEffect(effect, inputs) 等同于告知 React 在组件渲染完成后需要执行 effect 副作用（React 会记录这个副作用函数，并在组件渲染完成后调用）；参数 inputs 以数组形式告知 React 当某些数据变更时，才执行副作用（可以是函数式组件内的任何变量或属性，并在 effect 中有所使用）。在函数式组件中使用 useEffect，其意义在于便捷地通过 useState 访问状态；同时，每次重绘将会构建新的 effect，其效果等同于每次渲染都会调度不同的副作用，属于一次性消费。与 componentDidMount, componentDidUpdate 不同的是，useEffect 副作用不会阻塞视图更新。useLayoutEffect 方法与 useEffect 类似，可用于测算布局。</p>
<p>当所需执行的副作用为事件订阅类时，在组件卸载时，我们需要解绑事件，以防内存溢出。当 effect 返回函数（比如用于解绑事件）时，React 会在组件即将更新时执行这个函数。以下是</p>
<p>基于 useEffect，我们可以将相同功能点的处理逻辑写在一个 effect 中，组件内使用多个 effect 涵盖不同的功能点，而不是像类组件那样使相同功能点的处理逻辑散落在不同生命周期中。同时，我们也不需要在 componentDidUpdate 编写一套 props 变更的处理逻辑，因为 useEffect 在组件重置后均会得到调用。</p>
<h3 id="Custom-Hook"><a href="#Custom-Hook" class="headerlink" title="Custom Hook"></a>Custom Hook</h3><p>自定义 hook 允许在不同组件重用状态处理逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;li style=&#123;&#123; <span class="attr">color</span>: isOnline ? <span class="string">'green'</span> : <span class="string">'black'</span> &#125;&#125;&gt;</span><br><span class="line">      &#123;props.friend.name&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>自定义 hook 名需要使用 ‘use’ 起始，这样才能满足 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a>，React 也能侦测出这是一个 hook。其次，在不同组件中使用的自定义 hook，会构建不同的 state。</p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>当组件的状态管理略显复杂时，React 提供 useReducer 钩子以 Redux 风格管理状态。</p>
<p>useReducer 方法的首参为 reducer，次参为 initialState，尾参为 initialAction 如 {type: ‘reset’, payload: initialCount}。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todosReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">      <span class="keyword">return</span> [...state, &#123;</span><br><span class="line">        text: action.text,</span><br><span class="line">        completed: <span class="literal">false</span></span><br><span class="line">      &#125;];</span><br><span class="line">    <span class="comment">// ... other actions ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>(<span class="params">reducer, initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(initialState);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nextState = reducer(state, action);</span><br><span class="line">    setState(nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Todos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [todos, dispatch] = useReducer(todosReducer, []);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAddClick</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'add'</span>, text &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>useContext(context): 使用 React.createContext 创建的 context 对象作为参数，从就近的 Provider 中获取 context 对象。当 context 对象在 Provider 中更新时，组件将重绘。</li>
<li>useCallback(() =&gt; { doSomething(realInputs) }, inputs): 当 inputs 数组数据变更时，执行 doSomething 回调。useCallback(fn, inputs) 等价于 useMemo(() =&gt; fn, inputs)。</li>
<li>useMemo(() =&gt; { computeExpensiveValue(realInputs) }, inputs): 当 inputs 数组数据变更时，执行 computeExpensiveValue 函数，重新计算新值。</li>
<li>useRef(initialValue): 将使用接受的首参构建引用，通过 current 属性访问。该 ref 引用将在组件的生命周期中得到维持。</li>
<li>useImperativeMethods(ref, createInstance, [inputs]): 用于对外导出操纵子元素的 ref 引用方法，只能配合 forwardRef 方法使用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useRef</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` points to the mounted text input element</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// useImperativeMethods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeMethods(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">FancyInput = forwardRef(FancyInput);</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="Alfred">
            
              <p class="site-author-name" itemprop="name">Alfred</p>
              <p class="site-description motion-element" itemprop="description">人苦不知足，既得陇，复望蜀</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">113</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Alfred-sg" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/xiu-fan-79/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alfred</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.2</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.2"></script>



  

  
    <script id="dsq-count-scr" src="https://alfred.disqus.com/count.js" async></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

  





	





  












  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
