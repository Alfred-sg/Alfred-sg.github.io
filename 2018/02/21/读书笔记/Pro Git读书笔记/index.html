<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="carrier,git,">


<meta name="description" content="Getting Started原理git 版本管理通过 SHA-1 哈希算法为工作区的文件生成快照实现，存放于本地暂存区或版本库中（.git 目录下保存所有快照信息）。hash 算法基于文件内容和目录结构，git 保存的信息都通过 hash 值(SHA-1 哈希算法校验和/SHA-1 checksum)进行索引。修改工作区/working tree 的文件后(modified)，通过 git ad">
<meta name="keywords" content="carrier,git">
<meta property="og:type" content="article">
<meta property="og:title" content="Pro Git 笔记">
<meta property="og:url" content="http://yoursite.com/2018/02/21/读书笔记/Pro Git读书笔记/index.html">
<meta property="og:site_name" content="修子范语">
<meta property="og:description" content="Getting Started原理git 版本管理通过 SHA-1 哈希算法为工作区的文件生成快照实现，存放于本地暂存区或版本库中（.git 目录下保存所有快照信息）。hash 算法基于文件内容和目录结构，git 保存的信息都通过 hash 值(SHA-1 哈希算法校验和/SHA-1 checksum)进行索引。修改工作区/working tree 的文件后(modified)，通过 git ad">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-02-03T13:34:30.931Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pro Git 笔记">
<meta name="twitter:description" content="Getting Started原理git 版本管理通过 SHA-1 哈希算法为工作区的文件生成快照实现，存放于本地暂存区或版本库中（.git 目录下保存所有快照信息）。hash 算法基于文件内容和目录结构，git 保存的信息都通过 hash 值(SHA-1 哈希算法校验和/SHA-1 checksum)进行索引。修改工作区/working tree 的文件后(modified)，通过 git ad">






  <link rel="canonical" href="http://yoursite.com/2018/02/21/读书笔记/Pro Git读书笔记/">


  <title>Pro Git 笔记 | 修子范语</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">修子范语</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Alfredo's Notes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/21/读书笔记/Pro Git读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Pro Git 笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-21T00:00:00+08:00">2018-02-21</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/21/读书笔记/Pro Git读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/02/21/读书笔记/Pro Git读书笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>git 版本管理通过 SHA-1 哈希算法为工作区的文件生成快照实现，存放于本地暂存区或版本库中（.git 目录下保存所有快照信息）。hash 算法基于文件内容和目录结构，git 保存的信息都通过 hash 值(SHA-1 哈希算法校验和/SHA-1 checksum)进行索引。修改工作区/working tree 的文件后(modified)，通过 git add 命令提交到暂存区/staging range(staged)，再通过 git commit 命令提交到版本库/git directory(commited)；若文件未变更，将沿用原有的快照。因此本地多版本管理不需要远程交互。</p>
<p>当文件提交到暂存区时(stage)，git 会为每个文件计算校验和/checksum，在 git 仓库中保存 blob 对象以引用文件快照，校验和将保存到暂存区中。当提交到版本库时(commit)，git 会计算目录的校验和并构建树对象(blod 文件对象将以索引形式存储在树对象中)，随后创建提交对象，该提交对象包含作者名、电邮、message、指向上述树对象的指针、指向之前提交版本的指针。git 仓库可理解为存储系列提交对象的单链表结构(以哈希算法的校验和值作为索引)。在多分支开发的特殊情况下，提交对象会转变为树形结构(单链表可视为只有主干的树)，即多个提交对象的 parent 指针可以指向同一个提交对象父节点，提交历史产生分叉。在提交对象模型的基础上，git 分支就是指向某个提交对象的移动指针(通过校验和指向提交对象，文件形式存储)，其提交历史来自于提交对象模型，形成单链表结构。多分支管理、及单分支的回滚和提交动作均衍生于树结构的提交对象模型，分支仅承担着指向改变的任务；创建新分支即是创建一个指向当前提交对象的指针；提交时，创建新的提交对象，并改变当前分支的指向。在 git 中，HEAD 指针用于指向当前工作的分支，通过改变 HEAD 指针的指向即为切换分支操作。需要说明的是，当切换回较旧的分支时，不只改变了 HEAD 指针的指向，同时也使工作目录变更为该分支指向的提交对象，即资源快照。多分支开发时，新的提交对象将作为提交对象模型的叶子节点，这一过程也可以通过 HEAD 指针感知当前的提交对象属于哪个分支。因此在 git 中，分支不是多次提交记录的集合，而是在抽象所有提交记录为单一的模型后、衍伸而来的理念。遵照这样的设计，master 分支和其他分支拥有相同的特征，只是 master 分支会在 git 仓库初始化时被创建。</p>
<p>在 git 中，HEAD 指针指向版本库，INDEX 指针指向暂存区，版本库和暂存区都存储在 .git 文件夹中。因此，git add 命令将工作区内容复制到暂存区/INDEX。git commit 将暂存区内容复制到版本库/HEAD。git status 比较工作区、暂存区、版本库内容是否相同，若工作区和暂存区内容不相同，提示 not staged，需要通过 git add 暂存；若暂存区和版本库内容不同，提示 not committed，需要通过 git commit 提交。执行 git checkout, git clone 命令时，先将 HEAD 指针指向切换的分支，再将版本库内容复制到暂存区，再将暂存区内容复制到工作区。</p>
<p>git 提供了 git reset <checksum> 命令，执行该命令，不仅改变 HEAD 指针的指向，同时将工作分支指向 checksum 提交对象上。如果 HEAD 指向 master 分支，运行 git reset 9e5e64a 将会使 master 指向 9e5e64a，将撤销 9e5e64a 之后的提交，也可以用于重置 9e5e64a 之后的提交；git reset 命令默认将暂存区内容也替换为 9e5e64a 指向的提交对象，这和显式执行 git reset –mixed 命令相同。git reset –soft 命令只将版本库中内容替换为指定的提交对象。git reset –hard 命令可同时将版本库、暂存区和工作区内容替换为指定的提交对象。使用 git reset <filepath> 或 git reset <checksum> <filepath> 命令将目标从提交对象转向 filepath 路径指定的文件或目录，操作是从指定的提交对象中获取内容，复制到暂存区。</filepath></checksum></filepath></checksum></p>
<p>在 git checkout 命令执行过程中，会比较工作区和暂存区的差别，并尝试合并，这是 git reset 命令所没有的操作。当执行 git checkout <filepath> 命令时，该命令不仅会影响暂存区，同时会尝试合并工作区，这也是 git reset 命令所没有的操作。</filepath></p>
<p>合并/merge 分支时，会向上遍历文档对象模型，寻找共同的祖先节点作为合并基础。若待合并分支的提交/commit 动作在当前工作分支(work-in-progress branch)之后产生，当前分支将采用快进/fast-forward 方式修改，即将当前分支指向待合并分支的提交对象，指针右移。合并分叉分支时，即待合并的两个分支为同时开发，将获取这两个分支的提交对象，以及他们共同祖先节点的提交对象作为合并基础，作三方合并(three-way merge)，最终将构建出新的提交对象(该提交对象有两个父节点，使文档对象模型由树结构转变为合流结构)。若两个分叉分支同时对同一块区域做更改，git 不会自动合并，将产生一个合并冲突(merge conflict)，并阻止 git 的后续执行流程，如构建新的提交对象等，git 还会为冲突文件注入标准的冲突解决标记(standard conflict-resolution markers)。通过 git status 命令可查看冲突文件。冲突解决标记中，以 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 起始部分为当前工作分支内容，以 &gt;&gt;&gt;&gt;&gt;&gt;&gt; branchname 结束部分为待合并分支内容，中间以 =======。解决冲突后，需要依序提交到暂存区和版本库中，将产生一条合并记录，可能包含冲突解决记录。合并分支可使用 git mergetool 命令，启用图形化合并工具，参看 Git Branching。</p>
<p>git merge 合并发生冲突时，暂存区/stages 下缓存着共同祖先版本/stage-0，当前工作版本/stage-1，待合并的版本/stage-2。通过 git show :1|2|3:<conflictfilename> &gt; fileName 可以以拷贝形式导出冲突的共同祖先文件等。其中，:1|2|3:<conflictfilename> 为各冲突文件 bolb 对象相关 SHA-1 值的简写形式，:1:<conflictfilename> 为祖先冲突文件，:2:<conflictfilename> 为工作分支文件，:3:<conflictfilename> 为待合并文件。导出三份拷贝文件后，手工修复冲突，可使用 git merge-file 命令合并冲突文件，使用 git diff 命令可比较冲突结果与待比较文件的差异，git clean 命令用于清理为合并拷贝出来的文件。</conflictfilename></conflictfilename></conflictfilename></conflictfilename></conflictfilename></p>
<p>另外，在合并发生冲突时，使用 git checkout –conflict=diff3 命令可以查看不止于当前工作分支的冲突文件和待合并的冲突文件，还包含共同祖先的冲突文件。默认只查看当前工作分支的冲突文件和待合并的冲突文件，即 git checkout –conflict=merge 命令。使用 git config –global merge.conflictstyle diff3 命令，将全局的合并方案改成 diff3。git checkout –ours 合并时使用当前工作分支文件内容；git checkout –theirs 合并时使用待合并分支文件内容。git 在合并过程中，会将合并成功的文件提交到暂存区，因此 git diff 命令可以查看冲突文件；解决冲突后，仍可使用 git diff 或 git log –cc -p -1 命令查看解决冲突后的文件。</p>
<p>若想撤销文件合并，可使用 git reset –hard HEAD~ 命令将合并取消，提交记录返回到合并前；或者使用 git revert -m 1 basebranch 命令撤销合并，将提交对象撤回到 basebranch 分支内容。需要注意的是，git revert -m 1 basebranch 命令将无法合并待合并分支起始的提交内容，针对这一问题，可使用 git revert <checksum> 撤销还原。<br>参看 Git Tools。</checksum></p>
<p>远程引用(remote references)是对远程仓库中分支、标签等的引用或指针。更恰当的说，引用内容即为远程分支中的提交对象模型，单链表形式。远程跟踪分支(remote-tracking branches)将远程分支的引用保存在本地，不受用户影响，git fetch|pull|push 操作时更新引用，使本地 shortname/branchname 指向远程服务器的同名分支。远程引用采用 shortname/branchname 形式命名分支。当 git clone 命令执行时，将在本地创建 origin/master 分支和 master 分支，两者均指向相同的提交对象模型。当用户在 master 分支开发并提交时，另一用户将自己的代码 push 到远程 master 分支上，本地 origin/master 的指向将不作改变；假使在这时候执行 git fetch 命令，将抓取远程仓库新添加的提交对象，本地 origin/master 也将右移、指向另一用户创建的提交对象上，提交对象模型转化为树形结构。</p>
<p>变基/rebase 是 git 中除了 merge 以外整合两个分支的另一种方式。当提交历史呈分叉状态，可以将其中一个分叉的提交记录基于合并基础、提取为更新补丁，再将其合并到另一个分叉中，这个过程就是变基。变基命令在提取为补丁的分支上执行行，因此需要切换到该分支如 patch 分支，然后执行 git rebase basebaranch 命令，提取补丁并以该补丁产生新的提交对象(patch 分支指向该提交对象)，此时分叉的提交历史将转变为单链表形式，而 basebaranch 分支的指向仍保持不变。切换到 basebaranch 分支，再执行 git merge patch 命令，可以将 basebaranch 分支的指针右移，指向 rebase 命令新创建的提交对象。经过上述步骤后，整个开叉分支的整合操作也就完成了，patch 分支的提交对象将被抹去，但 patch 分支仍然存在，需要手动删除。变基同合并比较，最大的优点即是使提交历史呈线性状态，而不是分叉、合流结构。在开源项目中贡献代码通常采用变基命令。使用 git rebase basebranch patch 命令执行变基操作时，可以不用将工作分支切换到 patch 上，即提取 patch 分支的修改补丁，基于修改补丁在 basebranch 分支上创建新的提交对象。执行 git rebase –onto basebranch patch1 patch2 命令，获取 patch2 分支不同于 patch1 分支的修改补丁，基于修改补丁再在 basebranch 分支上创建新的提交对象。</p>
<p>执行变基操作有一条原则，即不能在你的本地仓库执行变基操作。变基操作能改变本地仓库的提交历史，进而影响远程仓库的提交记录，但是对于协作者而言，在分支开叉时拉取编程变更，又在变基后拉取远程变更，他本地远程引用的提交记录中即会保留变基前的开叉，又会有变基后新增的提交对象。git 变基的实现原理是，在每次提交时，git 不只计算本次提交的校验和，还会计算本次修改内容的校验和 patch-id。通过 patch-id，git 能分辨出新增的本地修改。在本地分支上，使用 git rebase remote/branch 命令将本地修改变基到远程引用，同时本地的提交历史将转变为单链表结构，这能解决前述变基前后的操作同时提交到远程仓库的问题。</p>
<p>除了合并和变基以外，git 支持拣选/cherry-pick 操作，其意义以校验和获取某次提交补丁，再应用到当前工作分支上。因为操作时间的不同，通过拣选在当前分支创建的提交会重新计算校验和。具体命令如 git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf。其中，e43a6fd3e94888d76779ad79fb568ed180e5fcdf 为之前提交对象的校验和/checksum，作为提交对象的索引。</p>
<p>参考：<br><a href="https://git-scm.com/book/zh/v2/Git-分支-分支简介" target="_blank" rel="noopener">分支简介</a><br><a href="https://git-scm.com/book/zh/v2/Git-分支-分支的新建与合并" target="_blank" rel="noopener">分支的新建与合并</a><br><a href="https://git-scm.com/book/zh/v2/Git-分支-变基" target="_blank" rel="noopener">变基</a><br><a href="https://git-scm.com/book/zh/v2/Git-工具-重置揭密" target="_blank" rel="noopener">重置揭密</a></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>git 配置分为三类，系统级，用户级，和项目级；优先级从右到左。git config 命令中，–system 选项指定系统级，–global 选项指定用户级，两者均没有为项目级。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">git config --list <span class="comment"># 查看配置</span></span><br><span class="line">git config user.name <span class="comment"># 查看用户配置</span></span><br><span class="line">git config --global user.name &lt;name&gt; <span class="comment"># 指定用户</span></span><br><span class="line">git config --global user.email &lt;email&gt; <span class="comment"># 指定邮箱</span></span><br><span class="line">git config --global core.editor emacs <span class="comment"># 指定编辑器，默认为系统自带编辑器，可选 vim, emacs, notepad++</span></span><br><span class="line">git config --global commit.template &lt;filepath&gt; <span class="comment"># 以 filepath 文件作为提交信息模板，打开编辑器时作为前缀</span></span><br><span class="line">git config --global core.pager <span class="string">''</span> <span class="comment"># 设置 git log|diff 命令的分页器，可选值 more, less。'' 空字符串为完整显示</span></span><br><span class="line">git config --global user.signingkey &lt;gpg-key-id&gt; <span class="comment"># 设置 GPG 签署密钥，影响 git tag -s &lt;tag-name&gt; 命令</span></span><br><span class="line">git config --global core.excludesfile &lt;filepath&gt; <span class="comment"># 设置忽略的文件</span></span><br><span class="line">git config --global help.autocorrect 1 <span class="comment"># 输入命令有误时，0.1s 后自动执行模糊匹配的命令</span></span><br><span class="line">git config --global credential.helper cache <span class="comment"># 将 https 推送需要的用户密码缓存在内存中，时效为几分钟</span></span><br><span class="line">git config --global color.ui <span class="literal">false</span> <span class="comment"># 禁用有彩色输出</span></span><br><span class="line">git config --global color.[diff|branch|interactive|status].meta <span class="string">"blue black bold"</span> <span class="comment"># 设置命令的颜色</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">true</span> <span class="comment"># Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 Mac 和 Linux 只使用换行（LF）一个字符。core.autocrlf 设置为 true，提交时自动将回车和换行转换成换行，检出时将换行转换成回车和换行。core.autocrlf 设置为 input，提交时自动把回车和换行转换成换行，检出时不转换</span></span><br><span class="line">git config --global core.whitespace \</span><br><span class="line">  trailing-space,space-before-tab,indent-with-non-tab <span class="comment"># 空格检测。默认开启项 blank-at-eol，查找行尾的空格；blank-at-eof，盯住文件底部的空行；space-before-tab，警惕行头 tab 前面的空格。默认关闭项 indent-with-non-tab，揪出以空格而非 tab 开头的行（你可以用 tabwidth 选项控制它）；tab-in-indent，监视在行头表示缩进的 tab；cr-at-eol，告诉 Git 忽略行尾的回车。git diff 时将应用空格检测；git apply --whitespace=warn &lt;patch&gt; 应用补丁时检测空格；git apply --whitespace=fix &lt;patch&gt; 自动修复；git rebase --whitespace=fix 变基时自动修复</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名</span></span><br><span class="line">git config --global alias.co checkout <span class="comment"># git co 将等价于 git checkout</span></span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.unstage <span class="string">'reset HEAD --'</span> <span class="comment"># git unstage 将等价于 git reset Head -- </span></span><br><span class="line">git config --global alias.last <span class="string">'log -1 HEAD'</span> <span class="comment"># git last 查看最后一次提交信息</span></span><br><span class="line">git config --global alias.visual <span class="string">'!npm'</span> <span class="comment"># git visual 将调用外部命令 npm</span></span><br><span class="line"></span><br><span class="line">git config --global pull.rebase <span class="literal">true</span> <span class="comment"># 更改 pull.rebase 的默认配置</span></span><br><span class="line">git config --global merge.conflictstyle diff3 <span class="comment"># 以 diff3 方式查看冲突文件，包含当前工作分支、待合并分支、共同祖先分支的冲突文件内容</span></span><br><span class="line"></span><br><span class="line">git config --system receive.fsckObjects <span class="literal">true</span> <span class="comment"># 推送生效前检验每个对象的有效性以及 SHA-1 检验和是否保持一致</span></span><br><span class="line">git config --system receive.denyNonFastForwards <span class="literal">true</span> <span class="comment"># 禁用强制更新 git push -f</span></span><br><span class="line">git config --system receive.denyDeletes <span class="literal">true</span> <span class="comment"># 避免删除远程分支后，再推送本地分支</span></span><br></pre></td></tr></table></figure>
<h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> config <span class="comment"># 打印 git config 命令的完整手册</span></span><br><span class="line">man git-confgi <span class="comment"># 同上</span></span><br><span class="line">git-config -h|--<span class="built_in">help</span> <span class="comment"># 简要帮助信息</span></span><br></pre></td></tr></table></figure>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ol>
<li>保存快照不吃磁盘空间吗？git 命令在运行时比较文件差异，如 add, commit？那执行效率如何提升？</li>
<li>数据库怎样存储历史版本数据？</li>
<li>游戏在用户端以补丁形式下载并更新，若代码使用 git 管理，怎样做到根据文件差异只做局部封信，而不是全量下载并更新？同样的，git pull 等命令怎样做到效率地只修改局部资源？</li>
<li>在多分支开发，又相继合并到 master 分支的情形下，提交对象链表会形成怎样的构造？根据提交时间形成单链表形式？</li>
<li>git reset 命令执行后，如何改变提交历史，新的提交对之前提交历史的影响？如重置第三次提交，新的提交会在第一次提交之后创建提交对象，还是在之前创建提交对象？</li>
<li>git checkout 命令可以针对某次提交对象，即可以执行 git checkout <checksum> 命令？</checksum></li>
</ol>
<h2 id="Git-Basics"><a href="#Git-Basics" class="headerlink" title="Git Basics"></a>Git Basics</h2><h3 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h3><p>创建 git 本地仓库，指定 git init 或 git clone <url> [projectName] 命令（projectName 用于指定本地目录名）。git clone 将拷贝远程仓库的所有版本及所有文件（当服务器磁盘损坏时，方便使用本地仓库的命令将远程仓库的资源回滚到拷贝前），创建 .git 目录，并检出最新分支。git clone 时，可使用 https 协议 或 git:// 起始的 SSH 协议。</url></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment"># 创建 git 本地仓库</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;url&gt; [projectName] <span class="comment"># 克隆远程仓库，指定远程仓库的简称默认为 origin，且本地 master 分支将跟踪/track 远程 master，可使用 git pull|push 命令</span></span><br></pre></td></tr></table></figure>
<h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>工作区的文件状态有两种，已追踪/tracked, 未追踪/untracked。暂存区的最新快照中包含某文件，该文件即被追踪；若不包含，该文件即未追踪。已追踪文件又分为三种状态，未变更/unmodified, 已变更/modified, 已提交到暂存区/staged。在切换分支时，git 会校验工作区的文件改动是否提交到版本库中，未提交，则阻止切换，用以防止丢失工作区的改动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment"># 获取文件状态</span></span><br><span class="line">git status -s|--short <span class="comment"># 文件状态扼要信息。?? 未追踪文件，A 新增文件提交到到暂存区，M 修改文件提交到暂存区，MM 暂存区和工作区文件状态</span></span><br><span class="line">git diff <span class="comment"># 工作区和暂存区文件差异，显示文件更新细节，包括添加的行、删除的行，合称为文件更新补丁/patch</span></span><br><span class="line">git diff --staged|--cached <span class="comment"># 暂存区和版本库文件差异</span></span><br><span class="line">git difftool <span class="comment"># 使用 Araxis, emerge, vimdiff 等软件以图形化或其他格式显示文件差异</span></span><br><span class="line">git difftool -tool-help <span class="comment"># 查看系统支持的 git diff 插件</span></span><br><span class="line">git add &lt;files&gt; <span class="comment"># 工作区文件提交到暂存区，将产生暂存区的历史快照/historical snapshort。参数为文件或目录路径</span></span><br><span class="line">git commit <span class="comment"># 暂存区快照提交版本去，需由命令行编辑器设置 message，# 起始内容将被忽略。命令行编辑器中默认以 # 添加 git status 输出内容。-v 选项可用于注入 git diff 完整信息</span></span><br><span class="line">git commit -m <span class="string">'message'</span> <span class="comment"># 设置 message 并提交</span></span><br><span class="line">git commit -a <span class="comment"># 直接将工作区中已追踪的文件提交到版本库，跳过暂存区</span></span><br><span class="line">git rm &lt;pattern&gt; <span class="comment"># 暂存区删除文件，工作区也作相应删除，需要提交到版本库。直接删除工作区中文件，不会影响暂存区</span></span><br><span class="line">git rm -f|--force &lt;pattern&gt; <span class="comment"># 修改后文件提交到暂存区，与版本库中文件有差异，需使用 -f 选项强制删除</span></span><br><span class="line">git rm --cached &lt;pattern&gt; <span class="comment"># 暂存区删除文件，但保留工作区文件，适用于未配置 .gitignore 的文件</span></span><br><span class="line">git mv file_from file_to <span class="comment"># 移动文件，可实现文件重命名。重命名时，等同于 mv file_from file_to; git rm file_from; git add file_to。git 没有显式追踪文件移动操作，通过执行的命令获知用户重命名行为</span></span><br></pre></td></tr></table></figure>
<h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>.gitignore 配置文件，即忽略文件列表。可设置多个 .gitignore 文件，当前文件所在目录自底向上获取 .gitignore 文件，作为优先级顺序。编写 .gitignore 文件可使用标准 glob 模式(shell 中简易正则，* 零或多个任意字符，** 任意中间目录，其余同正则)；空行或 ‘#’ 开头将被忽略；’/‘ 开头相对于工程目录；’/‘ 结尾匹配目录；’!’ 开头置否值。</p>
<h3 id="commit-历史记录"><a href="#commit-历史记录" class="headerlink" title="commit 历史记录"></a>commit 历史记录</h3><p>无论本地仓库，还是克隆下来的远程仓库，都可以使用 git log 命令查看提交记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 显示提交记录，反序排列，包含 SHA-1 哈希算法校验和(作为索引), 作者, 日期, message</span></span><br><span class="line">git <span class="built_in">log</span> -p|--patch <span class="comment"># 显示内容差异</span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span> <span class="comment"># 显示每次更新的文件修改统计信息</span></span><br><span class="line">git <span class="built_in">log</span> --shortstat <span class="comment"># 只显示 --stat 中最后的行数修改添加移除统计</span></span><br><span class="line">git <span class="built_in">log</span> --name-only <span class="comment"># 仅在提交信息后显示已修改的文件清单</span></span><br><span class="line">git <span class="built_in">log</span> --name-status <span class="comment"># 显示新增、修改、删除的文件清单</span></span><br><span class="line">git <span class="built_in">log</span> --abbrev-commit <span class="comment"># 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符</span></span><br><span class="line">git <span class="built_in">log</span> --relative-date <span class="comment"># 使用较短的相对时间显示，如 '2 weeks ago'</span></span><br><span class="line">git <span class="built_in">log</span> --graph <span class="comment"># 显示 ASCII 图形表示的分支合并历史</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment"># 指定显示格式，--pretty 选项的可选值为 oneline, short, full, fuller, format。其中，oneline 以一行展示提交信息</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span> <span class="comment"># 指定输出信息的模板字符串，用于提取分析报告。占位符包含 %H 提交对象/commit的完整哈希字串, %h 提交对象的简短哈希字串, %T 树对象/tree的完整哈希字串, %t, %P 父对象/parent的完整哈希字串, %p, %an 作者, %ae 作者的邮箱, %ad 作者修订日期, %ar 作者的相对修订日期, %cn 提交者, %ce, %cd, %cr, %s 说明</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># --pretty=oneline --abbrev-commit 简写形式</span></span><br><span class="line">git <span class="built_in">log</span> -&lt;n&gt; <span class="comment"># -n 指定只显示最后两次提交记录，如 -2。通常不需要使用。因为 git log 显示采用分页形式，用户只能看到第一页</span></span><br><span class="line">git <span class="built_in">log</span> --since|--after=2.weeks <span class="comment"># --since 选项指定起始时间，可用相对时间或绝对时间，如 '2 years 1 day 3 minutes ago'</span></span><br><span class="line">git <span class="built_in">log</span> --until|--before=<span class="string">"2008-01-15"</span> <span class="comment"># 同上，指定结束时间</span></span><br><span class="line">git <span class="built_in">log</span> --author=authorname <span class="comment"># 过滤作者</span></span><br><span class="line">git <span class="built_in">log</span> --committer=committername <span class="comment"># 过滤提交者</span></span><br><span class="line">git <span class="built_in">log</span> --grep=messagekey <span class="comment"># 按 message 中关键字检索，与 --author 合用时为或匹配，添加 --all-match 选项强制匹配 grep 指定关键字</span></span><br><span class="line">git <span class="built_in">log</span> -S function_name <span class="comment"># 指定字符串检索更改相应字符串的提交记录</span></span><br><span class="line">git <span class="built_in">log</span> --no-merges <span class="comment"># 不显示 merge 记录</span></span><br><span class="line">git <span class="built_in">log</span> --filename <span class="comment"># 作为最后一个选项，检索更改相应文件或目录的提交记录</span></span><br></pre></td></tr></table></figure>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>撤销操作不能回滚，容易引起数据丢失。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend <span class="comment"># 合并上一次提交记录，适用于文件漏提交等轻微改动场景。若暂存区文件未作更新，commit 快照将保持不变，只更改 message 或者连 message 也未作更改。只保留当前的提交记录；撤销上一次提交记录，即不会存在于提交记录中</span></span><br><span class="line">git reset HEAD &lt;filename&gt; <span class="comment"># 暂存区文件重置为提交前状态。执行 git status 命令，工作位已更改文件的状态为 unstaged。git reset 命令不加选项，只更改暂存区。git reset --hard 命令将可能导致工作区的当前进度全部丢失，相当危险</span></span><br><span class="line">git checkout -- &lt;file&gt; <span class="comment">#  使用暂存区的文件替换工作区的文件，即工作区文件回滚</span></span><br></pre></td></tr></table></figure>
<h3 id="远程协作"><a href="#远程协作" class="headerlink" title="远程协作"></a>远程协作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="comment"># 列出远程服务器的简称，默认为 origin</span></span><br><span class="line">git remote -v <span class="comment"># 列出远程服务器的简称和 url 列表，同一个项目可能指定了多个远程仓库。fetch, push 操作的服务器资源也可能不同，由远程仓库决定</span></span><br><span class="line">remote add &lt;shortname&gt; &lt;url&gt; <span class="comment"># 添加远程仓库</span></span><br><span class="line">git fetch &lt;shortname|url&gt; <span class="comment"># 抓取远程仓库资源，包含所有分支，并创建本地远程跟踪分支，却不会创建可修改、供开发的本地同名分支。只下载远程仓库资源，需手动 merge</span></span><br><span class="line">git pull <span class="comment"># 若本地分支跟踪远程分支，git pull 命令自动拉取远程仓库中指定的分支，并尝试 merge</span></span><br><span class="line">git pull &lt;remotename&gt; &lt;branchname&gt; <span class="comment"># 拉取远程分支资源，并尝试 merge。选项 remotename 指定远程仓库，branchname 指定分支</span></span><br><span class="line">git push <span class="comment"># 若本地分支跟踪远程分支，git push 将资源推送到远程仓库下的指定分支</span></span><br><span class="line">git push &lt;remotename&gt; &lt;branchname&gt; <span class="comment"># 推送资源到指定远程下的指定分支</span></span><br><span class="line">git remote show &lt;remotename&gt; <span class="comment"># 查看远程仓库 fetch|push 操作的 url，包含的分支，以及跟踪分支信息</span></span><br><span class="line">git remote rename shortname_before shortname_after <span class="comment"># 改写远程仓库的简称，同时改变分支名，如更新为 shortname_after/master</span></span><br><span class="line">git remote remove|rm &lt;remotename&gt; <span class="comment"># 本地移除某远程仓库，同时影响其下分支和配置，对远程仓库无影响</span></span><br></pre></td></tr></table></figure>
<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>git 标签分为两种，轻量标签lightweight, 附注标签 annotated。轻量标签通过 git tag 不带选项创建，附注标签通过 git tag -a 创建。附注标签以对象形式存储在 git 数据库中，包含标签作者，电邮，日期，标签信息/message，并且可以使用 GPG 签名和验证。git tag 命令通常用来发布不再修改的版本(通过 git push <tagname> 命令)，且发布以后，不能再作修改，需要在本地创建新分支拉取标签资源，作适当修改后再发布。</tagname></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="comment"># 列出所有标签，以字母顺序罗列</span></span><br><span class="line">git tag -l|-list &lt;pattern&gt; <span class="comment"># 只罗列匹配的标签，如 git tag -l "v1.8.5*"。pattern 中若含有通配符，-l 选项不可缺失</span></span><br><span class="line">git tag &lt;tagname&gt; <span class="comment"># 创建轻量标签，git show &lt;tagname&gt; 时只显示 commit 信息</span></span><br><span class="line">git tag -a &lt;tagname&gt; -m <span class="string">"message"</span> <span class="comment"># 创建附注标签，git show &lt;tagname&gt; 时除显示 commit 信息外，还显示标签作者，电邮，日期，标签信息等</span></span><br><span class="line">git show &lt;tagname&gt; <span class="comment"># 查看标签信息及对应的提交信息</span></span><br><span class="line">git tag -a &lt;tagname&gt; &lt;checksum&gt; <span class="comment"># 提交后再打标签，选项 checksum 为 hash算法校验和，即快照的索引，可以只包含部分 hash 值</span></span><br><span class="line">git push origin &lt;tagname&gt; <span class="comment"># 将标签推送到远程共享服务器上</span></span><br><span class="line">git push --tags <span class="comment"># 将本地所有标签推送到服务器上</span></span><br><span class="line">git checkout &lt;tagname&gt; <span class="comment"># 检出标签，但不能真正检出标签，本地仓库会进入 "detached HEAD" 状态，提交将不从属于任何分支，只有 commit checksum 校验和能被 git 感知到</span></span><br><span class="line">git checkout -b &lt;branchnam&gt; &lt;tagname&gt; <span class="comment"># 在本地创建新分支，并拉取指定标签资源。修改后，重新创建标签并 push</span></span><br></pre></td></tr></table></figure>
<h3 id="疑问-1"><a href="#疑问-1" class="headerlink" title="疑问"></a>疑问</h3><ol>
<li>暂存区存在的意义？</li>
<li>强制删除的意义？</li>
<li>commit 提交记录以何种形式存储，才能实现快速检索？关于 git database？</li>
<li>本地版本库如何回滚？</li>
<li>git pull|push 只拉取或推送快照，还是所有历史记录？</li>
<li>git 远程服务器对版本管理的实现是否和本地相同，可否指定局域网中某台机器作为拉取资源的源头？</li>
<li>打标签只针对 commit 操作？且标签只针对不会再修改的版本？git push origin [tagname] 推送到共享服务器和 git push origin [branchname] 的差异？</li>
<li>切换分支时，为什么需要提交到版本库，而不是暂存库，这样就可以避免工作区的变更丢失了？</li>
</ol>
<h2 id="Git-Branching"><a href="#Git-Branching" class="headerlink" title="Git Branching"></a>Git Branching</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>分支原理见 Getting Started。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --decorate <span class="comment"># --decorate 选项用于查询各个分支及 HEAD 指针指向哪个提交对象</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --decorate --graph --all <span class="comment"># 查看提交历史的分叉情况，各个分支及 HEAD 指针的指向</span></span><br><span class="line">git branch <span class="comment"># 查看所有分支，带 '*' 的为当前分支</span></span><br><span class="line">git branch -v <span class="comment"># 查看所有分支最后一次提交记录</span></span><br><span class="line">git branch --merged <span class="comment"># 查看已合并到当前分支的所有分支</span></span><br><span class="line">git branch --no-merged <span class="comment"># 查看未合并到当前分支的所有分支</span></span><br><span class="line">git branch --merged &lt;branchname&gt; <span class="comment"># 查看已合并到 branchname 分支的所有分支</span></span><br><span class="line">git branch --no-merged &lt;branchname&gt; <span class="comment"># 查看未合并到 branchname 分支的所有分支</span></span><br><span class="line">git branch &lt;branchname&gt; <span class="comment"># 创建分支，但不切换分支</span></span><br><span class="line">git branch -d &lt;branchname&gt; <span class="comment"># 删除分支，branchname 未合并到当前分支，将不予删除</span></span><br><span class="line">git branch -D &lt;branchname&gt; <span class="comment"># 强制删除分支</span></span><br><span class="line">git checkout &lt;branchname&gt; <span class="comment"># 切换分支，即改变 HEAD 指针指向。修改文件但未提交到版本库的，git 将阻止切换</span></span><br><span class="line">git checkout -b &lt;branchname&gt; <span class="comment"># 创建并切换分支</span></span><br><span class="line">git merge &lt;branchname&gt; <span class="comment"># 将 branchname 分支合并到当前分支</span></span><br><span class="line">git status <span class="comment"># 查看冲突文件</span></span><br><span class="line">git mergetool <span class="comment"># 使用图形化工具解决冲突，默认使用 opendiff 工具，可选用工具包含 opendiff, kdiff3, tkdiff, xxdiff, meld, tortoisemerge, gvimdiff, diffuse, diffmerge, ecmerge, p4merge, araxis, bc3, codecompare, vimdiff, emerge</span></span><br><span class="line">git mergetool --tool-help <span class="comment"># 合并工具帮助信息</span></span><br></pre></td></tr></table></figure>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>推荐使用的本地开发工作流/workflow 有两种，长期分支模式(Long-Running Branches)，特性分支模式(Topic Branches)。当然，这只是一种参考。</p>
<p>长期分支模式根据稳定性创建分支，需要较高稳定性的分支创建在前，较低稳定性的创建在后，如 master 分支先于 develop 分支，develop 分支先于 topic 分支，合并时依序将 topic 分支合并到 develop 分支，develop 分支合并到 master 分支。适用于大型项目，作为分支创建的基础结构，在每个分支可以再次使用特性分支模式。</p>
<p>特性分支模式适用于开发者想法多变的场景，比如在 master 分支基础创建 hotfix 分支，接着创建 hotfix_v2，同时开发 hotfix, hotfix_v2 分支，最终又启用 hotfix 分支；与此同时，开发过程中 master 分支不只产生了新的提交，后续又创建了实现新想法的 idea 分支，最后将 hotfix_v2, idea 分支合并到 master 分支。</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git ls-remote &lt;shortname&gt; <span class="comment"># 查看远程引用清单</span></span><br><span class="line">git remote show &lt;shortname&gt; <span class="comment"># 查看远程引用详细信息</span></span><br><span class="line">git push &lt;shortname&gt; &lt;branch&gt; <span class="comment"># 将当前分支的提交内容推送到远程 branch 分支，git 自动将分支名扩展为 refs/heads/branch:refs/heads/branch，意为将本地 branch 分支推送并更新远程 branch 分支</span></span><br><span class="line">git push shortname localebranch:remotebranch <span class="comment"># 推送本地 localebranch 分支，将其作为远程 remotebranch 分支</span></span><br><span class="line">git merge shortname/branchname <span class="comment"># 将远程跟踪分支 shortname/branchname 合并到当前分支，合并前须 git fetch</span></span><br><span class="line">git checkout -b localebranch shortname/remotebranch <span class="comment"># 通过远程跟踪分支创建本地分支，自动跟踪远程分支，可使用 git pull|push 简化拉取、提交操作；且可以在命令行中使用 @&#123;upstream&#125; 或 @&#123;u&#125; 代替 shortname/remotebranch</span></span><br><span class="line">git checkout --track shortname/remotebranch <span class="comment"># 上一条命令的简写形式，创建 remotebranch 同名分支</span></span><br><span class="line">git checkout remotebranch <span class="comment"># 上一条命令的简写形式，条件是本地未存在 remotebranch 同名分支，远程存在</span></span><br><span class="line">git branch -u|--<span class="built_in">set</span>-upstream-to shortname/remotebranch <span class="comment"># 当前分支切换跟踪远程 remotebranch 分支。-u 选项可用于 pull, push 命令</span></span><br><span class="line">git branch -vv <span class="comment"># 查看本地分支在跟踪哪个远程分支，以及ahead, behind, up to date等提交状态。这条命令基于最后一次 fetch 的数据，命令本身没有连接服务器</span></span><br><span class="line">git fetch &lt;shortname|url&gt; <span class="comment"># 抓取远程仓库资源，包含所有分支，并创建本地远程跟踪分支，却不会创建可修改、供开发的本地同名分支。只下载远程仓库资源，不会更改工作区内容，需手动 merge</span></span><br><span class="line">git pull <span class="comment"># git fetch, git merge 命令的结合，拉取数据并合并</span></span><br><span class="line">git push origin --delete remotebranch <span class="comment"># 删除远程分支</span></span><br></pre></td></tr></table></figure>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;basebranch&gt; <span class="comment"># 将当前分支以补丁形式在 basebranch 分支上创建新的提交对象。完成开叉分支的整合操作还需要在 basebranch 分支上 merge 当前分支</span></span><br><span class="line">git rebase &lt;basebranch&gt; &lt;topicbranch&gt; <span class="comment"># 同上，该命令不需要切换到 topicbranch 分支后执行</span></span><br><span class="line">git rebase --onto &lt;basebranch&gt; &lt;topicbranch1&gt; &lt;topicbranch2&gt; <span class="comment"># --onto 选项用于获取在 topicbranch2 分支内但不在 topicbranch1 内的文件修改补丁，并在 basebranch 分支上创建新的提交对象，即变基到 basebranch </span></span><br><span class="line">git rebase remote/branch <span class="comment"># 将本地修改变基到远程引用 remote/branch 分支上</span></span><br><span class="line">git pull --rebase remote/branch <span class="comment"># 等同 git fetch, get rebase remote/branch</span></span><br></pre></td></tr></table></figure>
<h2 id="Git-on-the-Server"><a href="#Git-on-the-Server" class="headerlink" title="Git on the Server"></a>Git on the Server</h2><h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>git 可以使用四种传输资料的协议：Local 本地协议，Http 协议，SSH 协议和 Git 协议。</p>
<p>Local 协议常见于协作者对同一个共享的文件系统(如一个挂载的 NFS)都有访问权限。git clone /opt/git/project.git 命令将采用硬链接或直接拷贝文件；git clone file:///opt/git/project.git 将触发用于网路传输资料的进程，传输效率较低；git remote add local_proj /opt/git/project.git 命令用于增加本地版本库。</p>
<p>Http 协议既支持像 git:// 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。Git 协议，要么谁都可以克隆这个版本库，要么谁也不能。</p>
<h3 id="搭建-git-服务器"><a href="#搭建-git-服务器" class="headerlink" title="搭建 git 服务器"></a>搭建 git 服务器</h3><p>首先需要把现有 git 仓库导出为一个裸仓库，即不包含工作目录的仓库。这一过程通过 –bare 选项完成，具体命令为 git clone –bare my_project my_project.git。其次将裸仓库放在服务器上，若已在 git.example.com 搭好服务器，且需要在 /opt/git 目录下放置所有 git 仓库，通过执行 scp -r my_project.git <a href="mailto:user@git.example.com" target="_blank" rel="noopener">user@git.example.com</a>:/opt/git 复制裸仓库到 /opt/git 目录下。此时，对服务器 /opt/git 目录拥有可读权限的用户就可以通过 git clone <a href="mailto:user@git.example.com" target="_blank" rel="noopener">user@git.example.com</a>:/opt/git/my_project.git 克隆仓库。若在仓库中执行 git init –bare –shared 命令，可将仓库的权限设为可写(基于服务器文件系统权限)。连接服务器的权限通过服务器自有的 SSH 服务实现，创建访问账户也针对服务器，而不是 git 仓库。访问权限也可以在服务器创建 git 账户，然后将需要写权限的用户的 SSH 公钥加入 git 账户的 ~/.ssh/authorized_keys 文件中；或者让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。</p>
<p>生成 SSH 公钥通过以下步骤完成：通过 ssh-keygen 命令创建公钥(存放在 id_dsa.pub 文件中)和密钥(存放在 id_dsa 文件中)；将公钥复制到 git 账户的 ~/.ssh/authorized_keys 文件中(通过 git 服务器管理员完成，或自动化脚本实现)。</p>
<p>在服务器创建 git 账户时，将使所有获得授权的用户都能以系统用户 git 的身份登录服务器从而获得一个普通 shell，即能对服务器进行一定操作。若想对此加以限制，则需要修改 passwd 文件中(git 用户所对应)的 shell 值；或者通过 git 软件包自带的 git-shell 工具代替 bash 或 csh 作为用户的登录 shell，用户即不能通过登录 shell 执行非 git 命令(上述过程，通过 sudo chsh git 命令改变系统用户的登录 shell 实现)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare my_project my_project.git <span class="comment"># 通过 --bare 选项创建裸仓库</span></span><br><span class="line">cp -Rf my_project/.git my_project.git <span class="comment"># 同上</span></span><br><span class="line">git init --bare <span class="comment"># 新疆一个空仓库</span></span><br><span class="line">git init --bare --shared <span class="comment"># 新疆一个空仓库，并将仓库的权限设为可写</span></span><br></pre></td></tr></table></figure>
<h3 id="疑问-2"><a href="#疑问-2" class="headerlink" title="疑问"></a>疑问</h3><ol>
<li>协议相关知识再梳理？</li>
<li>搭建 git 服务器过程再梳理，包含守护进程、git-http-backend 脚本在Apache 服务器上的使用、GitWeb 网页查看、GitLab 服务器等？</li>
</ol>
<h2 id="Distributed-Git"><a href="#Distributed-Git" class="headerlink" title="Distributed Git"></a>Distributed Git</h2><h3 id="分布式工作流"><a href="#分布式工作流" class="headerlink" title="分布式工作流"></a>分布式工作流</h3><p>分布式工作流有三种，包含集中式工作流、集成管理者工作流、司令官和副官工作流。一般项目采用集中式工作流，当 A 用户提交了代码后，B 用户再次提交前，先须拉取代码并合并，然后才能提交；否则会报提交失败。集成管理者工作流通常在 github 开源代码中采用，即作为开源代码的贡献者，先须 fork 该项目，创建一个自己的仓库，更新提交后，发送消息给开源代码的维护者，等待维护者合并贡献者的代码并提交。司令官和副官工作流见于 linux 开发项目，普通开发者完成开发后，基于司令官的 master 执行变基操作；副官再将普通开发者的分支合并到自己的 master 分支上；司令官合并所有副官的 master 分支并提交。</p>
<h3 id="提交准则"><a href="#提交准则" class="headerlink" title="提交准则"></a>提交准则</h3><ol>
<li>避免空白错误。</li>
<li>尝试让每一个提交成为一个逻辑上的独立变更集，即针对每个问题，独立提交一次。</li>
<li>完善提交信息，使用 vim 编辑提交信息，推荐使用 标题 + 空行 + 正文 形式。</li>
</ol>
<h3 id="贡献代码"><a href="#贡献代码" class="headerlink" title="贡献代码"></a>贡献代码</h3><h4 id="私有小型团队"><a href="#私有小型团队" class="headerlink" title="私有小型团队"></a>私有小型团队</h4><p>用户 A 创建特性分支 feature1 并作修改后，再将特性分支合并到 master 分支上。用户 B 创建了特性分支 feature2 并作修改后，若在此时，用户 B 想把 feature2 内容合并到 master 分支并作提交，那他需要在 master 分支上执行 git fetch; git merge origin/master; git merge feature2 命令，即合并本地特性分支和远程协作者提交内容后，才可以正式提交代码。这样的工作流程最常见于实际项目中。</p>
<h4 id="私有大型团队"><a href="#私有大型团队" class="headerlink" title="私有大型团队"></a>私有大型团队</h4><p>用户 A 和 B 在特性分支 feature1 上工作，用户 B 和 C 在特性分支 feature2 上工作。工作流程采用了整合-管理者工作流程，即独立小组的工作只能被特定的工程师整合，主仓库的 master 分支只能被那些工程师更新。当 feature1, feature2 开发并测试完成后，再由整合者将两个分支的内容合并到 master 分支上。对于 feature1, feature2 的开发工作流程，同小型私有团队，即提交前先要合并协作者上传到远端的代码。</p>
<h4 id="派生的公开项目"><a href="#派生的公开项目" class="headerlink" title="派生的公开项目"></a>派生的公开项目</h4><p>首先 clone 项目，然后在本地创建 feature1 分支(使 master 分支保持干净，避免维护者不采用你的代码时，需要回滚 master 分支到最初 clone 时的状态)，fork 仓库(即派生项目)后提交到远程自己的同名仓库中。通知开源项目的维护者拉取你的改动，这通常被称为拉取请求(pull request)，可通过执行 git request-pull origin/master feature 命令告知维护者改动是在你 fork 的仓库的 feature 分支上完成的。</p>
<h4 id="通过邮件的公开项目"><a href="#通过邮件的公开项目" class="headerlink" title="通过邮件的公开项目"></a>通过邮件的公开项目</h4><p>有几个历史悠久的、大型的项目会通过一个开发者的邮件列表接受补丁。使用 git format-patch 来生成可以邮寄到列表的 mbox 格式的文件 - 它将每一个提交转换为一封电子邮件，提交信息的第一行作为主题，剩余信息与提交引入的补丁作为正文。-M 选项用于告诉 Git 查找重命名。通过 git config 设置 imap 区块的 folder = “[Gmail]/Drafts”, host = imaps://imap.gmail.com, user = <a href="mailto:user@gmail.com" target="_blank" rel="noopener">user@gmail.com</a>, pass = p4ssw0rd, port = 993, sslverify = false 属性(如果 IMAP 服务器不使用 SSL，无需设置 port, sslverify 属性，host 的值会是 imap:// 而不是 imaps://)；再执行 git imap-send 可以将补丁序列放在特定 IMAP 服务器的 Drafts 文件夹。或者通过 git config 设置 sendemail 区块的 smtpencryption = tls, smtpserver = smtp.gmail.com, smtpuser = <a href="mailto:user@gmail.com" target="_blank" rel="noopener">user@gmail.com</a>, smtpserverport = 587 属性；再执行 git send-email 通过 SMTP 服务器发送补丁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff --check <span class="comment"># 检查空白错误。空白错误是指行尾的空格、Tab 制表符，和行首空格后跟 Tab 制表符的行为</span></span><br><span class="line">git format-patch -M origin/master <span class="comment"># 生成 .patch 扩展名的补丁文件，可以编辑该文件，添加额外信息</span></span><br><span class="line">cat *.patch |git imap-send <span class="comment"># 通过 IMAP 发送正确格式化的补丁</span></span><br><span class="line">git send-email *.patch <span class="comment"># 通过 SMTP 服务器发送补丁</span></span><br></pre></td></tr></table></figure>
<h3 id="维护项目"><a href="#维护项目" class="headerlink" title="维护项目"></a>维护项目</h3><h4 id="应用补丁"><a href="#应用补丁" class="headerlink" title="应用补丁"></a>应用补丁</h4><p>若补丁通过 git diff 生成，使用 git apply 命令可在当前工作分支中应用文件补丁。应用补丁前，使用 git apply –check 命令可检查补丁是否可以顺利应用。</p>
<p>若补丁通过 format-patch 生成，使用 git am 命令可以提取出 mbox 文件中的实际变更并应用，且自动创建新的提交。</p>
<h4 id="合并工作流"><a href="#合并工作流" class="headerlink" title="合并工作流"></a>合并工作流</h4><p>合并工作流，可以将特性分支逐次合并到 master 分支上；或者保持 master 分支的稳定性，再创建 develop 长期分支，将特性分支合并 develop 分支，等 develop 分支稳定后，再合并到 master 分支上；或者在 master 之外创建 next, pu(proposed updates，用于新工作), maint(maintenance backports，用于维护性向后移植工作) 分支，安全的特性分支先合并入 next 分支，再合并到 master 分支上。</p>
<h4 id="拣选"><a href="#拣选" class="headerlink" title="拣选"></a>拣选</h4><p>执行 git cherry-pick，见原理。</p>
<h4 id="重用冲突解决方案-reuse-recorded-resolution"><a href="#重用冲突解决方案-reuse-recorded-resolution" class="headerlink" title="重用冲突解决方案/reuse recorded resolution"></a>重用冲突解决方案/reuse recorded resolution</h4><p>执行 git config –global rerere.enabled true 缓存冲突解决方案。执行 git rerere 命令将从缓存中查找相似的冲突，并应用对应的解决方案。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">git apply *.patch <span class="comment"># 在当前分支中应用补丁</span></span><br><span class="line">git apply --check *.patch <span class="comment"># 检查补丁是否可被顺利应用</span></span><br><span class="line">git am *.patch <span class="comment"># 读取 mbox 文件实际变更并应用</span></span><br><span class="line">git am -3 *.patch <span class="comment"># -3 选项将使用三方合并应用补丁</span></span><br><span class="line">git am -3 -i mbox <span class="comment"># 使用交互模式应用多个补丁</span></span><br><span class="line">git am --resolved <span class="comment"># git am 报错后，手动解决冲突，执行下一个补丁的应用</span></span><br><span class="line">git am --skip <span class="comment"># 跳过当前补丁</span></span><br><span class="line">git am --abort <span class="comment"># 当前分支回退到应用补丁前状态，终止补丁应用</span></span><br><span class="line">git <span class="built_in">log</span> branch1 --not branch2 <span class="comment"># 找出仅属于 branch1 但不属于 branch2 的提交记录</span></span><br><span class="line">git diff branch <span class="comment"># 当前工作分支与 branch 分支比较差异</span></span><br><span class="line">git merge-base branch1 branch2 <span class="comment"># 找出 branch1 和 branch2 的共同祖先</span></span><br><span class="line">git diff branch1...branch2 <span class="comment"># 比较 branch1 的最新提交和两个分支的共同祖先之间的差异</span></span><br><span class="line">git cherry-pick &lt;checksum&gt; <span class="comment"># 以某个提交对象为基底在当前工作分支上创建新的提交对象，将重新计算校验和，如 git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf</span></span><br><span class="line">git config --global rerere.enabled <span class="literal">true</span> <span class="comment"># 开启冲突解决方案缓存</span></span><br><span class="line">git rerere <span class="comment"># 查找相似的冲突解决方案并应用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">git tag -s &lt;version&gt; -m <span class="string">'message'</span> <span class="comment"># 打标签</span></span><br><span class="line">gpg --list-keys <span class="comment"># 查找 GPG 公钥</span></span><br><span class="line">gpg -a --<span class="built_in">export</span> &lt;gpgkey&gt; | git <span class="built_in">hash</span>-object -w --stdin <span class="comment"># git hash-object 命令以 blob 对象形式在 git 中导入公钥，并返回该 blob 对象的 SHA-1 值。该 SHA-1 值可以用于发布标签，如 git tag -a &lt;tagname&gt; &lt;sha-1&gt;</span></span><br><span class="line">git show &lt;tagname&gt; | gpg --import <span class="comment"># 开发者获取并导入公钥，用于贡献代码</span></span><br><span class="line">git describe &lt;branch&gt; <span class="comment"># 生成构建号，包含最近的标签名、自该标签之后的提交数目和你所描述的提交的部分 SHA-1 值</span></span><br><span class="line">git archive master --prefix=<span class="string">'project/'</span> | gzip &gt; `git describe master`.tar.gz <span class="comment"># 创建 .tar.gz 压缩包</span></span><br><span class="line">git archive master --prefix=<span class="string">'project/'</span> --format=zip &gt; `git describe master`.zip <span class="comment"># 创建 .zip 压缩包</span></span><br><span class="line">git shortlog --no-merges master --not v1.0.1 <span class="comment"># 生成自 v1.0.1 版本发布以来所有提交的总结</span></span><br></pre></td></tr></table></figure>
<p>疑问：</p>
<ol>
<li>公共项目的发布问题？</li>
</ol>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>github 钩子和服务订制、API，参见：<br><a href="https://git-scm.com/book/zh/v2/GitHub-脚本-GitHub" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/GitHub-脚本-GitHub</a><br><a href="https://developer.github.com" target="_blank" rel="noopener">https://developer.github.com</a></p>
<h2 id="Git-Tools"><a href="#Git-Tools" class="headerlink" title="Git Tools"></a>Git Tools</h2><h3 id="选取提交记录"><a href="#选取提交记录" class="headerlink" title="选取提交记录"></a>选取提交记录</h3><p>根据提交对象的 SHA-1 值查看提交记录。引用日志只在本地生成，不能通过远程交互被协作者拷贝。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --abbrev-commit --pretty=oneline <span class="comment"># 获取简短且唯一的 SHA-1 值</span></span><br><span class="line">git show &lt;sha-1&gt;|&lt;branch&gt; <span class="comment"># 显示提交记录</span></span><br><span class="line">git rev-parse &lt;branch&gt; <span class="comment"># 获取最近一次提交的 SHA-1 值</span></span><br><span class="line">git reflog <span class="comment"># 查看引用日志，引用日志记录了最近几个月的 HEAD 和分支引用所指向的历史，包含提交对象的简短 SHA-1 值、HEAD 记录和提交信息</span></span><br><span class="line">git show HEAD@&#123;5&#125; <span class="comment"># 查看第五次提交记录</span></span><br><span class="line">git show &lt;branch&gt;@&#123;yesterday&#125; <span class="comment"># 查看 branch 分支昨天指向了哪个提交</span></span><br><span class="line">git show HEAD^ <span class="comment"># ^ 引用指上一次提交，HEAD^ 即上一次提交，HEAD^^ 即之前第二次提交</span></span><br><span class="line">git show &lt;sha-1&gt;^ <span class="comment"># 特定提交的上一次提交</span></span><br><span class="line">git show HEAD~ <span class="comment"># ~ 指父引用，~2 指之前第二次提交</span></span><br><span class="line">git show &lt;sha-1&gt;~num <span class="comment"># 特定提交前第 num 次提交</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> branch1..branch2 <span class="comment"># branch1..branch2 指在 branch2 分支中而不在 branch1 分支中的提交，branch2 留空，自动以 HEAD 填充，如 git log origin/master..HEAD 或 git log origin/master..。branch1..branch2可用于其他命令</span></span><br><span class="line">git <span class="built_in">log</span> refA refB ^refC <span class="comment"># 指定被 refA, refB 包含，但不被 refC 包含的提交记录</span></span><br><span class="line">git <span class="built_in">log</span> refA refB --not refC <span class="comment"># 同上</span></span><br><span class="line">git <span class="built_in">log</span> branch1...branch2 <span class="comment"># 选出不被两个分支同时包含的提交记录</span></span><br><span class="line">git <span class="built_in">log</span> --left-right branch1...branch2 <span class="comment"># 选出不被两个分支同时包含的提交记录，并显示提交对象属于 branch1 还是 branch2</span></span><br></pre></td></tr></table></figure>
<h3 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add -i|--interactive <span class="comment"># --interactive 选项用于开启交互式暂存命令行，执行后左侧显示已暂存的，右侧显示未暂存的；根据提示命令面板执行后续操作，如 1/status 显示状态, 2/update 提交到暂存区, 3/revert 从暂存区撤回, 4/add untracked 提交未追踪文件到暂存区, 5/patch 暂存补丁，可将部分修改提交到暂存区, 6/diff 查看已暂存内容的区别</span></span><br><span class="line">git add -p|--patch <span class="comment"># 暂存部分文件</span></span><br><span class="line">git reset --patch <span class="comment"># 部分重置文件</span></span><br><span class="line">git checkout --patch <span class="comment"># 部分检出文件</span></span><br><span class="line">git stash save --patch <span class="comment"># 部分暂存文件</span></span><br></pre></td></tr></table></figure>
<h3 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h3><p>通过 git stash 命令可以将工作区的改动储藏起来，却不是提交到暂存区；再使用 git stash apply 应用之前的储藏(可以在另一个分支上应用储藏；且当前分支做过修改后，仍可以应用储藏，必要时需解决冲突)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 储藏工作区的改动，可用于切换分支前避免与远程代码的合并</span></span><br><span class="line">git stash save <span class="comment"># 同上</span></span><br><span class="line">git stash --keep-index <span class="comment"># 同上，--keep-index 选项将不储藏已使用 git add 暂存的内容</span></span><br><span class="line">git stash -u|--include-untracked <span class="comment"># 默认 git stash 不包含未追踪的文件，--include-untracked 选项将包含未追踪的文件</span></span><br><span class="line">git stash --patch <span class="comment"># 交互式地指引用户需要将那些改动储藏，那些改动保存在工作区</span></span><br><span class="line">git stash --all <span class="comment"># 移除修改，并储藏起来</span></span><br><span class="line">git stash list <span class="comment"># 查看所有储藏内容</span></span><br><span class="line">git stash apply <span class="comment"># 将储藏重新应用在工作分支上，默认为最近的储藏</span></span><br><span class="line">git stash apply stash@&#123;num&#125; <span class="comment"># 将第 num 次储藏应用在工作分支上，0 为最近的储藏</span></span><br><span class="line">git stash apply --index <span class="comment"># 应用储藏，同时应用暂存</span></span><br><span class="line">git stash branch &lt;branchname&gt; <span class="comment"># 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，并扔掉储藏</span></span><br><span class="line">git stash drop stash@&#123;num&#125; <span class="comment"># 移除储藏</span></span><br><span class="line">git stash pop stash@&#123;num&#125; <span class="comment"># 应用并移除储藏</span></span><br></pre></td></tr></table></figure>
<h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clean <span class="comment"># 从工作目录中移除未被追踪的文件</span></span><br><span class="line">git clean -f -d <span class="comment"># 强制移除工作目录中所有未追踪的文件以及空的子目录</span></span><br><span class="line">git clean -d -n <span class="comment"># 移除项预览</span></span><br><span class="line">git clean -n -d -x <span class="comment"># git clean 默认不移除 .gitignore 中匹配的文件，-x 选项将移除该类文件</span></span><br><span class="line">git clean -x -i|--interactive <span class="comment"># 交互式执行 clean 命令</span></span><br></pre></td></tr></table></figure>
<h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><p>参考：<a href="https://git-scm.com/book/zh/v2/Git-工具-签署工作" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-工具-签署工作</a></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git grep string/regexp <span class="comment"># 从提交历史或工作目录中查找匹配正则或字符串的内容，--and 选项用于设置更复杂字符串或正则匹配规则</span></span><br><span class="line">git grep string/regexp &lt;filepath&gt; &lt;version&gt; <span class="comment"># 指定文件或文件夹、版本号搜索</span></span><br><span class="line">git grep -n string/regexp <span class="comment"># 输出行号</span></span><br><span class="line">git grep -p string/regexp <span class="comment"># 查看匹配的行属于哪一个方法或函数</span></span><br><span class="line">git grep -count string/regexp <span class="comment"># 输出概要信息</span></span><br><span class="line">git grep --<span class="built_in">break</span> --heading string/regexp <span class="comment"># 使输出更易读</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志搜索</span></span><br><span class="line">git <span class="built_in">log</span> -string --oneline <span class="comment"># 从提交历史或 diff 内容中检索匹配字符串或正则的提交记录，-S 选项只查看新增和删除匹配内容的提交，-G 选项使用正则表达式检索</span></span><br><span class="line">git <span class="built_in">log</span> -L :string:filepath <span class="comment"># 行日志搜索，搜索特定文件中 string 变更的提交记录</span></span><br></pre></td></tr></table></figure>
<h3 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h3><p>git commit –amend 用于修改前一次提交。<br>git rebase -i 交互式修改多次提交记录，可拆分，可弃用，可合并，可重置等。须在本地环境中使用，提交到线上再调用变基，会使协作者变得不方便。<br>git filter-branch 使用脚本的方式改写大量提交记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend <span class="comment"># 修改前一次提交记录，修改暂存区再执行该命令时可改变提交内容，否则只是改变提交信息</span></span><br><span class="line">git rebase -i HEAD~2^|HEAD~3 <span class="comment"># -i 选项开启交互式变基命令，将唤起编辑器，反序修改前三次提交，最后一次修改在前。因为之前的提交已提交，显示 p, pick 默认提交，修改为 r, reword 重写提交信息；e, edit 使用  git commit --amend 重置提交，可用于拆分提交；s, squash 将提交信息合并到之前执行 pick 命令的提交对象中，且将多次提交信息合并；f, fixup 同 squash，但丢弃提交信息，x, exec，唤起 shell 提交。弃用某次提交记录，可直接从 git rebase -i HEAD~2^|HEAD~3 显示的列表中删除</span></span><br><span class="line">git filter-branch --tree-filter <span class="string">'rm -f passwords.txt'</span> HEAD <span class="comment"># --tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。--all 选项用于改写所有分支</span></span><br><span class="line">git filter-branch --subdirectory-filter trunk HEAD <span class="comment"># 让 trunk 子目录作为每一个提交的新的项目根目录</span></span><br><span class="line">git filter-branch --commit-filter <span class="string">'</span></span><br><span class="line"><span class="string">  if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];</span></span><br><span class="line"><span class="string">  then</span></span><br><span class="line"><span class="string">    GIT_AUTHOR_NAME="Scott Chacon";</span></span><br><span class="line"><span class="string">    GIT_AUTHOR_EMAIL="schacon@example.com";</span></span><br><span class="line"><span class="string">    git commit-tree "$@";</span></span><br><span class="line"><span class="string">  else</span></span><br><span class="line"><span class="string">    git commit-tree "$@";</span></span><br><span class="line"><span class="string">  fi'</span> HEAD <span class="comment"># 修改多个项目的提交邮箱，且重写每个提交的校验和，不只匹配邮箱地址的提交</span></span><br></pre></td></tr></table></figure>
<h3 id="重置揭密"><a href="#重置揭密" class="headerlink" title="重置揭密"></a>重置揭密</h3><p>参考原理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p HEAD <span class="comment"># 查看版本库当前提交信息</span></span><br><span class="line">git ls-tree -r HEAD <span class="comment"># 查看版本库中提交文件的 checksum 及其文件名</span></span><br><span class="line">git ls-files -s <span class="comment"># 查看暂存区中文件的 checksum 及其文件名</span></span><br><span class="line"></span><br><span class="line">git reset &lt;checksum&gt; <span class="comment"># 将版本库和暂存区内容替换为 checksum 指向的提交对象</span></span><br><span class="line">git reset --soft &lt;checksum&gt; <span class="comment"># 将版本库内容替换为 checksum 指向的提交对象</span></span><br><span class="line">git reset --mixed &lt;checksum&gt; <span class="comment"># 将版本库和暂存区内容替换为 checksum 指向的提交对象</span></span><br><span class="line">git reset --hard &lt;checksum&gt; <span class="comment"># 将版本库、暂存区和工作区内容替换为 checksum 指向的提交对象</span></span><br><span class="line">git reset &lt;filepath&gt; <span class="comment"># 从 HEAD 中获取 filepath 文件或目录，复制到暂存区</span></span><br><span class="line">git reset &lt;checksum&gt; &lt;filepath&gt; <span class="comment"># 从 checksum 中获取 filepath 文件或目录，复制到暂存区</span></span><br></pre></td></tr></table></figure>
<h3 id="高级合并"><a href="#高级合并" class="headerlink" title="高级合并"></a>高级合并</h3><p>合并前可以通过保存到临时分支或通过执行 git stash 命令储藏起来，避免合并对工作区的影响，使工作区内容丢失。</p>
<p>子树合并是项目某目录下包含一个子工程，同时 git 分支也包含一个从属于子工程的分支，从而引起子分支和子工程目录的合并操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort <span class="comment"># 退出合并，工作区内容恢复到合并前</span></span><br><span class="line">git reset --hard HEAD <span class="comment"># 退出合并，将版本库、暂存区和工作区内容重置到合并前</span></span><br><span class="line">git merge -Xignore-space-change <span class="comment"># 忽略任意数量的已有空白的修改</span></span><br><span class="line">git merge -Xignore-space-change <span class="comment"># 忽略所有空白修改</span></span><br><span class="line">git show :1:&lt;conflictFileName&gt; &gt; commonFileName <span class="comment"># 拷贝并导出冲突的共同祖先文件</span></span><br><span class="line">git show :2:&lt;conflictFileName&gt; &gt; oursFileName <span class="comment"># 拷贝并导出冲突的工作目录文件</span></span><br><span class="line">git show :3:&lt;conflictFileName&gt; &gt; theirsFileName <span class="comment"># 拷贝并导出冲突的待合并文件</span></span><br><span class="line">git ls-files -u <span class="comment"># 查看冲突文件的完整 SHA-1 值</span></span><br><span class="line">git merge-file -p \</span><br><span class="line">  oursFileName commonFileName theirsFileName &gt; fileName <span class="comment"># oursFileName, commonFileName, theirsFileName 拷贝的冲突文件手工解决冲突后，合并冲突文件</span></span><br><span class="line">git diff --ours <span class="comment"># 查看合并结果和当前工作分支的差别，-b 选项用于移除空格比较，--base 选项查看比较文件两边是如何改动的</span></span><br><span class="line">git diff --theirs <span class="comment"># 查看合并结果和待合并分支的差别</span></span><br><span class="line">git clean -f <span class="comment"># 清理为合并拷贝的文件，如 commonFileName 等</span></span><br><span class="line">git checkout --conflict=diff3 <span class="comment"># 查看工作分支、待合并分支、共同祖先分支的冲突文件</span></span><br><span class="line">git checkout --conflict=merge <span class="comment"># 默认，查看工作分支、待合并分支的冲突文件</span></span><br><span class="line">git checkout --ours <span class="comment"># 合并时使用当前工作分支文件内容</span></span><br><span class="line">git checkout --theirs <span class="comment"># 合并时使用待合并分支文件内容</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --left-right branch1...branch2 <span class="comment"># 查看合并文件的提交记录来源</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --left-right --merge <span class="comment"># 查看合并过程中，有冲突文件的提交记录来源</span></span><br><span class="line">git diff <span class="comment"># 查看冲突文件或冲突结果</span></span><br><span class="line">git <span class="built_in">log</span> --cc -p -1 <span class="comment"># 查看冲突结果</span></span><br><span class="line">git reset --hard HEAD~ <span class="comment"># 撤销合并，将版本库撤回到合并前状态</span></span><br><span class="line">git revert -m 1 basebranch <span class="comment"># 撤销合并，将提交对象撤回到 basebranch 分支内容。-m 1 标记指出 “mainline” 需要被保留下来的父结点。此时将无法合并待合并分支的内容</span></span><br><span class="line">git revert &lt;checksum&gt; <span class="comment"># 撤销 git revert -m 1 basebranch 命令</span></span><br><span class="line">git merge -Xours &lt;branch&gt; <span class="comment"># 选用当前工作分支内容进行合并</span></span><br><span class="line">git merge -Theirs &lt;branch&gt; <span class="comment"># 选用待合并分支内容进行合并</span></span><br><span class="line">git merge-file --ours &lt;filepath&gt; <span class="comment"># 选用当前工作分支内容进行合并</span></span><br><span class="line">git merge-file --theirs &lt;filepath&gt; <span class="comment"># 选用待合并分支内容进行合并</span></span><br><span class="line">git merge -s ours &lt;branch&gt; <span class="comment"># 假合并，直接将当前工作分支内容作为合并结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子树合并</span></span><br><span class="line">git <span class="built_in">read</span>-tree --prefix=dirname/ -u sub_project_branch <span class="comment"># 将子工程分支的内容拷贝到 dirname 目录中</span></span><br><span class="line">git merge --squash -s recursive -Xsubtree=dirname sub_project_branch <span class="comment"># 将 sub_project_branch 分支内容合并到 dirname 目录中</span></span><br><span class="line">git diff-tree -p sub_project_branch <span class="comment"># 查看差异</span></span><br><span class="line">git diff-tree -p &lt;remote&gt;/&lt;branch&gt; <span class="comment"># 和远程引用相比较</span></span><br></pre></td></tr></table></figure>
<h3 id="rerere-命令"><a href="#rerere-命令" class="headerlink" title="rerere 命令"></a>rerere 命令</h3><p>通过 git config –global rerere.enabled true 命令开启 rerere 功能。rerere 记录冲突解决方案，自动解决冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global rerere.enabled <span class="literal">true</span> <span class="comment"># 开启 rerere 功能</span></span><br><span class="line">git rerere status <span class="comment"># 查看合并前的状态</span></span><br><span class="line">git rerere diff <span class="comment"># 查看解决前后的文件内容差异。冲突解决后，可查看 git rerere 将要记录的内容</span></span><br><span class="line">git ls-files -u <span class="comment"># 查看各冲突文件 checksum</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-git-调试"><a href="#使用-git-调试" class="headerlink" title="使用 git 调试"></a>使用 git 调试</h3><p>使用 git blame 命令可以查看文件内容的历次更改，适用在确知某方法会引起 bug 的场景，可查看该方法的改动细节。</p>
<p>使用 git bisect 命令可以定位哪次提交引起了异常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git blame -L startLine,endLine filepath <span class="comment"># 查看 filepath 文件自 startLine 起始、到 endLine 行结束的变更记录。-L 选项用于限制行号。-C 选项会分析拷贝之后再重命名文件的原始出处</span></span><br><span class="line"></span><br><span class="line">git bisect start <span class="comment"># 启动二分查找</span></span><br><span class="line">git bisect bad <span class="comment"># 告知 git 当前提交有问题</span></span><br><span class="line">git bisect good &lt;checksum&gt; <span class="comment"># 告知 git 将 checksum 指向的提交对象标记为好的。由 git 告知用户在正常提交和错误提交之间有多少次提交，二次查找中间那次提交，通过 git bisect bad 或 git bisect good 标记好坏。git 会自动定位到提交中点，再由用户判断提交结果的好坏</span></span><br><span class="line">git bisect reset <span class="comment"># 重置 HEAD 指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过执行脚本定位 bug 来源。checksum1 是坏的提交，checksum2 是好的提交</span></span><br><span class="line">git bisect start &lt;checksum1&gt;|HEAD &lt;checksum2&gt;</span><br><span class="line">git bisect run filepath</span><br></pre></td></tr></table></figure>
<h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><p>子模块虽然在工程目录中创建了子目录，但是若不在该子目录中，git 并不会跟踪子模块的文件内容，而是将它看作该仓库中的一个特殊提交。子模块提交时标记为 160000 模式，意味着将一次提交记作一项目录记录，而非将它记录成一个子目录或者一个文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &lt;remoteurl&gt; &lt;dirname&gt; <span class="comment"># 克隆远程仓库，以远程仓库名创建文件夹，或者自定义文件夹。同时会添加 .gitmodules 文件，用于保存本地目录和远程仓库地址</span></span><br><span class="line">git config submodule.&lt;dirname&gt;.url &lt;url&gt; <span class="comment"># 重设远程仓库地址</span></span><br><span class="line">git diff --cached --submodule <span class="comment"># 查看子模块的文件差异</span></span><br><span class="line">git submodule init <span class="comment"># 子模块初始化</span></span><br><span class="line">git submodule update <span class="comment"># 获取远程仓库数据，并检出父项目中属于子模块的提交</span></span><br><span class="line">git <span class="built_in">clone</span> --recursive mainurl <span class="comment"># mainurl 为父项目的 url，同时更新子模块</span></span><br><span class="line">git submodule update --remote subproject <span class="comment"># 在父项目工作目录中进行更新，避免手动进入子模块抓取和合并</span></span><br><span class="line">git submodule update --remote --merge <span class="comment"># 合并</span></span><br><span class="line">git submodule update --remote --rebase <span class="comment"># 变基</span></span><br><span class="line">git submodule update --init <span class="comment"># 初始化拉取远程内容</span></span><br><span class="line">git <span class="built_in">log</span> -p --submodule <span class="comment"># 查看子模块的提交日志</span></span><br><span class="line">git push --recurse-submodules=check <span class="comment"># 推送时校验子项目有否提交</span></span><br><span class="line">git push --recurse-submodules=on-demand <span class="comment"># 推送子模块，或者子项目中执行 git push 命令</span></span><br><span class="line">git submodule foreach <span class="string">'git stash'</span> <span class="comment"># 在所有子模块中运行 git stash 命令</span></span><br><span class="line">git rm -r &lt;dirname&gt; <span class="comment"># 从暂存区移除子项目目录</span></span><br><span class="line">rm -Rf &lt;dirname&gt; <span class="comment"># 移除子项目目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子模块命令别名</span></span><br><span class="line">git config alias.sdiff <span class="string">'!'</span><span class="string">"git diff &amp;&amp; git submodule foreach 'git diff'"</span></span><br><span class="line">git config alias.spush <span class="string">'push --recurse-submodules=on-demand'</span></span><br><span class="line">git config alias.supdate <span class="string">'submodule update --remote --merge'</span></span><br></pre></td></tr></table></figure>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git bundle create bundlefilename HEAD &lt;branch&gt; <span class="comment"># 将 branch 分支所有提交数据打包到 bundlefilename 文件中</span></span><br><span class="line">git bundle create bundlefilename &lt;branch&gt; ^&lt;checksum&gt; <span class="comment"># 设定提交区间，并打包文件。提交区间可以用 ... 等符号操作</span></span><br><span class="line">git <span class="built_in">clone</span> bundlefilename dirname <span class="comment"># 将打包文件解压到 dirname 目录中</span></span><br><span class="line">git bundle verify bundlefilename <span class="comment"># 校验打包文件是不是合法的 Git 包</span></span><br><span class="line">git bundle list-heads bundlefilename <span class="comment"># 查看打包文件包含哪些提交对象和分支</span></span><br><span class="line">git fetch bundlefilename branch:<span class="built_in">local</span>-branch <span class="comment"># 将打包文件中的分支导入本地工程中</span></span><br></pre></td></tr></table></figure>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>大型项目可分成一个短历史提交记录和一个长历史提交记录，短历史供新的开发者使用，后者给喜欢数据挖掘的人使用。制作短历史提交记录通过 git commit-tree 命令合并提交记录，再通过 git rebase 命令将必要的提交变基到刚创建的合并提交记录上，就可以制作短历史提交记录。执行 git replace 命令，可以查看长历史提交记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch&gt; &lt;checksum&gt; <span class="comment"># 以提交对象 checksum 创建分支 branch</span></span><br><span class="line">git push remote localbranch:remotebranch <span class="comment"># 将本地 localbranch 分支推送到远程仓库 remote 下的 remotebranch 分支</span></span><br><span class="line">git commit-tree &lt;checksum&gt;^&#123;tree&#125; <span class="comment"># 将 checksum 提交对象及其前的提交合并为新的提交对象，返回新提交对象的 SHA-1 </span></span><br><span class="line">git rebase --onto checksum1 checksum2 <span class="comment"># 将 checksum2 后的提交变基到 checksum1 上，checksum1 后产生新的提交记录</span></span><br><span class="line">git replace checksum1 checksum2 <span class="comment"># 将 checksum1 及其前的提交记录替换为 checksum2 及其前的提交记录</span></span><br><span class="line">git cat-file -p &lt;checksum&gt; <span class="comment"># 查看 checksum 提交的提交树 SHA-1 值及其父提交</span></span><br></pre></td></tr></table></figure>
<h3 id="凭证存储"><a href="#凭证存储" class="headerlink" title="凭证存储"></a>凭证存储</h3><p>使用 SSH 连接远端，且设置了一个没有口令的密钥，这样就可以在不用输入用户名和密码的情况下安全连接远端。使用 HTTP 存储，每一个连接都需要输入用户名和密码。git 凭证机制默认不存储用户名和密码，’cache’ 模式内存中暂时存储用户名和密码，’store’ 模式将用户名和密码存储在磁盘中，mac 下 ‘osxkeychain’ 以加密方式将凭证缓存到系统用户的钥匙串，windows 下可借助 ‘winstore’ 工具以加密方式将凭证存储在磁盘中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper cache|store <span class="comment"># 设置凭证存储模式</span></span><br><span class="line">git config --global credential.helper store --file &lt;path&gt; <span class="comment"># 设置存储目录</span></span><br><span class="line">git config --global credential.helper cache --timeout &lt;seconds&gt; <span class="comment"># 设置过期时间</span></span><br><span class="line">git credential fill <span class="comment"># 交互式设置凭证，通过 protocol/协议, host/主机名 设置</span></span><br></pre></td></tr></table></figure>
<h3 id="疑问-3"><a href="#疑问-3" class="headerlink" title="疑问"></a>疑问</h3><ol>
<li>获取某个特定的提交对象后，可否对该提交对象进行操作？</li>
<li>关于签署标签？</li>
<li>关于 git filter-branch？</li>
<li>关于子模块？</li>
</ol>
<h2 id="Customizing-Git"><a href="#Customizing-Git" class="headerlink" title="Customizing Git"></a>Customizing Git</h2><h3 id="自定义合并、比较工具"><a href="#自定义合并、比较工具" class="headerlink" title="自定义合并、比较工具"></a>自定义合并、比较工具</h3><p>借助 Perforce 图形化合并工具（P4Merge）来合并文件和解决冲突。</p>
<ol>
<li>下载 P4Merge。</li>
<li><p>创建一个名为 extMerge 的脚本包装 merge 命令，让它把参数转发给 p4merge 二进制文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /usr/local/bin/extMerge</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/Applications/p4merge.app/Contents/MacOS/p4merge $*</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个名为 extDiff 的脚本包装 diff 命令，让它把参数转发给 p4merge 二进制文件。git 传递以下参数给 diff：path old-file old-hex old-mode new-file new-hex new-mode。实际仅需要 old-file 和 new-file 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /usr/local/bin/extDiff</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ <span class="variable">$#</span> -eq 7 ] &amp;&amp; /usr/<span class="built_in">local</span>/bin/extMerge <span class="string">"<span class="variable">$2</span>"</span> <span class="string">"<span class="variable">$5</span>"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使 extMerge, extDiff 脚本拥有可执行权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/extMerge</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/extDiff</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件，自定义合并和比较文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool extMerge <span class="comment"># 通知 Git 该使用哪个合并工具</span></span><br><span class="line">git config --global mergetool.extMerge.cmd \</span><br><span class="line">  <span class="string">'extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"'</span> <span class="comment"># 规定命令运行的方式</span></span><br><span class="line">git config --global mergetool.extMerge.trustExitCode <span class="literal">false</span> <span class="comment"># 通知 Git 程序的返回值是否表示合并操作成功</span></span><br><span class="line">git config --global diff.external extDiff <span class="comment"># 通知 Git 该用什么命令做比较</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 git diff <checksum1> <checksum2> 命令，将自动唤起 P4Merge 图形化工具。</checksum2></checksum1></p>
</li>
<li>使用 git mergetool 命令，将自动唤起 P4Merge 图形化工具。</li>
</ol>
<h3 id="git-属性"><a href="#git-属性" class="headerlink" title="git 属性"></a>git 属性</h3><p>通过 .gitattributes 文件或 .git/info/attributes 文件设置属性，可用于识别二进制文件、比较二进制文件。</p>
<h4 id="识别二进制文件"><a href="#识别二进制文件" class="headerlink" title="识别二进制文件"></a>识别二进制文件</h4><p>只需配置 .gitattributes 文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.pbxproj binary <span class="comment"># 将 pbxproj 识别为二进制文件，git 将不会对其修改，如 CRLF 问题</span></span><br></pre></td></tr></table></figure></p>
<h4 id="比较-word-文件"><a href="#比较-word-文件" class="headerlink" title="比较 word 文件"></a>比较 word 文件</h4><p>比较二进制 Microsoft Word 文件步骤：</p>
<ol>
<li>下载 docx2txt。</li>
<li><p>编写可执行脚本，即 docx2txt 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">docx2txt.pl <span class="variable">$1</span> -</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config diff.word.textconv docx2txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 .gitattributes 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.docx diff=word <span class="comment"># 使用 “word” 过滤器，即借助 docx2txt 程序将 Word 文档转为可读文本文件</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="比较图像文件"><a href="#比较图像文件" class="headerlink" title="比较图像文件"></a>比较图像文件</h4><p>在比较时对图像文件运用一个过滤器(如 exiftool)，提炼出 EXIF 信息——这是在大部分图像格式中都有记录的一种元数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'*.png diff=exif'</span> &gt;&gt; .gitattributes</span><br><span class="line">git config diff.exif.textconv exiftool</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>/ <span class="built_in">export</span>-ignore <span class="comment"># .gitattributes 文件中设置不必导出的文件或文件夹</span></span><br><span class="line">LAST_COMMIT <span class="built_in">export</span>-subst <span class="comment"># 设置 LAST_COMMIT 文件用于接受提交记录，git commit 提交后，执行 git archive 命令，将提交记录导出到 LAST_COMMIT 文件中。LAST_COMMIT 文件内容如 'Last commit date: $Format:%cd by %aN$'</span></span><br><span class="line">database.xml merge=ours <span class="comment"># 设置合并策略，采用工作目录中的文件</span></span><br></pre></td></tr></table></figure>
<h3 id="git-钩子"><a href="#git-钩子" class="headerlink" title="git 钩子"></a>git 钩子</h3><p>git 钩子放置在 .git/hooks 子目录中。git init 初始化项目时有示例，可以用 Ruby 或 Python 编程。</p>
<h4 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h4><p>克隆远程仓库时不被复制。</p>
<ol>
<li>pre-commit 钩子在键入提交信息前运行。使用 git commit –no-verify 来绕过这个环节。</li>
<li>prepare-commit-msg 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。</li>
<li>commit-msg 钩子在编辑器退出后运行。</li>
<li>post-commit 钩子在整个提交过程完成后运行。</li>
<li>applypatch-msg 钩子在应用补丁之前运行，git am 命令执行。</li>
<li>pre-applypatch 钩子在应用补丁之后、产生提交之前运行，git am 命令执行。</li>
<li>post-applypatch 钩子在提交产生之后运行，git am 命令执行。</li>
<li>pre-rebase 钩子在变基之前运行。</li>
<li>post-rewrite 钩子被那些会替换提交记录的命令调用，比如 git commit –amend 和 git rebase 命令。</li>
<li>post-checkout 钩子在检出之后运行。</li>
<li>post-merge 钩子在合并之后运行。</li>
<li>pre-push 钩子在推送之前运行。</li>
<li>re-auto-gc 钩子会在垃圾回收开始之前被调用。git 的一些日常操作在运行时，偶尔会调用 git gc –auto 进行垃圾回收。</li>
</ol>
<h4 id="服务器端钩子"><a href="#服务器端钩子" class="headerlink" title="服务器端钩子"></a>服务器端钩子</h4><ol>
<li>pre-receive 钩子在推送过程运行，同时向多个分支推送的情形下也只触发一次。</li>
<li>update 钩子在推送过程运行，同时向多个分支推送的情形下触发多次。</li>
<li>post-receive 钩子在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。</li>
</ol>
<h3 id="疑问-4"><a href="#疑问-4" class="headerlink" title="疑问"></a>疑问</h3><ol>
<li>文件检出和暂存时设置过滤器，参考<a href="https://git-scm.com/book/zh/v2/自定义-Git-Git-属性" target="_blank" rel="noopener">git 属性</a>？</li>
<li>使用钩子，参考<a href="https://git-scm.com/book/zh/v2/自定义-Git-使用强制策略的一个例子" target="_blank" rel="noopener">使用强制策略的一个例子</a></li>
</ol>
<h2 id="Git-Internals"><a href="#Git-Internals" class="headerlink" title="Git Internals"></a>Git Internals</h2><p>从根本上来讲 git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。</p>
<p>.git 目录包含：description 文件仅供 GitWeb 程序使用；config 文件包含项目特有的配置选项；info 目录包含一个全局性排除文件；hooks 目录包含客户端或服务端的钩子脚本；objects 目录存储所有数据内容；refs 目录存储指向数据（分支）的提交对象的指针；HEAD 文件指示目前被检出的分支；index 文件保存暂存区信息。</p>
<h3 id="git-对象"><a href="#git-对象" class="headerlink" title="git 对象"></a>git 对象</h3><p>git 是一个内容寻址文件系统。这意味着，git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 通过底层命令 hash-object 可将任意数据保存于 .git 目录，并返回相应的键值。在 git 中，文件内容存储为数据对象/blob object，文件目录存储为树对象/tree object。一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p>
<p>通常，Git 根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象。所以创建树对象时，先须把文件写入暂存区，以此获得树对象的校验和。但是，树对象的校验和不便于记忆，即不便于获取该树对象。在 git 中，使用提交对象定位树对象，以及该树对象的创建时间，即通过提交对象的校验和获取或存储树对象。提交对象的格式为，先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据 user.name 和 user.email 配置来设定，外加一个时间戳）；留空一行，最后是提交注释。</p>
<p>运行 git add 和 git commit 命令时，git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。数据对象、树对象和提交对象最初均以单独文件的形式保存在 .git/objects 目录下（首先转换为带有如 “blob #{content.length}\0” 等头部信息的内存数据，其次计算校验和，最后再写入 .git/objects 目录下）。</p>
<p>在存储文件对象时，为避免同一文件的不同版本保存多份，git 使用包文件存储，即保存最新版本的完整数据，其他版本保存与最新版本的差异。使用 git gc 命令可执行打包过程；git verify-pack 命令查看打包的内容。自动打包过程发生在 push 命令触发或本地包含太多不同版本的文件，大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 git 启动一次真正的 gc 命令（可通过修改 gc.auto 与 gc.autopacklimit 的设置来改动这些数值）。打包后，.git/refs 目录将清空，相应创建 .git/packed-refs 目录；更新引用时，再相应创建 .git/refs 目录下文件；查找分支引用先从 .git/refs 目录找起，其次 .git/packed-refs 目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'test content'</span> | git <span class="built_in">hash</span>-object -w --stdin <span class="comment"># 写入数据。-w 选项指示 hash-object 命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值； --stdin 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。返回40位校验和，以前两位作为目录名，后38位作为文件名，存储在 .git/objects 目录中</span></span><br><span class="line">git <span class="built_in">hash</span>-object -w test.txt <span class="comment"># 写入数据</span></span><br><span class="line">git cat-file -p &lt;checksum&gt; <span class="comment"># 读取数据</span></span><br><span class="line">find .git/objects -<span class="built_in">type</span> f <span class="comment"># 查看 .git/objects 目录下文件列表</span></span><br><span class="line">git cat-file -p &lt;checksum&gt; &gt; &lt;filepath&gt; <span class="comment"># 将 .git/objects 目录下存储的某条数据导出到 filepath 文件中</span></span><br><span class="line">git cat-file -t &lt;checksum&gt; <span class="comment"># 查看 git 存储数据的对象类型，如返回 blob 或 tree</span></span><br><span class="line"></span><br><span class="line">git cat-file -p master^&#123;tree&#125; <span class="comment"># 查看树对象 master^&#123;tree&#125; 下的内容，可能包含 blob 或 tree 对象。master^&#123;tree&#125; 表示 master 分支上最新的提交所指向的树对象</span></span><br><span class="line">git cat-file -p &lt;checksum&gt; <span class="comment"># 查看树对象、提交对象下的内容，将获取最新版本的文件内容</span></span><br><span class="line">git update-index --add --cacheinfo 100644 \</span><br><span class="line">  83baae61804e65cc73a7201a7252750c76066a30 test.txt <span class="comment"># 通过 update-index 命令为 test.txt 文件创建暂存区，选项 --add 将文件存储到暂存区中；选项 --cacheinfo 将文件添加到 git 数据库，而非当前目录中；文件模式 100644 表示为普通文件，100755 为可执行文件，120000 为符号链接</span></span><br><span class="line">git update-index &lt;filepath&gt; <span class="comment"># 更新暂存区中文件</span></span><br><span class="line">git update-index --add &lt;filepath&gt; <span class="comment"># 添加暂存区中文件</span></span><br><span class="line">git write-tree <span class="comment"># 将暂存区内容写入树对象，返回树对象的 SHA-1 值</span></span><br><span class="line">git <span class="built_in">read</span>-tree &lt;checksum&gt; <span class="comment"># 将树对象读入暂存区</span></span><br><span class="line">git <span class="built_in">read</span>-tree --prefix=dirname &lt;checksum&gt; <span class="comment"># 将树对象读入暂存区，--prefix 选项将其作为子树存储在 dirname 目录下</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'first commit'</span> | git commit-tree &lt;checksum&gt; <span class="comment"># 以树对象 checksum 创建提交对象，返回提交对象的校验和。创建的提交对象可通过 git log 查看</span></span><br></pre></td></tr></table></figure>
<h3 id="git-引用"><a href="#git-引用" class="headerlink" title="git 引用"></a>git 引用</h3><p>git 通过 .git/refs 目录下的文件存储提交对象的引用，以分支形式分类存储，不同分支创建不同的文件，同一文件下包含该分支的提交记录历史。</p>
<p>HEAD 引用通过 .git/HEAD 文件存储，文件内容如 ref: refs/heads/master，指向其他分支引用。</p>
<p>标签对象（tag object）非常类似于一个提交对象——它包含标签创建者信息、日期、注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。它像是一个永不移动的分支引用——永远指向同一个提交对象，分支引用指向的提交对象可以改写。所以标签对象可用于发布。另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。标签对象存储在 .git/refs/tags 目录中，以标签名作为文件名。</p>
<p>.git/refs/remotes 目录下保存远程引用。远程引用和分支引用的主要区别在于，远程引用是只读的。虽然可以 git checkout 到某个远程引用，但是 git 并不会将 HEAD 引用指向该远程引用。因此，永远不能通过 commit 命令来更新远程引用，而只能通过 push 命令更新。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9 <span class="comment"># 在 master 分支中添加提交对象的校验和，比直接编辑文件更安全</span></span><br><span class="line">git symbolic-ref HEAD <span class="comment"># 查看 .git/HEAD 文件内容</span></span><br><span class="line">git symbolic-ref HEAD refs/heads/<span class="built_in">test</span> <span class="comment"># 修改 HEAD 引用的指向</span></span><br><span class="line">git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d <span class="comment"># 创建轻量标签</span></span><br><span class="line">git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m <span class="string">'test tag'</span> <span class="comment"># -a 选项用于创建附注标签</span></span><br></pre></td></tr></table></figure>
<h3 id="引用规格"><a href="#引用规格" class="headerlink" title="引用规格"></a>引用规格</h3><p>引用规格/refspec 用于设定 fetch 命令的请求地址和拉取的分支，以小节形式存储在 .git/config 文件中。引用规格的格式由一个可选的 + 号和紧随其后的 <src>:<dst> 组成，其中 <src> 是一个模式（pattern），代表远程版本库中的引用；<dst> 是那些远程引用在本地所对应的位置。 + 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</dst></src></dst></src></p>
<p>执行 git remote add origin <a href="https://github.com/schacon/simplegit-progit" target="_blank" rel="noopener">https://github.com/schacon/simplegit-progit</a> 命令，.git/config 文件将添加引用规格如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">	url = https://github.com/schacon/simplegit-progit</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/* <span class="comment"># 当修改为 fetch = +refs/heads/master:refs/remotes/origin/master 时，将只抓取远程 master 分支（fetch 可以设置多个，以拉取不同分支的引用）；或者单次执行 git fetch origin master:refs/remotes/origin/mymaster 命令，将远程 master 分支拉到本地的 origin/mymaster 分支</span></span><br><span class="line">  <span class="comment"># push = refs/heads/master:refs/heads/qa/master 用于设置推送，或执行 git push origin master:refs/heads/qa/master 命令</span></span><br></pre></td></tr></table></figure></p>
<p>执行 git push origin :topic 命令可删除远程 topic 分支，因为 src 为空值，即代表删除。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>引用日志/reflog 记录每一次你改变 HEAD 时它的值。每一次提交或改变分支时，引用日志都会被更新。引用日志也可以通过 git update-ref 命令更新。git reflog 命令用于查看引用日志。引用日志存放在 .git/logs/ 目录中。</p>
<p>引用日志可用于找回丢失的提交，如 reset, rebase 命令导致丢失。通过 git branch <branch> <checksum> 命令创建新分支指向丢失的提交。</checksum></branch></p>
<p>当引用日志也同样丢失时，可以使用 git fsck –full 查看没有被引用的提交对象，即丢失的提交对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reflog <span class="comment"># 查看引用日志</span></span><br><span class="line">git <span class="built_in">log</span> -g <span class="comment"># 以标准日志格式查看引用日志</span></span><br><span class="line">git count-objects -v <span class="comment"># 查看内存占用，size-pack 指以 kb 为大小的包文件</span></span><br></pre></td></tr></table></figure>
<h3 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h3><ol>
<li>git 的远程交互机制，参考<a href="https://git-scm.com/book/zh/v2/Git-内部原理-传输协议" target="_blank" rel="noopener">传输协议</a></li>
<li>移除git 数据库中的历史文件，参考<a href="https://git-scm.com/book/zh/v2/Git-内部原理-维护与数据恢复" target="_blank" rel="noopener">维护与数据恢复</a></li>
<li>git 环境变量，参考<a href="https://git-scm.com/book/zh/v2/Git-内部原理-环境变量" target="_blank" rel="noopener">环境变量</a></li>
</ol>
<p>参考：<br><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/carrier/" rel="tag"># carrier</a>
          
            <a href="/tags/git/" rel="tag"># git</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/13/手册/mocha使用指南/" rel="next" title="mocha使用指南">
                <i class="fa fa-chevron-left"></i> mocha使用指南
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/24/Js/flow使用指南/" rel="prev" title="flow使用指南">
                flow使用指南 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="Alfred">
            
              <p class="site-author-name" itemprop="name">Alfred</p>
              <p class="site-description motion-element" itemprop="description">人苦不知足，既得陇，复望蜀</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">85</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Alfred-sg" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/xiu-fan-79/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Getting-Started"><span class="nav-number">1.</span> <span class="nav-text">Getting Started</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置"><span class="nav-number">1.2.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#帮助"><span class="nav-number">1.3.</span> <span class="nav-text">帮助</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#疑问"><span class="nav-number">1.4.</span> <span class="nav-text">疑问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-Basics"><span class="nav-number">2.</span> <span class="nav-text">Git Basics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建本地仓库"><span class="nav-number">2.1.</span> <span class="nav-text">创建本地仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件状态"><span class="nav-number">2.2.</span> <span class="nav-text">文件状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gitignore"><span class="nav-number">2.3.</span> <span class="nav-text">.gitignore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit-历史记录"><span class="nav-number">2.4.</span> <span class="nav-text">commit 历史记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#撤销"><span class="nav-number">2.5.</span> <span class="nav-text">撤销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程协作"><span class="nav-number">2.6.</span> <span class="nav-text">远程协作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打标签"><span class="nav-number">2.7.</span> <span class="nav-text">打标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#疑问-1"><span class="nav-number">2.8.</span> <span class="nav-text">疑问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-Branching"><span class="nav-number">3.</span> <span class="nav-text">Git Branching</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本命令"><span class="nav-number">3.1.</span> <span class="nav-text">基本命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作流"><span class="nav-number">3.2.</span> <span class="nav-text">工作流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程分支"><span class="nav-number">3.3.</span> <span class="nav-text">远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变基"><span class="nav-number">3.4.</span> <span class="nav-text">变基</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-on-the-Server"><span class="nav-number">4.</span> <span class="nav-text">Git on the Server</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传输协议"><span class="nav-number">4.1.</span> <span class="nav-text">传输协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搭建-git-服务器"><span class="nav-number">4.2.</span> <span class="nav-text">搭建 git 服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#疑问-2"><span class="nav-number">4.3.</span> <span class="nav-text">疑问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Distributed-Git"><span class="nav-number">5.</span> <span class="nav-text">Distributed Git</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式工作流"><span class="nav-number">5.1.</span> <span class="nav-text">分布式工作流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提交准则"><span class="nav-number">5.2.</span> <span class="nav-text">提交准则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贡献代码"><span class="nav-number">5.3.</span> <span class="nav-text">贡献代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#私有小型团队"><span class="nav-number">5.3.1.</span> <span class="nav-text">私有小型团队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#私有大型团队"><span class="nav-number">5.3.2.</span> <span class="nav-text">私有大型团队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#派生的公开项目"><span class="nav-number">5.3.3.</span> <span class="nav-text">派生的公开项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过邮件的公开项目"><span class="nav-number">5.3.4.</span> <span class="nav-text">通过邮件的公开项目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#维护项目"><span class="nav-number">5.4.</span> <span class="nav-text">维护项目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#应用补丁"><span class="nav-number">5.4.1.</span> <span class="nav-text">应用补丁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并工作流"><span class="nav-number">5.4.2.</span> <span class="nav-text">合并工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拣选"><span class="nav-number">5.4.3.</span> <span class="nav-text">拣选</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重用冲突解决方案-reuse-recorded-resolution"><span class="nav-number">5.4.4.</span> <span class="nav-text">重用冲突解决方案/reuse recorded resolution</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Github"><span class="nav-number">6.</span> <span class="nav-text">Github</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-Tools"><span class="nav-number">7.</span> <span class="nav-text">Git Tools</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选取提交记录"><span class="nav-number">7.1.</span> <span class="nav-text">选取提交记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交互式暂存"><span class="nav-number">7.2.</span> <span class="nav-text">交互式暂存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#储藏"><span class="nav-number">7.3.</span> <span class="nav-text">储藏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清理"><span class="nav-number">7.4.</span> <span class="nav-text">清理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#签署标签"><span class="nav-number">7.5.</span> <span class="nav-text">签署标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索"><span class="nav-number">7.6.</span> <span class="nav-text">搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写历史"><span class="nav-number">7.7.</span> <span class="nav-text">重写历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重置揭密"><span class="nav-number">7.8.</span> <span class="nav-text">重置揭密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级合并"><span class="nav-number">7.9.</span> <span class="nav-text">高级合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rerere-命令"><span class="nav-number">7.10.</span> <span class="nav-text">rerere 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-git-调试"><span class="nav-number">7.11.</span> <span class="nav-text">使用 git 调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子模块"><span class="nav-number">7.12.</span> <span class="nav-text">子模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打包"><span class="nav-number">7.13.</span> <span class="nav-text">打包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#替换"><span class="nav-number">7.14.</span> <span class="nav-text">替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#凭证存储"><span class="nav-number">7.15.</span> <span class="nav-text">凭证存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#疑问-3"><span class="nav-number">7.16.</span> <span class="nav-text">疑问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Customizing-Git"><span class="nav-number">8.</span> <span class="nav-text">Customizing Git</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义合并、比较工具"><span class="nav-number">8.1.</span> <span class="nav-text">自定义合并、比较工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-属性"><span class="nav-number">8.2.</span> <span class="nav-text">git 属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#识别二进制文件"><span class="nav-number">8.2.1.</span> <span class="nav-text">识别二进制文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较-word-文件"><span class="nav-number">8.2.2.</span> <span class="nav-text">比较 word 文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较图像文件"><span class="nav-number">8.2.3.</span> <span class="nav-text">比较图像文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">8.2.4.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-钩子"><span class="nav-number">8.3.</span> <span class="nav-text">git 钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端钩子"><span class="nav-number">8.3.1.</span> <span class="nav-text">客户端钩子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务器端钩子"><span class="nav-number">8.3.2.</span> <span class="nav-text">服务器端钩子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#疑问-4"><span class="nav-number">8.4.</span> <span class="nav-text">疑问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-Internals"><span class="nav-number">9.</span> <span class="nav-text">Git Internals</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-对象"><span class="nav-number">9.1.</span> <span class="nav-text">git 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-引用"><span class="nav-number">9.2.</span> <span class="nav-text">git 引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用规格"><span class="nav-number">9.3.</span> <span class="nav-text">引用规格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据恢复"><span class="nav-number">9.4.</span> <span class="nav-text">数据恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#疑问："><span class="nav-number">9.5.</span> <span class="nav-text">疑问：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alfred</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.2</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.2"></script>



  

  
    <script id="dsq-count-scr" src="https://alfred.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/02/21/读书笔记/Pro Git读书笔记/';
        this.page.identifier = '2018/02/21/读书笔记/Pro Git读书笔记/';
        this.page.title = 'Pro Git 笔记';
      };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://alfred.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  





	





  












  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
