<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="analyst,vue," />


<meta name="description" content="序言数据侦测，也称为数据绑定，即是监测数据的更新状况，当数据更新时，触发后续动作的执行。以伪语法的形式，可以用 表达式 1 概括说明。 表达式 11234when(data changed)&amp;#123;  do compute  do reaction&amp;#125; 基于 表达式 1 ，有如下概念（基于 mobx 文档 整理）： 概念 112345Observable: 监测数据，可以是状态，更新其">
<meta name="keywords" content="analyst,vue">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue 源码分析 - 数据侦测">
<meta property="og:url" content="http://yoursite.com/2018/03/15/Vue/数据绑定/index.html">
<meta property="og:site_name" content="修子范语">
<meta property="og:description" content="序言数据侦测，也称为数据绑定，即是监测数据的更新状况，当数据更新时，触发后续动作的执行。以伪语法的形式，可以用 表达式 1 概括说明。 表达式 11234when(data changed)&amp;#123;  do compute  do reaction&amp;#125; 基于 表达式 1 ，有如下概念（基于 mobx 文档 整理）： 概念 112345Observable: 监测数据，可以是状态，更新其">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-15T15:02:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue 源码分析 - 数据侦测">
<meta name="twitter:description" content="序言数据侦测，也称为数据绑定，即是监测数据的更新状况，当数据更新时，触发后续动作的执行。以伪语法的形式，可以用 表达式 1 概括说明。 表达式 11234when(data changed)&amp;#123;  do compute  do reaction&amp;#125; 基于 表达式 1 ，有如下概念（基于 mobx 文档 整理）： 概念 112345Observable: 监测数据，可以是状态，更新其">






  <link rel="canonical" href="http://yoursite.com/2018/03/15/Vue/数据绑定/"/>


  <title>Vue 源码分析 - 数据侦测 | 修子范语</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">修子范语</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Alfredo's Notes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/Vue/数据绑定/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alfred">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="修子范语">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Vue 源码分析 - 数据侦测</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T00:00:00+08:00">2018-03-15</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/15/Vue/数据绑定/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/15/Vue/数据绑定/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>数据侦测，也称为数据绑定，即是监测数据的更新状况，当数据更新时，触发后续动作的执行。以伪语法的形式，可以用 <em>表达式 1</em> 概括说明。</p>
<p><em>表达式 1</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when(data changed)&#123;</span><br><span class="line">  <span class="keyword">do</span> compute</span><br><span class="line">  <span class="keyword">do</span> reaction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <em>表达式 1</em> ，有如下概念（基于 <a href="http://cn.mobx.js.org/" target="_blank" rel="noopener">mobx 文档</a> 整理）：</p>
<p><em>概念 1</em><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable: 监测数据，可以是状态，更新其值将触发执行 compute 及 reaction</span><br><span class="line">action: 促使 Observable 更新的动作，可用于收集 Observable 更新前后的状况</span><br><span class="line">compute: Observable 更新后，触发执行的动作，用于获取计算属性</span><br><span class="line">reaction: Observable 更新后，触发执行的动作，用于执行副作用</span><br><span class="line">derivations: 衍生，Observable 更新后触发动作的统称，包含 compute 及 reaction</span><br></pre></td></tr></table></figure></p>
<p>程序实现 <em>表达式 1</em> 中的逻辑，主要有两种方式。第一种方式是使用定时器周期性检测 <em>Observable</em> 数据（下文中的响应式数据，即指监测数据 <em>Observable</em>）的变更，当数据变更时，触发执行后续的动作。第二种方式是借助于硬编码或钩子，将后续执行动作添加到数据更新的过程 <em>action</em> 之后。本篇文章旨在讨论基于观察者模式（即钩子函数的底层实现）这一种解决方案。上述两种方式都聚焦于解决怎样在数据更新后、引起后续动作的执行。当使用观察者模式实现数据侦测时，所要面临的难题是，怎样推断单个 <em>Observable</em> 数据被哪些 <em>derivations</em> 订阅（也可以称为观察或监测，当数据更新时，将引起这些 <em>derivations</em> 的执行），以及单个 <em>derivations</em> 订阅了哪些 <em>Observable</em> 数据（在这些数据更新后，都会引起 <em>derivations</em> 的执行），即确定 <em>Observable</em> 和 <em>derivations</em> 的依赖关系。</p>
<p>这篇文章首先将探讨使用观察者模式实现数据侦测的基本思路（见诸 <em>探讨</em> 一节），随后分析 <em>Vue</em> 源码对数据侦测功能的实现（见诸 <em>Vue 实现</em> 一节），其次分析数据侦测在 <em>Vue</em> 中的实际使用，表现为 <em>Vue</em> 实例的配置项以及 <em>Vue</em> 对外提供的接口（见诸 <em>Vue 应用</em> 一节），最后将借鉴 <em>mobx</em> 的 api，简单制作一个相应类库（见诸 <em>延伸</em> 一节）。需要说明的是，无论探讨一节，还是延伸一节，都是基于笔者对 <em>Vue</em> 源码的领悟，思路也因而有所局限。对于实现数据侦测功能的多种技术方案，笔者譬如井底之蛙。在这方面，读者可自行翻阅实现了数据侦测功能的其他类库或框架，免使思维陷入这篇文章的小小格局。</p>
<p>在阅读后续章节前，读者可以酌情先了解下 <a href="http://xzfyu.com/2018/03/04/设计模式/观察者模式/" target="_blank" rel="noopener">观察者模式</a>，或者跟随笔者的思路拾级而上。</p>
<h2 id="探讨"><a href="#探讨" class="headerlink" title="探讨"></a>探讨</h2><p>数据侦测用观察者模式实现的简易原理是，当访问数据时，调用 <strong>Observer.subscribe(topic, listener)</strong> 方法，以绑定函数（下文将用订阅函数代称）形式添加订阅者；当更新数据时，调用 <strong>Observer.publish(topic, …args)</strong> 方法，执行后续的动作，即调用 <strong>listener(…args)</strong> 函数。通过在更新数据前，先访问数据，就可以使绑定函数观察这份数据变更，在数据变更后自动执行绑定函数。</p>
<p><em>代码段 1</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> handlebars <span class="keyword">from</span> <span class="string">'handlebars'</span>;</span><br><span class="line"><span class="keyword">import</span> Observer <span class="keyword">from</span> <span class="string">'./observer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rerender</span>(<span class="params">key, data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"entry"</span>);</span><br><span class="line">  <span class="keyword">let</span> template = el.innerHTML;</span><br><span class="line">  <span class="keyword">let</span> compiler = handlebars.compile(template);</span><br><span class="line">  <span class="keyword">let</span> html = compiler(data)</span><br><span class="line">  el.innerHTML = html;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">  data = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  construtor(data)&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key)&#123;</span><br><span class="line">    Observer.subscribe(key, rerender);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, val)&#123;</span><br><span class="line">    <span class="keyword">let</span> oldVal = <span class="keyword">this</span>.get(key);</span><br><span class="line">    <span class="keyword">if</span> ( oldVal !== val )&#123;</span><br><span class="line">      <span class="keyword">this</span>.data[key] = val;</span><br><span class="line">      Observer.publish(key, <span class="keyword">this</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ob = <span class="keyword">new</span> Observable(&#123; <span class="attr">name</span>: <span class="string">'jack'</span> &#125;);</span><br><span class="line">ob.set(<span class="string">'name'</span>, <span class="string">'andy'</span>);<span class="comment">// 通过执行绑定函数 rerender 重绘视图</span></span><br></pre></td></tr></table></figure></p>
<p>上述代码就是用观察者模式表现硬编码形式的 <strong>data.name = ‘andy’; rerender(data)</strong> 语句的处理逻辑。有关 <em>Observer</em> 类的实现，请参详 <a href="http://xzfyu.com/2018/03/04/设计模式/观察者模式/" target="_blank" rel="noopener">观察者模式</a> 一文。然而，上述代码存在下述问题：</p>
<p><em>问题清单 1</em></p>
<ol>
<li>代码书写风格的问题。<strong>ob.set(key, val)</strong> 可否简化为 <strong>data[key] = val</strong> 形式，使其同样能唤起后续动作的执行？</li>
<li>显式指明的订阅函数和硬编码风格相差无几，对于 <em>derivations</em> 多样的业务场景并不适用，能否将其解耦，使 <em>derivations</em> 的执行过程更为灵活？</li>
</ol>
<p><em>解决方案 1</em></p>
<ol>
<li>针对 <em>问题 1</em>，可通过调用 <strong>Object.defineProperty(targer, key, descriptor)</strong> 方法，将 <em>代码段 1</em> 中 <strong>get, set</strong> 方法的处理逻辑写进访问器属性中，得到解决。而 <strong>Object.defineProperty</strong> 方法，也是 Vue 相关源码的实现内核所在。</li>
<li>针对 <em>问题 2</em>，可通过将硬编码的 <strong>rerenderView</strong> 订阅函数演化为更灵活的订阅者管理器 <em>SubscriberManager</em> 类实现。即在响应式数据变更过程中，由 <em>SubscriberManager</em> 实例实时查找同这些响应式数据相关的订阅函数，并触发订阅函数的执行。</li>
</ol>
<p>为着实现 <em>SubscriberManager</em> 类，将要面临如何解决 <em>Observable</em> 和 <em>derivations</em> 之间依赖关系管理的问题。</p>
<p><em>问题清单 2</em></p>
<ol>
<li><em>Observable</em> 和 <em>derivations</em> 的依赖关系问题。思想如由 <strong>getFullname</strong> 计算函数获得的 <strong>fullname</strong> 依赖于响应式数据中 <strong>firstname, secondname</strong> 属性的场景，即 <strong>firstname, secondname</strong> 属性变更时，将触发调用 <strong>getFullname</strong> 订阅函数的执行，而当其他属性变更时，并不触发 <strong>getFullname</strong> 的执行。<strong>getFullname</strong> 订阅函数和 <strong>firstname, secondname</strong> 监测属性有相互依赖关系。当 <strong>firstname, secondname</strong> 属性移除后，<strong>getFullname</strong> 订阅函数不再执行；当 <strong>getFullname</strong> 函数移除后，<strong>firstname, secondname</strong> 属性更新不再通知 <strong>getFullname</strong> 函数。并且，依赖关系问题不只包含当响应式数据或订阅函数移除时如何重置依赖，还包含当新增一项 <em>derivations</em> 观察的数据或者新增一项订阅 <em>Observable</em> 的函数时如何更新依赖。</li>
</ol>
<p><em>解决方案 2</em></p>
<ol>
<li>针对 <em>问题 1</em>，在没有使用 <strong>Object.defineProperty(targer, key, descriptor)</strong> 方法的场景中，可以通过 <strong>Observer.subscribe(observale, key, listener)</strong> 方式显式指明订阅函数 <strong>listener</strong> 需要在 <strong>observale[key]</strong> 数据变更后执行。这种显式指明的方式譬如手动添加，其依赖关系也必然要手动移除，需要费一番功夫才能实现自动化更新和重置依赖。虽然，可以将订阅函数 <strong>listener</strong> 以 <strong>{ bindTo: [ keyPath ], linstener }</strong> 形式存储到 <strong>observale._listening</strong> 属性中（其中，<strong>keyPath</strong> 为键路径），或者以 <strong>Map</strong> 映射存储响应式对象键路径和订阅函数，通过 <strong>id</strong> 号搜寻依赖，以避免对外暴露依赖关系。在这方面，可以参考 <a href="https://github.com/jashkenas/backbone" target="_blank" rel="noopener">backbone</a> 及 <a href="https://github.com/emberjs/ember.js" target="_blank" rel="noopener">emberjs</a> 的实现。对这两者，笔者的领悟还不够充分。</li>
<li>继上，在使用 <strong>Object.defineProperty(targer, key, descriptor)</strong> 方法的场景中，订阅函数 <strong>listener</strong> 若以 <strong>observale</strong> 为上下文，在其执行过程中并访问 <strong>this[key]</strong> 属性时，<strong>descriptor.get</strong> 方法将得到调用。可以确知的是，<strong>descriptor.get</strong> 方法在 <strong>listener</strong> 执行背景下得到调用。当使用变量缓存 <strong>listener</strong> 时（必要情况下，可再使用先进后出队列存储执行中的订阅函数数组，其意义是在多个订阅函数嵌套执行的场景中获取当前执行的订阅函数），就可以从容建立当前订阅函数 <strong>listener</strong> 和监测数据 <strong>target[key]</strong> 的互为依赖关系。</li>
</ol>
<p><em>代码段 2</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentSubscriber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(reactiveData, subscriber)&#123;</span><br><span class="line">    currentSubscriber = subscriber.bind(reactiveData);</span><br><span class="line">    subscriber.call(reactiveData);</span><br><span class="line">    currentSubscriber = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscriberManager</span> </span>&#123;</span><br><span class="line">  subscribers = [];</span><br><span class="line"></span><br><span class="line">  refreshSubscribers()&#123;</span><br><span class="line">    <span class="comment">// 实时查找订阅者</span></span><br><span class="line">    <span class="keyword">let</span> &#123; subscribers &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> ( subscribers.indexOf(currentSubscriber) !== <span class="number">-1</span> ) </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    subscribers.push(currentSubscriber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify()&#123;</span><br><span class="line">    <span class="comment">// 通知订阅者数据已变更</span></span><br><span class="line">    <span class="keyword">this</span>.subscribers.map(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">      subscriber();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToReactiveData</span>(<span class="params">target, key, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> subscriberManager = <span class="keyword">new</span> SubscriberManager();<span class="comment">// target 的每个属性，都需要一个订阅者管理器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(target) : val;</span><br><span class="line">      <span class="keyword">if</span> ( currentSubscriber ) subscriberManager.refreshSubscribers();</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(target) : val;</span><br><span class="line">      <span class="keyword">if</span> ( newVal === value ) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> ( setter )</span><br><span class="line">        setter.call(target, newVal);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        val = newVal;</span><br><span class="line">      subscriberManager.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactiveDataManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">    data.__reactiveDataManager__ = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> val = data[key];</span><br><span class="line">      convertToReactiveData(data, key, val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">firstname</span>: <span class="string">'Steven'</span>, <span class="attr">secondname</span>: <span class="string">'Spielberg'</span> &#125;;</span><br><span class="line"><span class="keyword">new</span> ReactiveDataManager(data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeFullname</span>(<span class="params"></span>)</span>&#123;<span class="comment">// 将构建两个 SubscriberManager 实例</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`computed fullname is <span class="subst">$&#123;<span class="keyword">this</span>.firstname&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.secondname&#125;</span>.`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstname&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.secondname&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Watcher(data, computeFullname);<span class="comment">// 'computed fullname is Steven Spielberg.'</span></span><br><span class="line"></span><br><span class="line">data.secondname = <span class="string">'Jobs'</span>;<span class="comment">// 'computed fullname is Steven Jobs.'</span></span><br></pre></td></tr></table></figure></p>
<p><em>代码段 2</em> 即为 Vue 扼要的实现逻辑，至于怎样将数组和深度嵌套的数据转变成响应式数据，以及如何重置依赖关系，将在下一节分析 Vue 源码的过程中予以说明。</p>
<h2 id="Vue-实现"><a href="#Vue-实现" class="headerlink" title="Vue 实现"></a>Vue 实现</h2><p>在 <em>Vue</em> 源码中，<strong>src/core/oberser</strong> 目录下各模块用于实现数据侦测。下文将用 <strong>oberser</strong> 包代称 <strong>src/core/oberser</strong> 目录。</p>
<p><em>目录结构 1</em><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|--- observer </span><br><span class="line">  |--- index.js <span class="comment"># 将对象或数组转化为响应式数据</span></span><br><span class="line">  |--- array.js <span class="comment"># 提供改写数组 push 等原型方法的工具包</span></span><br><span class="line">  |--- watcher.js <span class="comment"># 将订阅函数实现为订阅者 Watcher 实例</span></span><br><span class="line">  |--- dep.js <span class="comment"># 管理响应式数据和订阅者 Watcher 的依赖关系，在 Vue 中视为 observable</span></span><br><span class="line">  └--- scheduler.js <span class="comment"># 用于调度订阅者的延迟执行</span></span><br></pre></td></tr></table></figure></p>
<p>本节主要针对 <strong>index, array, watcher, dep, scheduler</strong> 模块予以扼要分析，与 Vue 实例、重新渲染机制的交互过程将在下一节予以分析。</p>
<h3 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h3><p>在 <em>Vue</em> 中，<strong>index</strong> 模块提供的 <strong>new Observer(value)</strong> 类用于将普通数据 <strong>value</strong> 转化成响应式数据，当响应式数据更新时，将自动订阅函数的执行。<strong>value</strong> 的数据类型可以是对象或数组。若 <strong>value</strong> 为对象，遍历其属性，通过 <strong>defineReactive</strong> 函数将属性的存取过程转变为响应式，取值时更新依赖，赋值时触发订阅函数的执行。若 <strong>value</strong> 为数组，改写其 <strong>push, pop, shift, unshift, splice, sort, reverse</strong> 原型方法，将其变异为响应式数组，上述方法执行时将触发订阅函数的执行；并通过创建新的 <strong>Observer</strong> 实例将数组项转化为响应式数据。</p>
<p>因此，将普通数据转化为响应式数据基于 <strong>defineReactive(target, key, value)</strong> 函数。如前文所述，<strong>defineReactive</strong> 函数通过 <strong>Object.defineProperty(obj, key, descriptor)</strong> 方法改写属性描述符实现，其中，getter 方法用于更新订阅者，setter 方法用于触发订阅函数的执行。因为 obj[key] 等同于一个主题对象，因此在 defineReactive 函数执行过程，会针对每个 key 键创建一个 Dep 依赖管理实例，再由 getter 访问器属性调用 dep.depend 方法刷新依赖。刷新依赖的机制，可参见前文，也即订阅函数(在 Vue 表现为 Watcher 实例)在执行过程中需要访问 obj[key]，就可以将 watcher 实例赋值给 Dep.target 静态属性，并促使 dep 实例和 watcher 实例相互建立引用关系(其中，dep.subs 数组存储 watchcer 实例，即与主题对象相关的订阅函数；watcher.deps 数组存储 dep 实例，即与订阅函数相关的主题对象)。当 setter 访问器执行过程中(即 action 促使数据更新时。在 Vue 中，action 表现为 method)，将由 dep.notify 方法调用 dep.subs 数组中每个 watchcer 实例的update，进而执行 watcher 挂载的订阅函数。</p>
<p>当 obj 为深度嵌套的数据结构时，需要作怎样的处理才能将其转变为响应式数据？易于想到的处理方式是，遍历对象的属性，当其为复杂数据结构时，递归调用 new Observer(obj[key]) 将该属性转化为响应式数据，自顶向下(或者如backbone的实现，自底向上构建响应式数据)。Vue 另辟蹊径，既然每次调用 setter 访问器时，同样需要将 newValue 转变为响应式数据，将 obj[key] 初始值转化为 observer 实例也在属性描述符中处理。对于深度嵌套的数据结构，defineReactive 函数也多了入参 sallow，用于指定是否将复杂数据结构的子属性转化为响应式数据。</p>
<p><em>代码段 3</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer/array.js</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line">;[</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// observer/index.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: Object, keys: any</span>) </span>&#123;</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span> (<span class="params">value: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i]</span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">      dependArray(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment<span class="comment">// protoAugment(target, src) 执行 target.__proto__ = src</span></span><br><span class="line">        : copyAugment<span class="comment">// copyAugment(target, src, keys) 遍历 keys，将 src[key] 赋值给 target[key]</span></span><br><span class="line">      augment(value, arrayMethods, arrayKeys)<span class="comment">// 将数组的 push 等方法改写为响应式</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value)</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;<span class="comment">// 更新前后均为 NaN</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，数组的依赖(指需要访问数据的订阅函数，即实际的订阅者)更新仍旧基于 Object.defineProperty 方法，可以得知的是，observer 不能单纯地将数组转变为响应式数据，数组必须是某个响应式对象的子属性。因此，vue 中的数据侦测实现不能单独作为类库使用。这在下一节中将作再度说明。</p>
<p>当 observer 实例对应的原始数据为数组时，observer 实例的 dep 属性存在的意义是，用于在 getter 访问器属性中通过该 dep 值(即 childOb.dep.depend)更新依赖，以使数组的 push 等方法执行时，好通过调用 dep.notify 方法，触发订阅函数的执行。同时，Vue 也不支持通过 arr[idx] = item 或 arr.length = len 语句触发订阅函数的调用。</p>
<p>介于 Object.defineProperty 方法只能对存在的属性起作用，Vue 中提供 set(target, key, value), del(target, key) 函数用于实现新增和删除属性同样需要触发订阅函数的场景。针对数组项，调用改写的原型方法 unshift, pop, splice 即可以移除数组项，并触发订阅函数的执行。然而，Vue 中提供的 set, del 函数将调用变异的 splice 方法处理数组，在数组项新增或删除时也触发订阅函数的执行。因此，set(arr, idx, item) 函数可用于代替 arr[idx] = item。</p>
<p>若 set, del 函数为响应式对象，将调用该对象相应的 observer 实例的 dep.notify 方法，也因而，observer 实例的 dep 属性存在的另一层意义是，用于促使 set, del 函数中的 observer.dep.notify 方法调用过程中，唤起订阅函数的执行。更新依赖仍旧在于 getter 访问器属性中的 childOb.dep.depend 方法。</p>
<p><em>代码段 4</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(target, key)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.splice(key, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  hasOwn(target, key)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> target[key]</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>参见探讨一节中所示的最后一段代码，每个访问属性及其订阅函数的依赖关系可以通过 SubscriberManager 类加以管理。在 Vue 中，将 SubscriberManager 类分拆为 Dep 和 Watcher 两个类。</p>
<p>其中，Dep 根据对象的每个访问属性、或 Observer 实例(原始数据为对象或数组)，管理其依赖(即订阅函数)，因此，Vue 又将 Dep 实例注释为 observable 监视数据。依赖更新过程通过在 index.js 模块中调用 dep.depend 实现。dep.depend 方法执行过程中，将会调用 Dep.target. depend 方法更新该 dep 实例和 Dep.target(即当前运行中的订阅者 watcher 实例) 的依赖关系，也即更新 watcher.deps 数组(数组项为 Dep 实例)，表示订阅者 watcher 正在监测哪些响应式数据的变更；更新 dep.subs 数组(数组项为 Watcher 实例)，表示监视数据需要把状态更新通知哪些订阅者。这样就建立了 watcher 和 dep 互为引用关系。需要强调的是，更新依赖基于 getter 访问器属性中的 dep.depend 执行语句，getter 访问器又通过显式调用订阅函数才能触发，因此，在 Watcher 类的实现中，以 expOrFn 入参形式设定的订阅函数需要在响应式数据更新前得到调用，这也就是为什么在 Vue 中 Watcher 构造函数中会执行 this.get 方法的原因了。</p>
<p>因为实际的开发者可能嵌套两个以上订阅函数，所以 Vue 中使用 targetStack 以堆栈形式存储 Dep.target，以使嵌套调用的两个订阅函数中，后一个订阅函数执行完成后，将 Dep.target 回滚到前一个订阅函数的相关 Watcher 实例。</p>
<p><em>代码段 5</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer/dep.js</span></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对嵌套使用订阅函数的场景</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Dep.target = targetStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如前文所述，在 Vue 中，Watcher 构造函数的参数 expOrFn 为实际的订阅函数，而参数 cb 为响应式数据变更后待执行的回调函数，expOrFn 决定 cb 关联哪些响应式数据或其监测属性。</p>
<p>在 Watcher 类的实现中，参数 expOrFn 将被包装为 watcher.getter 方法，执行时以 vm 为上下文及首参，并通过 watcher.get 方法调用。watcher.get 方法的主要流程为，在 watcher.getter 执行前，通过 pushTarget(this) 将 Dep.target 赋值为当前的 watcher 实例，以使 dep.depend 方法执行过程中可以更新 watcher.deps 及 dep.subs 依赖；在 watcher.getter 执行后，通过调用 popTarget 函数释放 Dep.target，并调用 watcher 实例的 cleanupDeps 方法重置依赖。参数 expOrFn 可以是以 ‘.’ 分割的键名或普通函数。前者用于获取入参 vm 的深层属性，并作为返回值，意味着该属性及其祖先属性的更新将引起 cb 函数的执行(当返回值为复杂结构属性，可通过传参 options.deep 监测其子属性的更新，其实现原理是，利用 traverse 函数访问 watcher.getter 方法返回值的子孙属性或数组项，以此刷新依赖)；后者通过访问响应式数据 this 或首参 vm 的属性更新依赖，允许用户在 expOrFn 函数中自定义需要侦测哪个响应式数据的变更。</p>
<p>watcher 实例的依赖更新过程为，addDep 方法将新增的 dep 实例(通过和 newDepIds 比较判断新增与否)添加到 newDeps, newDepIds 中，所包含的 dep 实例为订阅函数执行过程中访问的响应式数据及其监测属性的相关 dep；cleanupDeps 方法将 newDeps, newDepIds 赋值给 deps, depIds，并置空 newDeps, newDepIds，即 newDeps, newDepIds 仅保留本次订阅函数执行过程中 dep 依赖，针对场景如订阅函数中使用条件语句变更访问的响应式数据等。</p>
<p>可以看见的是，Vue 更新 dep 和 watcher 的依赖关系都基于实际访问函数 expOrFn 的执行过程，却没法感知订阅函数的存在与否，这就造成了一个问题，当订阅函数删除时，dep.subs 中仍会有该订阅函数的相关 watcher 实例，这将促使订阅函数在响应式数据更新时再度执行。为此，Vue 提供了 watcher.teardown 实例方法，通过显式调用，能将当前 watcher 实例从 dep.subs 及 vm._watchers 数组中剔除掉。watcher.teardown 执行过程中，将this.active 标识符置为否，针对异步更新响应式数据过程时、手动调用 watcher.teardown 方法移除订阅函数的场景。而 watcher.depend 实例方法用于显式更新关联 dep 实例的依赖，即将当前 watcher 实例添加到各关联 dep.subs 数组中。</p>
<p>上述说明的 Watcher 类如下：</p>
<p><em>代码段 6</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: <span class="built_in">Function</span>;</span><br><span class="line">  id: number;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: ISet;</span><br><span class="line">  newDepIds: ISet;</span><br><span class="line">  getter: <span class="built_in">Function</span>;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: Object</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        traverse(value)<span class="comment">// 通过访问复杂结构数据 value 的子孙属性及数组项，实现依赖刷新</span></span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">      <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  teardown () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      remove(<span class="keyword">this</span>.vm._watchers, <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">this</span>.deps[i].removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.active = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码存在的问题：</p>
<p><em>问题清单 3</em></p>
<ol>
<li>每次响应式数据变更时，都会唤起订阅函数的执行，如一前一后分别改变 <strong>firstname</strong> 和 <strong>secondname</strong> 将会两次调用 <strong>getFullname</strong> 函数。有没有办法何必更新，只触发调用 <em>derivations</em> 执行一次呢？</li>
<li>订阅函数的执行时机由响应式数据有否更新决定。当开发者使用 <strong>computed</strong> 选项声明了一个计算属性，无论他有没有实际使用这个计算属性，当数据更新时，仍会触发 <strong>computed</strong> 方法的执行，这是不必要的。该问题的一般意义是，怎样只注册订阅函数，而订阅函数的执行时机仍由开发者决定，该订阅函数执行时，又能获取到更新后的数据？</li>
<li>作为 <em>derivations</em> 的 <strong>watcher.getter</strong> 兼有 <em>action</em> 更新响应式数据的能力，因其以响应式数据 <em>observale</em> 为执行上下文。用户可以在传入的 <strong>expOrFn</strong> 函数中使用 <strong>this[key] = value</strong> 语句唤起订阅函数的执行，该过程将再次调用 <strong>expOrFn</strong> 函数中的赋值语句，若 <strong>value</strong> 值每次都在改变（如赋值为 <strong>Math.random()</strong>），将造成死循环。</li>
</ol>
<p><em>解决方案 3</em></p>
<ol>
<li>针对 <em>问题 1</em>，可以将与当前触发本次响应式数据变更的 <em>action</em> 函数的所有相关 <strong>watcher</strong> 依赖添加到队列中，等待 <em>action</em> 执行完成后，再取出 <strong>watcher</strong> 实例加以执行。当然，这样处理存在的问题是，多个 <em>action</em> 更新同一份数据时，仍会造成订阅函数执行多次。在 Vue 的实现中，<strong>watcher</strong> 实例由 nextTick 函数添加到异步队列中，在主线程任务跑完后，才会执行异步队里中的 <strong>watcher</strong> 实例，而不是等待当前的 <em>action</em> 执行完成。这样处理的意义也解决了另一个问题，<em>Vue</em> 可以在模板中使用 <em>js</em> 语句更新响应式数据，这会造成承载着重绘职责的 <strong>watcher</strong> 实例变成深度嵌套结构。使用 nextTick 函数后，须等待前一个重绘流程完成，再执行下一个重绘流程。关于这部分内容，将在下一节再度予以分析。Vue 默认将 <strong>watcher</strong> 添加到异步队列中，与之平级的还有 <strong>lazy, sync</strong> 模式。顾名思义，<strong>sync</strong> 模式指，响应式数据变更后，当即触发订阅函数的执行。</li>
<li>针对 <em>问题 2</em>，Vue 中提供了 <em>lazy</em> 模式，通过传参 options.lazy = true 设置。该模式下，在响应式数据更新后，只引起 watcher.dirty 状态被置为 true，触发 watcher.get 方法需要主动调用 watcher.evaluate 方法。在 watcher.evaluate 方法执行过程中，watcher.getter 方法的返回值将存储在 watcher.value 中，由此对外提供访问属性，用于获取新的计算值。可以想见，使用 <em>lazy</em> 模式也能处理同一个 <em>action</em> 函数更新多个响应式数据、触发订阅函数执行多次的 <em>问题 1</em>。Vue 中的计算属性即基于 lazy 模式实现，即在视图更新时访问计算属性，以此主动调用 watcher.evaluate 方法，<strong>firstname</strong> 和 <strong>secondname</strong> 属性的前后变更都只将触发 <strong>getFullname</strong> 执行一次，而更新 watcher.dirty 状态的动作仍会执行两次。关于计算属性相关内容，将在下一节 <em>Vue 应用</em> 中予以再次分析。</li>
<li>异步队列仅能解决同一个 <em>action</em> 更新多个响应式数据引起的订阅函数执行多次的问题，但是，不能用于处理同一个 <em>action</em> 反复更新同一个响应式数据引起的死循环。对于 <em>问题 3</em> 中的特例 – 使用 lazy 模式处理的计算属性，响应式数据变更时实际触发的动作只是将 watcher.dirty 置为真值，而没有调用 <strong>watcher.getter</strong> 方法，<em>derivations</em> 并不兼有 <em>action</em> 更新响应式数据的能力，也就不会引起死循环问题。对于没有采用 <em>lazy</em> 模式的 <strong>watcher</strong> 实例，当监测中的响应式数据前后相继更新时，其 <strong>watcher.getter</strong> 方法仍会执行多次，而由外部传入的 <strong>expOrFn</strong> 函数以及 <strong>cb</strong> 回调也会执行多次。这也是 Vue 实例中 watch 选项存在的问题。当 watch 选项中某方法将关联的响应式属性赋值为 <strong>Math.random()</strong> 时，会引起死循环。参考计算属性的实现，订阅函数单次执行的场景，也许可使用 <strong>vue.$watch(expOrFn, null, { lazy: true })</strong> 处理，这也将在下一节予以分析。</li>
</ol>
<p><em>解决方案 3</em> 是不完全的，需要开发者遵从一种规约，譬如变异数组不能通过 <strong>arr[index] = item</strong> 语句触发订阅函数的执行一样。通过计算属性这个特例，也可以发现，在 Vue 使用过程中，需注意区分参数 expOrFn 及 cb 的职责。非 lazy 模式下，expOrFn 主要用于引导订阅者 watcher 监测哪些响应式数据变更，定位监测数据通过在函数形式 expOrFn 使用 this 关键字访问数据，或者通过键路径形式的 expOrFn 设定观察属性，或者通过 options.deep 选项监测两者的返回值。cb 仅在非 lazy 模式下使用，作为回调函数，有可能在响应式数据变更后执行。Vue 为 cb 设定的执行条件为，watcher.getter 方法返回值与原有值不等，或返回了对象，或 options.deep 为真值。这样的条件，也未见逻辑上的妥帖。非 lazy 模式下，在 expOrFn 中作除依赖收集之外的处理时须谨慎。lazy 模式下，cb 回调没有机会得到触发执行（除非 Vue 对外暴露 watcher 实例，可以显示调用 watcher.run 方法），expOrFn 的执行时机由 observer 模块的使用者调用 watcher.evaluate 方法决定（非 lazy 模式由 Vue 决定其执行时机）。计算属性这个特例就使用了 lazy 模式，expOrFn 的返回值用于更新 watcher.value 并输出。非 lazy 模式或 lazy 模式下，都需要避免在 expOrFn 或 cb 中修改响应式数据（cb 同样以全量的 observable 为执行上下文），以免再次触发订阅函数的执行。当然，若足够 Vue 实现的原理，在 expOrFn 或 cb 中修改响应式数据也许能开启某些黑魔法，这些黑魔法也可能因为 Vue 版本的升级而惨遭淘汰。</p>
<p>在 Vue 中，Watcher 实例化过程还接受 user 选项，用于判断当前 watcher 实例是 Vue 内建的，还是来自于开发者。而当 user 选项置真值时，Vue 只负责校验 expOrFn 键路径能否正确取值或者函数能否正确执行，而没有包含依赖关系的梳理、死循环的避免等等。</p>
<p>为实现 lazy, sync 模式，<em>代码段 3</em> 中 update 方法将被拆解为 update, run 方法。update 方法用于判断当前使用的模式，run 方法调用 watcher.get 更新依赖，再执行 cb 回调。</p>
<p><em>代码段 4</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; queueWatcher &#125; <span class="keyword">from</span> <span class="string">'./scheduler'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: Object</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()<span class="comment">// 当即执行，收集 watcher 观察的响应式数据，建立依赖关系</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update()&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">this</span>.lazy )&#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h4><p><em>代码段 4</em> 中的 <strong>queueWatcher</strong> 函数由 <strong>scheduler</strong> 模块提供。<strong>scheduler</strong> 模块通过 <strong>nextTick</strong> 函数将 <strong>watcher</strong> 添加到异步队列中，等待主线程任务执行完成后，再予以执行 <strong>watcher.run</strong> 方法。</p>
<p><strong>scheduler</strong> 模块主要逻辑为当主线程任务尚在执行过程中，将 <strong>watcher</strong> 实例添加到 <strong>queue</strong> 异步队列中；若异步队列已经开始执行，则将 <strong>watcher</strong> 按 <strong>id</strong> 顺序添加 <strong>queue</strong> 队列中。特殊情况是，若在 <strong>watcher</strong> 中更新响应式数据，触发当前 <strong>watcher</strong> 再度被添加到异步队列中、并等待执行，即如 <em>问题清单 3</em> 中 <em>问题 3</em> 中的描述，通过 <strong>circular</strong> 记录当前 <strong>watcher</strong> 执行次数，若超过 <strong>MAX_UPDATE_COUNT</strong> 个数，予以警告提示。</p>
<p>异步队列中，<strong>watcher</strong> 实例的执行顺序以 <strong>watcher</strong>实例的创建顺序为准，通过 <strong>watcher.id</strong> 判断，主要目的是保证组价的重绘动作放在响应式数据更新时尾端，同时保证父子组件的重绘顺序，这部分内容，将在下一节予以分析。</p>
<p><em>代码段 5</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_UPDATE_COUNT = <span class="number">100</span><span class="comment">// 开发环境同一个 watcher 在单次异步队列中最大执行次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = []</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: number]: ?<span class="literal">true</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span><span class="comment">// 异步队列等待执行中状态标识</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span><span class="comment">// 异步队列执行中状态标识</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  index = queue.length = <span class="number">0</span></span><br><span class="line">  has = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    circular = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> watcher, id</span><br><span class="line"></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)<span class="comment">// watcher 重排序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    id = watcher.id</span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    watcher.run()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You may have an infinite update loop '</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? <span class="string">`in watcher with expression "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resetSchedulerState()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程尚在执行中</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    <span class="comment">// 异步队列开始执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Vue-应用"><a href="#Vue-应用" class="headerlink" title="Vue 应用"></a>Vue 应用</h2><p>创建 <em>Vue</em> 实例（下文中 <strong>vm</strong> 即指 <em>Vue</em> 实例）过程中，调用 <strong>observe</strong> 包的模块主要包含 <strong>core/instance</strong> 目录下的 <strong>state, inject, lifecycle</strong> 模块。<strong>state</strong> 模块用于将 Vue 选项 <strong>prop, data, methods, computed, watch</strong> 注入数据侦测功能，并导出数据侦测功能相关的实例属性或方法如 <strong>$props, $data, $set, $del, $watch</strong>。<strong>inject</strong>模块用于将 Vue 选项 <strong>inject</strong> 注入数据侦测功能。<strong>lifecycle</strong> 模块用于将 <strong>updateComponent</strong> 组件更新函数绑定为订阅函数。</p>
<h3 id="prop-data-methods-computed-watch"><a href="#prop-data-methods-computed-watch" class="headerlink" title="prop, data, methods, computed, watch"></a>prop, data, methods, computed, watch</h3><p>注入 Vue 实例且与数据侦测功能相关的选项包含 prop, data, methods, computed, watch。其中 props 为父组件传入的属性或方法，data 将转化为实际的响应式数据，methods 为影响响应式数据变更的 action，computed 为响应式数据变更后执行的计算函数，watch 为响应式数据变更后执行的副作用函数。props, data, methods, computed 均将通过代理导出为 Vue 实例的实例属性或方法，意味着 props, data, methods, computed 中的属性或方法名不能相重，Vue 实例代理的优先级为 props, methods，data, computed。</p>
<p><em>代码段 6</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: Object, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initState 函数将在 Vue 实例化过程中通过 _init 实例方法得到执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="comment">// Firefox 中，普通对象含有 watch 原型方法，nativeWatch 即该原型方法</span></span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>代码段 6</em> 中，<strong>initState</strong> 函数将在 <em>Vue</em> 实例化过程中通过 <strong>vm._init</strong> 实例方法得到执行，其中，<strong>initProps, initMethods, initData, initComputed, initWatch</strong> 分别对 <strong>props, data, methods, computed, watch</strong> 选项进行处理操作。<strong>proxy</strong> 函数提供通过 <strong>vm</strong> 代理取值和赋值的功能。</p>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p><em>代码段 7</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm: Component, propsOptions: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> keys = vm.$options._propKeys = []<span class="comment">// 辅助遍历</span></span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line">  observerState.shouldConvert = isRoot</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = hyphenate(key)</span><br><span class="line">      <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`"<span class="subst">$&#123;hyphenatedKey&#125;</span>" is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">            <span class="string">`Instead, use a data or computed property based on the prop's `</span> +</span><br><span class="line">            <span class="string">`value. Prop being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  observerState.shouldConvert = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stateMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsDef = &#123;&#125;</span><br><span class="line">  propsDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._props &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    propsDef.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(<span class="string">`$props is readonly.`</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$props'</span>, propsDef)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>代码段 7</em> 中，通过 <strong>defineReactive</strong> 函数监测从父组件传入的 <strong>props</strong> 变更，该变更过程发生在更新子组件时，见于 <strong>core/instance/lifecycle.js</strong> 模块中的 <strong>updateChildComponent</strong> 函数。当渲染的是顶层根节点时，将 <strong>observerState.shouldConvert</strong> 标识符置为真值，意味着当顶层根节点的 <strong>props</strong> 子属性为复杂结构数据且不是响应式数据时，将其转换为响应式数据。当渲染的是其他节点是，<strong>props</strong> 子属性保持原有的数据状态，即其传入响应式数据，则输出响应式数据；传入普通数据，则输出普通数据。因为 <strong>props</strong> 是响应式数据，<em>Vue</em> 在开发环境下提示使用者修改 <strong>props</strong> 须谨慎。通过 <strong>stateMixin</strong> 函数导出的 <strong>vm.$props</strong> 在开发环境也是只读的。但用户仍可以修改 <strong>vm.$props</strong> 的子属性。</p>
<p>同时，<em>代码段 7</em> 中 observe 函数改写为 <em>代码段 7</em> 中形式，添加 <strong>observerState.shouldConvert</strong> 标识符阻止将子组件获得的 props 子属性转变为 Observer 实例。</p>
<p><em>代码段 8</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observerState = &#123;</span><br><span class="line">  shouldConvert: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    observerState.shouldConvert &amp;&amp;<span class="comment">// 阻止将子组件获得的 props 子属性转变为 Observer 实例</span></span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue<span class="comment">// 排除 Vue 实例</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><p><em>代码段 9</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">data: Function, vm: Component</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`data()`</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 data 转变为响应式数据</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stateMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dataDef = &#123;&#125;</span><br><span class="line">  dataDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._data &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    dataDef.set = <span class="function"><span class="keyword">function</span> (<span class="params">newData: Object</span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'Avoid replacing instance root $data. '</span> +</span><br><span class="line">        <span class="string">'Use nested data properties instead.'</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$data'</span>, dataDef)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>代码段 9</em> 中，通过 <strong>observe</strong> 函数将 <strong>data</strong> 选项转变为响应式数据。<strong>data</strong> 选项可以是对象或函数形式，当其为函数时，可以通过上下文或首参 <em>Vue</em> 实例获取从父组件注入的 <strong>props</strong>。<strong>initData</strong> 函数中，通过代理将 data 导出为 <em>Vue</em> 实例的属性，开发者也可以通过 <strong>vm._data</strong> 或 <strong>vm.$data</strong> 获取全量数据。</p>
<h4 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h4><p><em>代码段 10</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span> (<span class="params">vm: Component, methods: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has an undefined value in the component definition. `</span> +</span><br><span class="line">          <span class="string">`Did you reference the function correctly?`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((key <span class="keyword">in</span> vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" conflicts with an existing Vue instance method. `</span> +</span><br><span class="line">          <span class="string">`Avoid defining component methods that start with _ or $.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vm[key] = methods[key] == <span class="literal">null</span> ? noop : bind(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对 <strong>methods</strong> 选项的处理无他，也就是将 <em>Vue</em> 实例作为其执行上下文。methods 作为更新响应式数据的 <em>action</em>，仍是开发者需要遵从的一种规则。通过 <strong>methods</strong> 各方法对 <em>Vue</em> 实例中的响应式数据执行赋值操作，既可以触发订阅函数的执行。也可以通过直接赋值 <strong>vm.$data</strong> 的子属性触发订阅函数的执行，但不推荐。</p>
<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p><em>代码段 11</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">      vm,</span><br><span class="line">      getter || noop,</span><br><span class="line">      noop,</span><br><span class="line">      computedWatcherOptions</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: Object | Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = createComputedGetter(key)</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">      ? userDef.cache !== <span class="literal">false</span></span><br><span class="line">        ? createComputedGetter(key) </span><br><span class="line">        : userDef.get</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set</span><br><span class="line">      ? userDef.set</span><br><span class="line">      : noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Computed property "<span class="subst">$&#123;key&#125;</span>" was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>代码段 11</em> 中，通过创建 lazy 模式的 Watcher 实例处理计算属性。通过代码，也可以看出，开发者传入的 computed 选项，其属性 userDef 可以是函数或对象形式。若 userDef 为函数，当响应式数据未更新，使用 vm[computedKey] 取值时将获取缓存中的 watcher.value；当响应式数据已更新，则调用 watcher.evaluate 方法（即在模板 template 中使用计算属性时）重新计算值。若 userDef 为对象，且 userDef.cache 属性为真值，vm[computedKey] 取值方式与 userDef 为函数的情形相同；而 vm[computedKey] 赋值操作以 vm 为上下文，可以手动操作响应式数据，也就有可能触发 userDef.get 的再次执行，须谨慎。若 userDef 为对象，且 userDef.cache 属性为否值，vm[computedKey] 的取值、赋值操作仍以 vm 为上下文，两者在响应式数据更新后均不会触发执行，但可以可以手动操作响应式数据。</p>
<h4 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h4><p><em>代码段 12</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm: Component, watch: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  keyOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(keyOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对 watcher 选项处理，即是创建 Watcher 实例的过程。watcher 选项的属性名可以是键路径，作为 Watcher 构造函数的入参 keyOrFn；而其值可以是函数或对象，若为对象，以 watch[key].handler 作为 Watcher 构造函数的入参 cb，其余属性作为入参 options。vm.$watch 方法见下一小节。</p>
<h4 id="set-del-watch-Vue-set-Vue-del"><a href="#set-del-watch-Vue-set-Vue-del" class="headerlink" title="$set, $del, $watch, Vue.set, Vue.del"></a>$set, $del, $watch, Vue.set, Vue.del</h4><p><em>代码段 13</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stateMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Vue.prototype.$set = set</span><br><span class="line">  Vue.prototype.$<span class="keyword">delete</span> = del</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.user = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      cb.call(vm, watcher.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vm.$set, vm.$del 即取 observe 包导出的 set, del 函数。vm.$watch 方法允许次参 cb 为对象，并将 options.user 选项置为真值，标识为用户设定的 watcher；若 options.immediate 选项为真值，当即执行 cb；返回函数用于在 derivations, observale 依赖关系中释放该 watcher。</p>
<p>Vue.set, Vue.del 方法同 vm.$set, vm.$del。</p>
<h4 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide, inject"></a>provide, inject</h4><p><em>代码段 14</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProvide</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> provide = vm.$options.provide</span><br><span class="line">  <span class="keyword">if</span> (provide) &#123;</span><br><span class="line">    vm._provided = <span class="keyword">typeof</span> provide === <span class="string">'function'</span></span><br><span class="line">      ? provide.call(vm)</span><br><span class="line">      : provide</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initInjections</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = resolveInject(vm.$options.inject, vm)</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    observerState.shouldConvert = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(result).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        defineReactive(vm, key, result[key], () =&gt; &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating an injected value directly since the changes will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the provided component re-renders. `</span> +</span><br><span class="line">            <span class="string">`injection being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        defineReactive(vm, key, result[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    observerState.shouldConvert = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveInject</span> (<span class="params">inject: any, vm: Component</span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inject) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> keys = hasSymbol</span><br><span class="line">        ? <span class="built_in">Reflect</span>.ownKeys(inject).filter(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(inject, key).enumerable</span><br><span class="line">        &#125;)</span><br><span class="line">        : <span class="built_in">Object</span>.keys(inject)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = keys[i]</span><br><span class="line">      <span class="keyword">const</span> provideKey = inject[key].from</span><br><span class="line">      <span class="keyword">let</span> source = vm</span><br><span class="line">      <span class="keyword">while</span> (source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source._provided &amp;&amp; provideKey <span class="keyword">in</span> source._provided) &#123;</span><br><span class="line">          result[key] = source._provided[provideKey]</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        source = source.$parent</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'default'</span> <span class="keyword">in</span> inject[key]) &#123;</span><br><span class="line">          <span class="keyword">const</span> provideDefault = inject[key].default</span><br><span class="line">          result[key] = <span class="keyword">typeof</span> provideDefault === <span class="string">'function'</span></span><br><span class="line">            ? provideDefault.call(vm)</span><br><span class="line">            : provideDefault</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">`Injection "<span class="subst">$&#123;key&#125;</span>" not found`</span>, vm)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>provide, inject 选项用于实现组件间的跨级传递，其基本实现同 props 选项，可参考 props 一小节。</p>
<h4 id="vm-watcher"><a href="#vm-watcher" class="headerlink" title="vm._watcher"></a>vm._watcher</h4><p>Vue 中，将更新后的响应式数据重绘到页面上，这一过程借助于在挂载组件时执行 <strong>vm._watcher = new Watcher(vm, updateComponent, noop)</strong> 语句创建 Watcher 实例实现。需要更新视图时，通过 <strong>vm._watcher.update</strong> 方法即可更新视图。这条执行语句见于 lifecycle 模块中的 mountComponent 函数，updateComponent 函数将作为 Watcher 构造函数的入参 expOrFn，即当在 vm 中响应式数据变更后，调用 updateComponent 函数更新组件、重绘视图。这部分内容，笔者将在后续的文章中加以分析。</p>
<p>前文提到的 <strong>computed, watch</strong> 选项和 <strong>$watch</strong> 方法均会创建 <strong>watcher</strong> 实例；同时这一小节也指明，各组件的 <strong>mountComponent</strong> 函数执行过程中均会创建 <strong>watcher</strong> 实例。可以预知的是，与组件 <strong>updateComponent</strong> 函数相关的重绘 <strong>watcher</strong> 实例会在与 <strong>computed, watch</strong> 选项相关的一般 <strong>watcher</strong> 实例后创建，因此上文中的 <strong>scheduler</strong> 模块通过 <strong>watcher.id</strong> 排序执行各 <strong>watcher.run</strong> 方法，以保证一般 <strong>watcher</strong> 实例在重绘 <strong>watcher</strong> 实例之后执行；重绘 <strong>watcher</strong> 实例按父子组件的顺序执行；当子组件移除时，其下的各 <strong>watcher</strong> 实例又将被跳过（响应式数据删除后，相关 watcher 实例便不再被唤起执行）。实现参见 <em>代码段 5</em>。</p>
<p>当 <strong>updateComponent</strong> 函数执行过程中，模板中设定的 <em>js</em> 函数可以更新响应式数据，在该函数执行过程中，与一般 <strong>watcher</strong> 实例执行过程触发响应式数据变更一样，都会将后续的 <strong>watcher</strong> 实例添加到异步队列中，并在同一个异步队列中执行完成。在 <strong>updateComponent</strong> 函数，须执行组件的 update 钩子，组件 Vue 实例通过 watcher.vm 获取；以及 keep-alive 组件的 activated 钩子。关于这部分内容，笔者将在后续的文章中再加以分析</p>
<p>改写 <strong>scheduler</strong> 模块中 <strong>flushSchedulerQueue</strong> 的函数如下：</p>
<p><em>代码段 15</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  resetSchedulerState()</span><br><span class="line"></span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">'flush'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callUpdatedHooks</span> (<span class="params">queue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = queue.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = queue[i]</span><br><span class="line">    <span class="keyword">const</span> vm = watcher.vm</span><br><span class="line">    <span class="keyword">if</span> (vm._watcher === watcher &amp;&amp; vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'updated'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createComponent 函数执行时调用，添加 keep-alive 组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueActivatedComponent</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._inactive = <span class="literal">false</span></span><br><span class="line">  activatedChildren.push(vm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callActivatedHooks</span> (<span class="params">queue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">    queue[i]._inactive = <span class="literal">true</span></span><br><span class="line">    activateChildComponent(queue[i], <span class="literal">true</span> <span class="comment">/* true */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上即为 Vue 内部对数据监测功能的使用。</p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>本节将根据 mobx 的 api 接口设计响应式 model。</p>
<p>class Model {<br>  @observable data = {<br>    firstname: ‘steven’,<br>    secondname: ‘spielberg’<br>  };</p>
<p>  @action changeData(){<br>    this.data = {<br>      firstname: ‘steven’,<br>      secondname: ‘jobs’<br>    }<br>  }</p>
<p>  @computed get fullname(){<br>    return <code>${this.firstname}.${this.secondname}</code>;<br>  }</p>
<p>  @reaction log(){<br>    console.log(‘name changed’);<br>  }<br>};</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/analyst/" rel="tag"># analyst</a>
          
            <a href="/tags/vue/" rel="tag"># vue</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/04/设计模式/观察者模式/" rel="next" title="观察者模式">
                <i class="fa fa-chevron-left"></i> 观察者模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/17/es6/Decorator/" rel="prev" title="修饰器">
                修饰器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="Alfred" />
            
              <p class="site-author-name" itemprop="name">Alfred</p>
              <p class="site-description motion-element" itemprop="description">人苦不知足，既得陇，复望蜀</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">51</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Alfred-sg" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/xiu-fan-79/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#序言"><span class="nav-number">1.</span> <span class="nav-text">序言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#探讨"><span class="nav-number">2.</span> <span class="nav-text">探讨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-实现"><span class="nav-number">3.</span> <span class="nav-text">Vue 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#响应式数据"><span class="nav-number">3.1.</span> <span class="nav-text">响应式数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖管理"><span class="nav-number">3.2.</span> <span class="nav-text">依赖管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调度器"><span class="nav-number">3.2.1.</span> <span class="nav-text">调度器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-应用"><span class="nav-number">4.</span> <span class="nav-text">Vue 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#prop-data-methods-computed-watch"><span class="nav-number">4.1.</span> <span class="nav-text">prop, data, methods, computed, watch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#props"><span class="nav-number">4.1.1.</span> <span class="nav-text">props</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data"><span class="nav-number">4.1.2.</span> <span class="nav-text">data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#methods"><span class="nav-number">4.1.3.</span> <span class="nav-text">methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#computed"><span class="nav-number">4.1.4.</span> <span class="nav-text">computed</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#watcher"><span class="nav-number">4.1.5.</span> <span class="nav-text">watcher</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set-del-watch-Vue-set-Vue-del"><span class="nav-number">4.1.6.</span> <span class="nav-text">$set, $del, $watch, Vue.set, Vue.del</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#provide-inject"><span class="nav-number">4.1.7.</span> <span class="nav-text">provide, inject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vm-watcher"><span class="nav-number">4.1.8.</span> <span class="nav-text">vm._watcher</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延伸"><span class="nav-number">5.</span> <span class="nav-text">延伸</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alfred</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.2</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.2"></script>



  

  
    <script id="dsq-count-scr" src="https://alfred.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/03/15/Vue/数据绑定/';
        this.page.identifier = '2018/03/15/Vue/数据绑定/';
        this.page.title = 'Vue 源码分析 - 数据侦测';
      };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://alfred.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





	





  












  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
